//Author Marcin Matysek (Rewertyn)
==============================================================================
PLIK: Sources\cli\arg_parser.h
==============================================================================

﻿#pragma once

#include <cstdint>
#include <cstdlib>
#include <string>
#include <string_view>

#include "../config/run_config.h"

namespace sudoku_hpc {

struct ParseArgsResult {
    GenerateRunConfig cfg;

    bool list_geometries = false;
    bool validate_geometry = false;
    bool validate_geometry_catalog = false;
    bool run_regression_tests = false;

    bool run_geometry_gate = false;
    std::string geometry_gate_report = "geometry_gate_report.txt";

    bool run_quality_benchmark = false;
    std::string quality_benchmark_report = "quality_benchmark_report.txt";
    uint64_t quality_benchmark_max_cases = 0;

    bool run_pre_difficulty_gate = false;
    std::string pre_difficulty_gate_report = "pre_difficulty_gate_report.txt";

    bool run_asym_pair_benchmark = false;
    std::string asym_pair_benchmark_report = "asym_pair_benchmark_report.txt";

    bool run_vip_benchmark = false;
    std::string vip_benchmark_report = "vip_benchmark_report.txt";

    bool run_vip_gate = false;
    std::string vip_gate_report = "vip_gate_report.txt";

    bool explain_profile = false;
    bool benchmark_mode = false;
};

inline bool parse_i64(const char* s, long long& out) {
    if (s == nullptr) return false;
    char* end = nullptr;
    const long long v = std::strtoll(s, &end, 10);
    if (end == s || (end != nullptr && *end != '\0')) return false;
    out = v;
    return true;
}

inline bool parse_u64(const char* s, uint64_t& out) {
    if (s == nullptr) return false;
    char* end = nullptr;
    const unsigned long long v = std::strtoull(s, &end, 10);
    if (end == s || (end != nullptr && *end != '\0')) return false;
    out = static_cast<uint64_t>(v);
    return true;
}

inline bool parse_i32(const char* s, int& out) {
    long long v = 0;
    if (!parse_i64(s, v)) return false;
    out = static_cast<int>(v);
    return true;
}

inline bool parse_f64(const char* s, double& out) {
    if (s == nullptr) return false;
    char* end = nullptr;
    const double v = std::strtod(s, &end);
    if (end == s || (end != nullptr && *end != '\0')) return false;
    out = v;
    return true;
}

inline ParseArgsResult parse_args(int argc, char** argv) {
    ParseArgsResult r{};

    for (int i = 1; i < argc; ++i) {
        const std::string_view a(argv[i] != nullptr ? argv[i] : "");
        auto next = [&](const char*& out) -> bool {
            if (i + 1 >= argc) return false;
            out = argv[++i];
            return out != nullptr;
        };

        const char* v = nullptr;
        if (a == "--box-rows" && next(v)) { parse_i32(v, r.cfg.box_rows); continue; }
        if (a == "--box-cols" && next(v)) { parse_i32(v, r.cfg.box_cols); continue; }
        if (a == "--difficulty" && next(v)) { parse_i32(v, r.cfg.difficulty_level_required); continue; }
        if (a == "--required-strategy" && next(v)) {
            RequiredStrategy rs{};
            if (parse_required_strategy(v, rs)) r.cfg.required_strategy = rs;
            continue;
        }
        if (a == "--target" && next(v)) { parse_u64(v, r.cfg.target_puzzles); continue; }
        if (a == "--threads" && next(v)) { parse_i32(v, r.cfg.threads); continue; }
        if (a == "--seed" && next(v)) { parse_u64(v, r.cfg.seed); continue; }

        if (a == "--min-clues" && next(v)) { parse_i32(v, r.cfg.min_clues); continue; }
        if (a == "--max-clues" && next(v)) { parse_i32(v, r.cfg.max_clues); continue; }

        if (a == "--output-folder" && next(v)) { r.cfg.output_folder = v; continue; }
        if (a == "--output-file" && next(v)) { r.cfg.output_file = v; continue; }
        if (a == "--single-file-only") { r.cfg.write_individual_files = false; continue; }

        if (a == "--reseed-interval-s" && next(v)) { parse_i32(v, r.cfg.reseed_interval_s); continue; }
        if (a == "--force-new-seed") { r.cfg.force_new_seed_per_attempt = true; continue; }
        if (a == "--no-force-new-seed") { r.cfg.force_new_seed_per_attempt = false; continue; }

        if (a == "--attempt-time-budget-s" && next(v)) { parse_f64(v, r.cfg.attempt_time_budget_s); continue; }
        if (a == "--attempt-node-budget" && next(v)) { parse_u64(v, r.cfg.attempt_node_budget); continue; }
        if (a == "--max-attempts" && next(v)) { parse_u64(v, r.cfg.max_attempts); continue; }
        if (a == "--max-total-time-s" && next(v)) { parse_u64(v, r.cfg.max_total_time_s); continue; }

        if (a == "--symmetry-center") { r.cfg.symmetry_center = true; continue; }
        if (a == "--no-symmetry-center") { r.cfg.symmetry_center = false; continue; }

        if (a == "--pattern-forcing") { r.cfg.pattern_forcing_enabled = true; continue; }
        if (a == "--pattern-forcing-tries" && next(v)) { parse_i32(v, r.cfg.pattern_forcing_tries); continue; }
        if (a == "--pattern-anchor-count" && next(v)) { parse_i32(v, r.cfg.pattern_forcing_anchor_count); continue; }
        if (a == "--no-pattern-lock-anchors") { r.cfg.pattern_forcing_lock_anchors = false; continue; }

        if (a == "--mcts-digger") { r.cfg.mcts_digger_enabled = true; continue; }
        if (a == "--no-mcts-digger") { r.cfg.mcts_digger_enabled = false; continue; }
        if (a == "--mcts-profile" && next(v)) { r.cfg.mcts_tuning_profile = v; continue; }
        if (a == "--mcts-p7") { r.cfg.mcts_digger_enabled = true; r.cfg.mcts_tuning_profile = "p7"; continue; }
        if (a == "--mcts-p8") { r.cfg.mcts_digger_enabled = true; r.cfg.mcts_tuning_profile = "p8"; continue; }
        if (a == "--mcts-iterations" && next(v)) { parse_i32(v, r.cfg.mcts_digger_iterations); continue; }
        if (a == "--mcts-ucb-c" && next(v)) { parse_f64(v, r.cfg.mcts_ucb_c); continue; }
        if (a == "--mcts-fail-cap" && next(v)) { parse_i32(v, r.cfg.mcts_fail_cap); continue; }
        if (a == "--mcts-basic-level" && next(v)) { parse_i32(v, r.cfg.mcts_basic_logic_level); continue; }
        if (a == "--max-pattern-depth" && next(v)) { parse_i32(v, r.cfg.max_pattern_depth); continue; }

        if (a == "--strict-logical") { r.cfg.strict_logical = true; continue; }
        if (a == "--strict-canonical-strategies") { r.cfg.strict_canonical_strategies = true; continue; }
        if (a == "--allow-proxy-advanced") { r.cfg.allow_proxy_advanced = true; continue; }
        if (a == "--no-proxy-advanced") { r.cfg.allow_proxy_advanced = false; continue; }
        if (a == "--no-quality-contract") { r.cfg.enable_quality_contract = false; continue; }
        if (a == "--distribution-filter") { r.cfg.enable_distribution_filter = true; continue; }
        if (a == "--replay-validation") { r.cfg.enable_replay_validation = true; continue; }

        if (a == "--vip-grade-target" && next(v)) { r.cfg.vip_grade_target = v; continue; }
        if (a == "--vip-min-grade-by-geometry" && next(v)) { r.cfg.vip_min_grade_by_geometry_path = v; continue; }
        if (a == "--vip-score-profile" && next(v)) { r.cfg.vip_score_profile = v; continue; }

        if (a == "--cpu-backend" && next(v)) { r.cfg.cpu_backend = v; continue; }

        if (a == "--list-geometries") { r.list_geometries = true; continue; }
        if (a == "--validate-geometry") { r.validate_geometry = true; continue; }
        if (a == "--validate-geometry-catalog") { r.validate_geometry_catalog = true; continue; }
        if (a == "--run-regression-tests") { r.run_regression_tests = true; continue; }

        if (a == "--run-geometry-gate") { r.run_geometry_gate = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.geometry_gate_report = argv[++i]; continue; }
        if (a == "--run-quality-benchmark") { r.run_quality_benchmark = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.quality_benchmark_report = argv[++i]; continue; }
        if (a == "--quality-benchmark-max-cases" && next(v)) { parse_u64(v, r.quality_benchmark_max_cases); continue; }
        if (a == "--run-pre-difficulty-gate") { r.run_pre_difficulty_gate = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.pre_difficulty_gate_report = argv[++i]; continue; }
        if (a == "--run-asym-pair-benchmark") { r.run_asym_pair_benchmark = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.asym_pair_benchmark_report = argv[++i]; continue; }
        if (a == "--run-vip-benchmark") { r.run_vip_benchmark = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.vip_benchmark_report = argv[++i]; continue; }
        if (a == "--run-vip-gate") { r.run_vip_gate = true; if (i + 1 < argc && argv[i + 1][0] != '-') r.vip_gate_report = argv[++i]; continue; }
        if (a == "--explain-profile") { r.explain_profile = true; continue; }

        if (a == "--benchmark-mode") { r.benchmark_mode = true; continue; }
        if (a == "--benchmark-output-file" && next(v)) { r.cfg.benchmark_output_file = v; continue; }
        if (a == "--fast-test") { r.cfg.fast_test_mode = true; continue; }
        if (a == "--no-fast-test") { r.cfg.fast_test_mode = false; continue; }

        if (a == "--stage-start") { r.cfg.stage_start = true; continue; }
        if (a == "--stage-end") { r.cfg.stage_end = true; continue; }
        if (a == "--perf-ab-suite") { r.cfg.perf_ab_suite = true; continue; }
    }

    r.cfg.difficulty_level_required = std::clamp(r.cfg.difficulty_level_required, 1, 9);
    r.cfg.max_pattern_depth = std::clamp(r.cfg.max_pattern_depth, 0, 8);
    if (r.cfg.min_clues < 0) r.cfg.min_clues = 0;
    if (r.cfg.max_clues < 0) r.cfg.max_clues = 0;

    if (r.cfg.target_puzzles == 0) {
        r.cfg.target_puzzles = 1;
    }

    return r;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\config\bit_utils.h
==============================================================================

﻿#pragma once

#include <bit>
#include <cstdint>

namespace sudoku_hpc::config {

inline int bit_ctz_u64(uint64_t v) {
    if (v == 0ULL) {
        return -1;
    }
    return static_cast<int>(std::countr_zero(v));
}

inline uint64_t bit_clear_lsb_u64(uint64_t v) {
    return v & (v - 1ULL);
}

inline uint64_t bit_lsb(uint64_t v) {
    return v & (~v + 1ULL);
}

inline int single_digit_from_mask(uint64_t mask) {
    if (mask == 0ULL || (mask & (mask - 1ULL)) != 0ULL) {
        return 0;
    }
    return bit_ctz_u64(mask) + 1;
}

inline int single_digit(uint64_t mask) {
    return single_digit_from_mask(mask);
}

} // namespace sudoku_hpc::config



==============================================================================
PLIK: Sources\config\run_config.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)
#pragma once

#include <algorithm>
#include <array>
#include <cctype>
#include <cstdint>
#include <cmath>
#include <sstream>
#include <string>
#include <string_view>

namespace sudoku_hpc {

enum class RequiredStrategy : int {
    None = 0,
    NakedSingle,
    HiddenSingle,
    PointingPairs,
    BoxLineReduction,
    NakedPair,
    HiddenPair,
    NakedTriple,
    HiddenTriple,
    NakedQuad,
    HiddenQuad,
    XWing,
    YWing,
    Skyscraper,
    TwoStringKite,
    EmptyRectangle,
    RemotePairs,
    Swordfish,
    FinnedXWingSashimi,
    SimpleColoring,
    BUGPlusOne,
    UniqueRectangle,
    XYZWing,
    WWing,
    Jellyfish,
    XChain,
    XYChain,
    WXYZWing,
    FinnedSwordfishJellyfish,
    ALSXZ,
    UniqueLoop,
    AvoidableRectangle,
    BivalueOddagon,
    UniqueRectangleExtended,
    HiddenUniqueRectangle,
    BUGType2,
    BUGType3,
    BUGType4,
    BorescoperQiuDeadlyPattern,
    Medusa3D,
    AIC,
    GroupedAIC,
    GroupedXCycle,
    ContinuousNiceLoop,
    ALSXYWing,
    ALSChain,
    AlignedPairExclusion,
    AlignedTripleExclusion,
    ALSAIC,
    SueDeCoq,
    DeathBlossom,
    FrankenFish,
    MutantFish,
    KrakenFish,
    Squirmbag,
    MSLS,
    Exocet,
    SeniorExocet,
    SKLoop,
    PatternOverlayMethod,
    ForcingChains,
    DynamicForcingChains,
    Backtracking,
};

enum class RejectReason : uint8_t {
    None = 0,
    Prefilter,
    Logic,
    Uniqueness,
    Strategy,
    Replay,
    DistributionBias,
    UniquenessBudget,
};

struct RequiredStrategyAttemptInfo {
    bool analyzed_required_strategy = false;
    bool required_strategy_use_confirmed = false;
    bool required_strategy_hit_confirmed = false;
    bool matched_required_strategy = false;
};

struct ClueRange {
    int min_clues = 0;
    int max_clues = 0;
};

struct GenerateRunConfig {
    int box_rows = 3;
    int box_cols = 3;

    uint64_t target_puzzles = 100;
    int min_clues = 0;
    int max_clues = 0;

    int difficulty_level_required = 1;
    RequiredStrategy required_strategy = RequiredStrategy::None;

    int threads = 0;
    uint64_t seed = 0;

    int reseed_interval_s = 0;
    bool force_new_seed_per_attempt = true;

    double attempt_time_budget_s = 0.0;
    uint64_t attempt_node_budget = 0;
    uint64_t max_attempts = 0;
    uint64_t max_total_time_s = 0;

    bool symmetry_center = false;
    bool require_unique = true;
    bool write_individual_files = true;
    bool pause_on_exit_windows = false;

    std::string output_folder = "generated_sudoku_files";
    std::string output_file = "generated_sudoku.txt";

    bool pattern_forcing_enabled = false;
    int pattern_forcing_tries = 6;
    int pattern_forcing_anchor_count = 0;
    bool pattern_forcing_lock_anchors = true;

    bool mcts_digger_enabled = true;
    std::string mcts_tuning_profile = "auto";
    int mcts_digger_iterations = 0;
    double mcts_ucb_c = 1.41;
    int mcts_fail_cap = 0;
    int mcts_basic_logic_level = 5;
    int max_pattern_depth = 0;

    bool strict_logical = false;
    bool strict_canonical_strategies = false;
    bool allow_proxy_advanced = true;
    bool enable_quality_contract = true;
    bool enable_distribution_filter = false;
    bool enable_replay_validation = false;

    std::string vip_grade_target = "gold";
    std::string vip_min_grade_by_geometry_path;
    std::string vip_score_profile = "standard";

    std::string cpu_backend = "scalar";

    bool stage_start = false;
    bool stage_end = false;
    bool perf_ab_suite = false;
    bool fast_test_mode = false;
    std::string benchmark_output_file = "benchmark_report.txt";
};

struct GenerateRunResult {
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t rejected = 0;

    uint64_t reject_prefilter = 0;
    uint64_t reject_logic = 0;
    uint64_t reject_uniqueness = 0;
    uint64_t reject_strategy = 0;
    uint64_t reject_replay = 0;
    uint64_t reject_distribution_bias = 0;
    uint64_t reject_uniqueness_budget = 0;

    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    double uniqueness_elapsed_ms = 0.0;
    double uniqueness_avg_ms = 0.0;

    std::string cpu_backend_selected = "scalar";
    double kernel_time_ms = 0.0;
    uint64_t kernel_calls = 0;
    double backend_efficiency_score = 0.0;
    double asymmetry_efficiency_index = 0.0;

    uint64_t logic_steps_total = 0;
    uint64_t strategy_naked_use = 0;
    uint64_t strategy_naked_hit = 0;
    uint64_t strategy_hidden_use = 0;
    uint64_t strategy_hidden_hit = 0;

    double vip_score = 0.0;
    std::string vip_grade = "none";
    bool vip_contract_ok = false;
    std::string vip_contract_fail_reason;

    std::string premium_signature;
    std::string premium_signature_v2;

    double elapsed_s = 0.0;
    double accepted_per_sec = 0.0;
};

inline std::string normalize_token(std::string_view in) {
    std::string out;
    out.reserve(in.size());
    for (const unsigned char ch : in) {
        if (std::isalnum(ch) != 0) {
            out.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    return out;
}

inline std::string to_string(RequiredStrategy rs) {
    switch (rs) {
        case RequiredStrategy::None: return "none";
        case RequiredStrategy::NakedSingle: return "nakedsingle";
        case RequiredStrategy::HiddenSingle: return "hiddensingle";
        case RequiredStrategy::PointingPairs: return "pointingpairs";
        case RequiredStrategy::BoxLineReduction: return "boxlinereduction";
        case RequiredStrategy::NakedPair: return "nakedpair";
        case RequiredStrategy::HiddenPair: return "hiddenpair";
        case RequiredStrategy::NakedTriple: return "nakedtriple";
        case RequiredStrategy::HiddenTriple: return "hiddentriple";
        case RequiredStrategy::NakedQuad: return "nakedquad";
        case RequiredStrategy::HiddenQuad: return "hiddenquad";
        case RequiredStrategy::XWing: return "xwing";
        case RequiredStrategy::YWing: return "ywing";
        case RequiredStrategy::Skyscraper: return "skyscraper";
        case RequiredStrategy::TwoStringKite: return "twostringkite";
        case RequiredStrategy::EmptyRectangle: return "emptyrectangle";
        case RequiredStrategy::RemotePairs: return "remotepairs";
        case RequiredStrategy::Swordfish: return "swordfish";
        case RequiredStrategy::FinnedXWingSashimi: return "finnedxwingsashimi";
        case RequiredStrategy::SimpleColoring: return "simplecoloring";
        case RequiredStrategy::BUGPlusOne: return "bugplusone";
        case RequiredStrategy::UniqueRectangle: return "uniquerectangle";
        case RequiredStrategy::XYZWing: return "xyzwing";
        case RequiredStrategy::WWing: return "wwing";
        case RequiredStrategy::Jellyfish: return "jellyfish";
        case RequiredStrategy::XChain: return "xchain";
        case RequiredStrategy::XYChain: return "xychain";
        case RequiredStrategy::WXYZWing: return "wxyzwing";
        case RequiredStrategy::FinnedSwordfishJellyfish: return "finnedswordfishjellyfish";
        case RequiredStrategy::ALSXZ: return "alsxz";
        case RequiredStrategy::UniqueLoop: return "uniqueloop";
        case RequiredStrategy::AvoidableRectangle: return "avoidablerectangle";
        case RequiredStrategy::BivalueOddagon: return "bivalueoddagon";
        case RequiredStrategy::UniqueRectangleExtended: return "uniquerectangleextended";
        case RequiredStrategy::HiddenUniqueRectangle: return "hiddenuniquerectangle";
        case RequiredStrategy::BUGType2: return "bugtype2";
        case RequiredStrategy::BUGType3: return "bugtype3";
        case RequiredStrategy::BUGType4: return "bugtype4";
        case RequiredStrategy::BorescoperQiuDeadlyPattern: return "borescoperqiudeadlypattern";
        case RequiredStrategy::Medusa3D: return "medusa3d";
        case RequiredStrategy::AIC: return "aic";
        case RequiredStrategy::GroupedAIC: return "groupedaic";
        case RequiredStrategy::GroupedXCycle: return "groupedxcycle";
        case RequiredStrategy::ContinuousNiceLoop: return "continuousniceloop";
        case RequiredStrategy::ALSXYWing: return "alsxywing";
        case RequiredStrategy::ALSChain: return "alschain";
        case RequiredStrategy::AlignedPairExclusion: return "alignedpairexclusion";
        case RequiredStrategy::AlignedTripleExclusion: return "alignedtripleexclusion";
        case RequiredStrategy::ALSAIC: return "alsaic";
        case RequiredStrategy::SueDeCoq: return "suedecoq";
        case RequiredStrategy::DeathBlossom: return "deathblossom";
        case RequiredStrategy::FrankenFish: return "frankenfish";
        case RequiredStrategy::MutantFish: return "mutantfish";
        case RequiredStrategy::KrakenFish: return "krakenfish";
        case RequiredStrategy::Squirmbag: return "squirmbag";
        case RequiredStrategy::MSLS: return "msls";
        case RequiredStrategy::Exocet: return "exocet";
        case RequiredStrategy::SeniorExocet: return "seniorexocet";
        case RequiredStrategy::SKLoop: return "skloop";
        case RequiredStrategy::PatternOverlayMethod: return "patternoverlaymethod";
        case RequiredStrategy::ForcingChains: return "forcingchains";
        case RequiredStrategy::DynamicForcingChains: return "dynamicforcingchains";
        case RequiredStrategy::Backtracking: return "backtracking";
    }
    return "none";
}

inline bool parse_required_strategy(std::string_view raw, RequiredStrategy& out) {
    const std::string key = normalize_token(raw);
    if (key.empty() || key == "none") { out = RequiredStrategy::None; return true; }

    static const std::array<std::pair<std::string_view, RequiredStrategy>, 63> map = {{
        {"nakedsingle", RequiredStrategy::NakedSingle},
        {"hiddensingle", RequiredStrategy::HiddenSingle},
        {"pointingpairs", RequiredStrategy::PointingPairs},
        {"boxlinereduction", RequiredStrategy::BoxLineReduction},
        {"nakedpair", RequiredStrategy::NakedPair},
        {"hiddenpair", RequiredStrategy::HiddenPair},
        {"nakedtriple", RequiredStrategy::NakedTriple},
        {"hiddentriple", RequiredStrategy::HiddenTriple},
        {"nakedquad", RequiredStrategy::NakedQuad},
        {"hiddenquad", RequiredStrategy::HiddenQuad},
        {"xwing", RequiredStrategy::XWing},
        {"ywing", RequiredStrategy::YWing},
        {"skyscraper", RequiredStrategy::Skyscraper},
        {"twostringkite", RequiredStrategy::TwoStringKite},
        {"emptyrectangle", RequiredStrategy::EmptyRectangle},
        {"remotepairs", RequiredStrategy::RemotePairs},
        {"swordfish", RequiredStrategy::Swordfish},
        {"finnedxwingsashimi", RequiredStrategy::FinnedXWingSashimi},
        {"simplecoloring", RequiredStrategy::SimpleColoring},
        {"bugplusone", RequiredStrategy::BUGPlusOne},
        {"uniquerectangle", RequiredStrategy::UniqueRectangle},
        {"xyzwing", RequiredStrategy::XYZWing},
        {"wwing", RequiredStrategy::WWing},
        {"jellyfish", RequiredStrategy::Jellyfish},
        {"xchain", RequiredStrategy::XChain},
        {"xychain", RequiredStrategy::XYChain},
        {"wxyzwing", RequiredStrategy::WXYZWing},
        {"finnedswordfishjellyfish", RequiredStrategy::FinnedSwordfishJellyfish},
        {"alsxz", RequiredStrategy::ALSXZ},
        {"uniqueloop", RequiredStrategy::UniqueLoop},
        {"avoidablerectangle", RequiredStrategy::AvoidableRectangle},
        {"bivalueoddagon", RequiredStrategy::BivalueOddagon},
        {"uniquerectangleextended", RequiredStrategy::UniqueRectangleExtended},
        {"hiddenuniquerectangle", RequiredStrategy::HiddenUniqueRectangle},
        {"bugtype2", RequiredStrategy::BUGType2},
        {"bugtype3", RequiredStrategy::BUGType3},
        {"bugtype4", RequiredStrategy::BUGType4},
        {"borescoperqiudeadlypattern", RequiredStrategy::BorescoperQiuDeadlyPattern},
        {"medusa3d", RequiredStrategy::Medusa3D},
        {"aic", RequiredStrategy::AIC},
        {"groupedaic", RequiredStrategy::GroupedAIC},
        {"groupedxcycle", RequiredStrategy::GroupedXCycle},
        {"continuousniceloop", RequiredStrategy::ContinuousNiceLoop},
        {"alsxywing", RequiredStrategy::ALSXYWing},
        {"alschain", RequiredStrategy::ALSChain},
        {"alignedpairexclusion", RequiredStrategy::AlignedPairExclusion},
        {"alignedtripleexclusion", RequiredStrategy::AlignedTripleExclusion},
        {"alsaic", RequiredStrategy::ALSAIC},
        {"suedecoq", RequiredStrategy::SueDeCoq},
        {"deathblossom", RequiredStrategy::DeathBlossom},
        {"frankenfish", RequiredStrategy::FrankenFish},
        {"mutantfish", RequiredStrategy::MutantFish},
        {"krakenfish", RequiredStrategy::KrakenFish},
        {"squirmbag", RequiredStrategy::Squirmbag},
        {"msls", RequiredStrategy::MSLS},
        {"exocet", RequiredStrategy::Exocet},
        {"seniorexocet", RequiredStrategy::SeniorExocet},
        {"skloop", RequiredStrategy::SKLoop},
        {"patternoverlaymethod", RequiredStrategy::PatternOverlayMethod},
        {"forcingchains", RequiredStrategy::ForcingChains},
        {"dynamicforcingchains", RequiredStrategy::DynamicForcingChains},
        {"backtracking", RequiredStrategy::Backtracking},
        {"bruteforce", RequiredStrategy::Backtracking},
    }};

    for (const auto& [name, value] : map) {
        if (key == name) {
            out = value;
            return true;
        }
    }
    return false;
}

inline bool is_geometry_size_supported(int box_rows, int box_cols) {
    if (box_rows <= 0 || box_cols <= 0) {
        return false;
    }
    const int n = box_rows * box_cols;
    return n >= 4 && n <= 64;
}

inline bool difficulty_level_selectable_for_geometry(int level, int box_rows, int box_cols) {
    if (!is_geometry_size_supported(box_rows, box_cols)) {
        return false;
    }
    return level >= 1 && level <= 9;
}

inline int strategy_min_level(RequiredStrategy rs) {
    switch (rs) {
        case RequiredStrategy::None: return 1;
        case RequiredStrategy::NakedSingle:
        case RequiredStrategy::HiddenSingle:
            return 1;
        case RequiredStrategy::PointingPairs:
        case RequiredStrategy::BoxLineReduction:
        case RequiredStrategy::NakedPair:
        case RequiredStrategy::HiddenPair:
        case RequiredStrategy::NakedTriple:
        case RequiredStrategy::HiddenTriple:
            return 2;
        case RequiredStrategy::NakedQuad:
        case RequiredStrategy::HiddenQuad:
        case RequiredStrategy::XWing:
        case RequiredStrategy::YWing:
        case RequiredStrategy::Skyscraper:
        case RequiredStrategy::TwoStringKite:
        case RequiredStrategy::EmptyRectangle:
        case RequiredStrategy::RemotePairs:
            return 4;
        case RequiredStrategy::Swordfish:
        case RequiredStrategy::FinnedXWingSashimi:
        case RequiredStrategy::SimpleColoring:
        case RequiredStrategy::BUGPlusOne:
        case RequiredStrategy::UniqueRectangle:
        case RequiredStrategy::XYZWing:
        case RequiredStrategy::WWing:
            return 5;
        case RequiredStrategy::Jellyfish:
        case RequiredStrategy::XChain:
        case RequiredStrategy::XYChain:
        case RequiredStrategy::WXYZWing:
        case RequiredStrategy::FinnedSwordfishJellyfish:
        case RequiredStrategy::ALSXZ:
        case RequiredStrategy::UniqueLoop:
        case RequiredStrategy::AvoidableRectangle:
        case RequiredStrategy::BivalueOddagon:
        case RequiredStrategy::UniqueRectangleExtended:
        case RequiredStrategy::HiddenUniqueRectangle:
        case RequiredStrategy::BUGType2:
        case RequiredStrategy::BUGType3:
        case RequiredStrategy::BUGType4:
        case RequiredStrategy::BorescoperQiuDeadlyPattern:
            return 6;
        case RequiredStrategy::Medusa3D:
        case RequiredStrategy::AIC:
        case RequiredStrategy::GroupedAIC:
        case RequiredStrategy::GroupedXCycle:
        case RequiredStrategy::ContinuousNiceLoop:
        case RequiredStrategy::ALSXYWing:
        case RequiredStrategy::ALSChain:
        case RequiredStrategy::AlignedPairExclusion:
        case RequiredStrategy::AlignedTripleExclusion:
        case RequiredStrategy::ALSAIC:
        case RequiredStrategy::SueDeCoq:
        case RequiredStrategy::DeathBlossom:
        case RequiredStrategy::FrankenFish:
        case RequiredStrategy::MutantFish:
        case RequiredStrategy::KrakenFish:
        case RequiredStrategy::Squirmbag:
            return 7;
        case RequiredStrategy::MSLS:
        case RequiredStrategy::Exocet:
        case RequiredStrategy::SeniorExocet:
        case RequiredStrategy::SKLoop:
        case RequiredStrategy::PatternOverlayMethod:
        case RequiredStrategy::ForcingChains:
        case RequiredStrategy::DynamicForcingChains:
            return 8;
        case RequiredStrategy::Backtracking:
            return 9;
    }
    return 9;
}

inline bool required_strategy_selectable_for_geometry(RequiredStrategy rs, int box_rows, int box_cols) {
    if (!is_geometry_size_supported(box_rows, box_cols)) {
        return false;
    }
    const int n = box_rows * box_cols;
    if (n < 5 && strategy_min_level(rs) >= 6) {
        return false;
    }
    return true;
}

inline double suggest_time_budget_s(int box_rows, int box_cols, int difficulty_level) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    const int lvl = std::clamp(difficulty_level, 1, 9);
    const double base = 0.018 * static_cast<double>(n) * static_cast<double>(n);
    const double diff = 0.85 + static_cast<double>(lvl) * 0.55;
    return std::clamp(base + diff, 1.0, 300.0);
}

inline int strategy_adjusted_level(int difficulty_level, RequiredStrategy required) {
    return std::max(std::clamp(difficulty_level, 1, 9), strategy_min_level(required));
}

inline int suggest_reseed_interval_s(int box_rows, int box_cols, int effective_level) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    const int lvl = std::clamp(effective_level, 1, 9);
    const int base = std::max(1, n / 3);
    return std::clamp(base + lvl, 2, 90);
}

inline int suggest_attempt_time_budget_seconds(int box_rows, int box_cols, int effective_level) {
    return static_cast<int>(std::ceil(suggest_time_budget_s(box_rows, box_cols, effective_level)));
}

inline uint64_t suggest_attempt_node_budget(int box_rows, int box_cols, int effective_level) {
    const uint64_t n = static_cast<uint64_t>(std::max(1, box_rows) * std::max(1, box_cols));
    const uint64_t lvl = static_cast<uint64_t>(std::clamp(effective_level, 1, 9));
    return std::clamp<uint64_t>(n * n * (200 + 60 * lvl), 50'000ULL, 20'000'000ULL);
}

inline ClueRange resolve_auto_clue_range(int box_rows, int box_cols, int difficulty_level, RequiredStrategy required) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    const int nn = n * n;
    const int lvl = std::max(std::clamp(difficulty_level, 1, 9), strategy_min_level(required));

    const double ratio_hi = std::clamp(0.62 - 0.035 * static_cast<double>(lvl - 1), 0.18, 0.70);
    const double ratio_lo = std::clamp(ratio_hi - 0.10, 0.12, ratio_hi);

    int min_clues = static_cast<int>(ratio_lo * static_cast<double>(nn));
    int max_clues = static_cast<int>(ratio_hi * static_cast<double>(nn));

    min_clues = std::max(min_clues, std::max(4, n));
    max_clues = std::max(max_clues, min_clues + std::max(2, n / 4));

    min_clues = std::clamp(min_clues, 0, nn);
    max_clues = std::clamp(max_clues, min_clues, nn);

    return {min_clues, max_clues};
}

inline std::string explain_generation_profile_text(const GenerateRunConfig& cfg) {
    std::ostringstream out;
    out << "Generation profile\n";
    out << "geometry=" << cfg.box_rows << "x" << cfg.box_cols << " (n=" << (cfg.box_rows * cfg.box_cols) << ")\n";
    out << "difficulty=" << cfg.difficulty_level_required << " required_strategy=" << to_string(cfg.required_strategy) << "\n";
    out << "mcts=" << (cfg.mcts_digger_enabled ? "on" : "off") << " profile=" << cfg.mcts_tuning_profile << "\n";
    out << "pattern_forcing=" << (cfg.pattern_forcing_enabled ? "on" : "off") << " tries=" << cfg.pattern_forcing_tries << "\n";
    out << "strict_canonical=" << (cfg.strict_canonical_strategies ? "on" : "off")
        << " allow_proxy_advanced=" << (cfg.allow_proxy_advanced ? "on" : "off")
        << " max_pattern_depth=" << cfg.max_pattern_depth << "\n";
    out << "fast_test_mode=" << (cfg.fast_test_mode ? "on" : "off") << "\n";
    out << "quality_contract=" << (cfg.enable_quality_contract ? "on" : "off") << " replay=" << (cfg.enable_replay_validation ? "on" : "off") << "\n";
    return out.str();
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\core\board.h
==============================================================================

﻿#pragma once

#include <algorithm>
#include <cstdint>
#include <vector>

#include "geometry.h"

namespace sudoku_hpc {

struct GenericThreadScratch {
    int prepared_n = 0;
    std::vector<uint64_t> row_tmp;
    std::vector<uint64_t> col_tmp;
    std::vector<uint64_t> box_tmp;

    void ensure(const GenericTopology& topo) {
        if (prepared_n == topo.n) {
            return;
        }
        row_tmp.assign(static_cast<size_t>(topo.n), 0ULL);
        col_tmp.assign(static_cast<size_t>(topo.n), 0ULL);
        box_tmp.assign(static_cast<size_t>(topo.n), 0ULL);
        prepared_n = topo.n;
    }
};

inline GenericThreadScratch& generic_tls_for(const GenericTopology& topo) {
    thread_local GenericThreadScratch scratch;
    scratch.ensure(topo);
    return scratch;
}

struct GenericBoard {
    const GenericTopology* topo = nullptr;

    std::vector<uint16_t> values;
    std::vector<uint64_t> row_used;
    std::vector<uint64_t> col_used;
    std::vector<uint64_t> box_used;

    uint64_t full_mask = 0ULL;
    int empty_cells = 0;

    static int packed_row(uint32_t packed) {
        return static_cast<int>(packed & 63U);
    }

    static int packed_col(uint32_t packed) {
        return static_cast<int>((packed >> 6U) & 63U);
    }

    static int packed_box(uint32_t packed) {
        return static_cast<int>((packed >> 12U) & 63U);
    }

    void reset(const GenericTopology& t) {
        topo = &t;
        values.assign(static_cast<size_t>(t.nn), 0);
        row_used.assign(static_cast<size_t>(t.n), 0ULL);
        col_used.assign(static_cast<size_t>(t.n), 0ULL);
        box_used.assign(static_cast<size_t>(t.n), 0ULL);
        full_mask = (t.n >= 64) ? ~0ULL : ((1ULL << t.n) - 1ULL);
        empty_cells = t.nn;
    }

    bool can_place(int idx, int d) const {
        if (topo == nullptr || idx < 0 || idx >= topo->nn || d < 1 || d > topo->n) {
            return false;
        }
        const uint16_t cur = values[static_cast<size_t>(idx)];
        if (cur != 0) {
            return cur == static_cast<uint16_t>(d);
        }

        const uint32_t p = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(p);
        const int c = packed_col(p);
        const int b = packed_box(p);

        const uint64_t bit = (1ULL << (d - 1));
        return ((row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)]) & bit) == 0ULL;
    }

    bool place(int idx, int d) {
        if (!can_place(idx, d)) {
            return false;
        }
        const uint16_t cur = values[static_cast<size_t>(idx)];
        if (cur == static_cast<uint16_t>(d)) {
            return true;
        }

        const uint32_t p = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(p);
        const int c = packed_col(p);
        const int b = packed_box(p);
        const uint64_t bit = (1ULL << (d - 1));

        values[static_cast<size_t>(idx)] = static_cast<uint16_t>(d);
        row_used[static_cast<size_t>(r)] |= bit;
        col_used[static_cast<size_t>(c)] |= bit;
        box_used[static_cast<size_t>(b)] |= bit;
        --empty_cells;
        return true;
    }

    void unplace(int idx, int d) {
        if (topo == nullptr || idx < 0 || idx >= topo->nn || d < 1 || d > topo->n) {
            return;
        }
        if (values[static_cast<size_t>(idx)] == 0) {
            return;
        }

        const uint32_t p = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(p);
        const int c = packed_col(p);
        const int b = packed_box(p);
        const uint64_t bit = (1ULL << (d - 1));

        values[static_cast<size_t>(idx)] = 0;
        row_used[static_cast<size_t>(r)] &= ~bit;
        col_used[static_cast<size_t>(c)] &= ~bit;
        box_used[static_cast<size_t>(b)] &= ~bit;
        ++empty_cells;
    }

    uint64_t candidate_mask_for_idx(int idx) const {
        if (topo == nullptr || idx < 0 || idx >= topo->nn) {
            return 0ULL;
        }
        if (values[static_cast<size_t>(idx)] != 0) {
            return 0ULL;
        }
        const uint32_t p = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(p);
        const int c = packed_col(p);
        const int b = packed_box(p);
        const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
        return (~used) & full_mask;
    }

    bool init_from_puzzle(const std::vector<uint16_t>& puzzle, bool allow_invalid) {
        if (topo == nullptr) {
            return false;
        }
        if (static_cast<int>(puzzle.size()) != topo->nn) {
            return false;
        }
        reset(*topo);

        for (int idx = 0; idx < topo->nn; ++idx) {
            const int v = static_cast<int>(puzzle[static_cast<size_t>(idx)]);
            if (v == 0) {
                continue;
            }
            if (v < 1 || v > topo->n || !place(idx, v)) {
                if (allow_invalid) {
                    return false;
                }
                return false;
            }
        }
        return true;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\core\candidate_state.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CORE
// Moduł: candidate_state.h
// Opis: Reprezentacja stanu poszukiwań. Zmieniona z wektora na wskaźnik do
//       pamięci Thread Local Storage. Zapewnia Zero-Allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <chrono>

#include "board.h"
#include "geometry.h"
#include "../logic/logic_result.h"

namespace sudoku_hpc {

using logic::ApplyResult;

struct CandidateState {
    GenericBoard* board = nullptr;
    const GenericTopology* topo = nullptr;
    
    // Wskaźnik na płaski bufor thread_local, zapobiega alokacjom na stercie w trakcie rozwiązywania
    uint64_t* cands = nullptr;

    bool init(GenericBoard& b, const GenericTopology& t, uint64_t* tls_buffer) {
        board = &b;
        topo = &t;
        cands = tls_buffer;
        
        for (int idx = 0; idx < t.nn; ++idx) {
            if (b.values[idx] != 0) {
                cands[idx] = 0ULL;
                continue;
            }
            const uint64_t m = b.candidate_mask_for_idx(idx);
            if (m == 0ULL) return false;
            cands[idx] = m;
        }
        return true;
    }

    uint64_t now_ns() const {
        return static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
    }

    bool is_peer(int a, int b) const {
        if (a == b) return false;
        return topo->cell_row[a] == topo->cell_row[b] ||
               topo->cell_col[a] == topo->cell_col[b] ||
               topo->cell_box[a] == topo->cell_box[b];
    }

    bool place(int idx, int d) {
        if (board->values[idx] != 0) {
            return board->values[idx] == static_cast<uint16_t>(d);
        }
        const uint64_t bit = (1ULL << (d - 1));
        if ((cands[idx] & bit) == 0ULL) return false;
        if (!board->can_place(idx, d)) return false;
        
        board->place(idx, d);
        cands[idx] = 0ULL;
        
        const int p0 = topo->peer_offsets[idx];
        const int p1 = topo->peer_offsets[idx + 1];
        
        for (int p = p0; p < p1; ++p) {
            const int peer = topo->peers_flat[p];
            if (board->values[peer] != 0) continue;
            
            uint64_t& pm = cands[peer];
            if ((pm & bit) == 0ULL) continue;
            
            pm &= ~bit;
            if (pm == 0ULL) return false; // Sprzeczność - wyczerpano kandydatów
        }
        return true;
    }

    ApplyResult eliminate(int idx, uint64_t rm) {
        if (rm == 0ULL || board->values[idx] != 0) return ApplyResult::NoProgress;
        
        uint64_t& m = cands[idx];
        if ((m & rm) == 0ULL) return ApplyResult::NoProgress;
        
        m &= ~rm;
        if (m == 0ULL) return ApplyResult::Contradiction;
        
        return ApplyResult::Progress;
    }

    ApplyResult keep_only(int idx, uint64_t allowed) {
        if (board->values[idx] != 0) return ApplyResult::NoProgress;
        
        uint64_t& m = cands[idx];
        const uint64_t nm = m & allowed;
        
        if (nm == m) return ApplyResult::NoProgress;
        if (nm == 0ULL) return ApplyResult::Contradiction;
        
        m = nm;
        return ApplyResult::Progress;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\core\geometry.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)
#pragma once

#include <algorithm>
#include <array>
#include <cstdint>
#include <mutex>
#include <ostream>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

namespace sudoku_hpc {

struct GenericTopology {
    int box_rows = 0;
    int box_cols = 0;
    int n = 0;
    int nn = 0;

    int box_rows_count = 0;
    int box_cols_count = 0;

    std::vector<int> cell_row;
    std::vector<int> cell_col;
    std::vector<int> cell_box;
    std::vector<int> cell_center_sym;
    std::vector<uint32_t> cell_rcb_packed;

    std::vector<int> house_offsets;
    std::vector<int> houses_flat;

    std::vector<int> peer_offsets;
    std::vector<int> peers_flat;
};

inline uint32_t pack_rcb(int r, int c, int b) {
    return static_cast<uint32_t>((r & 63) | ((c & 63) << 6) | ((b & 63) << 12));
}

inline bool build_generic_topology(int box_rows, int box_cols, GenericTopology& topo, std::string* err = nullptr) {
    if (box_rows <= 0 || box_cols <= 0) {
        if (err != nullptr) *err = "box_rows and box_cols must be > 0";
        return false;
    }

    const int n = box_rows * box_cols;
    if (n < 4 || n > 64) {
        if (err != nullptr) *err = "n=box_rows*box_cols must be in [4,64]";
        return false;
    }

    const int nn = n * n;
    topo = {};
    topo.box_rows = box_rows;
    topo.box_cols = box_cols;
    topo.n = n;
    topo.nn = nn;
    topo.box_rows_count = n / box_rows;
    topo.box_cols_count = n / box_cols;

    topo.cell_row.resize(static_cast<size_t>(nn));
    topo.cell_col.resize(static_cast<size_t>(nn));
    topo.cell_box.resize(static_cast<size_t>(nn));
    topo.cell_center_sym.resize(static_cast<size_t>(nn));
    topo.cell_rcb_packed.resize(static_cast<size_t>(nn));

    for (int r = 0; r < n; ++r) {
        for (int c = 0; c < n; ++c) {
            const int idx = r * n + c;
            const int br = r / box_rows;
            const int bc = c / box_cols;
            const int box = br * topo.box_cols_count + bc;

            topo.cell_row[static_cast<size_t>(idx)] = r;
            topo.cell_col[static_cast<size_t>(idx)] = c;
            topo.cell_box[static_cast<size_t>(idx)] = box;
            topo.cell_center_sym[static_cast<size_t>(idx)] = (n - 1 - r) * n + (n - 1 - c);
            topo.cell_rcb_packed[static_cast<size_t>(idx)] = pack_rcb(r, c, box);
        }
    }

    const int house_count = 3 * n;
    topo.house_offsets.resize(static_cast<size_t>(house_count + 1), 0);
    topo.houses_flat.reserve(static_cast<size_t>(house_count * n));

    int cursor = 0;
    for (int h = 0; h < n; ++h) {
        topo.house_offsets[static_cast<size_t>(h)] = cursor;
        for (int c = 0; c < n; ++c) {
            topo.houses_flat.push_back(h * n + c);
            ++cursor;
        }
    }
    for (int h = 0; h < n; ++h) {
        topo.house_offsets[static_cast<size_t>(n + h)] = cursor;
        for (int r = 0; r < n; ++r) {
            topo.houses_flat.push_back(r * n + h);
            ++cursor;
        }
    }
    for (int b = 0; b < n; ++b) {
        topo.house_offsets[static_cast<size_t>(2 * n + b)] = cursor;
        const int br = b / topo.box_cols_count;
        const int bc = b % topo.box_cols_count;
        const int r0 = br * box_rows;
        const int c0 = bc * box_cols;
        for (int dr = 0; dr < box_rows; ++dr) {
            for (int dc = 0; dc < box_cols; ++dc) {
                topo.houses_flat.push_back((r0 + dr) * n + (c0 + dc));
                ++cursor;
            }
        }
    }
    topo.house_offsets[static_cast<size_t>(house_count)] = cursor;

    topo.peer_offsets.resize(static_cast<size_t>(nn + 1), 0);
    topo.peers_flat.clear();
    topo.peers_flat.reserve(static_cast<size_t>(nn * (3 * n)));

    std::array<uint8_t, 4096> seen{};
    for (int idx = 0; idx < nn; ++idx) {
        std::fill(seen.begin(), seen.end(), static_cast<uint8_t>(0));

        const int r = topo.cell_row[static_cast<size_t>(idx)];
        const int c = topo.cell_col[static_cast<size_t>(idx)];
        const int b = topo.cell_box[static_cast<size_t>(idx)];

        topo.peer_offsets[static_cast<size_t>(idx)] = static_cast<int>(topo.peers_flat.size());

        for (int cc = 0; cc < n; ++cc) {
            const int p = r * n + cc;
            if (p == idx || seen[static_cast<size_t>(p)] != 0) continue;
            seen[static_cast<size_t>(p)] = 1;
            topo.peers_flat.push_back(p);
        }
        for (int rr = 0; rr < n; ++rr) {
            const int p = rr * n + c;
            if (p == idx || seen[static_cast<size_t>(p)] != 0) continue;
            seen[static_cast<size_t>(p)] = 1;
            topo.peers_flat.push_back(p);
        }

        const int br = b / topo.box_cols_count;
        const int bc = b % topo.box_cols_count;
        const int r0 = br * box_rows;
        const int c0 = bc * box_cols;
        for (int dr = 0; dr < box_rows; ++dr) {
            for (int dc = 0; dc < box_cols; ++dc) {
                const int p = (r0 + dr) * n + (c0 + dc);
                if (p == idx || seen[static_cast<size_t>(p)] != 0) continue;
                seen[static_cast<size_t>(p)] = 1;
                topo.peers_flat.push_back(p);
            }
        }
    }
    topo.peer_offsets[static_cast<size_t>(nn)] = static_cast<int>(topo.peers_flat.size());

    return true;
}

inline const std::vector<std::pair<int, int>>& supported_geometry_pairs() {
    static const std::vector<std::pair<int, int>> pairs = [] {
        std::vector<std::pair<int, int>> out;
        for (int n = 4; n <= 64; ++n) {
            for (int br = 1; br <= n; ++br) {
                if (n % br != 0) continue;
                const int bc = n / br;
                out.emplace_back(br, bc);
            }
        }
        return out;
    }();
    return pairs;
}

inline std::string supported_geometries_text() {
    std::ostringstream out;
    out << "Supported geometries (asymmetric included), n in [4,64]\n";
    for (int n = 4; n <= 64; ++n) {
        out << "n=" << n << ": ";
        bool first = true;
        for (const auto& [br, bc] : supported_geometry_pairs()) {
            if (br * bc != n) continue;
            if (!first) out << ", ";
            first = false;
            out << br << "x" << bc;
        }
        out << "\n";
    }
    return out.str();
}

inline bool print_geometry_validation(int box_rows, int box_cols, std::ostream& out) {
    GenericTopology topo;
    std::string err;
    const bool ok = build_generic_topology(box_rows, box_cols, topo, &err);
    out << "geometry " << box_rows << "x" << box_cols << ": " << (ok ? "ok" : "fail") << "\n";
    if (!ok) {
        out << "reason: " << err << "\n";
        return false;
    }
    out << "n=" << topo.n << " nn=" << topo.nn
        << " box_rows_count=" << topo.box_rows_count
        << " box_cols_count=" << topo.box_cols_count << "\n";
    out << "houses=" << (static_cast<int>(topo.house_offsets.size()) - 1)
        << " peers_flat=" << topo.peers_flat.size() << "\n";
    return true;
}

inline bool print_geometry_catalog_validation(std::ostream& out) {
    int ok_count = 0;
    for (const auto& [br, bc] : supported_geometry_pairs()) {
        GenericTopology topo;
        std::string err;
        const bool ok = build_generic_topology(br, bc, topo, &err);
        if (!ok) {
            out << "FAIL " << br << "x" << bc << ": " << err << "\n";
            return false;
        }

        const int house_count = static_cast<int>(topo.house_offsets.size()) - 1;
        if (house_count != 3 * topo.n) {
            out << "FAIL " << br << "x" << bc << ": house_count mismatch\n";
            return false;
        }
        if (static_cast<int>(topo.cell_row.size()) != topo.nn ||
            static_cast<int>(topo.cell_col.size()) != topo.nn ||
            static_cast<int>(topo.cell_box.size()) != topo.nn ||
            static_cast<int>(topo.cell_center_sym.size()) != topo.nn) {
            out << "FAIL " << br << "x" << bc << ": cell arrays size mismatch\n";
            return false;
        }
        ++ok_count;
    }
    out << "Geometry catalog validation OK. cases=" << ok_count << "\n";
    return true;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\generator\concurrency\persistent_thread_pool.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CONCURRENCY
// Moduł: persistent_thread_pool.h
// Opis: Ekstremalnie niskolatencyjna pula wątków typu "Start & Wait".
//       Zoptymalizowana w C++20 poprzez użycie std::atomic::wait/notify.
//       Rozwiązany problem "missed wake-up".
// ============================================================================

#pragma once

#include <atomic>
#include <functional>
#include <mutex>
#include <thread>
#include <vector>

namespace sudoku_hpc::concurrency {

class PersistentThreadPool {
public:
    static PersistentThreadPool& instance() {
        static PersistentThreadPool pool;
        return pool;
    }

    // Wykonuje zadanie fn() w thread_count wątkach. Blokuje wątek wywołujący 
    // dopóki ostatni worker nie zgłosi zakończenia zadania.
    void run(int task_count, const std::function<void(int)>& fn) {
        if (task_count <= 0) {
            return;
        }

        std::lock_guard<std::mutex> run_guard(run_mu_);
        ensure_workers(task_count);

        job_fn_ = &fn;
        task_count_.store(task_count, std::memory_order_relaxed);
        next_task_.store(0, std::memory_order_relaxed);
        
        // Zapisz ile zadań pozostało przed budzeniem, aby zapobiec wybudzeniu 
        // zarządcy zanim workerzy zaczną przetwarzać
        remaining_.store(task_count, std::memory_order_release);
        
        // Zbudź workery korzystając z szybkiego mechanizmu w C++20
        epoch_.fetch_add(1, std::memory_order_acq_rel);
        epoch_.notify_all();

        // Czekaj bez aktywnego spinowania aż ostatni worker zakończy zadanie
        while (true) {
            const int rem = remaining_.load(std::memory_order_acquire);
            if (rem <= 0) break;
            remaining_.wait(rem, std::memory_order_acquire);
        }
    }

private:
    PersistentThreadPool() = default;

    ~PersistentThreadPool() {
        stop_.store(true, std::memory_order_release);
        epoch_.fetch_add(1, std::memory_order_acq_rel);
        epoch_.notify_all();
        for (auto& t : workers_) {
            if (t.joinable()) {
                t.join();
            }
        }
    }

    void ensure_workers(int min_workers) {
        const int base = std::max(1u, std::thread::hardware_concurrency());
        const int target = std::max(base, min_workers);
        if (static_cast<int>(workers_.size()) >= target) {
            return;
        }
        workers_.reserve(static_cast<size_t>(target));
        for (int i = static_cast<int>(workers_.size()); i < target; ++i) {
            workers_.emplace_back([this]() { worker_loop(); });
        }
    }

    void worker_loop() {
        // Zabezpiecza przed "missed wake-up". Nawet jeśli ten worker 
        // wystartował z opóźnieniem (np. po tym jak główny wątek wywołał już run() 
        // i podbił epoch_), to `seen_epoch` równe 0 zmusza go do dogonienia `epoch_`.
        uint64_t seen_epoch = 0;

        while (true) {
            if (stop_.load(std::memory_order_acquire)) return;
            
            // Czekamy na zmianę epoki zadaniowej. Zabezpiecza przed spurious wakeups.
            epoch_.wait(seen_epoch, std::memory_order_acquire);
            seen_epoch = epoch_.load(std::memory_order_acquire);
            
            if (stop_.load(std::memory_order_acquire)) return;

            // Worker konsumuje paczki zadań, aż licznik next_task dojdzie do limitu task_count.
            while (true) {
                const int idx = next_task_.fetch_add(1, std::memory_order_relaxed);
                if (idx >= task_count_.load(std::memory_order_relaxed)) {
                    break;
                }
                
                // Uruchomienie wyznaczonego zadania.
                (*job_fn_)(idx);
                
                // Atomowe odjęcie zadania ze wskaźnikiem na zakończenie całego bloku (1 => to był ostatni)
                if (remaining_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
                    // Budzimy główny wątek z funkcji run()
                    remaining_.notify_one();
                }
            }
        }
    }

    std::mutex run_mu_;
    std::vector<std::thread> workers_;
    
    // Pola współdzielone do delegacji zlecenia (tylko wskaźnik, unika kopiowania function)
    const std::function<void(int)>* job_fn_{nullptr};
    
    // Liczniki blokowane do oddzielnych warstw Cache'a
    alignas(64) std::atomic<int> task_count_{0};
    alignas(64) std::atomic<int> next_task_{0};
    alignas(64) std::atomic<int> remaining_{0};
    
    // Zarządzanie stanem i wybudzaniem
    alignas(64) std::atomic<uint64_t> epoch_{0};
    alignas(64) std::atomic<bool> stop_{false};
};

} // namespace sudoku_hpc::concurrency



==============================================================================
PLIK: Sources\generator\concurrency\telemetry_ring.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CONCURRENCY
// Moduł: telemetry_ring.h
// Opis: Wysoce wydajne, bezblokadowe (Lock-Free) kolejki pierścieniowe MPSC 
//       do przesyłania statystyk telemetrii oraz danych wynikowych z workerów.
//       Rozmiary chronione cache-line alignmentem (false sharing avoidance).
// ============================================================================

#pragma once

#include <array>
#include <atomic>
#include <cstdint>
#include <cstring>
#include <string>

namespace sudoku_hpc::concurrency {

struct TelemetryDelta {
    uint64_t attempts = 0;
    uint64_t rejected = 0;
    uint64_t reject_prefilter = 0;
    uint64_t reject_logic = 0;
    uint64_t reject_uniqueness = 0;
    uint64_t reject_strategy = 0;
    uint64_t reject_replay = 0;
    uint64_t reject_distribution_bias = 0;
    uint64_t reject_uniqueness_budget = 0;
    uint64_t analyzed_required = 0;
    uint64_t required_hits = 0;
    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    uint64_t uniqueness_elapsed_ns = 0;
    uint64_t logic_steps = 0;
    uint64_t naked_use = 0;
    uint64_t naked_hit = 0;
    uint64_t hidden_use = 0;
    uint64_t hidden_hit = 0;
    uint64_t reseeds = 0;

    bool empty() const noexcept {
        return attempts == 0 && rejected == 0 && reject_prefilter == 0 &&
               reject_logic == 0 && reject_uniqueness == 0 && reject_strategy == 0 &&
               reject_replay == 0 && reject_distribution_bias == 0 &&
               reject_uniqueness_budget == 0 && analyzed_required == 0 &&
               required_hits == 0 && uniqueness_calls == 0 && uniqueness_nodes == 0 &&
               uniqueness_elapsed_ns == 0 && logic_steps == 0 && naked_use == 0 &&
               naked_hit == 0 && hidden_use == 0 && hidden_hit == 0 && reseeds == 0;
    }
};

// ============================================================================
// KOLEJKA TELEMETRII (MPSC RING BUFFER)
// ============================================================================
template <size_t CapacityPow2 = 16384>
class alignas(64) TelemetryMpscRing {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "CapacityPow2 must be power-of-two");

    struct alignas(64) Slot {
        std::atomic<uint64_t> seq{0};
        TelemetryDelta payload{};
    };

public:
    TelemetryMpscRing() {
        for (size_t i = 0; i < CapacityPow2; ++i) {
            slots_[i].seq.store(static_cast<uint64_t>(i), std::memory_order_relaxed);
        }
    }

    bool try_push(const TelemetryDelta& delta) noexcept {
        uint64_t pos = head_.load(std::memory_order_relaxed);
        for (;;) {
            Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
            const uint64_t seq = slot.seq.load(std::memory_order_acquire);
            const intptr_t diff = static_cast<intptr_t>(seq) - static_cast<intptr_t>(pos);
            
            if (diff == 0) {
                if (head_.compare_exchange_weak(pos, pos + 1ULL, std::memory_order_relaxed, std::memory_order_relaxed)) {
                    slot.payload = delta;
                    slot.seq.store(pos + 1ULL, std::memory_order_release);
                    return true;
                }
                continue;
            }
            // Zbyt wolny konsument - wyrzucamy próbkę
            if (diff < 0) {
                dropped_.fetch_add(1, std::memory_order_relaxed);
                return false;
            }
            pos = head_.load(std::memory_order_relaxed);
        }
    }

    bool try_pop(TelemetryDelta& out) noexcept {
        const uint64_t pos = tail_.load(std::memory_order_relaxed);
        Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
        const uint64_t seq = slot.seq.load(std::memory_order_acquire);
        
        if (seq != (pos + 1ULL)) {
            return false;
        }
        out = slot.payload;
        slot.seq.store(pos + CapacityPow2, std::memory_order_release);
        tail_.store(pos + 1ULL, std::memory_order_relaxed);
        return true;
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

private:
    static constexpr uint64_t kMask = static_cast<uint64_t>(CapacityPow2 - 1);
    std::array<Slot, CapacityPow2> slots_{};
    
    // Zapobiega falszywemu współdzieleniu między wątkami zrzucając head_ i tail_ do oddzielnych cache-lines
    alignas(64) std::atomic<uint64_t> head_{0};
    alignas(64) std::atomic<uint64_t> tail_{0};
    alignas(64) std::atomic<uint64_t> dropped_{0};
};


// ============================================================================
// KOLEJKA WYNIKOWA (MPSC RING BUFFER)
// ============================================================================
struct OutputLineEvent {
    static constexpr size_t kMaxLineBytes = 8192;
    uint64_t accepted_idx = 0;
    uint32_t len = 0;
    std::array<char, kMaxLineBytes> bytes{};
};

template <size_t CapacityPow2 = 2048>
class alignas(64) OutputLineMpscRing {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "CapacityPow2 must be power-of-two");

    struct alignas(64) Slot {
        std::atomic<uint64_t> seq{0};
        OutputLineEvent payload{};
    };

public:
    OutputLineMpscRing() {
        for (size_t i = 0; i < CapacityPow2; ++i) {
            slots_[i].seq.store(static_cast<uint64_t>(i), std::memory_order_relaxed);
        }
    }

    bool try_push(uint64_t accepted_idx, const std::string& line) noexcept {
        if (line.size() > OutputLineEvent::kMaxLineBytes) {
            oversize_.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
        uint64_t pos = head_.load(std::memory_order_relaxed);
        for (;;) {
            Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
            const uint64_t seq = slot.seq.load(std::memory_order_acquire);
            const intptr_t diff = static_cast<intptr_t>(seq) - static_cast<intptr_t>(pos);
            
            if (diff == 0) {
                if (head_.compare_exchange_weak(pos, pos + 1ULL, std::memory_order_relaxed, std::memory_order_relaxed)) {
                    slot.payload.accepted_idx = accepted_idx;
                    slot.payload.len = static_cast<uint32_t>(line.size());
                    std::memcpy(slot.payload.bytes.data(), line.data(), line.size());
                    slot.seq.store(pos + 1ULL, std::memory_order_release);
                    return true;
                }
                continue;
            }
            if (diff < 0) {
                dropped_.fetch_add(1, std::memory_order_relaxed);
                return false;
            }
            pos = head_.load(std::memory_order_relaxed);
        }
    }

    bool try_pop(OutputLineEvent& out) noexcept {
        const uint64_t pos = tail_.load(std::memory_order_relaxed);
        Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
        const uint64_t seq = slot.seq.load(std::memory_order_acquire);
        
        if (seq != (pos + 1ULL)) {
            return false;
        }
        out = slot.payload;
        slot.seq.store(pos + CapacityPow2, std::memory_order_release);
        tail_.store(pos + 1ULL, std::memory_order_relaxed);
        return true;
    }

    bool empty() const noexcept {
        return tail_.load(std::memory_order_acquire) == head_.load(std::memory_order_acquire);
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

    uint64_t oversize() const noexcept {
        return oversize_.load(std::memory_order_relaxed);
    }

private:
    static constexpr uint64_t kMask = static_cast<uint64_t>(CapacityPow2 - 1);
    std::array<Slot, CapacityPow2> slots_{};
    
    alignas(64) std::atomic<uint64_t> head_{0};
    alignas(64) std::atomic<uint64_t> tail_{0};
    alignas(64) std::atomic<uint64_t> dropped_{0};
    alignas(64) std::atomic<uint64_t> oversize_{0};
};

} // namespace sudoku_hpc::concurrency



==============================================================================
PLIK: Sources\generator\core_engines\dlx_solver.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CORE ENGINES
// Moduł: dlx_solver.h
// Opis: Algorytm Dancing Links (DLX) do walidacji unikalności z mechanizmem
//       narzucania wzorców binarowych (allowed_masks) - Pattern Forcing Bridge.
// ============================================================================

#pragma once

#include <algorithm>
#include <array>
#include <bit>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include <atomic>
#include <vector>

#include "../../core/geometry.h"
#include "../../core/board.h"
#include "../../config/bit_utils.h" 

namespace sudoku_hpc::core_engines {

struct SearchAbortControl {
    bool time_enabled = false;
    bool node_enabled = false;
    std::chrono::steady_clock::time_point deadline{};
    uint64_t node_limit = 0;
    uint64_t nodes = 0;

    const std::atomic<bool>* force_abort_ptr = nullptr;
    const std::atomic<bool>* cancel_ptr = nullptr;
    const std::atomic<bool>* pause_ptr = nullptr;

    bool aborted_by_time = false;
    bool aborted_by_nodes = false;
    bool aborted_by_cancel = false;
    bool aborted_by_pause = false;
    bool aborted_by_force = false;

    bool aborted() const {
        return aborted_by_time || aborted_by_nodes || aborted_by_cancel || aborted_by_pause || aborted_by_force;
    }

    bool step(uint64_t add_nodes = 1) {
        nodes += add_nodes;

        if (force_abort_ptr != nullptr && force_abort_ptr->load(std::memory_order_relaxed)) {
            aborted_by_force = true;
            return false;
        }
        if (cancel_ptr != nullptr && cancel_ptr->load(std::memory_order_relaxed)) {
            aborted_by_cancel = true;
            return false;
        }
        if (pause_ptr != nullptr && pause_ptr->load(std::memory_order_relaxed)) {
            aborted_by_pause = true;
            return false;
        }
        if (node_enabled && node_limit > 0 && nodes >= node_limit) {
            aborted_by_nodes = true;
            return false;
        }
        if (time_enabled && std::chrono::steady_clock::now() >= deadline) {
            aborted_by_time = true;
            return false;
        }
        return true;
    }
};

struct GenericUniquenessCounter {
    static constexpr int kUnifiedMaxN = 64;

    struct UnifiedWideDlx {
        int n = 0;
        int nn = 0;
        int rows = 0;
        int cols = 0;
        int row_words = 0;
        int col_words = 0;
        int max_depth = 0;

        std::vector<std::array<uint16_t, 4>> row_cols;
        std::vector<uint64_t> col_rows_bits; // [cols * row_words]

        // Pamięć operacyjna dla aktualnego przebiegu szukania.
        std::vector<uint64_t> active_rows;    // [row_words]
        std::vector<uint64_t> uncovered_cols; // [col_words]

        // Undo logs - logi cofania. Zapewniają unikanie realokacji Node'ów w pamięci
        std::vector<uint16_t> undo_active_idx;
        std::vector<uint64_t> undo_active_old;
        std::vector<uint16_t> undo_col_idx;
        std::vector<uint64_t> undo_col_old;

        // Płaski stos dla zagnieżdżeń DFS z rekurencją zamienioną na "fake-recurrency" w DLX
        std::vector<uint64_t> recursion_stack;
        std::vector<int> solution_rows;
        int solution_depth = 0;

        bool matches(const GenericTopology& topo) const {
            return n == topo.n && nn == topo.nn;
        }
    };

    mutable UnifiedWideDlx ws_;

    static int row_id_for(int n, int r, int c, int d0) {
        return ((r * n + c) * n) + d0;
    }

    void build_if_needed(const GenericTopology& topo) const {
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) {
            return;
        }
        if (ws_.matches(topo)) {
            return;
        }

        UnifiedWideDlx w;
        w.n = topo.n;
        w.nn = topo.nn;
        w.rows = topo.n * topo.n * topo.n;
        w.cols = 4 * topo.nn;
        w.row_words = (w.rows + 63) / 64;
        w.col_words = (w.cols + 63) / 64;
        w.max_depth = topo.nn + 1;

        w.row_cols.resize(static_cast<size_t>(w.rows));
        w.col_rows_bits.assign(static_cast<size_t>(w.cols) * static_cast<size_t>(w.row_words), 0ULL);
        w.active_rows.assign(static_cast<size_t>(w.row_words), 0ULL);
        w.uncovered_cols.assign(static_cast<size_t>(w.col_words), 0ULL);

        // Zapobieganie realokacji - pojemność na potężne głębokości (P8/SKLoop testing)
        const size_t reserve_words = static_cast<size_t>(w.row_words) * 16ULL;
        w.undo_active_idx.reserve(reserve_words);
        w.undo_active_old.reserve(reserve_words);
        w.undo_col_idx.reserve(static_cast<size_t>(w.col_words) * 16ULL);
        w.undo_col_old.reserve(static_cast<size_t>(w.col_words) * 16ULL);

        w.recursion_stack.assign(static_cast<size_t>(w.max_depth) * static_cast<size_t>(w.row_words), 0ULL);
        w.solution_rows.assign(static_cast<size_t>(w.max_depth), -1);
        w.solution_depth = 0;

        for (int r = 0; r < topo.n; ++r) {
            for (int c = 0; c < topo.n; ++c) {
                const int b = topo.cell_box[static_cast<size_t>(r * topo.n + c)];
                for (int d0 = 0; d0 < topo.n; ++d0) {
                    const int row_id = row_id_for(topo.n, r, c, d0);
                    const int col_cell = r * topo.n + c;
                    const int col_row_digit = topo.nn + r * topo.n + d0;
                    const int col_col_digit = 2 * topo.nn + c * topo.n + d0;
                    const int col_box_digit = 3 * topo.nn + b * topo.n + d0;

                    w.row_cols[static_cast<size_t>(row_id)] = {
                        static_cast<uint16_t>(col_cell),
                        static_cast<uint16_t>(col_row_digit),
                        static_cast<uint16_t>(col_col_digit),
                        static_cast<uint16_t>(col_box_digit)};

                    const int rw = row_id >> 6;
                    const uint64_t bit = 1ULL << (row_id & 63);
                    w.col_rows_bits[static_cast<size_t>(col_cell) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_row_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_col_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_box_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                }
            }
        }

        ws_ = std::move(w);
    }

    void rollback_to(size_t active_marker, size_t col_marker) const {
        while (ws_.undo_active_idx.size() > active_marker) {
            const uint16_t idx = ws_.undo_active_idx.back();
            const uint64_t old = ws_.undo_active_old.back();
            ws_.undo_active_idx.pop_back();
            ws_.undo_active_old.pop_back();
            ws_.active_rows[static_cast<size_t>(idx)] = old;
        }
        while (ws_.undo_col_idx.size() > col_marker) {
            const uint16_t idx = ws_.undo_col_idx.back();
            const uint64_t old = ws_.undo_col_old.back();
            ws_.undo_col_idx.pop_back();
            ws_.undo_col_old.pop_back();
            ws_.uncovered_cols[static_cast<size_t>(idx)] = old;
        }
    }

    bool apply_row(int row_id) const {
        const int rw = row_id >> 6;
        const uint64_t rbit = 1ULL << (row_id & 63);
        if ((ws_.active_rows[static_cast<size_t>(rw)] & rbit) == 0ULL) {
            return false;
        }

        const auto& cols4 = ws_.row_cols[static_cast<size_t>(row_id)];
        for (int k = 0; k < 4; ++k) {
            const int col = static_cast<int>(cols4[static_cast<size_t>(k)]);
            const int cw = col >> 6;
            const uint64_t cbit = 1ULL << (col & 63);
            if ((ws_.uncovered_cols[static_cast<size_t>(cw)] & cbit) == 0ULL) {
                return false;
            }
        }

        for (int k = 0; k < 4; ++k) {
            const int col = static_cast<int>(cols4[static_cast<size_t>(k)]);
            const int cw = col >> 6;
            const uint64_t cbit = 1ULL << (col & 63);

            const uint64_t old_col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            const uint64_t new_col_word = old_col_word & ~cbit;
            if (new_col_word != old_col_word) {
                ws_.undo_col_idx.push_back(static_cast<uint16_t>(cw));
                ws_.undo_col_old.push_back(old_col_word);
                ws_.uncovered_cols[static_cast<size_t>(cw)] = new_col_word;
            }

            const uint64_t* const col_rows =
                &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
            for (int w = 0; w < ws_.row_words; ++w) {
                const uint64_t old_word = ws_.active_rows[static_cast<size_t>(w)];
                const uint64_t new_word = old_word & ~col_rows[static_cast<size_t>(w)];
                if (new_word != old_word) {
                    ws_.undo_active_idx.push_back(static_cast<uint16_t>(w));
                    ws_.undo_active_old.push_back(old_word);
                    ws_.active_rows[static_cast<size_t>(w)] = new_word;
                }
            }
        }
        return true;
    }

    void initialize_state() const {
        std::fill(ws_.active_rows.begin(), ws_.active_rows.end(), ~0ULL);
        const int valid_row_bits = ws_.rows & 63;
        if (valid_row_bits != 0) {
            ws_.active_rows[static_cast<size_t>(ws_.row_words - 1)] = (1ULL << valid_row_bits) - 1ULL;
        }

        std::fill(ws_.uncovered_cols.begin(), ws_.uncovered_cols.end(), ~0ULL);
        const int valid_col_bits = ws_.cols & 63;
        if (valid_col_bits != 0) {
            ws_.uncovered_cols[static_cast<size_t>(ws_.col_words - 1)] = (1ULL << valid_col_bits) - 1ULL;
        }

        ws_.undo_active_idx.clear();
        ws_.undo_active_old.clear();
        ws_.undo_col_idx.clear();
        ws_.undo_col_old.clear();
        ws_.solution_depth = 0;
        std::fill(ws_.solution_rows.begin(), ws_.solution_rows.end(), -1);
    }

    // Aplikuje z góry założony wzorzec z pattern_forcing do DLXa
    bool restrict_rows_by_allowed_masks(const GenericTopology& topo, const std::vector<uint64_t>& allowed_masks) const {
        if (static_cast<int>(allowed_masks.size()) != topo.nn) {
            return false;
        }
        const uint64_t full_mask = (topo.n >= 64) ? ~0ULL : ((1ULL << topo.n) - 1ULL);
        for (int idx = 0; idx < topo.nn; ++idx) {
            uint64_t allowed = allowed_masks[static_cast<size_t>(idx)] & full_mask;
            if (allowed == 0ULL) {
                return false;
            }
            if (allowed == full_mask) {
                continue;
            }
            const int row_base = idx * topo.n;
            for (int d0 = 0; d0 < topo.n; ++d0) {
                const uint64_t bit = (1ULL << d0);
                if ((allowed & bit) != 0ULL) {
                    continue;
                }
                const int row_id = row_base + d0;
                const int rw = row_id >> 6;
                ws_.active_rows[static_cast<size_t>(rw)] &= ~(1ULL << (row_id & 63));
            }
        }
        return true;
    }

    bool search_find_one(SearchAbortControl* budget, int depth) const {
        if (budget != nullptr && !budget->step()) return false;

        bool has_uncovered = false;
        for (int cw = 0; cw < ws_.col_words; ++cw) {
            if (ws_.uncovered_cols[static_cast<size_t>(cw)] != 0ULL) {
                has_uncovered = true;
                break;
            }
        }
        if (!has_uncovered) {
            ws_.solution_depth = depth;
            return true;
        }
        if (depth < 0 || depth >= ws_.max_depth) return false;

        const size_t best_base = static_cast<size_t>(depth) * static_cast<size_t>(ws_.row_words);
        uint64_t* const local_best = &ws_.recursion_stack[best_base];
        int best_col = -1;
        int best_count = std::numeric_limits<int>::max();

        // Heurystyka Minimalnego Wyboru (MRV) wyciągająca popcnt z przecięć słów
        for (int cw = 0; cw < ws_.col_words; ++cw) {
            uint64_t col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            while (col_word != 0ULL) {
                const int bit = config::bit_ctz_u64(col_word);
                const int col = (cw << 6) + bit;
                col_word = config::bit_clear_lsb_u64(col_word);
                if (col >= ws_.cols) continue;
                
                const uint64_t* const col_rows =
                    &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
                int cnt = 0;
                for (int w = 0; w < ws_.row_words; ++w) {
                    const uint64_t v = ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    cnt += static_cast<int>(std::popcount(v));
                }
                
                if (cnt == 0) return false;
                
                if (cnt < best_count) {
                    best_count = cnt;
                    best_col = col;
                    for (int w = 0; w < ws_.row_words; ++w) {
                        local_best[static_cast<size_t>(w)] =
                            ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    }
                    if (cnt == 1) break;
                }
            }
            if (best_count == 1) break;
        }
        
        if (best_col < 0) return false;

        for (int w = 0; w < ws_.row_words; ++w) {
            uint64_t rows_word = local_best[static_cast<size_t>(w)];
            while (rows_word != 0ULL) {
                const int rb = config::bit_ctz_u64(rows_word);
                const int row_id = (w << 6) + rb;
                rows_word = config::bit_clear_lsb_u64(rows_word);
                
                if (row_id >= ws_.rows) continue;
                
                const size_t active_marker = ws_.undo_active_idx.size();
                const size_t col_marker = ws_.undo_col_idx.size();
                ws_.solution_rows[static_cast<size_t>(depth)] = row_id;
                
                if (!apply_row(row_id)) {
                    rollback_to(active_marker, col_marker);
                    ws_.solution_rows[static_cast<size_t>(depth)] = -1;
                    continue;
                }
                
                if (search_find_one(budget, depth + 1)) return true;
                
                rollback_to(active_marker, col_marker);
                ws_.solution_rows[static_cast<size_t>(depth)] = -1;
                
                if (budget != nullptr && budget->aborted()) return false;
            }
        }
        return false;
    }

    bool search_with_limit(int& out_count, int limit, SearchAbortControl* budget, int depth) const {
        if (budget != nullptr && !budget->step()) return false;

        bool has_uncovered = false;
        for (int cw = 0; cw < ws_.col_words; ++cw) {
            if (ws_.uncovered_cols[static_cast<size_t>(cw)] != 0ULL) {
                has_uncovered = true;
                break;
            }
        }
        if (!has_uncovered) {
            ++out_count;
            return out_count >= limit; // True przerywa jako "Osiągnięto limit znalezień"
        }

        if (depth < 0 || depth >= ws_.max_depth) return false;

        const size_t best_base = static_cast<size_t>(depth) * static_cast<size_t>(ws_.row_words);
        uint64_t* const local_best = &ws_.recursion_stack[best_base];

        int best_col = -1;
        int best_count = std::numeric_limits<int>::max();

        for (int cw = 0; cw < ws_.col_words; ++cw) {
            uint64_t col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            while (col_word != 0ULL) {
                const int bit = config::bit_ctz_u64(col_word);
                const int col = (cw << 6) + bit;
                col_word = config::bit_clear_lsb_u64(col_word);
                if (col >= ws_.cols) continue;

                const uint64_t* const col_rows =
                    &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
                int cnt = 0;
                for (int w = 0; w < ws_.row_words; ++w) {
                    const uint64_t v = ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    cnt += static_cast<int>(std::popcount(v));
                }

                if (cnt == 0) return false;

                if (cnt < best_count) {
                    best_count = cnt;
                    best_col = col;
                    for (int w = 0; w < ws_.row_words; ++w) {
                        local_best[static_cast<size_t>(w)] =
                            ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    }
                    if (cnt == 1) break;
                }
            }
            if (best_count == 1) break;
        }

        if (best_col < 0) return false;

        for (int w = 0; w < ws_.row_words; ++w) {
            uint64_t rows_word = local_best[static_cast<size_t>(w)];
            while (rows_word != 0ULL) {
                const int rb = config::bit_ctz_u64(rows_word);
                const int row_id = (w << 6) + rb;
                rows_word = config::bit_clear_lsb_u64(rows_word);
                
                if (row_id >= ws_.rows) continue;

                const size_t active_marker = ws_.undo_active_idx.size();
                const size_t col_marker = ws_.undo_col_idx.size();
                
                if (!apply_row(row_id)) {
                    rollback_to(active_marker, col_marker);
                    continue;
                }
                
                if (search_with_limit(out_count, limit, budget, depth + 1)) return true;
                
                rollback_to(active_marker, col_marker);
                if (budget != nullptr && budget->aborted()) return false;
            }
        }
        return false;
    }

    int count_solutions_limit(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        int limit,
        SearchAbortControl* budget = nullptr) const {
            
        if (limit <= 0) return 0;
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) return 0;
        if (static_cast<int>(puzzle.size()) != topo.nn) return 0;

        build_if_needed(topo);
        if (!ws_.matches(topo)) return 0;

        initialize_state();

        const uint16_t* const puzzle_ptr = puzzle.data();
        const uint32_t* const packed_ptr = topo.cell_rcb_packed.data();
        
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
            if (d == 0) continue;
            if (d < 1 || d > topo.n) return 0;
            
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int row_id = row_id_for(topo.n, r, c, d - 1);
            
            const size_t active_marker = ws_.undo_active_idx.size();
            const size_t col_marker = ws_.undo_col_idx.size();
            
            if (!apply_row(row_id)) {
                rollback_to(active_marker, col_marker);
                return 0;
            }
        }

        int out_count = 0;
        const bool finished = search_with_limit(out_count, limit, budget, 0);
        const bool aborted = budget != nullptr && budget->aborted() && !finished;
        
        if (aborted) return -1;
        return out_count;
    }

    int count_solutions_limit2(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr) const {
        return count_solutions_limit(puzzle, topo, 2, budget);
    }

    // Zwraca rozwiązanie zbudowane z Pattern Forcing Bridge
    bool solve_and_capture(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        std::vector<uint16_t>& out_solution,
        SearchAbortControl* budget = nullptr,
        const std::vector<uint64_t>* allowed_masks = nullptr) const {
            
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) return false;
        if (static_cast<int>(puzzle.size()) != topo.nn) return false;

        build_if_needed(topo);
        if (!ws_.matches(topo)) return false;

        initialize_state();
        
        // Integracja Pattern Forcing z generatorem - to narzuca konkretne
        // ułożenie masek pod Exoceta / SK-Loop
        if (allowed_masks != nullptr && !restrict_rows_by_allowed_masks(topo, *allowed_masks)) {
            return false;
        }

        const uint16_t* const puzzle_ptr = puzzle.data();
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
            if (d == 0) continue;
            if (d < 1 || d > topo.n) return false;
            
            if (allowed_masks != nullptr) {
                const uint64_t allowed = (*allowed_masks)[static_cast<size_t>(idx)] & ((topo.n >= 64) ? ~0ULL : ((1ULL << topo.n) - 1ULL));
                if ((allowed & (1ULL << (d - 1))) == 0ULL) return false;
            }
            
            const int row_id = idx * topo.n + (d - 1);
            const size_t active_marker = ws_.undo_active_idx.size();
            const size_t col_marker = ws_.undo_col_idx.size();
            if (!apply_row(row_id)) {
                rollback_to(active_marker, col_marker);
                return false;
            }
        }

        const bool found = search_find_one(budget, 0);
        if (!found) return false;
        if (budget != nullptr && budget->aborted()) return false;

        if (out_solution.size() != static_cast<size_t>(topo.nn)) {
            out_solution.resize(static_cast<size_t>(topo.nn));
        }
        std::copy(puzzle.begin(), puzzle.end(), out_solution.begin());
        
        for (int i = 0; i < ws_.solution_depth; ++i) {
            const int row_id = ws_.solution_rows[static_cast<size_t>(i)];
            if (row_id < 0) continue;
            
            const int cell = row_id / topo.n;
            const int d0 = row_id % topo.n;
            out_solution[static_cast<size_t>(cell)] = static_cast<uint16_t>(d0 + 1);
        }
        
        for (int idx = 0; idx < topo.nn; ++idx) {
            if (out_solution[static_cast<size_t>(idx)] == 0) return false;
        }
        return true;
    }
};

} // namespace sudoku_hpc::core_engines



==============================================================================
PLIK: Sources\generator\core_engines\quick_prefilter.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CORE ENGINES
// Moduł: quick_prefilter.h
// Opis: Błyskawiczny, "brudny" filtr odrzucający siatki przed rygorystyczną
//       weryfikacją logiczną i MCTS. Zero-allocation, pełne AVX scaling.
// ============================================================================

#pragma once

#include <cstdint>
#include <vector>

#include "../../core/board.h"

namespace sudoku_hpc::core_engines {

struct GenericQuickPrefilter {
    // Zwraca false jeśli plansza na pewno jest nieprawidłowa lub nie ma sensu jej testować.
    bool check(const std::vector<uint16_t>& puzzle, const GenericTopology& topo, int min_clues, int max_clues) const {
        if (static_cast<int>(puzzle.size()) != topo.nn) {
            return false;
        }

        int clues = 0;
        const auto& rcb = topo.cell_rcb_packed;
        
        // Zero-allocation: wykorzystanie prealokowanego obszaru roboczego
        GenericThreadScratch& scratch = generic_tls_for(topo);
        
        // Szybkie wyzerowanie bitsetów
        std::fill(scratch.row_tmp.begin(), scratch.row_tmp.end(), 0ULL);
        std::fill(scratch.col_tmp.begin(), scratch.col_tmp.end(), 0ULL);
        std::fill(scratch.box_tmp.begin(), scratch.box_tmp.end(), 0ULL);
        
        uint64_t* const row_used = scratch.row_tmp.data();
        uint64_t* const col_used = scratch.col_tmp.data();
        uint64_t* const box_used = scratch.box_tmp.data();
        const uint32_t* const packed = rcb.data();
        
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle[static_cast<size_t>(idx)]);
            if (d == 0) {
                // Wczesna weryfikacja czy w ogóle starczy nam miejsc by dobić do min_clues
                const int remaining = topo.nn - idx - 1;
                if (clues + remaining < min_clues) {
                    return false;
                }
                continue;
            }
            if (d < 1 || d > topo.n) {
                return false;
            }
            
            ++clues;
            
            if (clues > max_clues) {
                return false;
            }

            const uint32_t p = packed[static_cast<size_t>(idx)];
            const int r = static_cast<int>(p & 63U);
            const int c = static_cast<int>((p >> 6U) & 63U);
            const int b = static_cast<int>((p >> 12U) & 63U);
            
            const uint64_t bit = (1ULL << (d - 1));
            
            // Kolizja w obrębie struktury?
            if ((row_used[static_cast<size_t>(r)] & bit) ||
                (col_used[static_cast<size_t>(c)] & bit) ||
                (box_used[static_cast<size_t>(b)] & bit)) {
                return false;
            }
            
            row_used[static_cast<size_t>(r)] |= bit;
            col_used[static_cast<size_t>(c)] |= bit;
            box_used[static_cast<size_t>(b)] |= bit;
        }
        
        return clues >= min_clues;
    }
};

} // namespace sudoku_hpc::core_engines



==============================================================================
PLIK: Sources\generator\core_engines\solved_kernel.h
==============================================================================

// ============================================================================
// SUDOKU HPC - CORE ENGINES
// Moduł: solved_kernel.h
// Opis: Ultraszybki generator pełnych plansz z wykorzystaniem wektoryzacji 
//       SIMD (AVX2/AVX512) i heurystyki MRV. Zero-allocation (CandidateCache).
// ============================================================================

#pragma once

#include <algorithm>
#include <bit>
#include <cstdint>
#include <vector>
#include <random>

#if defined(__x86_64__) || defined(__i386__)
#include <immintrin.h>
#endif

#include "../../core/board.h"
#include "../../config/bit_utils.h"

namespace sudoku_hpc::core_engines {

#if defined(__GNUC__) || defined(__clang__)
#define SUDOKU_HOT_INLINE inline __attribute__((always_inline))
#define SUDOKU_LIKELY(x) (__builtin_expect(!!(x), 1))
#define SUDOKU_UNLIKELY(x) (__builtin_expect(!!(x), 0))
#else
#define SUDOKU_HOT_INLINE inline
#define SUDOKU_LIKELY(x) (x)
#define SUDOKU_UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
#define SUDOKU_TARGET_AVX2 __attribute__((target("avx2")))
#define SUDOKU_TARGET_AVX512BW __attribute__((target("avx512f,avx512bw")))
#define SUDOKU_TARGET_AVX512VPOPCNT __attribute__((target("avx512f,avx512bw,avx512vpopcntdq")))
#else
#define SUDOKU_TARGET_AVX2
#define SUDOKU_TARGET_AVX512BW
#define SUDOKU_TARGET_AVX512VPOPCNT
#endif

// ============================================================================
// UTILS: Przetasowanie dostępnych cyfr na podstawie maski bitowej
// ============================================================================
inline int shuffled_digits_from_mask(uint64_t mask, std::mt19937_64& rng, int* out_digits) {
    int count = 0;
    while (mask != 0ULL) {
        const int bit = config::bit_ctz_u64(mask);
        out_digits[count++] = bit + 1;
        mask &= (mask - 1ULL);
    }
    if (count <= 2) {
        if (count == 2 && (rng() & 1ULL) != 0ULL) {
            std::swap(out_digits[0], out_digits[1]);
        }
        return count;
    }
    for (int i = count - 1; i > 0; --i) {
        const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
        std::swap(out_digits[i], out_digits[j]);
    }
    return count;
}

class GenericSolvedKernel {
public:
    enum class Backend : uint8_t {
        Scalar = 0,
        Avx2 = 1,
        Avx512 = 2
    };

    explicit GenericSolvedKernel(Backend backend = Backend::Scalar) : backend_(backend) {}

    static Backend backend_from_string(const std::string& backend) {
        if (backend == "avx2") return Backend::Avx2;
        if (backend == "avx512") return Backend::Avx512;
        return Backend::Scalar;
    }

    bool generate(
        const GenericTopology& topo,
        std::mt19937_64& rng,
        std::vector<uint16_t>& out_solution,
        SearchAbortControl* budget = nullptr) const {
        
        static thread_local GenericBoard board;
        board.reset(topo);
        
        if (!fill(board, rng, budget)) {
            return false;
        }
        
        if (out_solution.size() != static_cast<size_t>(topo.nn)) {
            out_solution.resize(static_cast<size_t>(topo.nn));
        }
        std::copy_n(board.values.data(), static_cast<size_t>(topo.nn), out_solution.data());
        return true;
    }

private:
    Backend backend_ = Backend::Scalar;

    struct CandidateCache {
        int prepared_nn = 0;
        std::vector<uint64_t> candidates;
        std::vector<uint8_t> candidate_popcnt;
        std::vector<uint64_t> singleton_words;
        std::vector<int> undo_idx;
        std::vector<uint64_t> undo_old;
        std::vector<uint8_t> undo_old_count;

        void ensure(const GenericTopology& topo) {
            if (prepared_nn != topo.nn) {
                candidates.resize(static_cast<size_t>(topo.nn));
                candidate_popcnt.resize(static_cast<size_t>(topo.nn));
                singleton_words.resize((static_cast<size_t>(topo.nn) + 63ULL) >> 6U);
                const size_t per_depth_hint = static_cast<size_t>(std::max(8, std::min(3 * topo.n, 64)));
                const size_t reserve_hint = static_cast<size_t>(topo.nn) * per_depth_hint;
                if (undo_idx.capacity() < reserve_hint) {
                    undo_idx.reserve(reserve_hint);
                    undo_old.reserve(reserve_hint);
                    undo_old_count.reserve(reserve_hint);
                }
                prepared_nn = topo.nn;
            }
            undo_idx.clear();
            undo_old.clear();
            undo_old_count.clear();
        }
    };

    static CandidateCache& candidate_cache_for(const GenericTopology& topo) {
        static thread_local CandidateCache cache;
        cache.ensure(topo);
        return cache;
    }

    static SUDOKU_HOT_INLINE void cache_set_candidate(
        CandidateCache& cache,
        int idx,
        uint64_t mask,
        uint8_t count) {
        const size_t uidx = static_cast<size_t>(idx);
        cache.candidates[uidx] = mask;
        cache.candidate_popcnt[uidx] = count;
        const size_t w = uidx >> 6U;
        const uint64_t bit = 1ULL << (uidx & 63ULL);
        uint64_t& word = cache.singleton_words[w];
        if (count == 1U) {
            word |= bit;
        } else {
            word &= ~bit;
        }
    }

    struct MvrState {
        int best_bucket = 65;
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        int best_pressure = -1;
        bool found_empty = false;
    };

    static bool consider_empty_cell_mrv_precount(
        int idx,
        uint64_t candidate_mask,
        int candidate_cnt,
        int used_pressure,
        MvrState& state) {
        if (candidate_cnt == 0) return false;
        
        state.found_empty = true;
        if (candidate_cnt < state.best_bucket) {
            state.best_bucket = candidate_cnt;
            state.best_idx = idx;
            state.best_mask = candidate_mask;
            state.best_pressure = (candidate_cnt == 1) ? 64 : used_pressure;
        } else if (candidate_cnt == state.best_bucket && candidate_cnt > 1) {
            if (used_pressure > state.best_pressure) {
                state.best_idx = idx;
                state.best_mask = candidate_mask;
                state.best_pressure = used_pressure;
            }
        }
        return true;
    }

    static bool finalize_mrv_pick(int& best_idx, uint64_t& best_mask, const MvrState& state) {
        if (!state.found_empty) {
            best_idx = -1;
            best_mask = 0ULL;
            return true;
        }
        best_idx = state.best_idx;
        best_mask = state.best_mask;
        return true;
    }

#if defined(__x86_64__) || defined(__i386__)
    SUDOKU_TARGET_AVX2 static void popcount4x64_avx2(const uint64_t* in_masks, int* out_counts) {
        const __m256i x = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(in_masks));
        const __m256i low_nibble_mask = _mm256_set1_epi8(0x0F);
        const __m256i lut = _mm256_setr_epi8(
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);

        const __m256i lo = _mm256_and_si256(x, low_nibble_mask);
        const __m256i hi = _mm256_and_si256(_mm256_srli_epi16(x, 4), low_nibble_mask);
        const __m256i pc = _mm256_add_epi8(_mm256_shuffle_epi8(lut, lo), _mm256_shuffle_epi8(lut, hi));
        const __m256i sad = _mm256_sad_epu8(pc, _mm256_setzero_si256());
        
        alignas(32) uint64_t sums[4];
        _mm256_store_si256(reinterpret_cast<__m256i*>(sums), sad);
        
        out_counts[0] = static_cast<int>(sums[0]);
        out_counts[1] = static_cast<int>(sums[1]);
        out_counts[2] = static_cast<int>(sums[2]);
        out_counts[3] = static_cast<int>(sums[3]);
    }

    SUDOKU_TARGET_AVX512VPOPCNT static void popcount8x64_avx512vpopcnt(const uint64_t* in_masks, int* out_counts) {
        const __m512i x = _mm512_loadu_si512(reinterpret_cast<const void*>(in_masks));
        const __m512i c = _mm512_popcnt_epi64(x);
        
        alignas(64) uint64_t lanes[8];
        _mm512_store_si512(reinterpret_cast<__m512i*>(lanes), c);
        
        for (int i = 0; i < 8; ++i) {
            out_counts[i] = static_cast<int>(lanes[i]);
        }
    }
#endif

    static bool select_best_cell_bucketed_scalar(const GenericBoard& board, int& best_idx, uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        for (int idx = 0; idx < topo->nn; ++idx) {
            if (board.values[static_cast<size_t>(idx)] != 0) continue;
            
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = static_cast<int>(rcb & 63U);
            const int c = static_cast<int>((rcb >> 6U) & 63U);
            const int b = static_cast<int>((rcb >> 12U) & 63U);
            
            const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
            const uint64_t candidate_mask = (~used) & full_mask;
            const int cnt = std::popcount(candidate_mask);
            const int pressure = std::popcount(used);
            
            if (!consider_empty_cell_mrv_precount(idx, candidate_mask, cnt, pressure, state)) {
                return false;
            }
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

#if defined(__x86_64__) || defined(__i386__)
    SUDOKU_TARGET_AVX2 static bool select_best_cell_bucketed_avx2(const GenericBoard& board, int& best_idx, uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        constexpr int kLanes = 16;  // 16x uint16_t in 256-bit reg
        const int nn = topo->nn;
        const auto* values_ptr = board.values.data();
        const __m256i zero = _mm256_setzero_si256();
        
        int batch_idx[4];
        uint64_t batch_cand[4];
        uint64_t batch_used[4];
        int batch_size = 0;
        
        auto flush_batch = [&](int count) -> bool {
            if (count <= 0) return true;
            int cand_cnt[4]{};
            int used_cnt[4]{};
            
            if (count == 4) {
                popcount4x64_avx2(batch_cand, cand_cnt);
                popcount4x64_avx2(batch_used, used_cnt);
            } else {
                for (int i = 0; i < count; ++i) {
                    cand_cnt[i] = std::popcount(batch_cand[i]);
                    used_cnt[i] = std::popcount(batch_used[i]);
                }
            }
            for (int i = 0; i < count; ++i) {
                if (!consider_empty_cell_mrv_precount(batch_idx[i], batch_cand[i], cand_cnt[i], used_cnt[i], state)) {
                    return false;
                }
            }
            return true;
        };

        int idx = 0;
        for (; idx + kLanes <= nn; idx += kLanes) {
            const __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(values_ptr + idx));
            const __m256i eq_zero = _mm256_cmpeq_epi16(v, zero);
            const uint32_t bytes_mask = static_cast<uint32_t>(_mm256_movemask_epi8(eq_zero));
            uint32_t pair_mask = bytes_mask & (bytes_mask >> 1U) & 0x55555555U;
            
            while (pair_mask != 0U) {
                const uint32_t bit = static_cast<uint32_t>(std::countr_zero(pair_mask));
                const int lane = static_cast<int>(bit >> 1U);
                const int cell_idx = idx + lane;
                
                const uint32_t rcb = packed_ptr[static_cast<size_t>(cell_idx)];
                const int r = static_cast<int>(rcb & 63U);
                const int c = static_cast<int>((rcb >> 6U) & 63U);
                const int b = static_cast<int>((rcb >> 12U) & 63U);
                
                const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
                
                batch_idx[batch_size] = cell_idx;
                batch_used[batch_size] = used;
                batch_cand[batch_size] = (~used) & full_mask;
                ++batch_size;
                
                if (batch_size == 4) {
                    if (!flush_batch(batch_size)) return false;
                    batch_size = 0;
                }
                pair_mask &= (pair_mask - 1U);
            }
        }
        
        for (; idx < nn; ++idx) {
            if (values_ptr[idx] != 0) continue;
            
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = static_cast<int>(rcb & 63U);
            const int c = static_cast<int>((rcb >> 6U) & 63U);
            const int b = static_cast<int>((rcb >> 12U) & 63U);
            
            const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
            
            batch_idx[batch_size] = idx;
            batch_used[batch_size] = used;
            batch_cand[batch_size] = (~used) & full_mask;
            ++batch_size;
            
            if (batch_size == 4) {
                if (!flush_batch(batch_size)) return false;
                batch_size = 0;
            }
        }
        
        if (!flush_batch(batch_size)) return false;
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

    SUDOKU_TARGET_AVX512BW static bool select_best_cell_bucketed_avx512(const GenericBoard& board, int& best_idx, uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        constexpr int kLanes = 32;  // 32x uint16_t in 512-bit register
        const int nn = topo->nn;
        const auto* values_ptr = board.values.data();
        const __m512i zero = _mm512_setzero_si512();
        
        static const bool kHasVpopcntDq = __builtin_cpu_supports("avx512vpopcntdq");

        int batch_idx[8];
        uint64_t batch_cand[8];
        uint64_t batch_used[8];
        int batch_size = 0;
        
        auto flush_batch = [&](int count) -> bool {
            if (count <= 0) return true;
            int cand_cnt[8]{};
            int used_cnt[8]{};
            
            if (count == 8 && kHasVpopcntDq) {
                popcount8x64_avx512vpopcnt(batch_cand, cand_cnt);
                popcount8x64_avx512vpopcnt(batch_used, used_cnt);
            } else {
                for (int i = 0; i < count; ++i) {
                    cand_cnt[i] = std::popcount(batch_cand[i]);
                    used_cnt[i] = std::popcount(batch_used[i]);
                }
            }
            for (int i = 0; i < count; ++i) {
                if (!consider_empty_cell_mrv_precount(batch_idx[i], batch_cand[i], cand_cnt[i], used_cnt[i], state)) {
                    return false;
                }
            }
            return true;
        };

        int idx = 0;
        for (; idx + kLanes <= nn; idx += kLanes) {
            const __m512i v = _mm512_loadu_si512(reinterpret_cast<const void*>(values_ptr + idx));
            uint32_t empty_mask = static_cast<uint32_t>(_mm512_cmpeq_epi16_mask(v, zero));
            
            while (empty_mask != 0U) {
                const uint32_t lane = static_cast<uint32_t>(std::countr_zero(empty_mask));
                const int cell_idx = idx + static_cast<int>(lane);
                
                const uint32_t rcb = packed_ptr[static_cast<size_t>(cell_idx)];
                const int r = static_cast<int>(rcb & 63U);
                const int c = static_cast<int>((rcb >> 6U) & 63U);
                const int b = static_cast<int>((rcb >> 12U) & 63U);
                
                const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
                
                batch_idx[batch_size] = cell_idx;
                batch_used[batch_size] = used;
                batch_cand[batch_size] = (~used) & full_mask;
                ++batch_size;
                
                if (batch_size == 8) {
                    if (!flush_batch(batch_size)) return false;
                    batch_size = 0;
                }
                empty_mask &= (empty_mask - 1U);
            }
        }
        
        for (; idx < nn; ++idx) {
            if (values_ptr[idx] != 0) continue;
            
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = static_cast<int>(rcb & 63U);
            const int c = static_cast<int>((rcb >> 6U) & 63U);
            const int b = static_cast<int>((rcb >> 12U) & 63U);
            
            const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
            
            batch_idx[batch_size] = idx;
            batch_used[batch_size] = used;
            batch_cand[batch_size] = (~used) & full_mask;
            ++batch_size;
            
            if (batch_size == 8) {
                if (!flush_batch(batch_size)) return false;
                batch_size = 0;
            }
        }
        if (!flush_batch(batch_size)) return false;
        return finalize_mrv_pick(best_idx, best_mask, state);
    }
#endif

    bool select_best_cell_bucketed(const GenericBoard& board, int& best_idx, uint64_t& best_mask) const {
        switch (backend_) {
        case Backend::Avx512:
#if defined(__x86_64__) || defined(__i386__)
            return select_best_cell_bucketed_avx512(board, best_idx, best_mask);
#endif
        case Backend::Avx2:
#if defined(__x86_64__) || defined(__i386__)
            return select_best_cell_bucketed_avx2(board, best_idx, best_mask);
#endif
        case Backend::Scalar:
        default:
            return select_best_cell_bucketed_scalar(board, best_idx, best_mask);
        }
    }

    bool init_candidate_cache(const GenericBoard& board, CandidateCache& cache) const {
        const auto* topo = board.topo;
        const int nn = topo->nn;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const auto* values_ptr = board.values.data();
        const uint64_t full_mask = board.full_mask;
        
        std::fill(cache.singleton_words.begin(), cache.singleton_words.end(), 0ULL);
        for (int idx = 0; idx < nn; ++idx) {
            if (values_ptr[static_cast<size_t>(idx)] != 0) {
                cache_set_candidate(cache, idx, 0ULL, 0U);
                continue;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = static_cast<int>(rcb & 63U);
            const int c = static_cast<int>((rcb >> 6U) & 63U);
            const int b = static_cast<int>((rcb >> 12U) & 63U);
            
            const uint64_t used = row_used[static_cast<size_t>(r)] | col_used[static_cast<size_t>(c)] | box_used[static_cast<size_t>(b)];
            const uint64_t mask = (~used) & full_mask;
            
            if (mask == 0ULL) return false;
            const uint8_t cnt = static_cast<uint8_t>(std::popcount(mask));
            cache_set_candidate(cache, idx, mask, cnt);
        }
        cache.undo_idx.clear();
        cache.undo_old.clear();
        cache.undo_old_count.clear();
        return true;
    }

    bool select_best_cell_cached(const GenericBoard& board, const CandidateCache& cache, int& best_idx, uint64_t& best_mask) const {
        MvrState state{};
        const int nn = board.topo->nn;
        const int n = board.topo->n;
        const uint64_t* const cand_ptr = cache.candidates.data();
        const uint8_t* const cnt_ptr = cache.candidate_popcnt.data();
        const uint64_t* const singles_ptr = cache.singleton_words.data();
        const int single_words = static_cast<int>(cache.singleton_words.size());
        
        // Priorytet dla Naked Singles
        for (int wi = 0; wi < single_words; ++wi) {
            uint64_t sw = singles_ptr[static_cast<size_t>(wi)];
            while (sw != 0ULL) {
                const int bit = static_cast<int>(std::countr_zero(sw));
                const int idx = (wi << 6) + bit;
                if (idx >= nn) break;
                
                const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
                if (candidate_mask != 0ULL) {
                    best_idx = idx;
                    best_mask = candidate_mask;
                    return true;
                }
                sw &= (sw - 1ULL);
            }
        }
        
        // Zwykłe przeszukiwanie
        for (int idx = 0; idx < nn; ++idx) {
            const int cnt = static_cast<int>(cnt_ptr[static_cast<size_t>(idx)]);
            if (cnt == 0) continue;
            if (cnt == 1) {
                const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
                best_idx = idx;
                best_mask = candidate_mask;
                return true;
            }
            const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
            const int pressure = n - cnt;
            if (!consider_empty_cell_mrv_precount(idx, candidate_mask, cnt, pressure, state)) {
                return false;
            }
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

    bool try_place_with_cache(GenericBoard& board, CandidateCache& cache, int idx, int digit, size_t& out_marker) const {
        const auto* topo = board.topo;
        const uint64_t placed_bit = 1ULL << (digit - 1);

        out_marker = cache.undo_idx.size();
        const size_t idx_u = static_cast<size_t>(idx);
        cache.undo_idx.push_back(idx);
        cache.undo_old.push_back(cache.candidates[idx_u]);
        cache.undo_old_count.push_back(cache.candidate_popcnt[idx_u]);
        cache_set_candidate(cache, idx, 0ULL, 0U);

        board.place(idx, digit);
        const int off0 = topo->peer_offsets[static_cast<size_t>(idx)];
        const int off1 = topo->peer_offsets[static_cast<size_t>(idx + 1)];
        for (int p = off0; p < off1; ++p) {
            const int peer_idx = topo->peers_flat[static_cast<size_t>(p)];
            const size_t peer_u = static_cast<size_t>(peer_idx);
            const uint64_t old_mask = cache.candidates[peer_u];
            if (old_mask == 0ULL) continue;
            
            const uint64_t new_mask = old_mask & ~placed_bit;
            if (new_mask == old_mask) continue;
            
            cache.undo_idx.push_back(peer_idx);
            cache.undo_old.push_back(old_mask);
            cache.undo_old_count.push_back(cache.candidate_popcnt[peer_u]);
            
            if (new_mask == 0ULL) {
                cache_set_candidate(cache, peer_idx, 0ULL, 0U);
                return false;
            }
            const uint8_t new_cnt = static_cast<uint8_t>(std::popcount(new_mask));
            cache_set_candidate(cache, peer_idx, new_mask, new_cnt);
        }
        return true;
    }

    void rollback_place_with_cache(GenericBoard& board, CandidateCache& cache, int idx, int digit, size_t marker) const {
        while (cache.undo_idx.size() > marker) {
            const int changed_idx = cache.undo_idx.back();
            const uint64_t old_mask = cache.undo_old.back();
            const uint8_t old_count = cache.undo_old_count.back();
            cache.undo_idx.pop_back();
            cache.undo_old.pop_back();
            cache.undo_old_count.pop_back();
            cache_set_candidate(cache, changed_idx, old_mask, old_count);
        }
        board.unplace(idx, digit);
    }

    bool fill_cached(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget, CandidateCache& cache) const {
        if (budget != nullptr && !budget->step()) return false;
        
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        if (!select_best_cell_cached(board, cache, best_idx, best_mask)) return false;
        if (best_idx == -1) return true;

        int digits[64];
        const int digit_count = shuffled_digits_from_mask(best_mask, rng, digits);
        
        if (digit_count == 1) {
            size_t marker = 0;
            const int d = digits[0];
            if (try_place_with_cache(board, cache, best_idx, d, marker)) {
                if (fill_cached(board, rng, budget, cache)) return true;
            }
            rollback_place_with_cache(board, cache, best_idx, d, marker);
            return false;
        }
        
        for (int i = 0; i < digit_count; ++i) {
            const int d = digits[i];
            size_t marker = 0;
            if (try_place_with_cache(board, cache, best_idx, d, marker)) {
                if (fill_cached(board, rng, budget, cache)) return true;
            }
            rollback_place_with_cache(board, cache, best_idx, d, marker);
            if (budget != nullptr && budget->aborted()) return false;
        }
        return false;
    }

    bool fill_recompute(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget) const {
        if (budget != nullptr && !budget->step()) return false;
        
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        if (!select_best_cell_bucketed(board, best_idx, best_mask)) return false;
        if (best_idx == -1) return true;

        int digits[64];
        const int digit_count = shuffled_digits_from_mask(best_mask, rng, digits);
        
        if (digit_count == 1) {
            const int d = digits[0];
            board.place(best_idx, d);
            if (fill_recompute(board, rng, budget)) return true;
            board.unplace(best_idx, d);
            return false;
        }
        
        for (int i = 0; i < digit_count; ++i) {
            const int d = digits[i];
            board.place(best_idx, d);
            if (fill_recompute(board, rng, budget)) return true;
            board.unplace(best_idx, d);
            if (budget != nullptr && budget->aborted()) return false;
        }
        return false;
    }

    bool fill(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget) const {
        // Cache przyspiesza proces tylko przy wyższych wartościach N
        static constexpr int kCacheMrvMinN = 25;
        if (board.topo->n < kCacheMrvMinN) {
            return fill_recompute(board, rng, budget);
        }
        CandidateCache& cache = candidate_cache_for(*board.topo);
        if (!init_candidate_cache(board, cache)) {
            return false;
        }
        return fill_cached(board, rng, budget, cache);
    }
};

} // namespace sudoku_hpc::core_engines



==============================================================================
PLIK: Sources\generator\generator_facade.h
==============================================================================

// ============================================================================
// SUDOKU HPC - GENERATOR PIPELINE
// Moduł: generator_facade.h
// Opis: Główna fasada sterująca procesem generacji łamigłówki (Pipeline).
//       Integruje Kernels, Pattern Forcing, MCTS Diggera oraz Certyfikator.
// ============================================================================
//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <atomic>
#include <charconv>
#include <chrono>
#include <cstdint>
#include <string>
#include <vector>

// Core & Config
#include "../core/board.h"
#include "../config/run_config.h"

// Core Engines
#include "core_engines/dlx_solver.h"
#include "core_engines/solved_kernel.h"
#include "core_engines/quick_prefilter.h"

// Logic & Strategies (Fasada silnika certyfikacji)
#include "../logic/sudoku_logic_engine.h"

// Post-Processing
#include "post_processing/quality_metrics.h"
#include "post_processing/replay_validator.h"

// MCTS Digger
#include "mcts_digger/bottleneck_digger.h"

// Pattern Forcing
#include "pattern_forcing/pattern_planter.h"

namespace sudoku_hpc::generator {

using core_engines::SearchAbortControl;

struct GenericPuzzleCandidate {
    std::vector<uint16_t> puzzle;
    std::vector<uint16_t> solution;
    int clues = 0;
};

// ============================================================================
// ZERO-ALLOCATION SERIALIZATION
// Zamiast std::ostringstream i tworzenia wielu mniejszych stringów używamy
// jednego bufora, a wartości wpisujemy przez systemowy std::to_chars().
// ============================================================================
inline std::string serialize_line_generic(
    uint64_t seed,
    const GenerateRunConfig& cfg,
    const GenericPuzzleCandidate& candidate,
    int nn) {
    
    std::string out;
    // Prealokacja maksymalnego bezpiecznego rozmiaru
    out.resize(128 + static_cast<size_t>(nn) * 4); 
    char* ptr = out.data();
    char* end = ptr + out.size(); 

    auto res1 = std::to_chars(ptr, end, seed); ptr = res1.ptr;
    *ptr++ = ',';
    auto res2 = std::to_chars(ptr, end, cfg.box_rows); ptr = res2.ptr;
    *ptr++ = ',';
    auto res3 = std::to_chars(ptr, end, cfg.box_cols); ptr = res3.ptr;

    const uint16_t* puz_ptr = candidate.puzzle.data();
    const uint16_t* sol_ptr = candidate.solution.data();

    for (int i = 0; i < nn; ++i) {
        *ptr++ = ',';
        const uint16_t v = puz_ptr[i];
        if (v != 0) {
            *ptr++ = 't'; // given (clue)
            auto res = std::to_chars(ptr, end, v); ptr = res.ptr;
        } else {
            // solution value
            auto res = std::to_chars(ptr, end, sol_ptr[i]); ptr = res.ptr;
        }
    }
    
    // Ucinamy sznurek do faktycznie wykorzystanego zakresu
    out.resize(ptr - out.data());
    return out;
}

// Struktura na wewnętrzne metryki pojedynczej próby, dla celów mikro-profilowania
struct AttemptPerfStats {
    uint64_t solved_elapsed_ns = 0;
    uint64_t dig_elapsed_ns = 0;
    uint64_t prefilter_elapsed_ns = 0;
    uint64_t logic_elapsed_ns = 0;
    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    uint64_t uniqueness_elapsed_ns = 0;
    uint64_t logic_steps = 0;
    uint64_t strategy_naked_use = 0;
    uint64_t strategy_naked_hit = 0;
    uint64_t strategy_hidden_use = 0;
    uint64_t strategy_hidden_hit = 0;
};

// Pomocnicza metoda oceniająca, czy oczekiwany poziom został spełniony
inline bool evaluate_difficulty_contract_generic(const logic::GenericLogicCertifyResult& logic_result, int difficulty_level_required) {
    const int lvl = std::clamp(difficulty_level_required, 1, 9);
    
    if (lvl <= 1) {
        return logic_result.solved && (logic_result.used_naked_single || logic_result.used_hidden_single);
    }
    if (lvl == 2) {
        return logic_result.used_pointing_pairs || logic_result.used_box_line;
    }
    if (lvl == 3) {
        return logic_result.used_naked_pair || logic_result.used_hidden_pair ||
               logic_result.used_naked_triple || logic_result.used_hidden_triple;
    }
    if (lvl == 4) {
        return logic_result.used_naked_quad || logic_result.used_hidden_quad ||
               logic_result.used_x_wing || logic_result.used_y_wing ||
               logic_result.used_skyscraper || logic_result.used_two_string_kite ||
               logic_result.used_empty_rectangle || logic_result.used_remote_pairs;
    }
    if (lvl == 5) {
        return logic_result.used_swordfish || logic_result.used_bug_plus_one ||
               logic_result.used_finned_x_wing_sashimi || logic_result.used_simple_coloring ||
               logic_result.used_unique_rectangle || logic_result.used_xyz_wing ||
               logic_result.used_w_wing;
    }
    if (lvl == 6) {
        return logic_result.used_jellyfish || logic_result.used_x_chain ||
               logic_result.used_xy_chain || logic_result.used_wxyz_wing ||
               logic_result.used_finned_swordfish_jellyfish || logic_result.used_als_xz ||
               logic_result.used_unique_loop || logic_result.used_avoidable_rectangle ||
               logic_result.used_bivalue_oddagon || logic_result.used_ur_extended ||
               logic_result.used_hidden_ur || logic_result.used_bug_type2 ||
               logic_result.used_bug_type3 || logic_result.used_bug_type4 ||
               logic_result.used_borescoper_qiu_deadly_pattern ||
               logic_result.used_unique_rectangle || logic_result.used_bug_plus_one ||
               logic_result.used_w_wing;
    }
    if (lvl == 7) {
        return logic_result.used_medusa_3d || logic_result.used_aic || logic_result.used_grouped_aic ||
               logic_result.used_grouped_x_cycle || logic_result.used_continuous_nice_loop ||
               logic_result.used_als_xy_wing || logic_result.used_als_chain ||
               logic_result.used_sue_de_coq || logic_result.used_death_blossom ||
               logic_result.used_franken_fish || logic_result.used_mutant_fish ||
               logic_result.used_kraken_fish || logic_result.used_squirmbag ||
               logic_result.used_aligned_pair_exclusion || logic_result.used_aligned_triple_exclusion ||
               logic_result.used_als_aic;
    }
    if (lvl == 8) {
        return logic_result.used_msls || logic_result.used_exocet || logic_result.used_senior_exocet ||
               logic_result.used_sk_loop || logic_result.used_pattern_overlay_method ||
               logic_result.used_forcing_chains || logic_result.used_dynamic_forcing_chains;
    }

    return true; // lvl 9 = Backtracking (brak specyficznych wymagań dla strategii)
}

// Sprawdzenie, czy Certyfikator użył żądanej strategii.
inline bool evaluate_required_strategy_contract_generic(
    const logic::GenericLogicCertifyResult& logic_result,
    const GenerateRunConfig& cfg,
    RequiredStrategy required,
    RequiredStrategyAttemptInfo& strategy_info) {

    strategy_info = {};
    if (required == RequiredStrategy::None) {
        return true;
    }

    size_t required_slot = 0;
    if (!mcts_digger::mcts_required_strategy_slot(required, required_slot)) {
        if (required == RequiredStrategy::Backtracking) {
            strategy_info.analyzed_required_strategy = true;
            strategy_info.required_strategy_use_confirmed = true;
            strategy_info.required_strategy_hit_confirmed = true;
            strategy_info.matched_required_strategy = true;
            return true;
        }
        return false;
    }

    if (cfg.strict_canonical_strategies && !logic::GenericLogicCertify::is_full_canonical_slot(required_slot)) {
        strategy_info.analyzed_required_strategy = true;
        strategy_info.required_strategy_use_confirmed = true;
        strategy_info.required_strategy_hit_confirmed = false;
        strategy_info.matched_required_strategy = false;
        return false;
    }
    if (!cfg.allow_proxy_advanced && logic::GenericLogicCertify::is_proxy_slot(required_slot)) {
        strategy_info.analyzed_required_strategy = true;
        strategy_info.required_strategy_use_confirmed = true;
        strategy_info.required_strategy_hit_confirmed = false;
        strategy_info.matched_required_strategy = false;
        return false;
    }

    strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[required_slot].use_count > 0;
    strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[required_slot].hit_count > 0;
    strategy_info.analyzed_required_strategy = strategy_info.required_strategy_use_confirmed;
    strategy_info.matched_required_strategy =
        strategy_info.required_strategy_use_confirmed && strategy_info.required_strategy_hit_confirmed;
    return strategy_info.matched_required_strategy;
}


// ============================================================================
// GŁÓWNA FUNKCJA KONTROLI PIPELINE'U (Wykonywana per każda próba generowania)
// ============================================================================
inline bool generate_one_generic(
    const GenerateRunConfig& cfg,
    const GenericTopology& topo,
    std::mt19937_64& rng,
    GenericPuzzleCandidate& candidate,
    RejectReason& reason,
    RequiredStrategyAttemptInfo& strategy_info,
    const core_engines::GenericSolvedKernel& solved,
    const core_engines::GenericQuickPrefilter& prefilter,
    const logic::GenericLogicCertify& logic,
    const core_engines::GenericUniquenessCounter& uniq,
    const std::atomic<bool>* force_abort_ptr = nullptr,
    bool* timed_out = nullptr,
    const std::atomic<bool>* external_cancel_ptr = nullptr,
    const std::atomic<bool>* external_pause_ptr = nullptr,
    post_processing::QualityContract* quality_contract_out = nullptr,
    post_processing::QualityMetrics* quality_metrics_out = nullptr,
    post_processing::ReplayValidationResult* replay_out = nullptr,
    AttemptPerfStats* perf_out = nullptr) {
    
    const bool has_timed_out_ptr = (timed_out != nullptr);
    const bool has_quality_contract_out = (quality_contract_out != nullptr);
    const bool has_quality_metrics_out = (quality_metrics_out != nullptr);
    const bool has_replay_out = (replay_out != nullptr);
    const bool collect_perf = (perf_out != nullptr);
    
    if (has_timed_out_ptr) *timed_out = false;
    strategy_info = {};
    if (has_quality_contract_out) *quality_contract_out = {};
    if (has_quality_metrics_out) *quality_metrics_out = {};
    if (has_replay_out) *replay_out = {};
    if (collect_perf) *perf_out = {};
    
    const bool quality_contract_enabled = cfg.enable_quality_contract;
    const bool distribution_filter_enabled = quality_contract_enabled && cfg.enable_distribution_filter;
    const bool replay_validation_enabled = quality_contract_enabled && cfg.enable_replay_validation;
    const bool need_quality_metrics = quality_contract_enabled || quality_contract_out != nullptr || quality_metrics_out != nullptr;
    const bool budget_enabled = cfg.attempt_time_budget_s > 0.0 || cfg.attempt_node_budget > 0 || force_abort_ptr != nullptr;
    
    SearchAbortControl budget;
    if (cfg.attempt_time_budget_s > 0.0) {
        budget.time_enabled = true;
        budget.deadline = std::chrono::steady_clock::now() + 
            std::chrono::duration_cast<std::chrono::steady_clock::duration>(std::chrono::duration<double>(cfg.attempt_time_budget_s));
    }
    if (cfg.attempt_node_budget > 0) {
        budget.node_enabled = true;
        budget.node_limit = cfg.attempt_node_budget;
    }
    if (force_abort_ptr != nullptr) budget.force_abort_ptr = force_abort_ptr;
    budget.cancel_ptr = external_cancel_ptr;
    budget.pause_ptr = external_pause_ptr;
    
    SearchAbortControl* budget_ptr = budget_enabled ? &budget : nullptr;

    candidate.solution.resize(static_cast<size_t>(topo.nn), 0);
    candidate.puzzle.resize(static_cast<size_t>(topo.nn), 0);
    candidate.clues = 0;

    // ------------------------------------------------------------------------
    // ETAP 1: Generowanie pełnej, poprawnej planszy "Solved Grid"
    // ------------------------------------------------------------------------
    const auto solved_t0 = std::chrono::steady_clock::now();
    bool solved_ok = false;
    const uint8_t* dig_protected_cells = nullptr;
    
    if (cfg.pattern_forcing_enabled) {
        const int pf_tries = std::max(1, cfg.pattern_forcing_tries);
        for (int pf_try = 0; pf_try < pf_tries && !solved_ok; ++pf_try) {
            pattern_forcing::PatternSeedView pf_seed{};
            if (!pattern_forcing::build_seed(
                    topo, cfg, cfg.required_strategy, cfg.difficulty_level_required, rng, pf_seed)) {
                break;
            }
            if (pf_seed.seed_puzzle == nullptr || pf_seed.allowed_masks == nullptr) {
                break;
            }

            // Rozwiązanie narzuconego układu przez DLX Solver
            solved_ok = uniq.solve_and_capture(
                *pf_seed.seed_puzzle, topo, candidate.solution, budget_ptr, pf_seed.allowed_masks);
                
            if (solved_ok && cfg.pattern_forcing_lock_anchors && pf_seed.protected_cells != nullptr &&
                !pf_seed.protected_cells->empty()) {
                dig_protected_cells = pf_seed.protected_cells->data();
            }
            if (budget_ptr != nullptr && budget_ptr->aborted()) break;
        }
    }

    // Fallback dla zwykłego generatora jeśli wzorzec nie jest wymagany
    if (!solved_ok) {
        solved_ok = solved.generate(topo, rng, candidate.solution, budget_ptr);
    }
    
    if (collect_perf) {
        perf_out->solved_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - solved_t0).count());
    }

    if (!solved_ok) {
        if (budget_ptr != nullptr && budget_ptr->aborted()) {
            if (budget_ptr->aborted_by_pause) {
                reason = RejectReason::None;
                return false;
            }
            if (has_timed_out_ptr) *timed_out = budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes;
        }
        reason = RejectReason::Logic;
        return false;
    }
    
    // ------------------------------------------------------------------------
    // ETAP 2: Wykopywanie dziur w planszy i ocena przez Bottleneck Digger
    // ------------------------------------------------------------------------
    const auto dig_t0 = std::chrono::steady_clock::now();
    if (cfg.mcts_digger_enabled) {
        mcts_digger::GenericMctsBottleneckDigger mcts_digger;
        mcts_digger::GenericMctsBottleneckDigger::RunStats mcts_stats{};
        
        const bool dig_ok = mcts_digger.dig_into(
            candidate.solution, topo, cfg, rng, uniq, logic,
            candidate.puzzle, candidate.clues, dig_protected_cells, budget_ptr, &mcts_stats);
            
        if (!dig_ok) {
            if (budget_ptr != nullptr && budget_ptr->aborted()) {
                if (budget_ptr->aborted_by_pause) {
                    reason = RejectReason::None;
                    return false;
                }
                if (has_timed_out_ptr) *timed_out = budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes;
            }
            reason = RejectReason::Logic;
            return false;
        }
    } else {
        // Fallback dla małych plansz lub gdy użytkownik prosi o brak MCTS
        // (Do dorzucenia np. standardowy random digger - tutaj uproszczony fallback na fail, jeśli wymagane)
        reason = RejectReason::Logic;
        return false;
    }
    
    if (collect_perf) {
        perf_out->dig_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - dig_t0).count());
    }

    // ------------------------------------------------------------------------
    // ETAP 3: Quick Prefilter
    // ------------------------------------------------------------------------
    const auto prefilter_t0 = std::chrono::steady_clock::now();
    const bool prefilter_ok = prefilter.check(candidate.puzzle, topo, cfg.min_clues, cfg.max_clues);
    if (collect_perf) {
        perf_out->prefilter_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - prefilter_t0).count());
    }
    if (!prefilter_ok) {
        reason = RejectReason::Prefilter;
        return false;
    }
    
    // ------------------------------------------------------------------------
    // ETAP 4: Weryfikacja Jakości i Symetrii (Quality Contract)
    // ------------------------------------------------------------------------
    post_processing::QualityMetrics quality_metrics{};
    if (need_quality_metrics) {
        quality_metrics = post_processing::evaluate_quality_metrics(candidate.puzzle, topo, cfg);
        if (has_quality_metrics_out) *quality_metrics_out = quality_metrics;
        
        if (has_quality_contract_out) {
            quality_contract_out->clue_range_ok = (candidate.clues >= cfg.min_clues && candidate.clues <= cfg.max_clues);
            quality_contract_out->symmetry_ok = quality_metrics.symmetry_ok;
            quality_contract_out->distribution_balance_ok = quality_metrics.distribution_balance_ok;
            quality_contract_out->givens_entropy_ok = quality_metrics.normalized_entropy >= quality_metrics.entropy_threshold;
        }

        if (quality_contract_enabled) {
            if (!quality_metrics.symmetry_ok) {
                reason = RejectReason::DistributionBias;
                return false;
            }
            if (distribution_filter_enabled) {
                if (!(quality_metrics.normalized_entropy >= quality_metrics.entropy_threshold) || 
                    !quality_metrics.distribution_balance_ok) {
                    reason = RejectReason::DistributionBias;
                    return false;
                }
            }
        }
    }
    
    // ------------------------------------------------------------------------
    // ETAP 5: Certyfikacja Logiczna (Rozwiązanie) i Odrzucenie zbyt prostych
    // ------------------------------------------------------------------------
    const bool capture_logic_solution = replay_validation_enabled;
    const auto logic_t0 = std::chrono::steady_clock::now();
    
    // Wywołanie głównego silnika z ewaluacją wszystkich wymaganych strategii
    const logic::GenericLogicCertifyResult logic_result = logic.certify(candidate.puzzle, topo, budget_ptr, capture_logic_solution);
    
    if (collect_perf) {
        perf_out->logic_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - logic_t0).count());
    }
    if (logic_result.timed_out) {
        if (budget_ptr != nullptr && budget_ptr->aborted_by_pause) {
            reason = RejectReason::None;
            return false;
        }
        if (has_timed_out_ptr) *timed_out = (budget_ptr == nullptr) ? true : (budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes);
        reason = RejectReason::Logic;
        return false;
    }
    
    if (collect_perf) {
        perf_out->logic_steps = static_cast<uint64_t>(std::max(0, logic_result.steps));
        perf_out->strategy_naked_use = logic_result.strategy_stats[logic::GenericLogicCertify::SlotNakedSingle].use_count;
        perf_out->strategy_naked_hit = logic_result.strategy_stats[logic::GenericLogicCertify::SlotNakedSingle].hit_count;
        perf_out->strategy_hidden_use = logic_result.strategy_stats[logic::GenericLogicCertify::SlotHiddenSingle].use_count;
        perf_out->strategy_hidden_hit = logic_result.strategy_stats[logic::GenericLogicCertify::SlotHiddenSingle].hit_count;
    }

    if (!cfg.fast_test_mode) {
        if (!evaluate_difficulty_contract_generic(logic_result, cfg.difficulty_level_required)) {
            reason = RejectReason::Strategy;
            return false;
        }

        const bool contract_ok = evaluate_required_strategy_contract_generic(logic_result, cfg, cfg.required_strategy, strategy_info);
        if (cfg.required_strategy != RequiredStrategy::None && !contract_ok) {
            reason = RejectReason::Strategy;
            return false;
        }
    }
    if (cfg.strict_logical && !logic_result.solved && cfg.required_strategy != RequiredStrategy::Backtracking) {
        reason = RejectReason::Logic;
        return false;
    }
    
    // ------------------------------------------------------------------------
    // ETAP 6: Gwarancja Unikalności przez algorytm Dancing Links X (DLX)
    // ------------------------------------------------------------------------
    bool uniqueness_ok = true;
    if (cfg.require_unique) {
        auto record_uniqueness_perf = [&](const SearchAbortControl& b, uint64_t elapsed_ns) {
            if (!collect_perf) return;
            ++perf_out->uniqueness_calls;
            perf_out->uniqueness_nodes += b.nodes;
            perf_out->uniqueness_elapsed_ns += elapsed_ns;
        };
        
        SearchAbortControl uniq_budget = budget;
        SearchAbortControl* uniq_budget_ptr = budget_enabled ? &uniq_budget : nullptr;
        
        const auto uniq_t0 = std::chrono::steady_clock::now();
        // Limitujemy wyjście DLX na poziomie 2, by nie przeszukiwać całej choinki rozwiązań.
        const int solutions = uniq.count_solutions_limit2(candidate.puzzle, topo, uniq_budget_ptr);
        const auto uniq_elapsed_ns = static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - uniq_t0).count());
            
        record_uniqueness_perf(uniq_budget, uniq_elapsed_ns);
        
        if (solutions < 0) {
            if (uniq_budget_ptr != nullptr && uniq_budget_ptr->aborted_by_pause) {
                reason = RejectReason::None;
                return false;
            }
            if (has_timed_out_ptr) *timed_out = true;
            reason = RejectReason::Logic;
            return false;
        }
        if (solutions != 1) {
            reason = RejectReason::Uniqueness;
            return false;
        }
    }

    // ------------------------------------------------------------------------
    // ETAP 7: Finalny Post-Processing (Podpis kryptograficzny)
    // ------------------------------------------------------------------------
    post_processing::ReplayValidationResult replay{};
    if (replay_validation_enabled) {
        replay = post_processing::run_replay_validation(candidate.puzzle, candidate.solution, topo, logic);
        
        if (has_replay_out) *replay_out = replay;
        if (!replay.ok) {
            reason = RejectReason::Replay;
            return false;
        }
    }
    
    if (has_quality_contract_out) {
        quality_contract_out->is_unique = uniqueness_ok;
        quality_contract_out->logic_replay_ok = replay.ok || !replay_validation_enabled;
    }
    
    if (has_quality_contract_out && !post_processing::quality_contract_passed(*quality_contract_out, cfg)) {
        reason = RejectReason::DistributionBias;
        return false;
    }
    
    reason = RejectReason::None;
    return true; // Sukces, plansza wygenerowana i obłożona wszelkimi certyfikatami.
}

} // namespace sudoku_hpc::generator



==============================================================================
PLIK: Sources\generator\mcts_digger\bottleneck_digger.h
==============================================================================

// ============================================================================
// SUDOKU HPC - MCTS DIGGER
// Moduł: bottleneck_digger.h
// Opis: Główny silnik kopacza (Digger) używający Monte Carlo Tree Search.
//       Szuka logicznych "wąskich gardeł" (bottlenecks) poprzez symulacje usuwania.
//       Zero-Allocation w gorącej pętli.
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>
#include <random>
#include <vector>

#include "mcts_node.h"
#include "mcts_ucb_policy.h"

// Zależności do głównych silników (zostaną dostarczone w fazach 3 i 5)
#include "../../core/board.h"
#include "../../config/run_config.h"
#include "../core_engines/dlx_solver.h" // GenericUniquenessCounter
#include "../../logic/sudoku_logic_engine.h" // GenericLogicCertify i GenericLogicCertifyResult

namespace sudoku_hpc::mcts_digger {

using core_engines::GenericUniquenessCounter;
using core_engines::SearchAbortControl;
using logic::GenericLogicCertify;
using logic::GenericLogicCertifyResult;

// Helper: mapuje enum RequiredStrategy na indeks tablicy statystyk w Certyfikatorze
inline bool mcts_required_strategy_slot(RequiredStrategy rs, size_t& out_slot) {
    return GenericLogicCertify::slot_from_required_strategy(rs, out_slot);
}

class GenericMctsBottleneckDigger {
public:
    struct RunStats {
        bool used = false;
        bool bottleneck_hit = false;
        int accepted_removals = 0;
        int rejected_uniqueness = 0;
        int rejected_logic_timeout = 0;
        int iterations = 0;
        int advanced_evals = 0;
        int advanced_p7_hits = 0;
        int advanced_p8_hits = 0;
        int required_strategy_hits = 0;
    };

    // Przeprowadza proces "kopania" na gotowej planszy (solved)
    bool dig_into(
        const std::vector<uint16_t>& solved,
        const GenericTopology& topo,
        const GenerateRunConfig& cfg,
        std::mt19937_64& rng,
        const GenericUniquenessCounter& uniq,
        const GenericLogicCertify& logic,
        std::vector<uint16_t>& out_puzzle,
        int& out_clues,
        const uint8_t* protected_cells = nullptr,
        SearchAbortControl* budget = nullptr,
        RunStats* stats = nullptr) const {

        if (stats != nullptr) {
            *stats = {};
            stats->used = true;
        }

        // Kopia startowa planszy
        out_puzzle.resize(solved.size());
        std::copy(solved.begin(), solved.end(), out_puzzle.begin());

        int min_clues = std::clamp(cfg.min_clues, 0, topo.nn);
        int max_clues = std::clamp(cfg.max_clues, min_clues, topo.nn);
        std::uniform_int_distribution<int> pick_target(min_clues, max_clues);
        const int target_clues = pick_target(rng);

        // Reset bufora MCTS (Zero-Allocation)
        MctsNodeScratch& sc = tls_mcts_node_scratch();
        sc.reset(topo.nn);

        // Aktywacja wszystkich niechronionych komórek
        for (int idx = 0; idx < topo.nn; ++idx) {
            if (protected_cells != nullptr && protected_cells[static_cast<size_t>(idx)] != 0) {
                continue;
            }
            sc.activate(idx);
        }

        int clues = topo.nn;
        int fail_streak = 0;
        
        const int fail_cap = std::max(16, cfg.mcts_fail_cap);
        const int iter_cap = (cfg.mcts_digger_iterations > 0) ? cfg.mcts_digger_iterations : std::max(256, topo.nn * 8);
        const int basic_level = std::clamp(cfg.mcts_basic_logic_level, 1, 5);
        const double ucb_c = std::clamp(cfg.mcts_ucb_c, 0.1, 4.0);
        
        const MctsAdvancedTuning tuning = resolve_mcts_advanced_tuning(cfg, topo);
        int advanced_level = std::clamp(std::max(6, cfg.difficulty_level_required), 6, 8);
        if (cfg.max_pattern_depth > 0) {
            advanced_level = std::min(advanced_level, cfg.max_pattern_depth);
            advanced_level = std::clamp(advanced_level, 6, 8);
        }
        const bool wants_p8 = (cfg.difficulty_level_required >= 8) || mcts_is_level8_strategy(cfg.required_strategy);
        
        size_t required_slot = 0;
        const bool has_required_slot = mcts_required_strategy_slot(cfg.required_strategy, required_slot);

        // Główna pętla MCTS
        for (int iter = 0; iter < iter_cap; ++iter) {
            if (stats != nullptr) stats->iterations = iter + 1;
            if (budget != nullptr && !budget->step()) return false;
            if (clues <= target_clues || sc.active_count <= 0 || fail_streak >= fail_cap) break;

            // Faza 1: Wybór akcji wg. UCB1
            const int idx = select_ucb_action(sc, rng, ucb_c);
            if (idx < 0) break;
            
            // Pusta komórka? Wyłącz ją.
            if (out_puzzle[static_cast<size_t>(idx)] == 0) {
                sc.disable(idx);
                continue;
            }

            int sym_idx = -1;
            bool remove_pair = false;
            
            // Sprawdzenie symetrii
            if (cfg.symmetry_center) {
                sym_idx = topo.cell_center_sym[static_cast<size_t>(idx)];
                if (sym_idx >= 0 && sym_idx != idx && out_puzzle[static_cast<size_t>(sym_idx)] != 0) {
                    if (!(protected_cells != nullptr && protected_cells[static_cast<size_t>(sym_idx)] != 0)) {
                        remove_pair = true;
                    }
                }
            }

            const int removal = remove_pair ? 2 : 1;
            if (clues - removal < target_clues) {
                sc.disable(idx);
                if (remove_pair) sc.disable(sym_idx);
                continue;
            }

            // Symulacja usunięcia
            const uint16_t old_a = out_puzzle[static_cast<size_t>(idx)];
            const uint16_t old_b = remove_pair ? out_puzzle[static_cast<size_t>(sym_idx)] : 0;
            
            out_puzzle[static_cast<size_t>(idx)] = 0;
            if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = 0;

            // Odrzucenie: brak unikalności (wielokrotne rozwiązania)
            const int solutions = uniq.count_solutions_limit2(out_puzzle, topo, budget);
            if (solutions < 0) { // Timeout w DLX
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                if (stats != nullptr) ++stats->rejected_logic_timeout;
                return false;
            }
            if (solutions != 1) { // Strata unikalności -> kara dla węzła
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                
                sc.update(idx, -6.0); // Mocna kara za popsucie planszy
                sc.disable(idx);
                if (remove_pair) {
                    sc.update(sym_idx, -6.0);
                    sc.disable(sym_idx);
                }
                
                ++fail_streak;
                if (stats != nullptr) ++stats->rejected_uniqueness;
                continue;
            }

            // Faza 2: Ocena stanu Basic (Poziomy 1-5)
            const GenericLogicCertifyResult basic = logic.certify_up_to_level(out_puzzle, topo, basic_level, budget, false);
            if (basic.timed_out) {
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                if (stats != nullptr) ++stats->rejected_logic_timeout;
                return false;
            }

            const bool basic_solved = basic.solved;
            
            // Faza 3: Wyznaczanie Nagrody (Reward Function)
            // Jeśli basic logic potrafi to rozwiązać, to nagroda jest mała (exploit).
            // Jeśli utknie, to nagroda jest gigantyczna, bo stworzyliśmy BOTTLENECK.
            double reward = basic_solved 
                ? (1.0 + 0.002 * static_cast<double>(std::max(0, basic.steps))) 
                : (18.0 + 0.005 * static_cast<double>(std::max(0, basic.steps)));

            int p7_hits = 0;
            int p8_hits = 0;
            int required_hits = 0;
            bool advanced_signal = false;
            bool stopping_signal = !basic_solved;

            // Faza 4: Certyfikacja zaawansowana (Opcjonalne dla wyższych poziomów MCTS Tuning)
            const bool do_advanced_eval = 
                tuning.enabled && 
                ((!basic_solved) || 
                 ((clues - removal) <= (target_clues + tuning.near_window)) || 
                 ((iter % tuning.eval_stride) == 0));

            if (do_advanced_eval) {
                const GenericLogicCertifyResult adv = logic.certify_up_to_level(out_puzzle, topo, advanced_level, budget, false);
                if (adv.timed_out) {
                    out_puzzle[static_cast<size_t>(idx)] = old_a;
                    if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                    if (stats != nullptr) ++stats->rejected_logic_timeout;
                    return false;
                }

                // Analiza wyników P7 (Sloty Medusa3D do KrakenFish / ALSAIC)
                for (size_t slot = GenericLogicCertify::SlotMedusa3D; slot <= GenericLogicCertify::SlotALSAIC; ++slot) {
                    p7_hits += static_cast<int>(adv.strategy_stats[slot].hit_count);
                }
                
                // Analiza wyników P8 (Sloty MSLS do DynamicForcingChains)
                for (size_t slot = GenericLogicCertify::SlotMSLS; slot <= GenericLogicCertify::SlotDynamicForcingChains; ++slot) {
                    p8_hits += static_cast<int>(adv.strategy_stats[slot].hit_count);
                }

                if (has_required_slot) {
                    required_hits = static_cast<int>(adv.strategy_stats[required_slot].hit_count);
                }

                // Kalkulacja zysku (Backpropagation value)
                reward += tuning.p7_hit_weight * static_cast<double>(p7_hits);
                reward += tuning.p8_hit_weight * static_cast<double>(p8_hits);
                reward += tuning.required_hit_weight * static_cast<double>(required_hits);
                
                if (wants_p8 && p8_hits == 0 && required_hits == 0) {
                    reward -= tuning.p8_miss_penalty;
                }
                
                reward = std::max(tuning.min_reward, reward);
                advanced_signal = (p7_hits + p8_hits + required_hits) > 0;
                
                if (tuning.require_p8_signal_for_stop) {
                    stopping_signal = (required_hits > 0 || p8_hits > 0 || (!basic_solved && p7_hits > 0));
                } else {
                    stopping_signal = (!basic_solved || advanced_signal);
                }

                if (stats != nullptr) {
                    ++stats->advanced_evals;
                    stats->advanced_p7_hits += p7_hits;
                    stats->advanced_p8_hits += p8_hits;
                    stats->required_strategy_hits += required_hits;
                }
            }

            // Aktualizacja węzła MCTS
            sc.update(idx, reward);
            if (remove_pair) {
                sc.update(sym_idx, reward);
            }
            
            // Zatwierdzenie modyfikacji
            clues -= removal;
            fail_streak = 0;
            
            if (stats != nullptr) {
                stats->accepted_removals += removal;
                if (stopping_signal) {
                    stats->bottleneck_hit = true;
                }
            }

            // Osiągnięcie celu - wcześniejsze wyjście dla optymalizacji czasowej
            if (stopping_signal && clues <= max_clues && clues >= min_clues) {
                break;
            }
        }

        out_clues = clues;
        return true;
    }
};

} // namespace sudoku_hpc::mcts_digger



==============================================================================
PLIK: Sources\generator\mcts_digger\mcts_node.h
==============================================================================

// ============================================================================
// SUDOKU HPC - MCTS DIGGER
// Moduł: mcts_node.h
// Opis: Reprezentuje węzeł drzewa Monte Carlo. Prealokowany w TLS.
//       Służy do oceny "wartości" usunięcia konkretnej komórki (reward).
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>
#include <vector>

namespace sudoku_hpc::mcts_digger {

// Struktura bufora przetrzymująca statystyki na danym etapie poszukiwań
// Utrzymuje do MAX_NN komórek jako dostępne akcje (usunięcia).
struct MctsNodeScratch {
    int prepared_nn = 0;
    
    // Tablice równoległe (SoA) zastępujące alokowane węzły
    std::vector<double> reward_sum;
    std::vector<uint32_t> visits;
    std::vector<int> active_cells;
    std::vector<int> active_pos; // Mapowanie: O(1) index w active_cells dla danej komórki
    
    int active_count = 0;
    uint64_t total_visits = 0;

    void ensure(int nn) {
        if (prepared_nn == nn) {
            return;
        }
        reward_sum.assign(static_cast<size_t>(nn), 0.0);
        visits.assign(static_cast<size_t>(nn), 0U);
        active_cells.assign(static_cast<size_t>(nn), -1);
        active_pos.assign(static_cast<size_t>(nn), -1);
        prepared_nn = nn;
        active_count = 0;
        total_visits = 0;
    }

    void reset(int nn) {
        ensure(nn);
        std::fill(reward_sum.begin(), reward_sum.end(), 0.0);
        std::fill(visits.begin(), visits.end(), 0U);
        std::fill(active_pos.begin(), active_pos.end(), -1);
        active_count = 0;
        total_visits = 0;
    }

    // Aktywuje komórkę jako możliwy cel usunięcia ("odnoga" w drzewie)
    void activate(int cell) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        if (active_pos[static_cast<size_t>(cell)] >= 0) {
            return; // Już aktywna
        }
        
        const int pos = active_count++;
        active_cells[static_cast<size_t>(pos)] = cell;
        active_pos[static_cast<size_t>(cell)] = pos;
    }

    // Usuwa komórkę z dostępnych odnóg w O(1) swap_and_pop
    void disable(int cell) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        const int pos = active_pos[static_cast<size_t>(cell)];
        if (pos < 0 || pos >= active_count) {
            return;
        }
        
        const int last_pos = active_count - 1;
        const int last_cell = active_cells[static_cast<size_t>(last_pos)];
        
        // Zastąpienie usuwanego elementu ostatnim elementem
        active_cells[static_cast<size_t>(pos)] = last_cell;
        if (last_cell >= 0) {
            active_pos[static_cast<size_t>(last_cell)] = pos;
        }
        
        // Wyczyszczenie ogona
        active_cells[static_cast<size_t>(last_pos)] = -1;
        active_pos[static_cast<size_t>(cell)] = -1;
        --active_count;
    }

    // Aktualizacja statystyk węzła na podstawie sygnału z Backpropagation
    void update(int cell, double reward) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        reward_sum[static_cast<size_t>(cell)] += reward;
        visits[static_cast<size_t>(cell)] += 1U;
        ++total_visits;
    }
};

// TLS dostęp (Gwarancja uniknięcia alokacji w głównej pętli MCTS Diggera)
inline MctsNodeScratch& tls_mcts_node_scratch() {
    thread_local MctsNodeScratch s{};
    return s;
}

} // namespace sudoku_hpc::mcts_digger



==============================================================================
PLIK: Sources\generator\mcts_digger\mcts_ucb_policy.h
==============================================================================

// ============================================================================
// SUDOKU HPC - MCTS DIGGER
// Moduł: mcts_ucb_policy.h
// Opis: Algorytm wyboru (Selection) oparty na UCB1 oraz dynamiczne
//       profile strojenia nagród (Advanced Tuning Profile).
// ============================================================================

#pragma once

#include <algorithm>
#include <cctype>
#include <cmath>
#include <limits>
#include <random>
#include <string>

// Moduł węzłów
#include "mcts_node.h"

// Do sprawdzenia required_strategy
#include "../../config/run_config.h"
#include "../../core/geometry.h"
#include "../../logic/logic_result.h" // dla Enum StrategySlot

namespace sudoku_hpc::mcts_digger {

// Profil konfiguracji nagród używany w fazie Rollout / Simulation
struct MctsAdvancedTuning {
    bool enabled = false;
    int eval_stride = 8;
    int near_window = 2;
    double p7_hit_weight = 1.5;
    double p8_hit_weight = 2.5;
    double required_hit_weight = 4.0;
    double p8_miss_penalty = 1.5;
    double min_reward = -8.0;
    bool require_p8_signal_for_stop = false;
};

// Szybkie testy na poziomy trudności (zapobiega twardemu wiązaniu zależności nagłówków)
inline bool mcts_is_level7_strategy(RequiredStrategy rs) {
    switch (rs) {
    case RequiredStrategy::Medusa3D:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::ALSXYWing:
    case RequiredStrategy::ALSChain:
    case RequiredStrategy::SueDeCoq:
    case RequiredStrategy::DeathBlossom:
    case RequiredStrategy::FrankenFish:
    case RequiredStrategy::MutantFish:
    case RequiredStrategy::KrakenFish:
    case RequiredStrategy::AlignedPairExclusion:
    case RequiredStrategy::AlignedTripleExclusion:
    case RequiredStrategy::ALSAIC:
    case RequiredStrategy::Squirmbag:
        return true;
    default:
        return false;
    }
}

inline bool mcts_is_level8_strategy(RequiredStrategy rs) {
    switch (rs) {
    case RequiredStrategy::MSLS:
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
        return true;
    default:
        return false;
    }
}

// Normalizacja ciągu wejściowego profilu
inline std::string mcts_normalize_profile(const std::string& raw) {
    std::string key;
    key.reserve(raw.size());
    for (unsigned char ch : raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "off" || key == "none" || key == "disabled") return "off";
    if (key == "p7" || key == "level7" || key == "nightmare") return "p7";
    if (key == "p8" || key == "level8" || key == "theoretical") return "p8";
    return "auto";
}

// Tworzy zestaw wag dla nagród (Reward Function) na podstawie profilu
inline MctsAdvancedTuning resolve_mcts_advanced_tuning(
    const GenerateRunConfig& cfg,
    const GenericTopology& topo) {
    
    const bool wants_p7 =
        (cfg.difficulty_level_required >= 7) ||
        mcts_is_level7_strategy(cfg.required_strategy) ||
        mcts_is_level8_strategy(cfg.required_strategy);
        
    const bool wants_p8 =
        (cfg.difficulty_level_required >= 8) ||
        mcts_is_level8_strategy(cfg.required_strategy);

    std::string profile = mcts_normalize_profile(cfg.mcts_tuning_profile);
    if (profile == "auto") {
        profile = wants_p8 ? "p8" : (wants_p7 ? "p7" : "off");
    }

    MctsAdvancedTuning t{};
    if (profile == "off") {
        t.enabled = false;
        return t;
    }

    t.enabled = true;
    if (profile == "p8") {
        t.eval_stride = 2; // Ocena zaawansowana częściej
        t.near_window = std::max(4, topo.n);
        t.p7_hit_weight = 2.0;
        t.p8_hit_weight = 5.5;
        t.required_hit_weight = 9.0;
        t.p8_miss_penalty = 3.5;
        t.min_reward = -14.0;
        t.require_p8_signal_for_stop = true;
        return t;
    }

    // Default "p7" (Level 7)
    t.eval_stride = 4;
    t.near_window = std::max(3, topo.n / 2);
    t.p7_hit_weight = 2.5;
    t.p8_hit_weight = 3.0;
    t.required_hit_weight = 6.0;
    t.p8_miss_penalty = wants_p8 ? 1.0 : 0.0;
    t.min_reward = -10.0;
    t.require_p8_signal_for_stop = false;
    return t;
}

// Implementacja wyboru węzła wg równania UCB1
inline int select_ucb_action(const MctsNodeScratch& sc, std::mt19937_64& rng, double c_param) {
    if (sc.active_count <= 0) {
        return -1;
    }
    
    // Faza 1: Losowy wybór nieodwiedzonego węzła (Rezerwuar Sampling dla optymalnej losowości)
    int unseen_pick = -1;
    int unseen_seen = 0;
    for (int i = 0; i < sc.active_count; ++i) {
        const int cell = sc.active_cells[static_cast<size_t>(i)];
        if (cell < 0) continue;
        
        if (sc.visits[static_cast<size_t>(cell)] == 0U) {
            ++unseen_seen;
            if ((rng() % static_cast<uint64_t>(unseen_seen)) == 0ULL) {
                unseen_pick = cell;
            }
        }
    }
    
    // Jeśli są węzły, których jeszcze nie testowaliśmy (0 wizyt), wymuś eksplorację
    if (unseen_pick >= 0) {
        return unseen_pick;
    }

    // Faza 2: Górna Granica Ufności (UCB1 formula) - Wszystkie odwiedzone
    // UCB1 = (w_i / n_i) + c * sqrt(ln(N) / n_i)
    const double log_total = std::log(static_cast<double>(std::max<uint64_t>(1ULL, sc.total_visits)));
    
    int best_cell = -1;
    double best_score = -std::numeric_limits<double>::infinity();
    
    for (int i = 0; i < sc.active_count; ++i) {
        const int cell = sc.active_cells[static_cast<size_t>(i)];
        if (cell < 0) continue;
        
        const uint32_t v = sc.visits[static_cast<size_t>(cell)];
        // Safeguard (na wypadek race'a w wywołaniach, choć system jest jednowątkowy logicznie)
        if (v == 0U) {
            return cell;
        }
        
        const double inv_v = 1.0 / static_cast<double>(v);
        const double exploit = sc.reward_sum[static_cast<size_t>(cell)] * inv_v;
        const double explore = c_param * std::sqrt(log_total * inv_v);
        const double score = exploit + explore;
        
        if (score > best_score) {
            best_score = score;
            best_cell = cell;
        }
    }
    
    return best_cell;
}

} // namespace sudoku_hpc::mcts_digger



==============================================================================
PLIK: Sources\generator\pattern_forcing\pattern_planter.h
==============================================================================

// ============================================================================
// SUDOKU HPC - EXACT PATTERN FORCING
// Moduł: pattern_planter.h
// Opis: Menedżer wstrzykiwania wzorców (Planter). Łączy konkretne szablony,
//       alokuje struktury na stosie w TLS i eksponuje widok (SeedView).
// ============================================================================

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>
#include <random>
#include <vector>

// Core 
#include "../../core/board.h"
#include "../../config/run_config.h"

// Specyficzne szablony
#include "template_exocet.h"
#include "template_sk_loop.h"
#include "template_forcing.h"

namespace sudoku_hpc::pattern_forcing {

// Typy wzorców (do losowych "luźnych" kotwic)
enum class PatternKind : uint8_t {
    None = 0,
    Chain,
    ExocetLike,
    LoopLike,
    ForcingLike
};

// Mapowanie z flagi w main()
enum class TargetPattern : uint8_t {
    None = 0,
    XChain,
    XYChain,
    Exocet,
    MSLS
};

// Bezpieczny widok przekazywany na zewnątrz bez kopiowania wektorów
struct PatternSeedView {
    PatternKind kind = PatternKind::None;
    const std::vector<uint16_t>* seed_puzzle = nullptr;
    const std::vector<uint64_t>* allowed_masks = nullptr;
    const std::vector<uint8_t>* protected_cells = nullptr;
    int anchor_count = 0;
};

// Bufor współdzielony dla każdego wątku (Thread Local Storage)
// Gwarantuje ZERO-ALLOC podczas wielokrotnego generowania masek.
struct PatternScratch {
    int prepared_nn = 0;
    std::vector<uint16_t> seed_puzzle;
    std::vector<uint64_t> allowed_masks;
    std::vector<uint8_t> protected_cells;
    std::array<int, 64> anchors{};
    int anchor_count = 0;

    void ensure(const GenericTopology& topo) {
        if (prepared_nn != topo.nn) {
            seed_puzzle.assign(static_cast<size_t>(topo.nn), 0);
            allowed_masks.assign(static_cast<size_t>(topo.nn), 0ULL);
            protected_cells.assign(static_cast<size_t>(topo.nn), 0);
            prepared_nn = topo.nn;
        }
    }

    void reset(const GenericTopology& topo) {
        ensure(topo);
        std::fill(seed_puzzle.begin(), seed_puzzle.end(), 0);
        const uint64_t full = pf_full_mask_for_n(topo.n);
        std::fill(allowed_masks.begin(), allowed_masks.end(), full);
        std::fill(protected_cells.begin(), protected_cells.end(), static_cast<uint8_t>(0));
        anchor_count = 0;
    }

    bool add_anchor(int idx) {
        if (idx < 0 || idx >= prepared_nn) return false;
        // Zabezpieczenie przed duplikatami
        for (int i = 0; i < anchor_count; ++i) {
            if (anchors[static_cast<size_t>(i)] == idx) return false;
        }
        if (anchor_count >= static_cast<int>(anchors.size())) return false;
        anchors[static_cast<size_t>(anchor_count++)] = idx;
        return true;
    }
};

inline PatternScratch& tls_pattern_scratch() {
    thread_local PatternScratch s{};
    return s;
}

// Funkcja pomocnicza - zwraca maskę złożoną z `want` unikalnych losowych cyfr
inline uint64_t random_digit_mask(int n, int want, std::mt19937_64& rng) {
    if (n <= 0) return 0ULL;
    const int k = std::clamp(want, 1, n);
    uint64_t m = 0ULL;
    int placed = 0;
    int guard = 0;
    while (placed < k && guard < n * 8) {
        ++guard;
        const int d0 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        const uint64_t bit = 1ULL << d0;
        if ((m & bit) != 0ULL) continue;
        m |= bit;
        ++placed;
    }
    if (m == 0ULL) {
        const int d0 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        m = (1ULL << d0);
    }
    return m;
}

inline PatternKind pick_kind(RequiredStrategy required, int level) {
    switch (required) {
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
        return PatternKind::ExocetLike;
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::MSLS:
    case RequiredStrategy::PatternOverlayMethod:
        return PatternKind::LoopLike;
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
        return PatternKind::ForcingLike;
    default:
        break;
    }
    if (level >= 8) return PatternKind::ForcingLike;
    if (level >= 6) return PatternKind::Chain;
    return PatternKind::None;
}

// --- Szablony luźne (fallback gdy brakuje Exact Template) ---

inline bool build_chain_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (topo.n < 2) return false;
    const int n = topo.n;
    int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int r2 = r1;
    int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c2 = c1;
    for (int t = 0; t < 64 && r2 == r1; ++t) r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    for (int t = 0; t < 64 && c2 == c1; ++t) c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    if (r1 == r2 || c1 == c2) return false;
    sc.add_anchor(r1 * n + c1);
    sc.add_anchor(r1 * n + c2);
    sc.add_anchor(r2 * n + c2);
    sc.add_anchor(r2 * n + c1);
    return sc.anchor_count >= 4;
}

inline bool build_exocet_like_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (topo.box_rows <= 1 || topo.box_cols <= 1) return false;
    const int n = topo.n;
    const int box = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const int house = 2 * n + box;
    const int start = topo.house_offsets[static_cast<size_t>(house)];
    const int end = topo.house_offsets[static_cast<size_t>(house + 1)];
    if (end - start < 2) return false;

    int b1 = topo.houses_flat[static_cast<size_t>(start + (rng() % static_cast<uint64_t>(end - start)))];
    int b2 = b1;
    for (int t = 0; t < 128; ++t) {
        const int c = topo.houses_flat[static_cast<size_t>(start + (rng() % static_cast<uint64_t>(end - start)))];
        if (c == b1) continue;
        if (topo.cell_row[static_cast<size_t>(c)] == topo.cell_row[static_cast<size_t>(b1)]) continue;
        if (topo.cell_col[static_cast<size_t>(c)] == topo.cell_col[static_cast<size_t>(b1)]) continue;
        b2 = c;
        break;
    }
    if (b1 == b2) return false;
    sc.add_anchor(b1);
    sc.add_anchor(b2);

    const int r1 = topo.cell_row[static_cast<size_t>(b1)];
    const int r2 = topo.cell_row[static_cast<size_t>(b2)];
    const int c1 = topo.cell_col[static_cast<size_t>(b1)];
    const int c2 = topo.cell_col[static_cast<size_t>(b2)];
    sc.add_anchor(r1 * n + c2);
    sc.add_anchor(r2 * n + c1);
    return sc.anchor_count >= 2;
}

inline bool build_loop_like_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (!build_chain_anchors(topo, sc, rng)) return false;
    const int n = topo.n;
    int r3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    sc.add_anchor(r3 * n + c3);
    r3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    c3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    sc.add_anchor(r3 * n + c3);
    return sc.anchor_count >= 4;
}

inline int default_anchor_count(const GenericTopology& topo, PatternKind kind) {
    switch (kind) {
    case PatternKind::ExocetLike: return std::clamp(topo.n / 2, 4, 10);
    case PatternKind::LoopLike: return std::clamp(topo.n / 2 + 2, 6, 12);
    case PatternKind::ForcingLike: return std::clamp(topo.n / 2, 6, 12);
    case PatternKind::Chain: return std::clamp(topo.n / 3 + 3, 4, 10);
    default: return 0;
    }
}

inline void apply_anchor_masks(const GenericTopology& topo, PatternScratch& sc, PatternKind kind, std::mt19937_64& rng) {
    if (sc.anchor_count <= 0) return;
    const uint64_t full = pf_full_mask_for_n(topo.n);
    uint64_t mask_a = random_digit_mask(topo.n, 2, rng);
    uint64_t mask_b = random_digit_mask(topo.n, 2, rng);
    uint64_t mask_c = random_digit_mask(topo.n, 3, rng);
    
    if (kind == PatternKind::ExocetLike) {
        const uint64_t shared = random_digit_mask(topo.n, 3, rng);
        if (sc.anchor_count >= 1) sc.allowed_masks[static_cast<size_t>(sc.anchors[0])] = shared;
        if (sc.anchor_count >= 2) sc.allowed_masks[static_cast<size_t>(sc.anchors[1])] = shared;
        for (int i = 2; i < sc.anchor_count; ++i) {
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = mask_c;
        }
        return;
    }
    if (kind == PatternKind::ForcingLike) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const uint64_t m = (i & 1) ? (mask_a | mask_b) : (mask_b | mask_c);
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (m & full);
        }
        return;
    }
    if (kind == PatternKind::LoopLike) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const uint64_t m = (i % 3 == 0) ? mask_c : ((i & 1) ? mask_a : mask_b);
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (m & full);
        }
        return;
    }
    // Domyślnie Chain
    for (int i = 0; i < sc.anchor_count; ++i) {
        sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (i & 1) ? mask_a : mask_b;
    }
}

// Główna funkcja orkiestratora
inline bool build_seed(
    const GenericTopology& topo,
    const GenerateRunConfig& cfg,
    RequiredStrategy required_strategy,
    int difficulty_level_required,
    std::mt19937_64& rng,
    PatternSeedView& out) {
    
    out = {};
    if (!cfg.pattern_forcing_enabled) return false;

    int forcing_level = std::clamp(difficulty_level_required, 1, 8);
    if (cfg.max_pattern_depth > 0) {
        forcing_level = std::min(forcing_level, cfg.max_pattern_depth);
        forcing_level = std::clamp(forcing_level, 1, 8);
    }

    PatternKind kind = pick_kind(required_strategy, forcing_level);
    if (kind == PatternKind::None) return false;

    PatternScratch& sc = tls_pattern_scratch();
    sc.reset(topo);

    ExactPatternTemplatePlan exact_plan{};
    bool exact_matched = false;

    // Próba wstrzyknięcia precyzyjnego matematycznego szablonu dla P8
    switch (required_strategy) {
        case RequiredStrategy::Exocet:
        case RequiredStrategy::SeniorExocet:
            exact_matched = TemplateExocet::build(topo, rng, exact_plan);
            break;
        case RequiredStrategy::SKLoop:
            exact_matched = TemplateSKLoop::build(topo, rng, exact_plan);
            break;
        case RequiredStrategy::PatternOverlayMethod:
        case RequiredStrategy::ForcingChains:
        case RequiredStrategy::DynamicForcingChains:
        case RequiredStrategy::AIC:
        case RequiredStrategy::GroupedAIC:
        case RequiredStrategy::GroupedXCycle:
        case RequiredStrategy::ContinuousNiceLoop:
        case RequiredStrategy::XChain:
        case RequiredStrategy::XYChain:
            exact_matched = TemplateForcing::build(topo, rng, exact_plan);
            break;
        default:
            break;
    }
    
    // Fallback dla wysokich poziomów jeśli brak zdefiniowanej konkretnej strategii
    if (!exact_matched) {
        if (forcing_level >= 8) {
            exact_matched = TemplateForcing::build(topo, rng, exact_plan);
        } else if (forcing_level >= 7) {
            exact_matched = TemplateSKLoop::build(topo, rng, exact_plan);
        }
    }

    // Aplikacja masek z Exact Planu (jeśli się udał)
    if (exact_matched && exact_plan.valid && exact_plan.anchor_count > 0) {
        for (int i = 0; i < exact_plan.anchor_count; ++i) {
            const int idx = exact_plan.anchor_idx[static_cast<size_t>(i)];
            if (!sc.add_anchor(idx)) continue;

            uint64_t mask = exact_plan.anchor_masks[static_cast<size_t>(i)];
            if (mask == 0ULL) mask = pf_full_mask_for_n(topo.n);
            
            sc.allowed_masks[static_cast<size_t>(idx)] = mask;
        }

        // Chronione komórki zapobiegają ich usunięciu przez MCTS Digger
        if (cfg.pattern_forcing_lock_anchors) {
            for (int i = 0; i < sc.anchor_count; ++i) {
                const int idx = sc.anchors[static_cast<size_t>(i)];
                sc.protected_cells[static_cast<size_t>(idx)] = 1;
            }
        }
        
        if (sc.anchor_count > 0) {
            out.kind = (kind == PatternKind::None) ? PatternKind::ForcingLike : kind;
            out.seed_puzzle = &sc.seed_puzzle;
            out.allowed_masks = &sc.allowed_masks;
            out.protected_cells = &sc.protected_cells;
            out.anchor_count = sc.anchor_count;
            return true;
        }
    }

    // Fallback: luźne kotwice (jeśli Exact Plan zawiódł z powodu asymetrii lub P1-P6)
    bool ok = false;
    switch (kind) {
        case PatternKind::ExocetLike:
            ok = build_exocet_like_anchors(topo, sc, rng);
            break;
        case PatternKind::LoopLike:
            ok = build_loop_like_anchors(topo, sc, rng);
            break;
        case PatternKind::ForcingLike:
        case PatternKind::Chain:
            ok = build_chain_anchors(topo, sc, rng);
            break;
        default:
            break;
    }
    
    if (!ok || sc.anchor_count <= 0) return false;

    int anchor_target = cfg.pattern_forcing_anchor_count > 0
        ? cfg.pattern_forcing_anchor_count
        : default_anchor_count(topo, kind);
    anchor_target = std::clamp(anchor_target, sc.anchor_count, std::min(topo.nn, 32));

    // Dopełnianie luźnymi cyframi
    int guard = 0;
    while (sc.anchor_count < anchor_target && guard < topo.nn * 4) {
        ++guard;
        const int idx = static_cast<int>(rng() % static_cast<uint64_t>(topo.nn));
        sc.add_anchor(idx);
    }

    apply_anchor_masks(topo, sc, kind, rng);
    
    if (cfg.pattern_forcing_lock_anchors) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const int idx = sc.anchors[static_cast<size_t>(i)];
            sc.protected_cells[static_cast<size_t>(idx)] = 1;
        }
    }

    out.kind = kind;
    out.seed_puzzle = &sc.seed_puzzle;
    out.allowed_masks = &sc.allowed_masks;
    out.protected_cells = &sc.protected_cells;
    out.anchor_count = sc.anchor_count;
    return true;
}

} // namespace sudoku_hpc::pattern_forcing



==============================================================================
PLIK: Sources\generator\pattern_forcing\template_exocet.h
==============================================================================

// ============================================================================
// SUDOKU HPC - EXACT PATTERN FORCING
// Moduł: template_exocet.h
// Opis: Generuje rygorystyczny matematyczny szablon dla strategii Exocet
//       wsparcia asymetrycznych geometrii NxN. Zero-allocation.
// ============================================================================

#pragma once

#include <array>
#include <cstdint>
#include <random>

// Zależności do głównej struktury topologii (zakładając ścieżkę do core/board.h)
#include "../../core/board.h"

namespace sudoku_hpc::pattern_forcing {

// Współdzielona struktura planu wstrzykiwania (Zero-Allocation na stosie)
struct ExactPatternTemplatePlan {
    bool valid = false;
    int anchor_count = 0;
    std::array<int, 64> anchor_idx{};
    std::array<uint64_t, 64> anchor_masks{};

    // Szybkie dodawanie komórki "zakotwiczonej" z rygorystyczną maską
    inline bool add_anchor(int idx, uint64_t mask) {
        if (idx < 0 || anchor_count >= 64) return false;
        
        // Unikamy duplikatów
        for (int i = 0; i < anchor_count; ++i) {
            if (anchor_idx[i] == idx) return false;
        }
        
        anchor_idx[anchor_count] = idx;
        anchor_masks[anchor_count] = mask;
        ++anchor_count;
        return true;
    }
};

// Generowanie pełnej maski bitowej dla danego N
inline uint64_t pf_full_mask_for_n(int n) {
    return (n >= 64) ? ~0ULL : ((1ULL << n) - 1ULL);
}

class TemplateExocet {
public:
    // Wstrzykuje układ Base Cells i Target Cells charakterystyczny dla Exoceta.
    // Zmusza DLX solver do wybudowania reszty planszy "wokół" tego szablonu.
    static bool build(const GenericTopology& topo, std::mt19937_64& rng, ExactPatternTemplatePlan& plan) {
        plan = {}; // Reset struktury

        // Exocet matematycznie wymaga podziału pudełek na minimum 2x2.
        if (topo.box_rows <= 1 || topo.box_cols <= 1) {
            return false;
        }

        const int n = topo.n;
        const uint64_t full = pf_full_mask_for_n(n);

        // Losujemy blok, który posłuży jako dom dla komórek bazowych (Base Cells)
        const int box = static_cast<int>(rng() % static_cast<uint64_t>(n));

        // Zgodnie z architekturą: 0..N-1 (rzędy), N..2N-1 (kolumny), 2N..3N-1 (bloki)
        const int house = 2 * n + box;
        const int p0 = topo.house_offsets[static_cast<size_t>(house)];
        const int p1 = topo.house_offsets[static_cast<size_t>(house + 1)];

        // Oczekujemy minimum 4 komórek w bloku
        if (p1 - p0 < 4) return false;

        int b1 = -1;
        int b2 = -1;

        // Baza Exoceta (Base Cells) musi leżeć w różnych rzędach i kolumnach tego samego bloku
        for (int i = p0; i < p1 && b1 < 0; ++i) {
            b1 = topo.houses_flat[static_cast<size_t>(i)];
        }

        for (int i = p1 - 1; i >= p0 && b2 < 0; --i) {
            const int c = topo.houses_flat[static_cast<size_t>(i)];
            if (b1 == c) continue;
            
            // Weryfikacja asymetrii rzędów i kolumn
            if (topo.cell_row[static_cast<size_t>(c)] == topo.cell_row[static_cast<size_t>(b1)]) continue;
            if (topo.cell_col[static_cast<size_t>(c)] == topo.cell_col[static_cast<size_t>(b1)]) continue;
            b2 = c;
        }

        if (b1 < 0 || b2 < 0) return false;

        const int r1 = topo.cell_row[static_cast<size_t>(b1)];
        const int c1 = topo.cell_col[static_cast<size_t>(b1)];
        const int r2 = topo.cell_row[static_cast<size_t>(b2)];
        const int c2 = topo.cell_col[static_cast<size_t>(b2)];

        // Cele krzyżowe (Target Cells)
        const int t1 = r1 * n + c2;
        const int t2 = r2 * n + c1;

        // Wybieramy dwie cyfry dla komórek bazowych
        const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int d2 = d1;
        for (int g = 0; g < 64 && d2 == d1; ++g) {
            d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }

        // Maska komórek bazowych i docelowych (w docelowych dorzucamy "szum" by wzbudzić Exocet, a nie prostego Naked Pair)
        const uint64_t base_mask = (1ULL << d1) | (1ULL << d2);
        const uint64_t cross_mask = base_mask | (1ULL << static_cast<int>((d1 + 1) % n));

        // Wstrzykiwanie masek w plan (100% precyzyjne ograniczenie dla DLX Solvera)
        plan.add_anchor(b1, base_mask);
        plan.add_anchor(b2, base_mask);
        plan.add_anchor(t1, cross_mask & full);
        plan.add_anchor(t2, cross_mask & full);

        plan.valid = (plan.anchor_count >= 4);
        return plan.valid;
    }
};

} // namespace sudoku_hpc::pattern_forcing



==============================================================================
PLIK: Sources\generator\pattern_forcing\template_forcing.h
==============================================================================

// ============================================================================
// SUDOKU HPC - EXACT PATTERN FORCING
// Moduł: template_forcing.h
// Opis: Generuje matematyczny szablon dla Forcing Chains (łańcuchów wymuszających).
//       Tworzy zbiór zablokowanych komórek bivalue, inicjując siatkę powiązań.
//       Zero-allocation.
// ============================================================================

#pragma once

#include <array>
#include <cstdint>
#include <random>

// Zależności do topologii i struktury planu
#include "../../core/board.h"
#include "template_exocet.h" // Używa ExactPatternTemplatePlan i pf_full_mask_for_n

namespace sudoku_hpc::pattern_forcing {

class TemplateForcing {
public:
    // Wstrzykuje "zalążek" łańcucha XY/Forcing Chain.
    // Tworzy 4 komórki w układzie prostokąta przypisując im zazębiające się pary cyfr.
    static bool build(const GenericTopology& topo, std::mt19937_64& rng, ExactPatternTemplatePlan& plan) {
        plan = {}; // Reset struktury

        const int n = topo.n;
        // Wymaga minimum siatki 4x4
        if (n < 4) return false;

        const uint64_t full = pf_full_mask_for_n(n);

        // Losujemy 2 różne rzędy i 2 różne kolumny
        int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int r2 = r1;
        int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int c2 = c1;

        // Ograniczone próby zapobiegające nieskończonemu zawieszeniu
        for (int g = 0; g < 64 && r2 == r1; ++g) {
            r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }
        for (int g = 0; g < 64 && c2 == c1; ++g) {
            c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }

        if (r1 == r2 || c1 == c2) return false;

        // Definiujemy wierzchołki struktury wymuszającej:
        // p - pivot (komórka startowa)
        // a, b - ramiona łańcucha
        // t - target (cel łańcucha)
        const int p = r1 * n + c1;
        const int a = r1 * n + c2;
        const int b = r2 * n + c2;
        const int t = r2 * n + c1;

        // Wybieramy 3 różne cyfry, które utworzą łańcuch bivalue
        const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int d2 = d1;
        for (int g = 0; g < 64 && d2 == d1; ++g) {
            d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }
        int d3 = d2;
        for (int g = 0; g < 64 && (d3 == d1 || d3 == d2); ++g) {
            d3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }

        // Maski bivalue (zazębiające się) łączące cyfry w zamknięty łańcuch (graf)
        const uint64_t m12 = (1ULL << d1) | (1ULL << d2);
        const uint64_t m23 = (1ULL << d2) | (1ULL << d3);
        const uint64_t m13 = (1ULL << d1) | (1ULL << d3);

        // Wstrzykujemy kotwice:
        // Pivot(m12) -> widzi A(m23) i T(m12)
        // A(m23) -> widzi Pivot(m12) i B(m13)
        // B(m13) -> widzi A(m23) i T(m12)
        // W efekcie tworzy to zamknięty graf zależności wymuszających dla Solver'a i Digger'a.
        plan.add_anchor(p, m12 & full);
        plan.add_anchor(a, m23 & full);
        plan.add_anchor(b, m13 & full);
        plan.add_anchor(t, m12 & full);

        plan.valid = (plan.anchor_count >= 4);
        return plan.valid;
    }
};

} // namespace sudoku_hpc::pattern_forcing



==============================================================================
PLIK: Sources\generator\pattern_forcing\template_sk_loop.h
==============================================================================

// ============================================================================
// SUDOKU HPC - EXACT PATTERN FORCING
// Moduł: template_sk_loop.h
// Opis: Generuje rygorystyczny matematyczny szablon dla strategii SK-Loop.
//       Wymusza powstanie łańcucha cyklicznego w DLX. Zero-allocation.
// ============================================================================

#pragma once

#include <array>
#include <cstdint>
#include <random>

// Zależności do topologii i struktury planu
#include "../../core/board.h"
#include "template_exocet.h" // Używamy wspóldzielonego ExactPatternTemplatePlan i pf_full_mask_for_n

namespace sudoku_hpc::pattern_forcing {

class TemplateSKLoop {
public:
    // Wstrzykuje układ wierzchołków dla SK-Loop (cykliczny prostokąt).
    // Dwie komórki stają się twardymi bivalue, a dwie dostają cyfry "wyjściowe" (exit digits).
    static bool build(const GenericTopology& topo, std::mt19937_64& rng, ExactPatternTemplatePlan& plan) {
        plan = {}; // Reset struktury

        const int n = topo.n;
        // SK-Loop wymaga minimum siatki 4x4 (w praktyce sensowne dla N>=6)
        if (n < 4) return false;

        const uint64_t full = pf_full_mask_for_n(n);

        // Losujemy dwa różne rzędy i dwie różne kolumny
        int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int r2 = r1;
        int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int c2 = c1;

        // Ograniczona pętla zapobiegająca nieskończonemu zawieszeniu
        for (int g = 0; g < 64 && r2 == r1; ++g) {
            r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }
        for (int g = 0; g < 64 && c2 == c1; ++g) {
            c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }

        if (r1 == r2 || c1 == c2) return false;

        // Wyznaczamy 4 wierzchołki (prostokąt)
        const int a = r1 * n + c1;
        const int b = r1 * n + c2;
        const int c = r2 * n + c1;
        const int d = r2 * n + c2;

        // Wybieramy dwie cyfry rdzeniowe (core digits)
        const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        int d2 = d1;
        for (int g = 0; g < 64 && d2 == d1; ++g) {
            d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        }

        const uint64_t core = (1ULL << d1) | (1ULL << d2);

        // Dodajemy cyfry wyjściowe dla dwóch wierzchołków by uniknąć natychmiastowego Unique Rectangle (Deadly Pattern)
        // Ograniczamy do modulo n, żeby nie przekroczyć rozmiaru maski
        const uint64_t ex1 = core | (1ULL << static_cast<int>((d1 + 2) % n));
        const uint64_t ex2 = core | (1ULL << static_cast<int>((d2 + 3) % n));

        // Wstrzykujemy ograniczenia
        // B i C to twarde węzły bivalue. A i D to węzły wyjściowe pętli.
        plan.add_anchor(a, ex1 & full);
        plan.add_anchor(b, core);
        plan.add_anchor(c, core);
        plan.add_anchor(d, ex2 & full);

        plan.valid = (plan.anchor_count == 4);
        return plan.valid;
    }
};

} // namespace sudoku_hpc::pattern_forcing



==============================================================================
PLIK: Sources\generator\post_processing\quality_metrics.h
==============================================================================

// ============================================================================
// SUDOKU HPC - POST PROCESSING
// Moduł: quality_metrics.h
// Opis: Ocena estetyki siatki, rozkładu wskazówek (clues) oraz entropii.
//       Zawiera optymalizacje LUT (Look-Up Table) dla obliczeń logarytmów.
//       Zero-allocation w gorącej ścieżce wywołań.
// ============================================================================

#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <vector>

#include "../../core/board.h"
#include "../../config/run_config.h"

namespace sudoku_hpc::post_processing {

struct QualityMetrics {
    int clues = 0;
    int row_min = 0;
    int row_max = 0;
    int col_min = 0;
    int col_max = 0;
    int box_min = 0;
    int box_max = 0;
    int digit_min = 0;
    int digit_max = 0;
    
    double normalized_entropy = 0.0;
    double entropy_threshold = 0.0;
    
    bool symmetry_ok = true;
    bool distribution_balance_ok = true;
};

// ============================================================================
// BŁYSKAWICZNA ENTROPIA (LUT)
// Tworzymy Look-Up Table (LUT) przy starcie dla funkcji x * log2(x).
// W siatce do 64x64 pojedyncza cyfra może wystąpić max 64 razy, więc rozmiar 82 
// zostawia bezpieczny bufor dla standardowych i rozszerzonych plansz.
// ============================================================================
inline const std::array<double, 82>& get_c_log2_c_lut() {
    static const std::array<double, 82> lut =[]() {
        std::array<double, 82> arr{};
        arr[0] = 0.0;
        for (int i = 1; i <= 81; ++i) {
            arr[static_cast<size_t>(i)] = static_cast<double>(i) * std::log2(static_cast<double>(i));
        }
        return arr;
    }();
    return lut;
}

inline double entropy_threshold_for_n(int n) {
    if (n <= 12) return 0.40;
    if (n <= 24) return 0.55;
    return 0.65;
}

// Sprawdza czy plansza posiada symetrię środkową (180 stopni)
inline bool check_center_symmetry_givens(const std::vector<uint16_t>& puzzle, const GenericTopology& topo) {
    const auto& sym = topo.cell_center_sym;
    const uint16_t* const puzzle_ptr = puzzle.data();
    for (int idx = 0; idx < topo.nn; ++idx) {
        const int sym_idx = sym[static_cast<size_t>(idx)];
        // Sprawdzamy tylko do połowy, by nie powtarzać pracy
        if (idx > sym_idx) continue;
        
        const bool given_a = puzzle_ptr[static_cast<size_t>(idx)] != 0;
        const bool given_b = puzzle_ptr[static_cast<size_t>(sym_idx)] != 0;
        if (given_a != given_b) {
            return false;
        }
    }
    return true;
}

// Bufor wątkowy dla statystyk, zapobiegający alokacjom std::vector w ewaluacji
struct QualityScratch {
    int prepared_n = 0;
    std::vector<int> row_counts;
    std::vector<int> col_counts;
    std::vector<int> box_counts;
    std::vector<int> digit_counts;

    void ensure(int n) {
        if (prepared_n != n) {
            row_counts.assign(static_cast<size_t>(n), 0);
            col_counts.assign(static_cast<size_t>(n), 0);
            box_counts.assign(static_cast<size_t>(n), 0);
            digit_counts.assign(static_cast<size_t>(n), 0);
            prepared_n = n;
        } else {
            std::fill(row_counts.begin(), row_counts.end(), 0);
            std::fill(col_counts.begin(), col_counts.end(), 0);
            std::fill(box_counts.begin(), box_counts.end(), 0);
            std::fill(digit_counts.begin(), digit_counts.end(), 0);
        }
    }
};

inline QualityScratch& tls_quality_scratch() {
    thread_local QualityScratch s{};
    return s;
}

inline QualityMetrics evaluate_quality_metrics(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    const GenerateRunConfig& cfg) {
    
    QualityMetrics m{};
    QualityScratch& scratch = tls_quality_scratch();
    scratch.ensure(topo.n);

    int* const row_ptr = scratch.row_counts.data();
    int* const col_ptr = scratch.col_counts.data();
    int* const box_ptr = scratch.box_counts.data();
    int* const digit_ptr = scratch.digit_counts.data();
    const uint32_t* const packed = topo.cell_rcb_packed.data();
    const uint16_t* const puzzle_ptr = puzzle.data();

    // 1. Zbieranie statystyk
    for (int idx = 0; idx < topo.nn; ++idx) {
        const int v = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
        if (v <= 0) continue;
        
        ++m.clues;
        const uint32_t p = packed[static_cast<size_t>(idx)];
        // Dekodowanie z 32-bitowego wektora
        const int r = static_cast<int>(p & 63U);
        const int c = static_cast<int>((p >> 6U) & 63U);
        const int b = static_cast<int>((p >> 12U) & 63U);
        
        ++row_ptr[static_cast<size_t>(r)];
        ++col_ptr[static_cast<size_t>(c)];
        ++box_ptr[static_cast<size_t>(b)];
        if (v <= topo.n) {
            ++digit_ptr[static_cast<size_t>(v - 1)];
        }
    }

    auto get_minmax = [n = topo.n](const std::vector<int>& counts) -> std::pair<int, int> {
        if (n <= 0) return {0, 0};
        int mn = counts[0];
        int mx = counts[0];
        for (int i = 1; i < n; ++i) {
            const int x = counts[static_cast<size_t>(i)];
            if (x < mn) mn = x;
            if (x > mx) mx = x;
        }
        return {mn, mx};
    };

    // 2. Analiza dystrybucji Min/Max
    const auto [row_min, row_max] = get_minmax(scratch.row_counts);
    const auto [col_min, col_max] = get_minmax(scratch.col_counts);
    const auto[box_min, box_max] = get_minmax(scratch.box_counts);
    const auto[digit_min, digit_max] = get_minmax(scratch.digit_counts);
    
    m.row_min = row_min; m.row_max = row_max;
    m.col_min = col_min; m.col_max = col_max;
    m.box_min = box_min; m.box_max = box_max;
    m.digit_min = digit_min; m.digit_max = digit_max;

    // 3. Obliczanie znormalizowanej Entropii Shannon'a
    if (m.clues > 0) {
        double sum_c_log2_c = 0.0;
        const auto& lut = get_c_log2_c_lut();
        for (int i = 0; i < topo.n; ++i) {
            const int c = digit_ptr[static_cast<size_t>(i)];
            // Chroni przed wyjściem poza LUT w skrajnych nieobsługiwanych siatkach
            if (c > 0 && c <= 81) { 
                sum_c_log2_c += lut[static_cast<size_t>(c)];
            }
        }
        const double T = static_cast<double>(m.clues);
        const double entropy = std::log2(T) - (sum_c_log2_c / T);
        
        const double max_entropy = std::log2(static_cast<double>(topo.n));
        m.normalized_entropy = max_entropy > 0.0 ? (entropy / max_entropy) : 0.0;
    }
    
    m.entropy_threshold = entropy_threshold_for_n(topo.n);
    m.symmetry_ok = (!cfg.symmetry_center) || check_center_symmetry_givens(puzzle, topo);

    // 4. Tolerancja dystrybucji
    const double ideal = topo.n > 0 ? static_cast<double>(m.clues) / static_cast<double>(topo.n) : 0.0;
    const double allowed_dev = std::max(2.0, ideal * 0.80);
    
    auto within_dev = [ideal, allowed_dev](int x) {
        return std::abs(static_cast<double>(x) - ideal) <= (allowed_dev + 1.0);
    };
    
    m.distribution_balance_ok = 
        within_dev(m.row_min) && within_dev(m.row_max) &&
        within_dev(m.col_min) && within_dev(m.col_max) &&
        within_dev(m.box_min) && within_dev(m.box_max) &&
        within_dev(m.digit_min) && within_dev(m.digit_max);

    return m;
}

// Interfejs umowy jakościowej - czy grid spełnia wymagania run_config
struct QualityContract {
    bool is_unique = true;
    bool logic_replay_ok = true;
    bool clue_range_ok = true;
    bool symmetry_ok = true;
    bool givens_entropy_ok = true;
    bool distribution_balance_ok = true;
    std::string generation_mode;
};

inline bool quality_contract_passed(const QualityContract& c, const GenerateRunConfig& cfg) {
    if (!cfg.enable_quality_contract) return true;
    if (!c.is_unique) return false;
    if (!c.clue_range_ok || !c.symmetry_ok) return false;
    if (!c.givens_entropy_ok) return false;
    if (cfg.enable_distribution_filter && !c.distribution_balance_ok) return false;
    if (cfg.enable_replay_validation && !c.logic_replay_ok) return false;
    return true;
}

} // namespace sudoku_hpc::post_processing



==============================================================================
PLIK: Sources\generator\post_processing\replay_validator.h
==============================================================================

// ============================================================================
// SUDOKU HPC - POST PROCESSING
// Moduł: replay_validator.h
// Opis: Walidacja rozwiązania po procesie "kopania" (Replay Validation)
//       oraz sprzętowo optymalizowane (64-bitowe) hashowanie FNV-1a.
// ============================================================================

#pragma once

#include <cstdint>
#include <vector>

#include "../../core/board.h"
#include "../../logic/logic_result.h"
#include "../../logic/sudoku_logic_engine.h"

namespace sudoku_hpc::post_processing {

struct ReplayValidationResult {
    bool ok = false;
    bool solved = false;
    uint64_t puzzle_hash = 0;
    uint64_t expected_solution_hash = 0;
    uint64_t replay_solution_hash = 0;
    uint64_t trace_hash = 0;
};

// ============================================================================
// OPTYMALIZACJA WEKTORYZACJI HASHOWANIA
// Procesor trawi pamięć paczkami 64-bitowymi zamiast bajtami.
// Algorytm bazuje na wariancie FNV-1a zaadaptowanym do bloków 8-bajtowych.
// ============================================================================
inline uint64_t fnv1a64_bytes(const void* data, size_t len, uint64_t seed = 1469598103934665603ULL) {
    uint64_t h = seed;
    const size_t blocks = len / 8;
    const size_t remainder = len % 8;
    const uint64_t* ptr64 = static_cast<const uint64_t*>(data);
    
    // Pętla odwijana i pipelinowana przez kompilator dla 64-bitowych słów
    for (size_t i = 0; i < blocks; ++i) {
        h ^= ptr64[i];
        h *= 1099511628211ULL;
    }
    
    // Ewentualna reszta (max 7 bajtów) - cast na standardowe przetworzenie
    if (remainder > 0) {
        const uint8_t* ptr8 = reinterpret_cast<const uint8_t*>(ptr64 + blocks);
        for (size_t i = 0; i < remainder; ++i) {
            h ^= static_cast<uint64_t>(ptr8[i]);
            h *= 1099511628211ULL;
        }
    }
    return h;
}

// Hashowanie zoptymalizowane dla wektorów cyfr Sudoku (uint16_t)
inline uint64_t hash_u16_vector(const std::vector<uint16_t>& data, uint64_t seed = 1469598103934665603ULL) {
    if (data.empty()) return seed;
    return fnv1a64_bytes(data.data(), data.size() * sizeof(uint16_t), seed);
}

// Funkcja wykonująca pełne przejście kontrolne z weryfikacją poprawności
// oraz budująca "Trace Hash" ze statystyk użytych strategii.
inline ReplayValidationResult run_replay_validation(
    const std::vector<uint16_t>& puzzle,
    const std::vector<uint16_t>& expected_solution,
    const GenericTopology& topo,
    const logic::GenericLogicCertify& logic) {
    
    ReplayValidationResult out{};
    
    // 1. Hash wejścia i wzorca
    out.puzzle_hash = hash_u16_vector(puzzle);
    out.expected_solution_hash = hash_u16_vector(expected_solution);
    
    // 2. Symulacja logiczna na "czysto" (Replay)
    const logic::GenericLogicCertifyResult replay = logic.certify(puzzle, topo, nullptr, true);
    out.solved = replay.solved;
    out.replay_solution_hash = hash_u16_vector(replay.solved_grid);

    // 3. Budowa Trace Hash z poszczególnych kroków silnika (szybkie flush block memory)
    uint64_t trace_seed = 1469598103934665603ULL;
    trace_seed = fnv1a64_bytes(&replay.steps, sizeof(replay.steps), trace_seed);
    
    // Unikanie iteracji po arrayu za pomocą bezpośredniego zrzutu pamięci struktury
    trace_seed = fnv1a64_bytes(
        replay.strategy_stats.data(), 
        replay.strategy_stats.size() * sizeof(logic::StrategyStats), 
        trace_seed
    );
    
    out.trace_hash = trace_seed;
    
    // 4. Werdykt
    out.ok = replay.solved && (replay.solved_grid == expected_solution);
    
    return out;
}

} // namespace sudoku_hpc::post_processing



==============================================================================
PLIK: Sources\generator\post_processing\vip_scoring.h
==============================================================================

// ============================================================================
// SUDOKU HPC - POST PROCESSING
// Moduł: vip_scoring.h
// Opis: Algorytmy heurystyczne oceniające jakość i trudność układu.
//       Kalkulacja VIP Score i przypisywanie rang (Bronze-Platinum).
// ============================================================================

#pragma once

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <string>
#include <unordered_map>

#include "../../config/run_config.h"

namespace sudoku_hpc::post_processing {

inline double clamp01(double v) { 
    return std::clamp(v, 0.0, 1.0); 
}

// Szybkie formatowanie liczby zmiennoprzecinkowej bez globalnych alokacji (dla logów/json)
inline std::string format_fixed_vip(double value, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << value;
    return oss.str();
}

inline std::string normalize_vip_grade_target(const std::string& grade_raw) {
    std::string key;
    key.reserve(grade_raw.size());
    for (unsigned char ch : grade_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "bronze") return "bronze";
    if (key == "silver") return "silver";
    if (key == "platinum") return "platinum";
    return "gold"; // Default
}

inline std::string normalize_vip_score_profile(const std::string& profile_raw) {
    std::string key;
    key.reserve(profile_raw.size());
    for (unsigned char ch : profile_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "strict") return "strict";
    if (key == "ultra") return "ultra";
    return "standard";
}

inline std::string vip_grade_from_score(double score) {
    if (score >= 700.0) return "platinum";
    if (score >= 500.0) return "gold";
    if (score >= 300.0) return "silver";
    if (score > 0.0) return "bronze";
    return "none";
}

inline int vip_grade_rank(const std::string& grade) {
    const std::string g = normalize_vip_grade_target(grade);
    if (g == "bronze") return 1;
    if (g == "silver") return 2;
    if (g == "gold") return 3;
    if (g == "platinum") return 4;
    return 0;
}

struct VipScoreBreakdown {
    double logic_depth_norm = 0.0;
    double hidden_norm = 0.0;
    double naked_norm = 0.0;
    double uniqueness_norm = 0.0;
    double branching_norm = 0.0;
    double level_norm = 0.0;
    double weighted = 0.0;
    double asym_multiplier = 1.0;
    double final_score = 0.0;
    std::string profile = "standard";

    std::string to_json() const {
        std::ostringstream out;
        out << "{\"profile\":\"" << profile << "\","
            << "\"logic_depth_norm\":" << format_fixed_vip(logic_depth_norm, 6) << ","
            << "\"hidden_norm\":" << format_fixed_vip(hidden_norm, 6) << ","
            << "\"naked_norm\":" << format_fixed_vip(naked_norm, 6) << ","
            << "\"uniqueness_norm\":" << format_fixed_vip(uniqueness_norm, 6) << ","
            << "\"branching_norm\":" << format_fixed_vip(branching_norm, 6) << ","
            << "\"level_norm\":" << format_fixed_vip(level_norm, 6) << ","
            << "\"weighted\":" << format_fixed_vip(weighted, 6) << ","
            << "\"asym_multiplier\":" << format_fixed_vip(asym_multiplier, 6) << ","
            << "\"final_score\":" << format_fixed_vip(final_score, 6) << "}";
        return out.str();
    }
};

inline std::string geometry_key_for_grade_target(int box_rows, int box_cols) {
    return std::to_string(box_rows) + "x" + std::to_string(box_cols);
}

inline std::unordered_map<std::string, std::string> load_vip_grade_target_overrides(const std::string& path_raw) {
    std::unordered_map<std::string, std::string> out_map;
    if (path_raw.empty()) return out_map;
    
    std::ifstream in(path_raw);
    if (!in) return out_map;
    
    std::string line;
    while (std::getline(in, line)) {
        if (line.empty() || line[0] == '#') continue;
        std::replace(line.begin(), line.end(), ';', ',');
        std::istringstream iss(line);
        std::string n_s, br_s, bc_s, grade_s;
        
        if (std::getline(iss, n_s, ',') && std::getline(iss, br_s, ',') && 
            std::getline(iss, bc_s, ',') && std::getline(iss, grade_s, ',')) {
            try {
                out_map[geometry_key_for_grade_target(std::stoi(br_s), std::stoi(bc_s))] = normalize_vip_grade_target(grade_s);
            } catch (...) {}
        }
    }
    return out_map;
}

inline std::string resolve_vip_grade_target_for_geometry(const GenerateRunConfig& cfg) {
    const std::string default_grade = normalize_vip_grade_target(cfg.vip_grade_target);
    if (cfg.vip_min_grade_by_geometry_path.empty()) return default_grade;
    
    const auto overrides = load_vip_grade_target_overrides(cfg.vip_min_grade_by_geometry_path);
    const auto it = overrides.find(geometry_key_for_grade_target(cfg.box_rows, cfg.box_cols));
    
    return it != overrides.end() ? normalize_vip_grade_target(it->second) : default_grade;
}

// Analiza heurystyczna uwzględniająca statystyki solvera oraz specyfikę geometrii
inline VipScoreBreakdown compute_vip_score_breakdown(
    const GenerateRunResult& result, 
    const GenerateRunConfig& cfg, 
    double asymmetry_ratio) {
    
    VipScoreBreakdown b{};
    b.profile = normalize_vip_score_profile(cfg.vip_score_profile);
    
    const int n = std::max(1, cfg.box_rows) * std::max(1, cfg.box_cols);
    const double attempts = static_cast<double>(std::max<uint64_t>(1, result.attempts));
    
    const double logic_steps_per_attempt = static_cast<double>(result.logic_steps_total) / attempts;
    const double hidden_rate = static_cast<double>(result.strategy_hidden_hit) / attempts;
    const double naked_rate = static_cast<double>(result.strategy_naked_hit) / attempts;
    const double uniqueness_nodes_per_attempt = static_cast<double>(result.uniqueness_nodes) / attempts;
    const double reject_branching_rate = static_cast<double>(result.reject_logic + result.reject_strategy + result.reject_uniqueness) / attempts;
    
    const double asymmetry_norm = clamp01((asymmetry_ratio - 1.0) / 3.0);

    // Normalizacja parametrów względem szacowanych progów trudności dla rozmiaru N
    b.logic_depth_norm = clamp01(logic_steps_per_attempt / std::max(4.0, static_cast<double>(n) * 0.35));
    b.hidden_norm      = clamp01(hidden_rate / 0.60);
    b.naked_norm       = clamp01(naked_rate / 0.80);
    b.uniqueness_norm  = clamp01(uniqueness_nodes_per_attempt / std::max(500.0, static_cast<double>(n * n) * 0.90));
    b.branching_norm   = clamp01(reject_branching_rate / 0.85);
    b.level_norm       = clamp01(static_cast<double>(std::clamp(cfg.difficulty_level_required, 1, 9) - 1) / 8.0);

    // Profil wag
    double w_logic = 0.30, w_hidden = 0.22, w_naked = 0.12, w_uniq = 0.20, w_branch = 0.10, w_level = 0.06;
    
    if (b.profile == "strict") {
        w_logic = 0.34; w_hidden = 0.24; w_naked = 0.08; w_uniq = 0.22; w_branch = 0.08; w_level = 0.04;
    } else if (b.profile == "ultra") {
        w_logic = 0.36; w_hidden = 0.25; w_naked = 0.06; w_uniq = 0.23; w_branch = 0.07; w_level = 0.03;
    }
    
    b.weighted = w_logic * b.logic_depth_norm + 
                 w_hidden * b.hidden_norm + 
                 w_naked * b.naked_norm +
                 w_uniq * b.uniqueness_norm + 
                 w_branch * b.branching_norm + 
                 w_level * b.level_norm;
                 
    // Premia za trudność wniesioną przez geometrię asymetryczną
    b.asym_multiplier = 1.0 + 0.15 * asymmetry_norm;
    if (b.profile == "ultra") {
        b.asym_multiplier += 0.05 * asymmetry_norm;
    }
    
    b.final_score = std::clamp(b.weighted * b.asym_multiplier * 1000.0, 0.0, 1000.0);
    return b;
}

inline double compute_vip_score(const GenerateRunResult& result, const GenerateRunConfig& cfg, double asymmetry_ratio) {
    return compute_vip_score_breakdown(result, cfg, asymmetry_ratio).final_score;
}

inline bool vip_contract_passed(double score, const std::string& target_grade) {
    return vip_grade_rank(vip_grade_from_score(score)) >= vip_grade_rank(target_grade);
}

} // namespace sudoku_hpc::post_processing



==============================================================================
PLIK: Sources\generator\runtime_runner.h
==============================================================================

﻿#pragma once

#include <atomic>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <functional>
#include <mutex>
#include <random>
#include <string>
#include <thread>
#include <vector>

#include "../config/run_config.h"
#include "../core/geometry.h"
#include "../monitor.h"
#include "../utils/logging.h"
#include "../generator/generator_facade.h"
#include "../generator/post_processing/vip_scoring.h"

namespace sudoku_hpc {

inline void accumulate_reject_reason(GenerateRunResult& r, RejectReason reason, bool timed_out) {
    if (timed_out) {
        ++r.reject_uniqueness_budget;
    }
    switch (reason) {
        case RejectReason::Prefilter: ++r.reject_prefilter; break;
        case RejectReason::Logic: ++r.reject_logic; break;
        case RejectReason::Uniqueness: ++r.reject_uniqueness; break;
        case RejectReason::Strategy: ++r.reject_strategy; break;
        case RejectReason::Replay: ++r.reject_replay; break;
        case RejectReason::DistributionBias: ++r.reject_distribution_bias; break;
        case RejectReason::UniquenessBudget: ++r.reject_uniqueness_budget; break;
        case RejectReason::None: break;
    }
}

inline GenerateRunResult run_generic_sudoku(
    const GenerateRunConfig& cfg,
    ConsoleStatsMonitor* monitor = nullptr,
    std::atomic<bool>* cancel_flag = nullptr,
    std::atomic<bool>* pause_flag = nullptr,
    std::function<void(uint64_t, uint64_t)> on_progress = nullptr,
    std::function<void(const std::string&)> on_log = nullptr) {

    using namespace std::chrono;

    GenerateRunResult result{};
    result.cpu_backend_selected = cfg.cpu_backend;

    GenericTopology topo;
    std::string topo_err;
    if (!build_generic_topology(cfg.box_rows, cfg.box_cols, topo, &topo_err)) {
        log_error("runner", "invalid geometry: " + topo_err);
        if (on_log) on_log("invalid geometry: " + topo_err);
        result.reject_logic = 1;
        result.rejected = 1;
        return result;
    }

    const int n = topo.n;
    const int nn = topo.nn;
    GenerateRunConfig run_cfg = cfg;

    if (run_cfg.min_clues <= 0 || run_cfg.max_clues <= 0 || run_cfg.max_clues < run_cfg.min_clues) {
        const ClueRange auto_range = resolve_auto_clue_range(run_cfg.box_rows, run_cfg.box_cols, run_cfg.difficulty_level_required, run_cfg.required_strategy);
        if (run_cfg.min_clues <= 0) run_cfg.min_clues = auto_range.min_clues;
        if (run_cfg.max_clues <= 0) run_cfg.max_clues = auto_range.max_clues;
        if (run_cfg.max_clues < run_cfg.min_clues) run_cfg.max_clues = run_cfg.min_clues;
    }
    run_cfg.min_clues = std::clamp(run_cfg.min_clues, 0, nn);
    run_cfg.max_clues = std::clamp(run_cfg.max_clues, run_cfg.min_clues, nn);

    if (run_cfg.fast_test_mode) {
        // Fast smoke profile: bounded runtime and relaxed heavy verification stages.
        run_cfg.enable_quality_contract = false;
        run_cfg.enable_distribution_filter = false;
        run_cfg.enable_replay_validation = false;
        run_cfg.require_unique = false;
        run_cfg.strict_logical = false;
        run_cfg.strict_canonical_strategies = false;
        run_cfg.allow_proxy_advanced = true;

        if (run_cfg.max_attempts == 0) {
            run_cfg.max_attempts = std::max<uint64_t>(32ULL, run_cfg.target_puzzles * 32ULL);
        }
        if (run_cfg.max_total_time_s == 0) {
            run_cfg.max_total_time_s = 20ULL;
        }
        if (run_cfg.attempt_time_budget_s <= 0.0) {
            run_cfg.attempt_time_budget_s = (run_cfg.difficulty_level_required >= 7) ? 1.2 : 0.7;
        }
        if (run_cfg.attempt_node_budget == 0) {
            const uint64_t suggested = suggest_attempt_node_budget(
                run_cfg.box_rows,
                run_cfg.box_cols,
                std::max(1, run_cfg.difficulty_level_required));
            run_cfg.attempt_node_budget = std::max<uint64_t>(20'000ULL, suggested / 8ULL);
        }
    }

    if (run_cfg.attempt_time_budget_s <= 0.0) {
        run_cfg.attempt_time_budget_s = 0.0;
    }

    const int hw = std::max(1u, std::thread::hardware_concurrency());
    const int worker_count = std::max(1, run_cfg.threads <= 0 ? hw : run_cfg.threads);

    std::filesystem::create_directories(run_cfg.output_folder);
    const std::filesystem::path output_path = std::filesystem::path(run_cfg.output_folder) / run_cfg.output_file;
    std::ofstream batch_out(output_path, std::ios::out | std::ios::app);
    if (!batch_out) {
        log_error("runner", "cannot open output file: " + output_path.string());
        if (on_log) on_log("cannot open output file: " + output_path.string());
        result.reject_logic = 1;
        result.rejected = 1;
        return result;
    }

    if (monitor != nullptr) {
        monitor->set_target(run_cfg.target_puzzles);
        monitor->set_active_workers(worker_count);
        monitor->set_grid_info(run_cfg.box_rows, run_cfg.box_cols, run_cfg.difficulty_level_required);
        monitor->set_background_status("runtime initialized");
    }

    std::mutex write_mu;
    std::mutex result_mu;

    std::atomic<uint64_t> accepted{0};
    std::atomic<uint64_t> written{0};
    std::atomic<uint64_t> attempts{0};

    std::atomic<uint64_t> uniqueness_calls{0};
    std::atomic<uint64_t> uniqueness_nodes{0};
    std::atomic<uint64_t> uniqueness_elapsed_ns{0};
    std::atomic<uint64_t> logic_steps_total{0};
    std::atomic<uint64_t> strategy_naked_use{0};
    std::atomic<uint64_t> strategy_naked_hit{0};
    std::atomic<uint64_t> strategy_hidden_use{0};
    std::atomic<uint64_t> strategy_hidden_hit{0};
    std::atomic<uint64_t> kernel_elapsed_ns{0};
    std::atomic<uint64_t> kernel_calls{0};

    const auto t0 = steady_clock::now();

    auto is_cancelled = [&]() -> bool {
        return (cancel_flag != nullptr) && cancel_flag->load(std::memory_order_relaxed);
    };

    auto is_paused = [&]() -> bool {
        return (pause_flag != nullptr) && pause_flag->load(std::memory_order_relaxed);
    };

    std::vector<std::thread> workers;
    workers.reserve(static_cast<size_t>(worker_count));

    for (int worker_idx = 0; worker_idx < worker_count; ++worker_idx) {
        workers.emplace_back([&, worker_idx]() {
            const uint64_t base_seed = (run_cfg.seed == 0)
                ? static_cast<uint64_t>(std::chrono::high_resolution_clock::now().time_since_epoch().count())
                : run_cfg.seed;
            std::mt19937_64 rng(base_seed ^ (0x9E3779B97F4A7C15ULL + static_cast<uint64_t>(worker_idx) * 0x100000001B3ULL));

            core_engines::GenericSolvedKernel solved(
                core_engines::GenericSolvedKernel::backend_from_string(run_cfg.cpu_backend));
            core_engines::GenericQuickPrefilter prefilter;
            logic::GenericLogicCertify logic;
            core_engines::GenericUniquenessCounter uniq;

            uint64_t local_attempts = 0;
            uint64_t local_written = 0;

            while (true) {
                if (is_cancelled()) {
                    break;
                }

                if (run_cfg.max_total_time_s > 0) {
                    const auto elapsed = duration_cast<seconds>(steady_clock::now() - t0).count();
                    if (elapsed >= static_cast<long long>(run_cfg.max_total_time_s)) {
                        break;
                    }
                }

                while (is_paused() && !is_cancelled()) {
                    std::this_thread::sleep_for(milliseconds(20));
                }

                const uint64_t current_accepted = accepted.load(std::memory_order_relaxed);
                if (current_accepted >= run_cfg.target_puzzles) {
                    break;
                }

                if (run_cfg.max_attempts > 0) {
                    const uint64_t current_attempts = attempts.load(std::memory_order_relaxed);
                    if (current_attempts >= run_cfg.max_attempts) {
                        break;
                    }
                }

                ++local_attempts;
                attempts.fetch_add(1, std::memory_order_relaxed);

                generator::GenericPuzzleCandidate candidate;
                RejectReason reason = RejectReason::None;
                RequiredStrategyAttemptInfo strategy_info{};
                generator::AttemptPerfStats perf{};
                bool timed_out = false;

                const bool ok = generator::generate_one_generic(
                    run_cfg,
                    topo,
                    rng,
                    candidate,
                    reason,
                    strategy_info,
                    solved,
                    prefilter,
                    logic,
                    uniq,
                    nullptr,
                    &timed_out,
                    cancel_flag,
                    pause_flag,
                    nullptr,
                    nullptr,
                    nullptr,
                    &perf);

                kernel_elapsed_ns.fetch_add(perf.solved_elapsed_ns + perf.dig_elapsed_ns, std::memory_order_relaxed);
                kernel_calls.fetch_add(1, std::memory_order_relaxed);

                uniqueness_calls.fetch_add(perf.uniqueness_calls, std::memory_order_relaxed);
                uniqueness_nodes.fetch_add(perf.uniqueness_nodes, std::memory_order_relaxed);
                uniqueness_elapsed_ns.fetch_add(perf.uniqueness_elapsed_ns, std::memory_order_relaxed);
                logic_steps_total.fetch_add(perf.logic_steps, std::memory_order_relaxed);
                strategy_naked_use.fetch_add(perf.strategy_naked_use, std::memory_order_relaxed);
                strategy_naked_hit.fetch_add(perf.strategy_naked_hit, std::memory_order_relaxed);
                strategy_hidden_use.fetch_add(perf.strategy_hidden_use, std::memory_order_relaxed);
                strategy_hidden_hit.fetch_add(perf.strategy_hidden_hit, std::memory_order_relaxed);

                if (ok) {
                    uint64_t accepted_idx = 0;
                    bool slot_acquired = false;
                    while (true) {
                        uint64_t cur = accepted.load(std::memory_order_relaxed);
                        if (cur >= run_cfg.target_puzzles) {
                            slot_acquired = false;
                            break;
                        }
                        if (accepted.compare_exchange_weak(cur, cur + 1, std::memory_order_relaxed, std::memory_order_relaxed)) {
                            accepted_idx = cur + 1;
                            slot_acquired = true;
                            break;
                        }
                    }
                    if (!slot_acquired) {
                        continue;
                    }

                    const std::string line = generator::serialize_line_generic(
                        (base_seed + local_attempts),
                        run_cfg,
                        candidate,
                        topo.nn);

                    {
                        std::lock_guard<std::mutex> lock(write_mu);
                        batch_out << line << '\n';
                        if (run_cfg.write_individual_files) {
                            const std::filesystem::path file_path =
                                std::filesystem::path(run_cfg.output_folder) /
                                ("sudoku_" + std::to_string(accepted_idx) + ".txt");
                            std::ofstream one(file_path, std::ios::out | std::ios::trunc);
                            if (one) {
                                one << line << '\n';
                            }
                        }
                    }

                    ++local_written;
                    written.fetch_add(1, std::memory_order_relaxed);

                    if (on_progress) {
                        on_progress(accepted_idx, run_cfg.target_puzzles);
                    }

                    if (on_log && (accepted_idx % 10ULL == 0ULL || accepted_idx == run_cfg.target_puzzles)) {
                        on_log("accepted=" + std::to_string(accepted_idx) + "/" + std::to_string(run_cfg.target_puzzles));
                    }
                } else {
                    std::lock_guard<std::mutex> lock(result_mu);
                    ++result.rejected;
                    accumulate_reject_reason(result, reason, timed_out);
                }

                if (monitor != nullptr && ((local_attempts % 16ULL) == 0ULL || local_written > 0)) {
                    monitor->set_attempts(attempts.load(std::memory_order_relaxed));
                    monitor->set_accepted(accepted.load(std::memory_order_relaxed));
                    monitor->set_written(written.load(std::memory_order_relaxed));
                    monitor->set_rejected(result.rejected);

                    WorkerRow row{};
                    row.worker = "worker_" + std::to_string(worker_idx);
                    row.clues = candidate.clues;
                    row.seed = base_seed;
                    row.applied = local_attempts;
                    row.status = is_paused() ? "paused" : "running";
                    row.reseed_interval_s = run_cfg.reseed_interval_s;
                    row.attempt_time_budget_s = run_cfg.attempt_time_budget_s;
                    row.attempt_node_budget = run_cfg.attempt_node_budget;
                    row.stage_solved_ms = static_cast<double>(perf.solved_elapsed_ns) / 1e6;
                    row.stage_dig_ms = static_cast<double>(perf.dig_elapsed_ns) / 1e6;
                    row.stage_prefilter_ms = static_cast<double>(perf.prefilter_elapsed_ns) / 1e6;
                    row.stage_logic_ms = static_cast<double>(perf.logic_elapsed_ns) / 1e6;
                    row.stage_uniqueness_ms = static_cast<double>(perf.uniqueness_elapsed_ns) / 1e6;
                    monitor->set_worker_row(static_cast<size_t>(worker_idx), row);
                }
            }

            if (monitor != nullptr) {
                WorkerRow row{};
                row.worker = "worker_" + std::to_string(worker_idx);
                row.applied = local_attempts;
                row.status = "done";
                monitor->set_worker_row(static_cast<size_t>(worker_idx), row);
            }
        });
    }

    for (auto& t : workers) {
        if (t.joinable()) {
            t.join();
        }
    }

    result.accepted = accepted.load(std::memory_order_relaxed);
    result.written = written.load(std::memory_order_relaxed);
    result.attempts = attempts.load(std::memory_order_relaxed);

    result.uniqueness_calls = uniqueness_calls.load(std::memory_order_relaxed);
    result.uniqueness_nodes = uniqueness_nodes.load(std::memory_order_relaxed);
    result.uniqueness_elapsed_ms = static_cast<double>(uniqueness_elapsed_ns.load(std::memory_order_relaxed)) / 1e6;
    result.uniqueness_avg_ms = (result.uniqueness_calls > 0)
        ? (result.uniqueness_elapsed_ms / static_cast<double>(result.uniqueness_calls))
        : 0.0;

    result.kernel_calls = kernel_calls.load(std::memory_order_relaxed);
    result.kernel_time_ms = static_cast<double>(kernel_elapsed_ns.load(std::memory_order_relaxed)) / 1e6;
    result.logic_steps_total = logic_steps_total.load(std::memory_order_relaxed);
    result.strategy_naked_use = strategy_naked_use.load(std::memory_order_relaxed);
    result.strategy_naked_hit = strategy_naked_hit.load(std::memory_order_relaxed);
    result.strategy_hidden_use = strategy_hidden_use.load(std::memory_order_relaxed);
    result.strategy_hidden_hit = strategy_hidden_hit.load(std::memory_order_relaxed);

    const double asymmetry_ratio = static_cast<double>(std::max(run_cfg.box_rows, run_cfg.box_cols)) /
                                   static_cast<double>(std::max(1, std::min(run_cfg.box_rows, run_cfg.box_cols)));
    result.asymmetry_efficiency_index = asymmetry_ratio;
    result.backend_efficiency_score = (result.kernel_time_ms > 0.0)
        ? static_cast<double>(result.accepted) / (result.kernel_time_ms / 1000.0)
        : 0.0;

    const auto elapsed = duration_cast<duration<double>>(steady_clock::now() - t0).count();
    result.elapsed_s = elapsed;
    result.accepted_per_sec = (elapsed > 0.0) ? static_cast<double>(result.accepted) / elapsed : 0.0;

    const auto vip_target = post_processing::resolve_vip_grade_target_for_geometry(run_cfg);
    result.vip_score = post_processing::compute_vip_score(result, run_cfg, asymmetry_ratio);
    result.vip_grade = post_processing::vip_grade_from_score(result.vip_score);
    result.vip_contract_ok = post_processing::vip_contract_passed(result.vip_score, vip_target);
    result.vip_contract_fail_reason = result.vip_contract_ok ? "" : ("required=" + vip_target + ", actual=" + result.vip_grade);

    const std::string sig_raw =
        std::to_string(result.accepted) + ":" +
        std::to_string(result.written) + ":" +
        std::to_string(result.attempts) + ":" +
        std::to_string(result.uniqueness_nodes) + ":" +
        std::to_string(run_cfg.box_rows) + "x" + std::to_string(run_cfg.box_cols);
    const size_t h1 = std::hash<std::string>{}(sig_raw);
    const size_t h2 = std::hash<std::string>{}(sig_raw + ":v2");
    result.premium_signature = std::to_string(static_cast<unsigned long long>(h1));
    result.premium_signature_v2 = std::to_string(static_cast<unsigned long long>(h2));

    if (monitor != nullptr) {
        monitor->set_attempts(result.attempts);
        monitor->set_accepted(result.accepted);
        monitor->set_written(result.written);
        monitor->set_rejected(result.rejected);
        monitor->set_background_status("done accepted=" + std::to_string(result.accepted) + " written=" + std::to_string(result.written));
    }

    log_info(
        "runner",
        "done accepted=" + std::to_string(result.accepted) +
        " written=" + std::to_string(result.written) +
        " attempts=" + std::to_string(result.attempts));

    return result;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\gui-old.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>
#ifdef _WIN32
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#endif

namespace sudoku_hpc {
#ifdef _WIN32
enum : int {
    IDC_PROGRESS_BAR = 1001,
    IDC_PROGRESS_TEXT,
    IDC_MONITOR_BOX,
    IDC_LOG_BOX,
    IDC_BTN_START,
    IDC_BTN_CANCEL,
    IDC_BTN_PAUSE
};

constexpr UINT WM_APP_PROGRESS = WM_APP + 101;
constexpr UINT WM_APP_LOG = WM_APP + 102;
constexpr UINT WM_APP_DONE = WM_APP + 103;
constexpr UINT WM_APP_INLINE_CLOSE = WM_APP + 104;
constexpr UINT WM_APP_FORM_NAV = WM_APP + 105;
constexpr UINT_PTR IDT_MONITOR_REFRESH = 1;
constexpr UINT_PTR IDSC_INLINE_EDITOR = 1;
constexpr int IDC_INLINE_EDIT = 4500;
constexpr int IDC_FORM_PANEL = 4501;

enum class FormFieldType {
    Int,
    Text,
    Combo,
    Checkbox,
    ActionButton
};

enum FormFieldKey {
    F_BOX_ROWS = 1,
    F_BOX_COLS,
    F_TARGET_PUZZLES,
    F_MIN_CLUES,
    F_MAX_CLUES,
    F_DIFFICULTY,
    F_CLUES_PRESET,
    F_THREADS,
    F_SEED,
    F_RESEED_INTERVAL,
    F_FORCE_NEW_SEED,
    F_ATTEMPT_TIME_BUDGET,
    F_ATTEMPT_NODE_BUDGET,
    F_MAX_ATTEMPTS,
    F_MAX_TOTAL_TIME,  // Globalny limit czasu na całe uruchomienie
    F_REQUIRED_STRATEGY,
    F_OUTPUT_FOLDER,
    F_OUTPUT_FILE,
    F_SYMMETRY_CENTER,
    F_REQUIRE_UNIQUE,
    F_SHOW_MONITOR
};

struct FormField {
    int key = 0;
    FormFieldType type = FormFieldType::Text;
    std::wstring label;
    std::wstring text;
    std::vector<std::wstring> options;
    std::vector<int> option_payload;
    int option_index = 0;
    bool checked = false;
    bool enabled = true;
    bool has_browse = false;
    RECT label_rect{};
    RECT value_rect{};
    RECT browse_rect{};
};

struct FormLayoutItem {
    bool is_section = false;
    std::wstring section_title;
    int field_key = 0;
    RECT section_rect{};
};

struct GuiAppState {
    HWND hwnd = nullptr;
    HWND h_form_panel = nullptr;
    HWND h_inline_editor = nullptr;
    HWND h_progress = nullptr;
    HWND h_progress_text = nullptr;
    HWND h_monitor = nullptr;
    HWND h_log = nullptr;
    HWND h_start = nullptr;
    HWND h_cancel = nullptr;
    HWND h_pause = nullptr;
    HFONT h_mono_font = nullptr;
    int inline_field_key = 0;
    int focused_field_key = 0;
    int hover_field_key = 0;
    bool inline_is_combo = false;
    bool form_read_only = false;
    bool inline_close_posted = false;
    bool mouse_tracking = false;
    int form_scroll_y = 0;
    int form_content_height = 0;
    int form_view_height = 0;
    std::vector<FormField> form_fields;
    std::vector<FormLayoutItem> form_layout;

    std::jthread run_thread;
    std::atomic<bool> running{false};
    std::atomic<bool> cancel_requested{false};
    std::atomic<bool> paused{false};
    uint64_t target = 0;

    std::mutex monitor_mu;
    std::shared_ptr<ConsoleStatsMonitor> gui_monitor;
};

int form_first_focusable_key(const GuiAppState* state);
void form_set_focused_field(GuiAppState* state, int field_key, bool ensure_visible);

#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstringop-overread"
#endif

std::wstring utf8_to_wide(const std::string& s) {
    if (s.empty()) {
        return L"";
    }
    const int len = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, nullptr, 0);
    if (len <= 0) {
        return L"";
    }
    std::wstring out;
    out.resize(static_cast<size_t>(len));
    MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, out.data(), len);
    out.resize(static_cast<size_t>(len - 1));
    return out;
}

std::string wide_to_utf8(const std::wstring& ws) {
    if (ws.empty()) {
        return "";
    }
    const int len = WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, nullptr, 0, nullptr, nullptr);
    if (len <= 0) {
        return "";
    }
    std::string out;
    out.resize(static_cast<size_t>(len));
    WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, out.data(), len, nullptr, nullptr);
    out.resize(static_cast<size_t>(len - 1));
    return out;
}

#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif

std::wstring get_text(HWND h) {
    const int len = GetWindowTextLengthW(h);
    std::wstring text(static_cast<size_t>(len) + 1, L'\0');
    GetWindowTextW(h, text.data(), len + 1);
    text.resize(static_cast<size_t>(len));
    return text;
}

void set_text(HWND h, const std::wstring& value) {
    SetWindowTextW(h, value.c_str());
}

int parse_int_text_or_default(const std::wstring& text, int fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return std::stoi(text);
    } catch (...) {
        return fallback;
    }
}

uint64_t parse_u64_text_or_default(const std::wstring& text, uint64_t fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return static_cast<uint64_t>(std::stoull(text));
    } catch (...) {
        return fallback;
    }
}

long long parse_i64_text_or_default(const std::wstring& text, long long fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return static_cast<long long>(std::stoll(text));
    } catch (...) {
        return fallback;
    }
}

FormField* find_form_field(GuiAppState* state, int key) {
    if (state == nullptr) {
        return nullptr;
    }
    for (auto& field : state->form_fields) {
        if (field.key == key) {
            return &field;
        }
    }
    return nullptr;
}

const FormField* find_form_field(const GuiAppState* state, int key) {
    if (state == nullptr) {
        return nullptr;
    }
    for (const auto& field : state->form_fields) {
        if (field.key == key) {
            return &field;
        }
    }
    return nullptr;
}

std::wstring form_field_text(const GuiAppState* state, int key, const std::wstring& fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr || field->text.empty()) {
        return fallback;
    }
    return field->text;
}

int form_field_int(const GuiAppState* state, int key, int fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_int_text_or_default(field->text, fallback);
}

uint64_t form_field_u64(const GuiAppState* state, int key, uint64_t fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_u64_text_or_default(field->text, fallback);
}

long long form_field_i64(const GuiAppState* state, int key, long long fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_i64_text_or_default(field->text, fallback);
}

int form_field_combo_index(const GuiAppState* state, int key, int fallback = 0) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return field->option_index;
}

bool form_field_checked(const GuiAppState* state, int key, bool fallback = false) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return field->checked;
}

void set_form_field_text(GuiAppState* state, int key, const std::wstring& value) {
    FormField* field = find_form_field(state, key);
    if (field != nullptr) {
        field->text = value;
    }
}

void set_form_field_combo_index(GuiAppState* state, int key, int index) {
    FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return;
    }
    if (field->options.empty()) {
        field->option_index = 0;
        return;
    }
    field->option_index = std::clamp(index, 0, static_cast<int>(field->options.size()) - 1);
}

void set_form_field_checked(GuiAppState* state, int key, bool checked) {
    FormField* field = find_form_field(state, key);
    if (field != nullptr) {
        field->checked = checked;
    }
}

struct RequiredStrategyUiEntry {
    RequiredStrategy strategy = RequiredStrategy::None;
    const wchar_t* label = L"";
};

struct DifficultyUiEntry {
    int level = 1;
    const wchar_t* label = L"";
};

inline const std::vector<DifficultyUiEntry>& difficulty_ui_catalog() {
    static const std::vector<DifficultyUiEntry> entries = {
        {1, L"1 - Naked/Hidden Single"},
        {2, L"2 - Pointing / Box-Line"},
        {3, L"3 - Pairs/Triples"},
        {4, L"4 - Wings/Fishes basic"},
        {5, L"5 - Swordfish/FinnedXW/Coloring"},
        {6, L"6 - Jellyfish/Chains/ALS"},
        {7, L"7 - Medusa/AIC/Sue de Coq"},
        {8, L"8 - MSLS/Exocet/Forcing Chains"},
        {9, L"9 - Backtracking/Brutalny (max_clues=L1)"},
    };
    return entries;
}

inline int difficulty_level_from_form(const GuiAppState* state) {
    const FormField* field = find_form_field(state, F_DIFFICULTY);
    if (field == nullptr) {
        return 1;
    }
    const int sel = std::clamp(field->option_index, 0, std::max(0, static_cast<int>(field->options.size()) - 1));
    if (!field->option_payload.empty() && sel >= 0 && sel < static_cast<int>(field->option_payload.size())) {
        return std::clamp(field->option_payload[static_cast<size_t>(sel)], 1, 9);
    }
    return std::clamp(sel + 1, 1, 9);
}

inline void refresh_difficulty_options(GuiAppState* state, bool keep_selection = true) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, F_DIFFICULTY);
    if (field == nullptr || field->type != FormFieldType::Combo) {
        return;
    }
    const int prev = keep_selection ? difficulty_level_from_form(state) : 1;
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));

    field->options.clear();
    field->option_payload.clear();
    for (const auto& entry : difficulty_ui_catalog()) {
        if (!difficulty_level_selectable_for_geometry(entry.level, box_rows, box_cols)) {
            continue;
        }
        field->options.push_back(entry.label);
        field->option_payload.push_back(entry.level);
    }
    if (field->options.empty()) {
        field->options.push_back(L"1 - Naked/Hidden Single");
        field->option_payload.push_back(1);
    }
    int next_index = 0;
    for (int i = 0; i < static_cast<int>(field->option_payload.size()); ++i) {
        if (field->option_payload[static_cast<size_t>(i)] == prev) {
            next_index = i;
            break;
        }
    }
    field->option_index = std::clamp(next_index, 0, static_cast<int>(field->options.size()) - 1);
}

inline const std::vector<RequiredStrategyUiEntry>& required_strategy_ui_catalog() {
    static const std::vector<RequiredStrategyUiEntry> entries = {
        {RequiredStrategy::None, L"(brak)"},
        {RequiredStrategy::NakedSingle, L"Naked Single"},
        {RequiredStrategy::HiddenSingle, L"Hidden Single"},
        {RequiredStrategy::PointingPairs, L"Pointing Pairs/Triples"},
        {RequiredStrategy::BoxLineReduction, L"Box/Line Reduction"},
        {RequiredStrategy::NakedPair, L"Naked Pair"},
        {RequiredStrategy::HiddenPair, L"Hidden Pair"},
        {RequiredStrategy::NakedTriple, L"Naked Triple"},
        {RequiredStrategy::HiddenTriple, L"Hidden Triple"},
        {RequiredStrategy::NakedQuad, L"Naked Quad"},
        {RequiredStrategy::HiddenQuad, L"Hidden Quad"},
        {RequiredStrategy::XWing, L"X-Wing"},
        {RequiredStrategy::YWing, L"Y-Wing"},
        {RequiredStrategy::Skyscraper, L"Skyscraper"},
        {RequiredStrategy::TwoStringKite, L"2-String Kite"},
        {RequiredStrategy::EmptyRectangle, L"Empty Rectangle"},
        {RequiredStrategy::RemotePairs, L"Remote Pairs"},
        {RequiredStrategy::Swordfish, L"Swordfish"},
        {RequiredStrategy::FinnedXWingSashimi, L"Finned X-Wing/Sashimi"},
        {RequiredStrategy::SimpleColoring, L"Simple Coloring"},
        {RequiredStrategy::BUGPlusOne, L"BUG+1"},
        {RequiredStrategy::UniqueRectangle, L"Unique Rectangle"},
        {RequiredStrategy::XYZWing, L"XYZ-Wing"},
        {RequiredStrategy::WWing, L"W-Wing"},
        {RequiredStrategy::Jellyfish, L"Jellyfish"},
        {RequiredStrategy::XChain, L"X-Chain"},
        {RequiredStrategy::XYChain, L"XY-Chain"},
        {RequiredStrategy::WXYZWing, L"WXYZ-Wing"},
        {RequiredStrategy::FinnedSwordfishJellyfish, L"Finned Swordfish/Jellyfish"},
        {RequiredStrategy::ALSXZ, L"ALS-XZ"},
        {RequiredStrategy::UniqueLoop, L"Unique Loop"},
        {RequiredStrategy::AvoidableRectangle, L"Avoidable Rectangle"},
        {RequiredStrategy::BivalueOddagon, L"Bivalue Oddagon"},
        {RequiredStrategy::UniqueRectangleExtended, L"UR Extended (Type 2-6)"},
        {RequiredStrategy::HiddenUniqueRectangle, L"Hidden UR"},
        {RequiredStrategy::BUGType2, L"BUG Type 2"},
        {RequiredStrategy::BUGType3, L"BUG Type 3"},
        {RequiredStrategy::BUGType4, L"BUG Type 4"},
        {RequiredStrategy::BorescoperQiuDeadlyPattern, L"Borescoper/Qiu Deadly"},
        {RequiredStrategy::Medusa3D, L"3D Medusa"},
        {RequiredStrategy::AIC, L"AIC"},
        {RequiredStrategy::GroupedAIC, L"Grouped AIC"},
        {RequiredStrategy::GroupedXCycle, L"Grouped X-Cycle"},
        {RequiredStrategy::ContinuousNiceLoop, L"Continuous Nice Loop"},
        {RequiredStrategy::ALSXYWing, L"ALS-XY-Wing"},
        {RequiredStrategy::ALSChain, L"ALS-Chain"},
        {RequiredStrategy::AlignedPairExclusion, L"Aligned Pair Exclusion"},
        {RequiredStrategy::AlignedTripleExclusion, L"Aligned Triple Exclusion"},
        {RequiredStrategy::ALSAIC, L"ALS-AIC"},
        {RequiredStrategy::SueDeCoq, L"Sue de Coq"},
        {RequiredStrategy::DeathBlossom, L"Death Blossom"},
        {RequiredStrategy::FrankenFish, L"Franken Fish"},
        {RequiredStrategy::MutantFish, L"Mutant Fish"},
        {RequiredStrategy::KrakenFish, L"Kraken Fish"},
        {RequiredStrategy::Squirmbag, L"Squirmbag / Starfish"},
        {RequiredStrategy::MSLS, L"MSLS"},
        {RequiredStrategy::Exocet, L"Exocet"},
        {RequiredStrategy::SeniorExocet, L"Senior Exocet"},
        {RequiredStrategy::SKLoop, L"SK Loop"},
        {RequiredStrategy::PatternOverlayMethod, L"Pattern Overlay Method"},
        {RequiredStrategy::ForcingChains, L"Forcing Chains"},
        {RequiredStrategy::DynamicForcingChains, L"Dynamic Forcing Chains"},
        {RequiredStrategy::Backtracking, L"Backtracking"},
    };
    return entries;
}

inline RequiredStrategy required_strategy_from_form(const GuiAppState* state) {
    const FormField* field = find_form_field(state, F_REQUIRED_STRATEGY);
    if (field == nullptr) {
        return RequiredStrategy::None;
    }
    const int sel = std::clamp(field->option_index, 0, std::max(0, static_cast<int>(field->options.size()) - 1));
    if (!field->option_payload.empty() && sel >= 0 && sel < static_cast<int>(field->option_payload.size())) {
        return static_cast<RequiredStrategy>(field->option_payload[static_cast<size_t>(sel)]);
    }
    return RequiredStrategy::None;
}

inline void refresh_required_strategy_options(GuiAppState* state, bool keep_selection = true) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, F_REQUIRED_STRATEGY);
    if (field == nullptr || field->type != FormFieldType::Combo) {
        return;
    }
    const RequiredStrategy prev = keep_selection ? required_strategy_from_form(state) : RequiredStrategy::None;
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));

    field->options.clear();
    field->option_payload.clear();
    for (const auto& entry : required_strategy_ui_catalog()) {
        if (entry.strategy != RequiredStrategy::None &&
            !required_strategy_selectable_for_geometry(entry.strategy, box_rows, box_cols)) {
            continue;
        }
        field->options.push_back(entry.label);
        field->option_payload.push_back(static_cast<int>(entry.strategy));
    }
    if (field->options.empty()) {
        field->options.push_back(L"(brak)");
        field->option_payload.push_back(static_cast<int>(RequiredStrategy::None));
    }

    int next_index = 0;
    if (keep_selection) {
        for (int i = 0; i < static_cast<int>(field->option_payload.size()); ++i) {
            if (field->option_payload[static_cast<size_t>(i)] == static_cast<int>(prev)) {
                next_index = i;
                break;
            }
        }
    }
    field->option_index = std::clamp(next_index, 0, static_cast<int>(field->options.size()) - 1);
}

void init_form_model(GuiAppState* state) {
    state->form_fields.clear();
    state->form_layout.clear();
    auto add_field = [&](FormField field) {
        state->form_fields.push_back(std::move(field));
    };
    auto add_layout_field = [&](int key) {
        FormLayoutItem it;
        it.field_key = key;
        state->form_layout.push_back(it);
    };
    auto add_section = [&](const wchar_t* title) {
        FormLayoutItem it;
        it.is_section = true;
        it.section_title = title;
        state->form_layout.push_back(std::move(it));
    };
    auto make_field = [](int key, FormFieldType type, const wchar_t* label, const wchar_t* text) {
        FormField f;
        f.key = key;
        f.type = type;
        f.label = label;
        f.text = text;
        return f;
    };

    add_field(make_field(F_BOX_ROWS, FormFieldType::Int, L"box_rows:", L"3"));
    add_field(make_field(F_BOX_COLS, FormFieldType::Int, L"box_cols:", L"3"));
    add_field(make_field(F_TARGET_PUZZLES, FormFieldType::Int, L"target_puzzles:", L"100"));
    add_field(make_field(F_MIN_CLUES, FormFieldType::Int, L"min_clues (0=auto, można nadpisać):", L"0"));
    add_field(make_field(F_MAX_CLUES, FormFieldType::Int, L"max_clues (0=auto, można nadpisać):", L"0"));

    FormField difficulty;
    difficulty.key = F_DIFFICULTY;
    difficulty.type = FormFieldType::Combo;
    difficulty.label = L"difficulty_level_required:";
    difficulty.options.clear();
    difficulty.option_payload.clear();
    difficulty.option_index = 0;
    add_field(std::move(difficulty));

    FormField preset;
    preset.key = F_CLUES_PRESET;
    preset.type = FormFieldType::ActionButton;
    preset.label = L"clues_preset:";
    preset.text = L"Auto (wg difficulty + rozmiaru)";
    add_field(std::move(preset));

    add_field(make_field(F_THREADS, FormFieldType::Int, L"threads (0=auto):", L"0"));
    add_field(make_field(F_SEED, FormFieldType::Int, L"seed (uint64_t, 0=random):", L"0"));
    add_field(make_field(F_RESEED_INTERVAL, FormFieldType::Int, L"reseed_interval_s (0=off, full worker reset):", L"0"));
    FormField force_seed;
    force_seed.key = F_FORCE_NEW_SEED;
    force_seed.type = FormFieldType::Checkbox;
    force_seed.label = L"Force new seed per attempt";
    force_seed.checked = true;
    add_field(std::move(force_seed));
    add_field(make_field(F_ATTEMPT_TIME_BUDGET, FormFieldType::Int, L"attempt_time_budget_s (0=brak limitu):", L"0"));
    add_field(make_field(F_ATTEMPT_NODE_BUDGET, FormFieldType::Int, L"attempt_node_budget (0=brak limitu):", L"0"));
    add_field(make_field(F_MAX_ATTEMPTS, FormFieldType::Int, L"max_attempts (0=bez limitu):", L"0"));
    add_field(make_field(F_MAX_TOTAL_TIME, FormFieldType::Int, L"max_total_time_s (0=bez limitu, CAŁE URUCHOMIENIE):", L"0"));

    FormField strategy;
    strategy.key = F_REQUIRED_STRATEGY;
    strategy.type = FormFieldType::Combo;
    strategy.label = L"required_strategy (opcjonalnie):";
    strategy.options.clear();
    strategy.option_payload.clear();
    strategy.option_index = 0;
    add_field(std::move(strategy));

    FormField out_folder;
    out_folder.key = F_OUTPUT_FOLDER;
    out_folder.type = FormFieldType::Text;
    out_folder.label = L"output_folder:";
    out_folder.text = L"generated_sudoku_files";
    out_folder.has_browse = true;
    add_field(std::move(out_folder));

    FormField out_file;
    out_file.key = F_OUTPUT_FILE;
    out_file.type = FormFieldType::Text;
    out_file.label = L"output_file:";
    out_file.text = L"generated_sudoku.txt";
    out_file.has_browse = true;
    add_field(std::move(out_file));

    FormField symmetry;
    symmetry.key = F_SYMMETRY_CENTER;
    symmetry.type = FormFieldType::Checkbox;
    symmetry.label = L"symmetry_center";
    symmetry.checked = false;
    add_field(std::move(symmetry));

    FormField unique;
    unique.key = F_REQUIRE_UNIQUE;
    unique.type = FormFieldType::Checkbox;
    unique.label = L"require_unique (wymuszone)";
    unique.checked = true;
    unique.enabled = false;
    add_field(std::move(unique));

    FormField show_monitor;
    show_monitor.key = F_SHOW_MONITOR;
    show_monitor.type = FormFieldType::Checkbox;
    show_monitor.label = L"live monitor (GUI+console)";
    show_monitor.checked = true;
    add_field(std::move(show_monitor));

    add_section(L"Podstawowe parametry");
    add_layout_field(F_BOX_ROWS);
    add_layout_field(F_BOX_COLS);
    add_layout_field(F_TARGET_PUZZLES);
    add_layout_field(F_MIN_CLUES);
    add_layout_field(F_MAX_CLUES);
    add_layout_field(F_DIFFICULTY);
    add_layout_field(F_CLUES_PRESET);

    add_section(L"Ustawienia zaawansowane / silnika");
    add_layout_field(F_THREADS);
    add_layout_field(F_SEED);
    add_layout_field(F_RESEED_INTERVAL);
    add_layout_field(F_FORCE_NEW_SEED);
    add_layout_field(F_ATTEMPT_TIME_BUDGET);
    add_layout_field(F_ATTEMPT_NODE_BUDGET);
    add_layout_field(F_MAX_ATTEMPTS);
    add_layout_field(F_MAX_TOTAL_TIME);  // Globalny limit czasu
    add_layout_field(F_REQUIRED_STRATEGY);

    add_section(L"Zapis i eksport");
    add_layout_field(F_OUTPUT_FOLDER);
    add_layout_field(F_OUTPUT_FILE);
    add_layout_field(F_SYMMETRY_CENTER);
    add_layout_field(F_SHOW_MONITOR);

    refresh_difficulty_options(state, false);
    refresh_required_strategy_options(state, false);
}

void append_log(GuiAppState* state, const std::wstring& line) {
    if (state == nullptr || state->h_log == nullptr) {
        return;
    }
    const int len = GetWindowTextLengthW(state->h_log);
    SendMessageW(state->h_log, EM_SETSEL, len, len);
    std::wstring text = line + L"\r\n";
    SendMessageW(state->h_log, EM_REPLACESEL, FALSE, reinterpret_cast<LPARAM>(text.c_str()));
}

void set_monitor_text(GuiAppState* state, const std::wstring& text) {
    if (state == nullptr || state->h_monitor == nullptr) {
        return;
    }
    set_text(state->h_monitor, text);
}

void post_log(HWND hwnd, const std::wstring& line) {
    auto* payload = new std::wstring(line);
    PostMessageW(hwnd, WM_APP_LOG, 0, reinterpret_cast<LPARAM>(payload));
}

bool browse_for_folder(HWND owner, std::wstring& out_path) {
    BROWSEINFOW bi{};
    wchar_t display_name[MAX_PATH]{};
    bi.hwndOwner = owner;
    bi.pszDisplayName = display_name;
    bi.lpszTitle = L"Wybierz folder wyjsciowy";
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
    PIDLIST_ABSOLUTE pidl = SHBrowseForFolderW(&bi);
    if (pidl == nullptr) {
        return false;
    }
    wchar_t path[MAX_PATH]{};
    const BOOL ok = SHGetPathFromIDListW(pidl, path);
    CoTaskMemFree(pidl);
    if (!ok) {
        return false;
    }
    out_path = path;
    return true;
}

bool browse_for_save_file(HWND owner, std::wstring& out_path) {
    wchar_t file_buffer[MAX_PATH] = L"generated_sudoku.txt";
    OPENFILENAMEW ofn{};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = owner;
    ofn.lpstrFile = file_buffer;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFilter = L"Text Files\0*.txt\0All Files\0*.*\0";
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"txt";
    if (!GetSaveFileNameW(&ofn)) {
        return false;
    }
    out_path = file_buffer;
    return true;
}

void apply_clues_preset(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));
    const int lvl = difficulty_level_from_form(state);
    const RequiredStrategy required = required_strategy_from_form(state);
    const int effective_budget_level = strategy_adjusted_level(lvl, required);
    const bool unlimited_by_default = (effective_budget_level >= 3);
    const ClueRange range = resolve_auto_clue_range(box_rows, box_cols, lvl, required);
    const int min_clues = range.min_clues;
    const int max_clues = range.max_clues;
    const int suggested_reseed_s = suggest_reseed_interval_s(box_rows, box_cols, effective_budget_level);
    const int suggested_attempt_time_s = suggest_attempt_time_budget_seconds(box_rows, box_cols, effective_budget_level);
    const uint64_t suggested_attempt_nodes = suggest_attempt_node_budget(box_rows, box_cols, effective_budget_level);

    set_form_field_text(state, F_MIN_CLUES, std::to_wstring(min_clues));
    set_form_field_text(state, F_MAX_CLUES, std::to_wstring(max_clues));
    set_form_field_text(state, F_RESEED_INTERVAL, std::to_wstring(suggested_reseed_s));
    set_form_field_text(state, F_ATTEMPT_TIME_BUDGET, unlimited_by_default ? L"0" : std::to_wstring(suggested_attempt_time_s));
    set_form_field_text(state, F_ATTEMPT_NODE_BUDGET, unlimited_by_default ? L"0" : std::to_wstring(suggested_attempt_nodes));
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
    append_log(
        state,
        L"Preset: clues=" + std::to_wstring(min_clues) + L"-" + std::to_wstring(max_clues) +
            L", reseed=" + std::to_wstring(suggested_reseed_s) + L"s, attempt_time=" +
            (unlimited_by_default ? std::wstring(L"0(unlimited)") : std::to_wstring(suggested_attempt_time_s) + L"s") +
            L", attempt_nodes=" +
            (unlimited_by_default ? std::wstring(L"0(unlimited)") : std::to_wstring(suggested_attempt_nodes)) + L", budget_lvl=" +
            std::to_wstring(effective_budget_level));
}

void set_running_state(GuiAppState* state, bool running) {
    state->running.store(running, std::memory_order_relaxed);
    state->form_read_only = running;
    EnableWindow(state->h_start, running ? FALSE : TRUE);
    EnableWindow(state->h_cancel, running ? TRUE : FALSE);
    EnableWindow(state->h_pause, running ? TRUE : FALSE);
    if (state->h_form_panel != nullptr) {
        form_set_focused_field(state, form_first_focusable_key(state), false);
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool is_live_monitor_enabled(const GuiAppState* state) {
    if (state == nullptr) {
        return true;
    }
    return form_field_checked(state, F_SHOW_MONITOR, true);
}

bool read_config_from_form(GuiAppState* state, GenerateRunConfig& cfg, std::map<std::string, std::string>& dict) {
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    cfg.box_rows = form_field_int(state, F_BOX_ROWS, 3);
    cfg.box_cols = form_field_int(state, F_BOX_COLS, 3);
    cfg.target_puzzles = form_field_u64(state, F_TARGET_PUZZLES, 100);
    cfg.difficulty_level_required = difficulty_level_from_form(state);
    cfg.required_strategy = required_strategy_from_form(state);
    const int min_clues_input = form_field_int(state, F_MIN_CLUES, 0);
    const int max_clues_input = form_field_int(state, F_MAX_CLUES, 0);
    const ClueRange auto_clues = resolve_auto_clue_range(
        cfg.box_rows,
        cfg.box_cols,
        cfg.difficulty_level_required,
        cfg.required_strategy);
    cfg.min_clues = (min_clues_input > 0) ? min_clues_input : auto_clues.min_clues;
    cfg.max_clues = (max_clues_input > 0) ? max_clues_input : auto_clues.max_clues;
    cfg.threads = form_field_int(state, F_THREADS, 0);
    cfg.seed = form_field_u64(state, F_SEED, 0);
    cfg.reseed_interval_s = form_field_int(state, F_RESEED_INTERVAL, 0);
    cfg.force_new_seed_per_attempt = form_field_checked(state, F_FORCE_NEW_SEED, true);
    cfg.attempt_time_budget_s = static_cast<double>(form_field_u64(state, F_ATTEMPT_TIME_BUDGET, 0));
    cfg.attempt_node_budget = form_field_u64(state, F_ATTEMPT_NODE_BUDGET, 0);
    cfg.max_attempts = form_field_u64(state, F_MAX_ATTEMPTS, 0);
    cfg.max_total_time_s = form_field_u64(state, F_MAX_TOTAL_TIME, 0);  // Globalny limit czasu
    cfg.symmetry_center = form_field_checked(state, F_SYMMETRY_CENTER, false);
    cfg.require_unique = true;
    cfg.write_individual_files = true;
    cfg.output_folder = wide_to_utf8(form_field_text(state, F_OUTPUT_FOLDER, L"generated_sudoku_files"));
    cfg.output_file = wide_to_utf8(form_field_text(state, F_OUTPUT_FILE, L"generated_sudoku.txt"));
    cfg.pause_on_exit_windows = false;

    if (cfg.box_rows <= 0 || cfg.box_cols <= 0) {
        MessageBoxW(state->hwnd, L"box_rows i box_cols musza byc > 0", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "box_rows/box_cols must be > 0");
        return false;
    }
    if (!difficulty_level_selectable_for_geometry(cfg.difficulty_level_required, cfg.box_rows, cfg.box_cols)) {
        MessageBoxW(
            state->hwnd,
            L"Wybrany poziom trudnosci nie jest jeszcze dostepny runtime dla tej geometrii.",
            L"Walidacja",
            MB_ICONWARNING);
        log_warn("gui.validation", "difficulty level not selectable for geometry");
        return false;
    }
    if (!required_strategy_selectable_for_geometry(cfg.required_strategy, cfg.box_rows, cfg.box_cols)) {
        MessageBoxW(
            state->hwnd,
            L"required_strategy nie jest dostepna dla tej geometrii.",
            L"Walidacja",
            MB_ICONWARNING);
        log_warn("gui.validation", "required_strategy not selectable for geometry");
        return false;
    }
    if (cfg.max_clues < cfg.min_clues) {
        MessageBoxW(state->hwnd, L"max_clues musi byc >= min_clues", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "max_clues must be >= min_clues");
        return false;
    }
    if (cfg.target_puzzles == 0) {
        MessageBoxW(state->hwnd, L"target_puzzles musi byc > 0", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "target_puzzles must be > 0");
        return false;
    }
    const int n = cfg.box_rows * cfg.box_cols;
    const int nn = n * n;
    cfg.min_clues = std::clamp(cfg.min_clues, 0, nn);
    cfg.max_clues = std::clamp(cfg.max_clues, cfg.min_clues, nn);
    if (cfg.output_folder.empty() || cfg.output_file.empty()) {
        MessageBoxW(state->hwnd, L"output_folder i output_file nie moga byc puste", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "output_folder/output_file cannot be empty");
        return false;
    }

    dict["box_rows"] = std::to_string(cfg.box_rows);
    dict["box_cols"] = std::to_string(cfg.box_cols);
    dict["target_puzzles"] = std::to_string(cfg.target_puzzles);
    dict["min_clues"] = std::to_string(cfg.min_clues);
    dict["max_clues"] = std::to_string(cfg.max_clues);
    dict["difficulty_level_required"] = std::to_string(cfg.difficulty_level_required);
    dict["required_strategy"] = to_string(cfg.required_strategy);
    dict["threads"] = std::to_string(cfg.threads);
    dict["seed"] = std::to_string(cfg.seed);
    dict["reseed_interval_s"] = std::to_string(cfg.reseed_interval_s);
    dict["force_new_seed_per_attempt"] = cfg.force_new_seed_per_attempt ? "true" : "false";
    dict["attempt_time_budget_s"] = std::to_string(static_cast<int>(cfg.attempt_time_budget_s));
    dict["attempt_node_budget_s"] = std::to_string(cfg.attempt_node_budget);
    dict["max_attempts"] = std::to_string(cfg.max_attempts);
    dict["max_total_time_s"] = std::to_string(cfg.max_total_time_s);  // Globalny limit czasu
    dict["symmetry_center"] = cfg.symmetry_center ? "true" : "false";
    dict["require_unique"] = "true";
    dict["output_folder"] = cfg.output_folder;
    dict["output_file"] = cfg.output_file;
    return true;
}

void toggle_pause(GuiAppState* state);
void start_generation(GuiAppState* state);
void cancel_generation(GuiAppState* state);

void start_generation(GuiAppState* state) {
    if (state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.start_generation", "ignored start while already running");
        return;
    }
    GenerateRunConfig cfg;
    std::map<std::string, std::string> dict;
    if (!read_config_from_form(state, cfg, dict)) {
        log_warn("gui.start_generation", "read_config_from_form failed");
        return;
    }

    std::cout << "start_generation() form values:\n";
    for (const auto& [k, v] : dict) {
        std::cout << "  " << k << " = " << v << "\n";
    }
    
    // Show suggestions for profile and currently configured attempt budgets.
    const double suggested_time = suggest_time_budget_s(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required);
    const ClueRange suggested_clues = resolve_auto_clue_range(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy);
    
    std::wcout << L"\n[SUGESTIA] Dla rozmiaru " << (cfg.box_rows * cfg.box_cols) << L"x" << (cfg.box_rows * cfg.box_cols) << L":\n";
    std::wcout << L"  attempt_time_budget_s: sugerowane=" << static_cast<int>(std::ceil(suggested_time))
               << L"s, ustawione=" << static_cast<int>(cfg.attempt_time_budget_s) << L"s\n";
    std::wcout << L"  min_clues: sugerowane=" << suggested_clues.min_clues << L", ustawione=" << cfg.min_clues << L"\n";
    std::wcout << L"  max_clues: sugerowane=" << suggested_clues.max_clues << L", ustawione=" << cfg.max_clues << L"\n\n";
    
    append_log(state, L"Start generation...");
    log_info(
        "gui.start_generation",
        "start target=" + std::to_string(cfg.target_puzzles) +
            " level=" + std::to_string(cfg.difficulty_level_required) +
            " required=" + to_string(cfg.required_strategy) +
            " threads=" + std::to_string(cfg.threads) +
            " suggested_time_budget=" + std::to_string(suggested_time) +
            " suggested_clues=" + std::to_string(suggested_clues.min_clues) + "-" + std::to_string(suggested_clues.max_clues));
    for (const auto& [k, v] : dict) {
        append_log(state, utf8_to_wide(k + "=" + v));
    }

    state->target = cfg.target_puzzles;
    SendMessageW(state->h_progress, PBM_SETRANGE32, 0, static_cast<LPARAM>(std::min<uint64_t>(cfg.target_puzzles, 0x7fffffffULL)));
    SendMessageW(state->h_progress, PBM_SETPOS, 0, 0);
    set_text(state->h_progress_text, L"Wygenerowano 0/" + std::to_wstring(cfg.target_puzzles));
    state->cancel_requested.store(false, std::memory_order_relaxed);
    state->paused.store(false, std::memory_order_relaxed);
    SetWindowTextW(state->h_pause, L"Pauza");
    set_running_state(state, true);
    SetTimer(state->hwnd, IDT_MONITOR_REFRESH, 500, nullptr);
    set_monitor_text(state, L"Monitor start...");
    const bool live_monitor_on = is_live_monitor_enabled(state);
    EnableWindow(state->h_monitor, live_monitor_on ? TRUE : FALSE);
    if (!live_monitor_on) {
        set_monitor_text(state, L"Live monitor: OFF");
    }

    state->run_thread = std::jthread([state, cfg, live_monitor_on]() {
        auto monitor = std::make_shared<ConsoleStatsMonitor>();
        monitor->start_ui_thread(5000);
        {
            std::lock_guard<std::mutex> lock(state->monitor_mu);
            state->gui_monitor = monitor;
        }
        GenerateRunResult result = run_generic_sudoku(
            cfg,
            monitor.get(),
            &state->cancel_requested,
            &state->paused,
            [hwnd = state->hwnd](uint64_t accepted, uint64_t target) {
                PostMessageW(hwnd, WM_APP_PROGRESS, static_cast<WPARAM>(accepted), static_cast<LPARAM>(target));
            },
            [hwnd = state->hwnd](const std::string& msg) {
                post_log(hwnd, utf8_to_wide(msg));
            });
        log_info(
            "gui.run_thread",
            "run done accepted=" + std::to_string(result.accepted) +
                " written=" + std::to_string(result.written) +
                " attempts=" + std::to_string(result.attempts));
        monitor->stop_ui_thread();
        {
            std::lock_guard<std::mutex> lock(state->monitor_mu);
            state->gui_monitor.reset();
        }
        auto* payload = new GenerateRunResult(result);
        PostMessageW(state->hwnd, WM_APP_DONE, reinterpret_cast<WPARAM>(payload), 0);
    });
}

void publish_cli_status(GuiAppState* state, const std::string& status) {
    if (state == nullptr) {
        return;
    }
    std::shared_ptr<ConsoleStatsMonitor> monitor;
    {
        std::lock_guard<std::mutex> lock(state->monitor_mu);
        monitor = state->gui_monitor;
    }
    if (monitor != nullptr) {
        monitor->set_background_status(status);
    }
}

void cancel_generation(GuiAppState* state) {
    if (!state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.cancel_generation", "cancel ignored - not running");
        return;
    }
    state->cancel_requested.store(true, std::memory_order_relaxed);
    state->paused.store(false, std::memory_order_relaxed);
    SetWindowTextW(state->h_pause, L"Pauza");
    publish_cli_status(state, "Generowanie: cancel requested");
    log_info("gui.cancel_generation", "cancel requested - waiting for workers to finish");
    append_log(state, L"Anulowanie... czekam na zakonczenie workerow.");
}

void toggle_pause(GuiAppState* state) {
    if (!state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.toggle_pause", "pause ignored - not running");
        return;
    }
    const bool new_paused = !state->paused.load(std::memory_order_relaxed);
    state->paused.store(new_paused, std::memory_order_relaxed);
    if (new_paused) {
        append_log(state, L"Pauza - generowanie wstrzymane");
        SetWindowTextW(state->h_pause, L"Wznow");
        publish_cli_status(state, "Generowanie: paused");
        log_info("gui.toggle_pause", "PAUSED - all workers will sleep");
    } else {
        append_log(state, L"Wznowienie - kontynuacja generowania");
        SetWindowTextW(state->h_pause, L"Pauza");
        publish_cli_status(state, "Generowanie: resumed");
        log_info("gui.toggle_pause", "RESUMED - workers continue processing");
    }
}

// 
void sync_live_monitor_visual_state(GuiAppState* state) {
    if (state == nullptr || state->h_monitor == nullptr) {
        return;
    }
    const bool on = is_live_monitor_enabled(state);
    EnableWindow(state->h_monitor, on ? TRUE : FALSE);
    if (!on) {
        set_monitor_text(state, L"Live monitor: OFF");
    } else if (!state->running.load(std::memory_order_relaxed)) {
        append_log(state, L"Live monitor: ON");
    }
}

void form_update_scrollbar(GuiAppState* state) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    RECT rc{};
    GetClientRect(state->h_form_panel, &rc);
    const int view_h = std::max(1, static_cast<int>(rc.bottom - rc.top));
    state->form_view_height = view_h;
    const int max_scroll = std::max(0, state->form_content_height - view_h);
    state->form_scroll_y = std::clamp(state->form_scroll_y, 0, max_scroll);
    SCROLLINFO si{};
    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
    si.nMin = 0;
    si.nMax = std::max(0, state->form_content_height - 1);
    si.nPage = static_cast<UINT>(view_h);
    si.nPos = state->form_scroll_y;
    SetScrollInfo(state->h_form_panel, SB_VERT, &si, TRUE);
}

void form_layout_fields(GuiAppState* state) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    RECT client{};
    GetClientRect(state->h_form_panel, &client);
    const int client_w = std::max(1, static_cast<int>(client.right - client.left));
    const int margin = 14;
    const int row_h = 26;
    const int row_gap = 8;
    const int section_h = 28;
    const int label_w = std::clamp(client_w / 2 - 20, 210, 430);
    const int value_x = margin + label_w + 10;
    const int browse_w = 28;
    const int value_w = std::max(160, client_w - value_x - margin);

    for (auto& field : state->form_fields) {
        field.label_rect = RECT{};
        field.value_rect = RECT{};
        field.browse_rect = RECT{};
    }

    int y = margin;
    FormLayoutItem* current_section = nullptr;
    for (auto& item : state->form_layout) {
        if (item.is_section) {
            item.section_rect = RECT{margin - 4, y + 10, client_w - margin + 4, y + 34};
            current_section = &item;
            y += section_h;
            continue;
        }
        FormField* field = find_form_field(state, item.field_key);
        if (field == nullptr) {
            continue;
        }
        if (item.field_key == F_SYMMETRY_CENTER) {
            FormField* req_unique = find_form_field(state, F_REQUIRE_UNIQUE);
            const int half_w = std::max(220, (client_w - margin * 2 - 24) / 2);
            field->value_rect = RECT{margin + 2, y, margin + 2 + half_w, y + row_h};
            if (req_unique != nullptr) {
                req_unique->value_rect = RECT{margin + 14 + half_w, y, margin + 14 + half_w + half_w, y + row_h};
            }
            if (current_section != nullptr) {
                current_section->section_rect.bottom =
                    std::max(current_section->section_rect.bottom, static_cast<LONG>(y + row_h + 12));
            }
            y += row_h + row_gap;
            continue;
        }

        field->label_rect = RECT{margin, y, margin + label_w, y + row_h};
        if (field->type == FormFieldType::Checkbox) {
            field->value_rect = RECT{margin + 2, y, margin + 2 + value_w, y + row_h};
        } else if (field->has_browse) {
            field->value_rect = RECT{value_x, y, value_x + value_w - (browse_w + 4), y + row_h};
            field->browse_rect = RECT{value_x + value_w - browse_w, y, value_x + value_w, y + row_h};
        } else {
            field->value_rect = RECT{value_x, y, value_x + value_w, y + row_h};
        }
        if (current_section != nullptr) {
            current_section->section_rect.bottom =
                std::max(current_section->section_rect.bottom, static_cast<LONG>(y + row_h + 12));
        }
        y += row_h + row_gap;
    }
    for (auto& item : state->form_layout) {
        if (item.is_section) {
            item.section_rect.bottom = std::max(item.section_rect.bottom, item.section_rect.top + 48);
        }
    }

    state->form_content_height = y + margin;
    form_update_scrollbar(state);
}

bool form_affects_clues_preset(int field_key);
void update_suggestions_for_grid_size(GuiAppState* state);

void form_destroy_inline_editor(GuiAppState* state, bool commit) {
    if (state == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, state->inline_field_key);
    int committed_field_key = 0;
    if (commit && field != nullptr) {
        if (state->inline_is_combo) {
            const int sel = static_cast<int>(SendMessageW(state->h_inline_editor, CB_GETCURSEL, 0, 0));
            if (sel >= 0 && sel < static_cast<int>(field->options.size())) {
                field->option_index = sel;
                committed_field_key = field->key;
            }
        } else {
            field->text = get_text(state->h_inline_editor);
            committed_field_key = field->key;
        }
    }
    DestroyWindow(state->h_inline_editor);
    state->h_inline_editor = nullptr;
    state->inline_field_key = 0;
    state->inline_is_combo = false;
    state->inline_close_posted = false;
    if (commit && !state->form_read_only && form_affects_clues_preset(committed_field_key)) {
        apply_clues_preset(state);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

void form_request_inline_close(GuiAppState* state, bool commit) {
    if (state == nullptr || state->h_form_panel == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    if (state->inline_close_posted) {
        return;
    }
    state->inline_close_posted = true;
    PostMessageW(state->h_form_panel, WM_APP_INLINE_CLOSE, commit ? 1 : 0, 0);
}

LRESULT CALLBACK form_inline_editor_subclass_proc(
    HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, UINT_PTR /*id*/, DWORD_PTR ref_data) {
    auto* state = reinterpret_cast<GuiAppState*>(ref_data);
    if (state != nullptr && msg == WM_KEYDOWN) {
        if (wParam == VK_TAB) {
            const bool back = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            form_request_inline_close(state, true);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, back ? static_cast<WPARAM>(0) : static_cast<WPARAM>(1), 0);
            return 0;
        }
        if (wParam == VK_ESCAPE) {
            form_request_inline_close(state, false);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, 0, 1);
            return 0;
        }
        if (!state->inline_is_combo && wParam == VK_RETURN) {
            form_request_inline_close(state, true);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, 0, 1);
            return 0;
        }
    }
    if (msg == WM_NCDESTROY) {
        RemoveWindowSubclass(hwnd, form_inline_editor_subclass_proc, IDSC_INLINE_EDITOR);
    }
    return DefSubclassProc(hwnd, msg, wParam, lParam);
}

void form_attach_inline_subclass(GuiAppState* state) {
    if (state == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    SetWindowSubclass(state->h_inline_editor, form_inline_editor_subclass_proc, IDSC_INLINE_EDITOR, reinterpret_cast<DWORD_PTR>(state));
}

RECT form_view_rect(const RECT& content_rect, int scroll_y) {
    RECT rc = content_rect;
    rc.top -= scroll_y;
    rc.bottom -= scroll_y;
    return rc;
}

void form_begin_inline_edit(GuiAppState* state, FormField* field) {
    if (state == nullptr || field == nullptr || state->h_form_panel == nullptr || state->form_read_only || !field->enabled) {
        return;
    }
    form_destroy_inline_editor(state, true);

    RECT rc = form_view_rect(field->value_rect, state->form_scroll_y);
    const DWORD style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL |
                        ((field->type == FormFieldType::Int) ? ES_NUMBER : 0);
    state->h_inline_editor = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        field->text.c_str(),
        style,
        rc.left,
        rc.top,
        std::max(60, static_cast<int>(rc.right - rc.left)),
        std::max(22, static_cast<int>(rc.bottom - rc.top)),
        state->h_form_panel,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_INLINE_EDIT)),
        GetModuleHandleW(nullptr),
        nullptr);
    if (state->h_inline_editor != nullptr) {
        form_attach_inline_subclass(state);
        HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        SendMessageW(state->h_inline_editor, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        SendMessageW(state->h_inline_editor, EM_SETSEL, 0, -1);
        SetFocus(state->h_inline_editor);
        state->inline_field_key = field->key;
        state->inline_is_combo = false;
        state->inline_close_posted = false;
    }
}

void form_begin_inline_combo(GuiAppState* state, FormField* field) {
    if (state == nullptr || field == nullptr || state->h_form_panel == nullptr || state->form_read_only || !field->enabled) {
        return;
    }
    form_destroy_inline_editor(state, true);

    RECT rc = form_view_rect(field->value_rect, state->form_scroll_y);
    state->h_inline_editor = CreateWindowExW(
        0,
        L"COMBOBOX",
        nullptr,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | CBS_DROPDOWNLIST | WS_VSCROLL,
        rc.left,
        rc.top,
        std::max(120, static_cast<int>(rc.right - rc.left)),
        260,
        state->h_form_panel,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_INLINE_EDIT)),
        GetModuleHandleW(nullptr),
        nullptr);
    if (state->h_inline_editor != nullptr) {
        form_attach_inline_subclass(state);
        HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        SendMessageW(state->h_inline_editor, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        for (const auto& opt : field->options) {
            SendMessageW(state->h_inline_editor, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(opt.c_str()));
        }
        SendMessageW(state->h_inline_editor, CB_SETCURSEL, field->option_index, 0);
        SetFocus(state->h_inline_editor);
        SendMessageW(state->h_inline_editor, CB_SHOWDROPDOWN, TRUE, 0);
        state->inline_field_key = field->key;
        state->inline_is_combo = true;
        state->inline_close_posted = false;
    }
}

void form_set_scroll(GuiAppState* state, int new_scroll) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    const int max_scroll = std::max(0, state->form_content_height - state->form_view_height);
    new_scroll = std::clamp(new_scroll, 0, max_scroll);
    if (new_scroll == state->form_scroll_y) {
        return;
    }
    form_destroy_inline_editor(state, true);
    state->form_scroll_y = new_scroll;
    SCROLLINFO si{};
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = state->form_scroll_y;
    SetScrollInfo(state->h_form_panel, SB_VERT, &si, TRUE);
    InvalidateRect(state->h_form_panel, nullptr, TRUE);
}

bool form_field_is_focusable(const GuiAppState* state, const FormField* field) {
    if (state == nullptr || field == nullptr) {
        return false;
    }
    if (field->key == F_REQUIRE_UNIQUE) {
        return false;
    }
    if (state->form_read_only) {
        return field->key == F_SHOW_MONITOR;
    }
    return field->enabled;
}

int form_first_focusable_key(const GuiAppState* state) {
    if (state == nullptr) {
        return 0;
    }
    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }
        const FormField* field = find_form_field(state, item.field_key);
        if (form_field_is_focusable(state, field)) {
            return item.field_key;
        }
    }
    return 0;
}

int form_next_focusable_key(const GuiAppState* state, int current_key, int direction) {
    if (state == nullptr) {
        return 0;
    }
    std::vector<int> keys;
    keys.reserve(state->form_layout.size());
    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }
        const FormField* field = find_form_field(state, item.field_key);
        if (form_field_is_focusable(state, field)) {
            keys.push_back(item.field_key);
        }
    }
    if (keys.empty()) {
        return 0;
    }
    int idx = -1;
    for (int i = 0; i < static_cast<int>(keys.size()); ++i) {
        if (keys[static_cast<size_t>(i)] == current_key) {
            idx = i;
            break;
        }
    }
    if (idx < 0) {
        return direction < 0 ? keys.back() : keys.front();
    }
    idx = (idx + (direction < 0 ? -1 : 1) + static_cast<int>(keys.size())) % static_cast<int>(keys.size());
    return keys[static_cast<size_t>(idx)];
}

void form_ensure_field_visible(GuiAppState* state, int field_key) {
    if (state == nullptr || state->h_form_panel == nullptr || field_key == 0) {
        return;
    }
    const FormField* field = find_form_field(state, field_key);
    if (field == nullptr) {
        return;
    }
    RECT rc = field->value_rect;
    if (rc.bottom <= rc.top) {
        return;
    }
    const int top = static_cast<int>(rc.top);
    const int bottom = static_cast<int>(rc.bottom);
    const int view_top = state->form_scroll_y;
    const int view_bottom = state->form_scroll_y + std::max(1, state->form_view_height);
    if (top < view_top + 8) {
        form_set_scroll(state, std::max(0, top - 8));
    } else if (bottom > view_bottom - 8) {
        form_set_scroll(state, bottom - std::max(1, state->form_view_height) + 8);
    }
}

void form_set_focused_field(GuiAppState* state, int field_key, bool ensure_visible) {
    if (state == nullptr) {
        return;
    }
    if (field_key != 0) {
        const FormField* field = find_form_field(state, field_key);
        if (!form_field_is_focusable(state, field)) {
            field_key = 0;
        }
    }
    if (field_key == 0) {
        field_key = form_first_focusable_key(state);
    }
    if (state->focused_field_key == field_key) {
        if (ensure_visible) {
            form_ensure_field_visible(state, field_key);
        }
        return;
    }
    state->focused_field_key = field_key;
    if (ensure_visible) {
        form_ensure_field_visible(state, field_key);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

void form_navigate_focus(GuiAppState* state, int direction) {
    if (state == nullptr) {
        return;
    }
    const int next_key = form_next_focusable_key(state, state->focused_field_key, direction);
    form_set_focused_field(state, next_key, true);
}

int form_hit_test_field_key(const GuiAppState* state, POINT pt_client, bool* hit_browse) {
    if (state == nullptr) {
        return 0;
    }
    POINT pt = pt_client;
    pt.y += state->form_scroll_y;
    if (hit_browse != nullptr) {
        *hit_browse = false;
    }

    const FormField* sym = find_form_field(state, F_SYMMETRY_CENTER);
    const FormField* req = find_form_field(state, F_REQUIRE_UNIQUE);
    if (sym != nullptr && PtInRect(&sym->value_rect, pt)) {
        return F_SYMMETRY_CENTER;
    }
    if (req != nullptr && PtInRect(&req->value_rect, pt)) {
        return F_REQUIRE_UNIQUE;
    }

    for (const auto& field : state->form_fields) {
        if (field.key == F_REQUIRE_UNIQUE || field.key == F_SYMMETRY_CENTER) {
            continue;
        }
        if (PtInRect(&field.value_rect, pt) || PtInRect(&field.label_rect, pt)) {
            return field.key;
        }
        if (field.has_browse && PtInRect(&field.browse_rect, pt)) {
            if (hit_browse != nullptr) {
                *hit_browse = true;
            }
            return field.key;
        }
    }
    return 0;
}

void form_set_hover_field(GuiAppState* state, int field_key) {
    if (state == nullptr) {
        return;
    }
    if (state->hover_field_key == field_key) {
        return;
    }
    state->hover_field_key = field_key;
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool form_affects_clues_preset(int field_key) {
    return field_key == F_CLUES_PRESET ||
           field_key == F_BOX_ROWS ||
           field_key == F_BOX_COLS ||
           field_key == F_DIFFICULTY ||
           field_key == F_REQUIRED_STRATEGY;
}

// Update clues suggestions based on grid size/level/strategy.
void update_suggestions_for_grid_size(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    const int box_rows = form_field_int(state, F_BOX_ROWS, 3);
    const int box_cols = form_field_int(state, F_BOX_COLS, 3);
    const int difficulty = difficulty_level_from_form(state);
    const RequiredStrategy required = required_strategy_from_form(state);
    const ClueRange suggested_clues = resolve_auto_clue_range(box_rows, box_cols, difficulty, required);
    
    // Update min/max clues fields (only if user hasn't modified them)
    const int current_min = form_field_int(state, F_MIN_CLUES, 0);
    const int current_max = form_field_int(state, F_MAX_CLUES, 0);
    if (current_min == 0) {
        set_form_field_text(state, F_MIN_CLUES, std::to_wstring(suggested_clues.min_clues));
    }
    if (current_max == 0) {
        set_form_field_text(state, F_MAX_CLUES, std::to_wstring(suggested_clues.max_clues));
    }
    
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool form_step_combo_value(GuiAppState* state, int field_key, int delta) {
    if (state == nullptr || delta == 0) {
        return false;
    }
    FormField* field = find_form_field(state, field_key);
    if (field == nullptr || field->type != FormFieldType::Combo || field->options.empty()) {
        return false;
    }
    const int count = static_cast<int>(field->options.size());
    int idx = field->option_index;
    idx = (idx + delta + count) % count;
    if (idx == field->option_index) {
        return false;
    }
    field->option_index = idx;
    if (!state->form_read_only && form_affects_clues_preset(field_key)) {
        apply_clues_preset(state);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
    return true;
}

void form_activate_focused_field(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, state->focused_field_key);
    if (field == nullptr || !form_field_is_focusable(state, field)) {
        return;
    }
    switch (field->type) {
    case FormFieldType::Int:
    case FormFieldType::Text:
        form_begin_inline_edit(state, field);
        break;
    case FormFieldType::Combo:
        form_begin_inline_combo(state, field);
        break;
    case FormFieldType::Checkbox:
        if (field->enabled) {
            field->checked = !field->checked;
            if (field->key == F_SHOW_MONITOR) {
                sync_live_monitor_visual_state(state);
            }
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        break;
    case FormFieldType::ActionButton:
        if (!state->form_read_only) {
            apply_clues_preset(state);
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        break;
    default:
        break;
    }
}

void form_draw_checkbox(HDC hdc, const RECT& row_rc, const std::wstring& text, bool checked, bool enabled) {
    RECT box = row_rc;
    box.left += 2;
    box.top += 4;
    box.right = box.left + 16;
    box.bottom = box.top + 16;
    UINT state = DFCS_BUTTONCHECK;
    if (checked) {
        state |= DFCS_CHECKED;
    }
    if (!enabled) {
        state |= DFCS_INACTIVE;
    }
    DrawFrameControl(hdc, &box, DFC_BUTTON, state);

    RECT text_rc = row_rc;
    text_rc.left = box.right + 8;
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, enabled ? RGB(20, 20, 20) : RGB(130, 130, 130));
    DrawTextW(hdc, text.c_str(), -1, &text_rc, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
}

void form_draw_outline(HDC hdc, const RECT& rc, COLORREF color) {
    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HGDIOBJ old_pen = SelectObject(hdc, pen);
    HGDIOBJ old_brush = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hdc, old_brush);
    SelectObject(hdc, old_pen);
    DeleteObject(pen);
}

void form_handle_click(GuiAppState* state, POINT pt_client) {
    if (state == nullptr) {
        return;
    }
    bool hit_browse = false;
    const int hit_key = form_hit_test_field_key(state, pt_client, &hit_browse);
    form_destroy_inline_editor(state, true);
    if (hit_key == 0) {
        form_set_focused_field(state, 0, false);
        return;
    }
    form_set_focused_field(state, hit_key, true);

    FormField* field = find_form_field(state, hit_key);
    if (field == nullptr) {
        return;
    }
    if (hit_key == F_REQUIRE_UNIQUE) {
        return;
    }
    if (state->form_read_only && hit_key != F_SHOW_MONITOR) {
        return;
    }
    if (hit_browse && field->has_browse) {
        if (state->form_read_only) {
            return;
        }
        std::wstring path;
        if (field->key == F_OUTPUT_FOLDER) {
            if (browse_for_folder(state->hwnd, path)) {
                field->text = path;
                InvalidateRect(state->h_form_panel, nullptr, TRUE);
            }
        } else if (field->key == F_OUTPUT_FILE) {
            if (browse_for_save_file(state->hwnd, path)) {
                std::filesystem::path p(path);
                field->text = p.filename().wstring();
                set_form_field_text(state, F_OUTPUT_FOLDER, p.parent_path().wstring());
                InvalidateRect(state->h_form_panel, nullptr, TRUE);
            }
        }
        return;
    }

    POINT pt = pt_client;
    pt.y += state->form_scroll_y;
    const bool clicked_value = PtInRect(&field->value_rect, pt);
    if (!clicked_value && field->type != FormFieldType::Checkbox) {
        return;
    }

    switch (field->type) {
    case FormFieldType::Int:
    case FormFieldType::Text:
        form_begin_inline_edit(state, field);
        return;
    case FormFieldType::Combo:
        form_begin_inline_combo(state, field);
        return;
    case FormFieldType::Checkbox:
        if (field->enabled) {
            field->checked = !field->checked;
            if (field->key == F_SHOW_MONITOR) {
                sync_live_monitor_visual_state(state);
            }
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        return;
    case FormFieldType::ActionButton:
        apply_clues_preset(state);
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
        return;
    default:
        return;
    }
}

void form_paint(HWND hwnd, GuiAppState* state) {
    PAINTSTRUCT ps{};
    HDC hdc = BeginPaint(hwnd, &ps);
    RECT client{};
    GetClientRect(hwnd, &client);
    const int width = std::max(1, static_cast<int>(client.right - client.left));
    const int height = std::max(1, static_cast<int>(client.bottom - client.top));

    HDC mem = CreateCompatibleDC(hdc);
    HBITMAP bmp = CreateCompatibleBitmap(hdc, width, height);
    HGDIOBJ old_bmp = SelectObject(mem, bmp);

    HBRUSH bg = CreateSolidBrush(RGB(242, 246, 250));
    FillRect(mem, &client, bg);
    DeleteObject(bg);

    HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
    HGDIOBJ old_font = SelectObject(mem, font);

    const int scroll_y = state->form_scroll_y;

    for (const auto& item : state->form_layout) {
        if (!item.is_section) {
            continue;
        }
        RECT sec = form_view_rect(item.section_rect, scroll_y);
        if (sec.bottom < 0 || sec.top > height) {
            continue;
        }
        FrameRect(mem, &sec, reinterpret_cast<HBRUSH>(GetStockObject(GRAY_BRUSH)));
        RECT title_bg{sec.left + 10, sec.top - 9, sec.left + 320, sec.top + 10};
        HBRUSH bg_br = CreateSolidBrush(RGB(242, 246, 250));
        FillRect(mem, &title_bg, bg_br);
        DeleteObject(bg_br);
        RECT title_txt = title_bg;
        title_txt.left += 4;
        SetBkMode(mem, TRANSPARENT);
        SetTextColor(mem, RGB(25, 36, 48));
        DrawTextW(mem, item.section_title.c_str(), -1, &title_txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
    }

    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }

        FormField* field = find_form_field(state, item.field_key);
        if (field == nullptr || item.field_key == F_REQUIRE_UNIQUE) {
            continue;
        }
        RECT label_rc = form_view_rect(field->label_rect, scroll_y);
        RECT value_rc = form_view_rect(field->value_rect, scroll_y);
        RECT browse_rc = form_view_rect(field->browse_rect, scroll_y);
        const bool is_hover = (state->hover_field_key == field->key);
        const bool is_focus = (state->focused_field_key == field->key);
        if (value_rc.bottom < 0 || value_rc.top > height) {
            continue;
        }

        if (item.field_key == F_SYMMETRY_CENTER) {
            FormField* req_unique = find_form_field(state, F_REQUIRE_UNIQUE);
            form_draw_checkbox(mem, value_rc, field->label, field->checked, !state->form_read_only && field->enabled);
            if (req_unique != nullptr) {
                RECT req_rc = form_view_rect(req_unique->value_rect, scroll_y);
                form_draw_checkbox(mem, req_rc, req_unique->label, req_unique->checked, false);
            }
            if (is_focus || is_hover) {
                form_draw_outline(mem, value_rc, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
            }
            continue;
        }

        if (field->type == FormFieldType::Checkbox) {
            form_draw_checkbox(mem, value_rc, field->label, field->checked, !state->form_read_only && field->enabled);
            if (is_focus || is_hover) {
                form_draw_outline(mem, value_rc, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
            }
            continue;
        }

        SetBkMode(mem, TRANSPARENT);
        SetTextColor(mem, RGB(26, 26, 26));
        DrawTextW(mem, field->label.c_str(), -1, &label_rc, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

        RECT frame = value_rc;
        if (field->type == FormFieldType::ActionButton) {
            HBRUSH btn_br = CreateSolidBrush(
                state->form_read_only ? RGB(214, 220, 226) : (is_hover ? RGB(196, 216, 236) : RGB(206, 223, 238)));
            FillRect(mem, &frame, btn_br);
            DeleteObject(btn_br);
            DrawEdge(mem, &frame, EDGE_RAISED, BF_RECT);
            RECT txt = frame;
            txt.left += 8;
            SetTextColor(mem, RGB(20, 34, 50));
            DrawTextW(mem, field->text.c_str(), -1, &txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
        } else {
            COLORREF field_bg = field->enabled ? (is_hover ? RGB(248, 252, 255) : RGB(255, 255, 255)) : RGB(236, 236, 236);
            HBRUSH white_br = CreateSolidBrush(field_bg);
            FillRect(mem, &frame, white_br);
            DeleteObject(white_br);
            form_draw_outline(mem, frame, RGB(140, 140, 140));
            RECT txt = frame;
            txt.left += 6;
            txt.right -= 6;
            std::wstring display;
            if (field->type == FormFieldType::Combo) {
                if (!field->options.empty() && field->option_index >= 0 && field->option_index < static_cast<int>(field->options.size())) {
                    display = field->options[static_cast<size_t>(field->option_index)];
                }
            } else {
                display = field->text;
            }
            SetTextColor(mem, field->enabled ? RGB(22, 22, 22) : RGB(130, 130, 130));
            DrawTextW(mem, display.c_str(), -1, &txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
            if (field->type == FormFieldType::Combo) {
                RECT arrow = frame;
                arrow.left = arrow.right - 20;
                DrawFrameControl(mem, &arrow, DFC_SCROLL, DFCS_SCROLLCOMBOBOX);
            }
        }
        if (is_focus || is_hover) {
            form_draw_outline(mem, frame, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
        }

        if (field->has_browse) {
            const bool browse_hover = is_hover;
            HBRUSH b = CreateSolidBrush(state->form_read_only ? RGB(214, 220, 226) : (browse_hover ? RGB(216, 226, 236) : RGB(226, 232, 238)));
            FillRect(mem, &browse_rc, b);
            DeleteObject(b);
            DrawEdge(mem, &browse_rc, EDGE_RAISED, BF_RECT);
            RECT dots = browse_rc;
            DrawTextW(mem, L"...", -1, &dots, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
        }
    }

    BitBlt(hdc, 0, 0, width, height, mem, 0, 0, SRCCOPY);
    SelectObject(mem, old_font);
    SelectObject(mem, old_bmp);
    DeleteObject(bmp);
    DeleteDC(mem);
    EndPaint(hwnd, &ps);
}

LRESULT CALLBACK form_panel_wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    auto* state = reinterpret_cast<GuiAppState*>(GetWindowLongPtrW(hwnd, GWLP_USERDATA));
    switch (msg) {
    case WM_CREATE: {
        auto* cs = reinterpret_cast<CREATESTRUCTW*>(lParam);
        auto* s = reinterpret_cast<GuiAppState*>(cs->lpCreateParams);
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(s));
        return 0;
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_GETDLGCODE:
        return static_cast<LRESULT>(DLGC_WANTTAB | DLGC_WANTARROWS | DLGC_WANTCHARS);
    case WM_SETFOCUS:
        if (state != nullptr) {
            if (!form_field_is_focusable(state, find_form_field(state, state->focused_field_key))) {
                form_set_focused_field(state, form_first_focusable_key(state), false);
            } else {
                InvalidateRect(hwnd, nullptr, TRUE);
            }
        }
        return 0;
    case WM_KILLFOCUS:
        if (state != nullptr) {
            InvalidateRect(hwnd, nullptr, TRUE);
        }
        return 0;
    case WM_SIZE:
        if (state != nullptr) {
            form_layout_fields(state);
            if (!form_field_is_focusable(state, find_form_field(state, state->focused_field_key))) {
                form_set_focused_field(state, form_first_focusable_key(state), false);
            }
            InvalidateRect(hwnd, nullptr, TRUE);
        }
        return 0;
    case WM_VSCROLL:
        if (state != nullptr) {
            SCROLLINFO si{};
            si.cbSize = sizeof(si);
            si.fMask = SIF_ALL;
            GetScrollInfo(hwnd, SB_VERT, &si);
            int pos = state->form_scroll_y;
            switch (LOWORD(wParam)) {
            case SB_TOP:
                pos = 0;
                break;
            case SB_BOTTOM:
                pos = si.nMax;
                break;
            case SB_LINEUP:
                pos -= 26;
                break;
            case SB_LINEDOWN:
                pos += 26;
                break;
            case SB_PAGEUP:
                pos -= static_cast<int>(si.nPage);
                break;
            case SB_PAGEDOWN:
                pos += static_cast<int>(si.nPage);
                break;
            case SB_THUMBTRACK:
            case SB_THUMBPOSITION:
                pos = si.nTrackPos;
                break;
            default:
                break;
            }
            form_set_scroll(state, pos);
        }
        return 0;
    case WM_MOUSEWHEEL:
        if (state != nullptr) {
            const int delta = GET_WHEEL_DELTA_WPARAM(wParam);
            const int lines = delta / WHEEL_DELTA;
            form_set_scroll(state, state->form_scroll_y - lines * 48);
        }
        return 0;
    case WM_MOUSEMOVE:
        if (state != nullptr) {
            if (!state->mouse_tracking) {
                TRACKMOUSEEVENT tme{};
                tme.cbSize = sizeof(tme);
                tme.dwFlags = TME_LEAVE;
                tme.hwndTrack = hwnd;
                TrackMouseEvent(&tme);
                state->mouse_tracking = true;
            }
            POINT pt{GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
            form_set_hover_field(state, form_hit_test_field_key(state, pt, nullptr));
        }
        return 0;
    case WM_MOUSELEAVE:
        if (state != nullptr) {
            state->mouse_tracking = false;
            form_set_hover_field(state, 0);
        }
        return 0;
    case WM_LBUTTONDOWN:
        if (state != nullptr) {
            POINT pt{GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
            form_handle_click(state, pt);
            if (state->h_inline_editor == nullptr) {
                SetFocus(hwnd);
            }
        }
        return 0;
    case WM_KEYDOWN:
        if (state != nullptr) {
            if (wParam == VK_TAB) {
                const bool back = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                form_navigate_focus(state, back ? -1 : 1);
                return 0;
            }
            if (wParam == VK_UP || wParam == VK_DOWN) {
                const int delta = (wParam == VK_UP) ? -1 : 1;
                if (form_step_combo_value(state, state->focused_field_key, delta)) {
                    return 0;
                }
                form_set_scroll(state, state->form_scroll_y + (delta < 0 ? -26 : 26));
                return 0;
            }
            if (wParam == VK_RETURN || wParam == VK_SPACE) {
                form_activate_focused_field(state);
                return 0;
            }
        }
        break;
    case WM_APP_INLINE_CLOSE:
        if (state != nullptr) {
            const bool commit = (wParam != 0);
            form_destroy_inline_editor(state, commit);
        }
        return 0;
    case WM_APP_FORM_NAV:
        if (state != nullptr) {
            if (lParam != 0) {
                SetFocus(hwnd);
                return 0;
            }
            form_navigate_focus(state, (wParam == 0) ? -1 : 1);
            SetFocus(hwnd);
        }
        return 0;
    case WM_COMMAND:
        if (state != nullptr && LOWORD(wParam) == IDC_INLINE_EDIT) {
            const int code = HIWORD(wParam);
            if (!state->inline_is_combo && code == EN_KILLFOCUS) {
                form_request_inline_close(state, true);
                return 0;
            }
            if (state->inline_is_combo) {
                if (code == CBN_SELENDOK) {
                    form_request_inline_close(state, true);
                    return 0;
                }
                if (code == CBN_SELENDCANCEL) {
                    form_request_inline_close(state, false);
                    return 0;
                }
                if (code == CBN_KILLFOCUS && !state->inline_close_posted) {
                    const LRESULT dropped = SendMessageW(state->h_inline_editor, CB_GETDROPPEDSTATE, 0, 0);
                    if (dropped != 0) {
                        return 0;
                    }
                    form_request_inline_close(state, true);
                    return 0;
                }
            }
        }
        break;
    case WM_PAINT:
        if (state != nullptr) {
            form_paint(hwnd, state);
            return 0;
        }
        break;
    default:
        break;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void layout_gui_controls(GuiAppState* s) {
    if (s == nullptr) {
        return;
    }
    RECT client{};
    GetClientRect(s->hwnd, &client);
    const int margin = 12;
    const int gap = 8;
    const int client_w = std::max(1, static_cast<int>(client.right - client.left));
    const int client_h = std::max(1, static_cast<int>(client.bottom - client.top));
    const int content_w = std::max(1, client_w - margin * 2);

    const int btn_h = 30;
    const int btn_w = 100;
    const int btn_y = std::max(margin, client_h - margin - btn_h);
    const int btn_total = btn_w * 3 + 20 * 2;
    const int btn_x0 = std::max(margin, client_w / 2 - btn_total / 2);
    SetWindowPos(s->h_start, nullptr, btn_x0, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);
    SetWindowPos(s->h_cancel, nullptr, btn_x0 + btn_w + 20, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);
    SetWindowPos(s->h_pause, nullptr, btn_x0 + btn_w * 2 + 40, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);

    const int body_bottom = std::max(margin, btn_y - gap);
    int y = margin;
    int remain = body_bottom - y;
    const int progress_pack_h = 54;
    const int fixed_spacing = gap * 3;
    const int usable = std::max(40, remain - progress_pack_h - fixed_spacing);
    int form_h = std::max(40, (usable * 58) / 100);
    int monitor_h = std::max(0, (usable * 24) / 100);
    int log_h = std::max(0, usable - form_h - monitor_h);
    if (log_h < 36) {
        const int need = 36 - log_h;
        const int take_from_form = std::min(need, std::max(0, form_h - 60));
        form_h -= take_from_form;
        log_h += take_from_form;
    }
    if (log_h < 36) {
        const int need = 36 - log_h;
        const int take_from_monitor = std::min(need, std::max(0, monitor_h - 40));
        monitor_h -= take_from_monitor;
        log_h += take_from_monitor;
    }
    if (form_h < 40) {
        const int need = 40 - form_h;
        const int take = std::min(need, std::max(0, monitor_h - 20));
        monitor_h -= take;
        form_h += take;
    }
    log_h = std::max(0, usable - form_h - monitor_h);

    SetWindowPos(s->h_form_panel, nullptr, margin, y, content_w, form_h, SWP_NOZORDER | SWP_NOACTIVATE);
    y += form_h + gap;
    SetWindowPos(s->h_progress_text, nullptr, margin + 4, y, 380, 22, SWP_NOZORDER | SWP_NOACTIVATE);
    y += 24;
    SetWindowPos(s->h_progress, nullptr, margin, y, content_w, 20, SWP_NOZORDER | SWP_NOACTIVATE);
    y += 20 + gap;
    SetWindowPos(s->h_monitor, nullptr, margin, y, content_w, monitor_h, SWP_NOZORDER | SWP_NOACTIVATE);
    ShowWindow(s->h_monitor, monitor_h > 0 ? SW_SHOW : SW_HIDE);
    y += monitor_h + gap;
    const int final_log_h = std::max(0, body_bottom - y);
    SetWindowPos(s->h_log, nullptr, margin, y, content_w, final_log_h, SWP_NOZORDER | SWP_NOACTIVATE);
    ShowWindow(s->h_log, final_log_h > 0 ? SW_SHOW : SW_HIDE);

    form_layout_fields(s);
}

void create_gui_controls(GuiAppState* s) {
    HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
    init_form_model(s);

    s->h_form_panel = CreateWindowExW(
        0,
        L"SudokuHpcFormPanelClass",
        nullptr,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0,
        0,
        100,
        100,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_FORM_PANEL)),
        GetModuleHandleW(nullptr),
        s);

    s->h_progress_text = CreateWindowExW(
        0,
        L"STATIC",
        L"Wygenerowano 0/0",
        WS_CHILD | WS_VISIBLE,
        0,
        0,
        260,
        22,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_PROGRESS_TEXT)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_progress = CreateWindowExW(
        0,
        PROGRESS_CLASSW,
        nullptr,
        WS_CHILD | WS_VISIBLE,
        0,
        0,
        260,
        20,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_PROGRESS_BAR)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_monitor = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        L"",
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        0,
        0,
        260,
        120,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_MONITOR_BOX)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_log = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        L"",
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        0,
        0,
        260,
        90,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_LOG_BOX)),
        GetModuleHandleW(nullptr),
        nullptr);

    s->h_start = CreateWindowExW(
        0,
        L"BUTTON",
        L"Start",
        WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_START)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_cancel = CreateWindowExW(
        0,
        L"BUTTON",
        L"Anuluj",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_CANCEL)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_pause = CreateWindowExW(
        0,
        L"BUTTON",
        L"Pauza",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_PAUSE)),
        GetModuleHandleW(nullptr),
        nullptr);

    const HWND controls[] = {s->h_progress_text, s->h_progress, s->h_monitor, s->h_log, s->h_start, s->h_cancel, s->h_pause};
    for (HWND h : controls) {
        if (h != nullptr) {
            SendMessageW(h, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        }
    }

    HFONT mono_font = CreateFontW(
        -14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        FF_DONTCARE, L"Consolas");
    if (mono_font != nullptr) {
        s->h_mono_font = mono_font;
        SendMessageW(s->h_monitor, WM_SETFONT, reinterpret_cast<WPARAM>(mono_font), TRUE);
    }

    SendMessageW(s->h_progress, PBM_SETRANGE32, 0, 100);
    SendMessageW(s->h_progress, PBM_SETPOS, 0, 0);
    EnableWindow(s->h_cancel, FALSE);
    layout_gui_controls(s);
    form_set_focused_field(s, form_first_focusable_key(s), false);
    sync_live_monitor_visual_state(s);
    apply_clues_preset(s);
}

LRESULT CALLBACK gui_wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    auto* state = reinterpret_cast<GuiAppState*>(GetWindowLongPtrW(hwnd, GWLP_USERDATA));
    switch (msg) {
    case WM_CREATE: {
        auto* s = new GuiAppState();
        s->hwnd = hwnd;
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(s));
        create_gui_controls(s);
        append_log(s, L"GUI gotowe.");
        append_log(s, L"Author copyright Marcin Matysek (Rewertyn)");
        append_log(s, L"Typ seed: uint64_t (unsigned 64-bit).");
        return 0;
    }
    case WM_COMMAND:
        if (state == nullptr) {
            break;
        }
        if (LOWORD(wParam) == IDC_BTN_START) {
            start_generation(state);
            return 0;
        }
        if (LOWORD(wParam) == IDC_BTN_CANCEL) {
            cancel_generation(state);
            return 0;
        }
        if (LOWORD(wParam) == IDC_BTN_PAUSE) {
            toggle_pause(state);
            return 0;
        }
        break;
    case WM_APP_PROGRESS:
        if (state == nullptr) {
            return 0;
        }
        SendMessageW(state->h_progress, PBM_SETRANGE32, 0, static_cast<LPARAM>(std::min<uint64_t>(static_cast<uint64_t>(lParam), 0x7fffffffULL)));
        SendMessageW(state->h_progress, PBM_SETPOS, static_cast<WPARAM>(std::min<uint64_t>(static_cast<uint64_t>(wParam), 0x7fffffffULL)), 0);
        set_text(state->h_progress_text, L"Wygenerowano " + std::to_wstring(static_cast<uint64_t>(wParam)) + L"/" + std::to_wstring(static_cast<uint64_t>(lParam)));
        if (is_live_monitor_enabled(state)) {
            std::shared_ptr<ConsoleStatsMonitor> monitor;
            {
                std::lock_guard<std::mutex> lock(state->monitor_mu);
                monitor = state->gui_monitor;
            }
            if (monitor != nullptr) {
                set_monitor_text(state, utf8_to_wide(monitor->snapshot_text()));
            }
        }
        return 0;
    case WM_APP_LOG:
        if (state == nullptr) {
            return 0;
        } else {
            std::unique_ptr<std::wstring> payload(reinterpret_cast<std::wstring*>(lParam));
            if (payload) {
                append_log(state, *payload);
            }
        }
        return 0;
    case WM_APP_DONE:
        if (state == nullptr) {
            return 0;
        }
        KillTimer(hwnd, IDT_MONITOR_REFRESH);
        {
            std::unique_ptr<GenerateRunResult> result(reinterpret_cast<GenerateRunResult*>(wParam));
            set_running_state(state, false);
            if (result) {
                append_log(state, L"Zakonczono: accepted=" + std::to_wstring(result->accepted) + L", attempts=" + std::to_wstring(result->attempts));
                set_text(state->h_progress_text, L"Wygenerowano " + std::to_wstring(result->written) + L"/" + std::to_wstring(state->target));
                SendMessageW(state->h_progress, PBM_SETPOS, static_cast<WPARAM>(std::min<uint64_t>(result->written, 0x7fffffffULL)), 0);
            }
        }
        if (state->run_thread.joinable()) {
            state->run_thread.join();
        }
        return 0;
    case WM_TIMER:
        if (state != nullptr && wParam == IDT_MONITOR_REFRESH) {
            if (is_live_monitor_enabled(state)) {
                std::shared_ptr<ConsoleStatsMonitor> monitor;
                {
                    std::lock_guard<std::mutex> lock(state->monitor_mu);
                    monitor = state->gui_monitor;
                }
                if (monitor != nullptr) {
                    set_monitor_text(state, utf8_to_wide(monitor->snapshot_text()));
                }
            }
            return 0;
        }
        break;
    case WM_SIZE:
        if (state != nullptr) {
            layout_gui_controls(state);
        }
        return 0;
    case WM_CLOSE:
        if (state != nullptr && state->running.load(std::memory_order_relaxed)) {
            if (MessageBoxW(hwnd, L"Generowanie trwa. Zamknac i anulowac?", L"Potwierdzenie", MB_ICONQUESTION | MB_YESNO) == IDYES) {
                cancel_generation(state);
                DestroyWindow(hwnd);
            }
            return 0;
        }
        DestroyWindow(hwnd);
        return 0;
    case WM_DESTROY:
        if (state != nullptr) {
            KillTimer(hwnd, IDT_MONITOR_REFRESH);
            state->cancel_requested.store(true, std::memory_order_relaxed);
            if (state->run_thread.joinable()) {
                state->run_thread.request_stop();
                state->run_thread.join();
            }
            if (state->h_mono_font != nullptr) {
                DeleteObject(state->h_mono_font);
                state->h_mono_font = nullptr;
            }
            delete state;
            SetWindowLongPtrW(hwnd, GWLP_USERDATA, 0);
        }
        PostQuitMessage(0);
        return 0;
    default:
        break;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

int run_gui_winapi(HINSTANCE hinst) {
    CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

    INITCOMMONCONTROLSEX icc{};
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_PROGRESS_CLASS | ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icc);

    const wchar_t* panel_cls = L"SudokuHpcFormPanelClass";
    WNDCLASSW wc_panel{};
    wc_panel.lpfnWndProc = form_panel_wnd_proc;
    wc_panel.hInstance = hinst;
    wc_panel.lpszClassName = panel_cls;
    wc_panel.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc_panel.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
    RegisterClassW(&wc_panel);

    const wchar_t* cls = L"SudokuHpcGuiWndClass";
    WNDCLASSW wc{};
    wc.lpfnWndProc = gui_wnd_proc;
    wc.hInstance = hinst;
    wc.lpszClassName = cls;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
    RegisterClassW(&wc);

    RECT work{};
    SystemParametersInfoW(SPI_GETWORKAREA, 0, &work, 0);
    const int work_w = std::max(640, static_cast<int>(work.right - work.left));
    const int work_h = std::max(480, static_cast<int>(work.bottom - work.top));
    const int wnd_w = std::min(1040, std::max(760, work_w - 32));
    const int wnd_h = std::min(860, std::max(560, work_h - 32));
    const int wnd_x = work.left + std::max(0, (work_w - wnd_w) / 2);
    const int wnd_y = work.top + std::max(0, (work_h - wnd_h) / 2);

    HWND hwnd = CreateWindowExW(
        0,
        cls,
        L"Sudoku HPC Generator - GUI",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        wnd_x,
        wnd_y,
        wnd_w,
        wnd_h,
        nullptr,
        nullptr,
        hinst,
        nullptr);
    if (hwnd == nullptr) {
        return 1;
    }
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    CoUninitialize();
    return static_cast<int>(msg.wParam);
}

void ensure_console_attached() {
    if (GetConsoleWindow() != nullptr) {
        return;
    }
    if (!AllocConsole()) {
        return;
    }
    std::freopen("CONIN$", "r", stdin);
    std::freopen("CONOUT$", "w", stdout);
    std::freopen("CONOUT$", "w", stderr);
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
    std::ios::sync_with_stdio(true);
}

bool is_parent_explorer() {
    const DWORD self_pid = GetCurrentProcessId();
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD parent_pid = 0;
    PROCESSENTRY32W pe{};
    pe.dwSize = sizeof(pe);
    if (Process32FirstW(snapshot, &pe)) {
        do {
            if (pe.th32ProcessID == self_pid) {
                parent_pid = pe.th32ParentProcessID;
                break;
            }
        } while (Process32NextW(snapshot, &pe));
    }

    std::wstring parent_name;
    if (parent_pid != 0) {
        pe.dwSize = sizeof(pe);
        if (Process32FirstW(snapshot, &pe)) {
            do {
                if (pe.th32ProcessID == parent_pid) {
                    parent_name = pe.szExeFile;
                    break;
                }
            } while (Process32NextW(snapshot, &pe));
        }
    }
    CloseHandle(snapshot);

    if (parent_name.empty()) {
        return false;
    }
    std::transform(parent_name.begin(), parent_name.end(), parent_name.begin(), [](wchar_t ch) {
        return static_cast<wchar_t>(std::towlower(ch));
    });
    return parent_name == L"explorer.exe";
}
#endif

bool has_arg(int argc, char** argv, const char* key) {
    for (int i = 1; i < argc; ++i) {
        if (std::string_view(argv[i]) == key) {
            return true;
        }
    }
    return false;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\gui.h
==============================================================================

﻿#pragma once

#include "utils/logging.h"
#include "config/run_config.h"
#include "core/geometry.h"
#include "monitor.h"
#include "generator/runtime_runner.h"

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <tlhelp32.h>
#include <shlobj.h>
#include <commdlg.h>
#endif

#include "gui-old.h"



==============================================================================
PLIK: Sources\logic\logic_result.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// File: logic_result.h
// Description: Result and telemetry structures for the logical solver.
// ============================================================================

#pragma once

#include <array>
#include <cstddef>
#include <cstdint>
#include <string_view>
#include <vector>

namespace sudoku_hpc::logic {

enum class ApplyResult : uint8_t {
    NoProgress = 0,
    Progress = 1,
    Contradiction = 2
};

enum class StrategyImplTier : uint8_t {
    Full = 0,
    Hybrid = 1,
    Proxy = 2,
    Disabled = 3,
};

inline constexpr size_t impl_tier_index(StrategyImplTier tier) {
    return static_cast<size_t>(tier);
}

inline constexpr size_t kStrategySlotCount = 61;
inline constexpr size_t kMaxStepTrace = 4096;

struct StrategyStats {
    uint64_t use_count = 0;
    uint64_t hit_count = 0;
    uint64_t placements = 0;
    uint64_t elapsed_ns = 0;
};

struct StepTrace {
    uint16_t slot = 0;
    StrategyImplTier impl_tier = StrategyImplTier::Full;
    ApplyResult result = ApplyResult::NoProgress;
    uint16_t placements_delta = 0;
    uint16_t hit_delta = 0;
    uint32_t step_index = 0;
    std::string_view proof_tag{};
};

struct GenericLogicCertifyResult {
    bool solved = false;
    bool timed_out = false;

    // Per-strategy usage flags.
    bool used_naked_single = false;
    bool used_hidden_single = false;
    bool used_pointing_pairs = false;
    bool used_box_line = false;
    bool used_naked_pair = false;
    bool used_hidden_pair = false;
    bool used_naked_triple = false;
    bool used_hidden_triple = false;
    bool used_naked_quad = false;
    bool used_hidden_quad = false;
    bool used_x_wing = false;
    bool used_y_wing = false;
    bool used_skyscraper = false;
    bool used_two_string_kite = false;
    bool used_empty_rectangle = false;
    bool used_remote_pairs = false;
    bool used_swordfish = false;
    bool used_finned_x_wing_sashimi = false;
    bool used_simple_coloring = false;
    bool used_bug_plus_one = false;
    bool used_unique_rectangle = false;
    bool used_xyz_wing = false;
    bool used_w_wing = false;
    bool used_jellyfish = false;
    bool used_x_chain = false;
    bool used_xy_chain = false;
    bool used_wxyz_wing = false;
    bool used_finned_swordfish_jellyfish = false;
    bool used_als_xz = false;
    bool used_unique_loop = false;
    bool used_avoidable_rectangle = false;
    bool used_bivalue_oddagon = false;
    bool used_medusa_3d = false;
    bool used_aic = false;
    bool used_grouped_aic = false;
    bool used_grouped_x_cycle = false;
    bool used_continuous_nice_loop = false;
    bool used_als_xy_wing = false;
    bool used_als_chain = false;
    bool used_sue_de_coq = false;
    bool used_death_blossom = false;
    bool used_franken_fish = false;
    bool used_mutant_fish = false;
    bool used_kraken_fish = false;
    bool used_msls = false;
    bool used_exocet = false;
    bool used_senior_exocet = false;
    bool used_sk_loop = false;
    bool used_pattern_overlay_method = false;
    bool used_forcing_chains = false;
    bool used_squirmbag = false;
    bool used_ur_extended = false;
    bool used_hidden_ur = false;
    bool used_bug_type2 = false;
    bool used_bug_type3 = false;
    bool used_bug_type4 = false;
    bool used_borescoper_qiu_deadly_pattern = false;
    bool used_aligned_pair_exclusion = false;
    bool used_aligned_triple_exclusion = false;
    bool used_als_aic = false;
    bool used_dynamic_forcing_chains = false;

    bool naked_single_scanned = false;
    bool hidden_single_scanned = false;

    int steps = 0;
    std::vector<uint16_t> solved_grid; // kept for replay validation

    // Fixed-size strategy stats matching GenericLogicCertify::StrategySlot.
    std::array<StrategyStats, kStrategySlotCount> strategy_stats{};

    // Telemetry: number of successful progress events grouped by impl tier.
    std::array<uint64_t, 4> impl_tier_hits{};

    // Telemetry: bounded step trace (no dynamic allocation in hot path).
    std::array<StepTrace, kMaxStepTrace> step_trace{};
    uint32_t step_trace_count = 0;
    uint32_t step_trace_dropped = 0;

    inline void record_step(
        uint16_t slot,
        StrategyImplTier tier,
        ApplyResult result_kind,
        uint16_t placements_delta,
        uint16_t hit_delta,
        std::string_view proof_tag) {
        if (result_kind == ApplyResult::Progress) {
            ++impl_tier_hits[impl_tier_index(tier)];
        }
        if (step_trace_count >= step_trace.size()) {
            ++step_trace_dropped;
            return;
        }
        StepTrace& row = step_trace[step_trace_count++];
        row.slot = slot;
        row.impl_tier = tier;
        row.result = result_kind;
        row.placements_delta = placements_delta;
        row.hit_delta = hit_delta;
        row.step_index = static_cast<uint32_t>(steps);
        row.proof_tag = proof_tag;
    }
};

} // namespace sudoku_hpc::logic



==============================================================================
PLIK: Sources\logic\p1_easy\naked_hidden_single.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: naked_hidden_single.h (Poziom 1)
// Opis: Rozwiązywanie na zasadzie gołych (Naked) lub ukrytych (Hidden) Singli.
//       Absolutnie pierwsza linia obrony przy certyfikacji. Zero-allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p1_easy {

inline ApplyResult apply_naked_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Szukamy komórki, która ma dostępnego tylko jednego kandydata
    for (int idx = 0; idx < st.topo->nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        
        const uint64_t m = st.cands[idx];
        if (m == 0ULL) { 
            s.elapsed_ns += st.now_ns() - t0; 
            return ApplyResult::Contradiction; 
        }
        
        const int d = config::single_digit(m);
        if (d == 0) continue; // Posiada wielu kandydatów
        
        // Czas na postawienie jedynego dostępnego kandydata
        if (!st.place(idx, d)) { 
            s.elapsed_ns += st.now_ns() - t0; 
            return ApplyResult::Contradiction; 
        }
        
        ++s.hit_count; 
        ++s.placements; 
        ++r.steps; 
        r.used_naked_single = true;
        
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_hidden_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    
    // Szukamy w każdym rzędzie, kolumnie i bloku, czy jakakolwiek cyfra 
    // występuje tylko w jednej dostępnej komórce dla danego domku
    for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
        const int p0 = st.topo->house_offsets[h];
        const int p1 = st.topo->house_offsets[h + 1];
        
        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int pos = -1;
            int cnt = 0;
            
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[idx] != 0) continue;
                if ((st.cands[idx] & bit) == 0ULL) continue;
                
                pos = idx; 
                ++cnt; 
                if (cnt > 1) break; // Szybkie zakończenie poszukiwań - występuje min 2 razy
            }
            
            if (cnt != 1) continue;
            
            // Postawienie cyfry
            if (!st.place(pos, d)) { 
                s.elapsed_ns += st.now_ns() - t0; 
                return ApplyResult::Contradiction; 
            }
            
            ++s.hit_count; 
            ++s.placements; 
            ++r.steps; 
            r.used_hidden_single = true;
            
            s.elapsed_ns += st.now_ns() - t0;
            return ApplyResult::Progress;
        }
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p1_easy



==============================================================================
PLIK: Sources\logic\p2_intersections\intersections.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: intersections.h (Poziom 2)
// Opis: Usuwanie zablokowanych intersekcji z rzędów do bloków (Pointing) 
//       oraz z bloków do rzędów (Box-Line). 
//       Kompletnie odporne na prostokątne obszary (Asymetryczna geometria).
// ============================================================================

#pragma once

#include <cstdint>
#include "../../core/candidate_state.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p2_intersections {

// Obie te techniki szukają bardzo podobnych wzorców (przecięcie Box-Line), dlatego
// w celu optymalizacji przebiegów na pamięci, są zaimplementowane w jednej funkcji z 
// dwiema statystykami.
inline ApplyResult apply_pointing_and_boxline(
    CandidateState& st, 
    StrategyStats& sp, 
    StrategyStats& sb, 
    GenericLogicCertifyResult& r) {
    
    const uint64_t t0p = st.now_ns();
    ++sp.use_count;
    const int n = st.topo->n;
    bool p_progress = false;
    
    // ------------------------------------------------------------------------
    // FAZA 1: Pointing Pairs/Triples (Z Box'a do Row/Col)
    // ------------------------------------------------------------------------
    for (int brg = 0; brg < st.topo->box_rows_count; ++brg) {
        for (int bcg = 0; bcg < st.topo->box_cols_count; ++bcg) {
            const int r0 = brg * st.topo->box_rows;
            const int c0 = bcg * st.topo->box_cols;
            
            for (int d = 1; d <= n; ++d) {
                const uint64_t bit = (1ULL << (d - 1));
                int fr = -1, fc = -1, cnt = 0;
                bool same_row = true, same_col = true;
                
                for (int dr = 0; dr < st.topo->box_rows; ++dr) {
                    for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                        const int rr = r0 + dr;
                        const int cc = c0 + dc;
                        const int idx = rr * n + cc;
                        
                        if (st.board->values[idx] != 0) continue;
                        if ((st.cands[idx] & bit) == 0ULL) continue;
                        
                        if (cnt == 0) { 
                            fr = rr; 
                            fc = cc; 
                        } else { 
                            same_row = same_row && (rr == fr); 
                            same_col = same_col && (cc == fc); 
                        }
                        ++cnt;
                    }
                }
                
                // Wymaga min. 2 komórek do eliminacji na podstawie rzutowania
                if (cnt < 2) continue;
                
                if (same_row) {
                    for (int c = 0; c < n; ++c) {
                        // Omijanie wewnątrz bloku
                        if (c >= c0 && c < c0 + st.topo->box_cols) continue;
                        
                        const ApplyResult er = st.eliminate(fr * n + c, bit);
                        if (er == ApplyResult::Contradiction) { 
                            sp.elapsed_ns += st.now_ns() - t0p; 
                            return er; 
                        }
                        p_progress = p_progress || (er == ApplyResult::Progress);
                    }
                }
                
                if (same_col) {
                    for (int rr = 0; rr < n; ++rr) {
                        // Omijanie wewnątrz bloku
                        if (rr >= r0 && rr < r0 + st.topo->box_rows) continue;
                        
                        const ApplyResult er = st.eliminate(rr * n + fc, bit);
                        if (er == ApplyResult::Contradiction) { 
                            sp.elapsed_ns += st.now_ns() - t0p; 
                            return er; 
                        }
                        p_progress = p_progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
    }
    
    sp.elapsed_ns += st.now_ns() - t0p;
    if (p_progress) { 
        ++sp.hit_count; 
        r.used_pointing_pairs = true; 
        return ApplyResult::Progress; 
    }

    // ------------------------------------------------------------------------
    // FAZA 2: Box/Line Reduction (Z Row/Col do Box'a)
    // ------------------------------------------------------------------------
    const uint64_t t0b = st.now_ns();
    ++sb.use_count;
    bool b_progress = false;
    
    // Skan rzędów
    for (int r0 = 0; r0 < n; ++r0) {
        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int first_box = -1, cnt = 0; 
            bool same_box = true;
            
            for (int c = 0; c < n; ++c) {
                const int idx = r0 * n + c;
                if (st.board->values[idx] != 0 || (st.cands[idx] & bit) == 0ULL) continue;
                
                const int box = st.topo->cell_box[idx];
                if (cnt == 0) first_box = box; 
                else same_box = same_box && (box == first_box);
                ++cnt;
            }
            
            if (!same_box || cnt < 2 || first_box < 0) continue;
            
            // Asymetryczna matematyka: Box zdekodowany
            const int brg = first_box / st.topo->box_cols_count;
            const int bcg = first_box % st.topo->box_cols_count;
            
            for (int dr = 0; dr < st.topo->box_rows; ++dr) {
                for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                    const int rr = brg * st.topo->box_rows + dr;
                    const int cc = bcg * st.topo->box_cols + dc;
                    // Omijanie źródłowego rzędu
                    if (rr == r0) continue;
                    
                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                    if (er == ApplyResult::Contradiction) { 
                        sb.elapsed_ns += st.now_ns() - t0b; 
                        return er; 
                    }
                    b_progress = b_progress || (er == ApplyResult::Progress);
                }
            }
        }
    }
    
    // Skan kolumn
    for (int c0 = 0; c0 < n; ++c0) {
        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int first_box = -1, cnt = 0; 
            bool same_box = true;
            
            for (int r0 = 0; r0 < n; ++r0) {
                const int idx = r0 * n + c0;
                if (st.board->values[idx] != 0 || (st.cands[idx] & bit) == 0ULL) continue;
                
                const int box = st.topo->cell_box[idx];
                if (cnt == 0) first_box = box; 
                else same_box = same_box && (box == first_box);
                ++cnt;
            }
            
            if (!same_box || cnt < 2 || first_box < 0) continue;
            
            const int brg = first_box / st.topo->box_cols_count;
            const int bcg = first_box % st.topo->box_cols_count;
            
            for (int dr = 0; dr < st.topo->box_rows; ++dr) {
                for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                    const int rr = brg * st.topo->box_rows + dr;
                    const int cc = bcg * st.topo->box_cols + dc;
                    // Omijanie źródłowej kolumny
                    if (cc == c0) continue;
                    
                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                    if (er == ApplyResult::Contradiction) { 
                        sb.elapsed_ns += st.now_ns() - t0b; 
                        return er; 
                    }
                    b_progress = b_progress || (er == ApplyResult::Progress);
                }
            }
        }
    }
    
    sb.elapsed_ns += st.now_ns() - t0b;
    if (b_progress) { 
        ++sb.hit_count; 
        r.used_box_line = true; 
        return ApplyResult::Progress; 
    }
    
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p2_intersections



==============================================================================
PLIK: Sources\logic\p3_subsets\house_subsets.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: house_subsets.h (Poziomy 2, 3, 4)
// Opis: Wykrywanie i aplikacja podzbiorów (Naked/Hidden Pairs, Triples, Quads).
//       Kompletnie zunifikowana funkcja zero-allocation używająca masek bitowych
//       i bitowych sum (union). 
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p3_subsets {

// Parametry:
// subset = 2 (Pair), 3 (Triple), 4 (Quad)
// hidden = true (szukamy na podstawie dystrybucji masek wewnątrz rzędu/kolumny/boxa)
//        = false (szukamy na podstawie pojemności pojedynczej komórki)
inline ApplyResult apply_house_subset(
    CandidateState& st, 
    StrategyStats& s, 
    GenericLogicCertifyResult& r, 
    int subset, 
    bool hidden) {
    
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    const int n = st.topo->n;
    bool progress = false;
    
    // Tablice na stosie (gwarantowane wsparcie N=64 bez heap-alloc)
    uint64_t pos[64]{};
    int cells[64]{};
    int active_digits[64]{};

    const size_t house_count = st.topo->house_offsets.size() - 1;
    for (size_t h = 0; h < house_count; ++h) {
        const int p0 = st.topo->house_offsets[h];
        const int p1 = st.topo->house_offsets[h + 1];
        
        // ====================================================================
        // TRYB: NAKED SUBSETS
        // ====================================================================
        if (!hidden) {
            int m = 0;
            // Szukamy komórek, które mają od 2 do N kandydatów
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[idx] != 0) continue;
                
                const int bits = std::popcount(st.cands[idx]);
                // Tylko komórki mające tyle lub mniej kandydatów co nasz docelowy podzbiór
                if (bits >= 2 && bits <= subset) {
                    if (m < 64) cells[m++] = idx;
                }
            }
            
            if (m < subset) continue;
            
            // Funkcja do weryfikacji i zastosowania Naked Subsetu
            auto try_apply_naked_union = [&](int a, int b, int c, int d) -> ApplyResult {
                uint64_t um = st.cands[cells[a]] | st.cands[cells[b]];
                if (c >= 0) um |= st.cands[cells[c]];
                if (d >= 0) um |= st.cands[cells[d]];
                
                if (std::popcount(um) != subset) return ApplyResult::NoProgress;
                
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    
                    // Omijamy komórki, które tworzą podzbiór
                    if (idx == cells[a] || idx == cells[b] ||
                        (c >= 0 && idx == cells[c]) ||
                        (d >= 0 && idx == cells[d])) {
                        continue;
                    }
                    
                    const ApplyResult er = st.eliminate(idx, um);
                    if (er == ApplyResult::Contradiction) return er;
                    progress = progress || (er == ApplyResult::Progress);
                }
                return ApplyResult::NoProgress;
            };

            // Permutacje dla N=2,3,4 bez używania n-silni
            for (int i = 0; i < m; ++i) {
                for (int j = i + 1; j < m; ++j) {
                    if (subset == 2) {
                        const ApplyResult rr = try_apply_naked_union(i, j, -1, -1);
                        if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                        continue;
                    }
                    for (int k = j + 1; k < m; ++k) {
                        if (subset == 3) {
                            const ApplyResult rr = try_apply_naked_union(i, j, k, -1);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                            continue;
                        }
                        for (int l = k + 1; l < m; ++l) {
                            const ApplyResult rr = try_apply_naked_union(i, j, k, l);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                        }
                    }
                }
            }
        } 
        // ====================================================================
        // TRYB: HIDDEN SUBSETS
        // ====================================================================
        else {
            std::fill_n(pos, n, 0ULL);
            
            // Mapowanie cyfra -> maska wystąpień (gdzie maska to pozycja komórki w "domku")
            for (int d = 1; d <= n; ++d) {
                const uint64_t bit = (1ULL << (d - 1));
                uint64_t bits = 0ULL;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[idx] != 0) continue;
                    
                    if ((st.cands[idx] & bit) != 0ULL) {
                        bits |= (1ULL << (p - p0));
                    }
                }
                pos[d - 1] = bits;
            }
            
            int ad_count = 0;
            for (int d = 1; d <= n; ++d) {
                const int cnt = std::popcount(pos[d - 1]);
                if (cnt >= 1 && cnt <= subset) {
                    if (ad_count < 64) active_digits[ad_count++] = d;
                }
            }
            
            if (ad_count < subset) continue;
            
            auto try_apply_hidden_union = [&](int d1, int d2, int d3, int d4) -> ApplyResult {
                uint64_t up = pos[d1 - 1] | pos[d2 - 1];
                uint64_t allowed = (1ULL << (d1 - 1)) | (1ULL << (d2 - 1));
                
                if (d3 > 0) {
                    up |= pos[d3 - 1];
                    allowed |= (1ULL << (d3 - 1));
                }
                if (d4 > 0) {
                    up |= pos[d4 - 1];
                    allowed |= (1ULL << (d4 - 1));
                }
                
                if (std::popcount(up) != subset) return ApplyResult::NoProgress;
                
                // Redukujemy kandydatów do tylko dozwolonych w tych specyficznych komórkach
                for (uint64_t w = up; w != 0ULL; w &= (w - 1ULL)) {
                    const int b = config::bit_ctz_u64(w);
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p0 + b)];
                    
                    const ApplyResult rr = st.keep_only(idx, allowed);
                    if (rr == ApplyResult::Contradiction) return rr;
                    progress = progress || (rr == ApplyResult::Progress);
                }
                return ApplyResult::NoProgress;
            };

            for (int i = 0; i < ad_count; ++i) {
                const int d1 = active_digits[i];
                for (int j = i + 1; j < ad_count; ++j) {
                    const int d2 = active_digits[j];
                    if (subset == 2) {
                        const ApplyResult rr = try_apply_hidden_union(d1, d2, -1, -1);
                        if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                        continue;
                    }
                    for (int k = j + 1; k < ad_count; ++k) {
                        const int d3 = active_digits[k];
                        if (subset == 3) {
                            const ApplyResult rr = try_apply_hidden_union(d1, d2, d3, -1);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                            continue;
                        }
                        for (int l = k + 1; l < ad_count; ++l) {
                            const int d4 = active_digits[l];
                            const ApplyResult rr = try_apply_hidden_union(d1, d2, d3, d4);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return rr; }
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        if (!hidden && subset == 2) r.used_naked_pair = true;
        if (!hidden && subset == 3) r.used_naked_triple = true;
        if (!hidden && subset == 4) r.used_naked_quad = true;
        if (hidden && subset == 2) r.used_hidden_pair = true;
        if (hidden && subset == 3) r.used_hidden_triple = true;
        if (hidden && subset == 4) r.used_hidden_quad = true;
        
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p3_subsets



==============================================================================
PLIK: Sources\logic\p4_hard\empty_rectangle.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: empty_rectangle.h (Poziom 4)
// Opis: Algorytm wyszukujący tzw. Puste Prostokąty (Empty Rectangle).
//       Sprawdza bloki, w których dana cyfra występuje tylko w jednej 
//       kolumnie i jednym rzędzie (kształt litery 'L' na bitboardzie).
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>
#include <array>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p4_hard {

// Zoptymalizowany dla siatek wielkoformatowych algorytm ER.
inline ApplyResult apply_empty_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    const int n = st.topo->n;
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    bool progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);
        
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        for (int b = 0; b < n; ++b) {
            sp.als_cell_count = 0; // reużywamy wolny bufor w P4 na cele box_cells
            
            // Znajdź wszystkie wystąpienia cyfry 'd' w aktualnym Box'ie
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.topo->cell_box[idx] != b) continue;
                if (st.board->values[idx] != 0) continue;
                if ((st.cands[idx] & bit) == 0ULL) continue;
                
                sp.als_cells[sp.als_cell_count++] = idx;
                // Jeśli w boxie są więcej niż 2 wystąpienia, nadal może być to ER o ile tworzą +
                // ale dla celów zoptymalizowanej heurystyki HPC ograniczamy do kształtu L
                if (sp.als_cell_count > 2) break;
            }
            
            if (sp.als_cell_count != 2) continue;
            
            const int p = sp.als_cells[0];
            const int q = sp.als_cells[1];
            
            const int pr = st.topo->cell_row[p];
            const int pc = st.topo->cell_col[p];
            const int qr = st.topo->cell_row[q];
            const int qc = st.topo->cell_col[q];
            
            // Komórki z Box'a muszą znajdować się w innych rzędach i innych kolumnach, by utworzyć kształt L
            if (pr == qr || pc == qc) continue;

            struct OrientedPair { 
                int row_cell; 
                int col_cell; 
            };
            const std::array<OrientedPair, 2> orientations = {{
                {p, q}, {q, p}
            }};
            
            for (const auto& orient : orientations) {
                const int row_cell = orient.row_cell;
                const int col_cell = orient.col_cell;
                
                const int rr = st.topo->cell_row[row_cell];
                const int cc = st.topo->cell_col[col_cell];

                // Badamy wierzchołek ER od strony rzędu
                const uint64_t row_m = sp.fish_row_masks[rr];
                if (std::popcount(row_m) != 2 || (row_m & (1ULL << st.topo->cell_col[row_cell])) == 0ULL) continue;
                
                const uint64_t row_other_mask = row_m & ~(1ULL << st.topo->cell_col[row_cell]);
                if (row_other_mask == 0ULL) continue;
                const int row_other_col = config::bit_ctz_u64(row_other_mask);
                const int row_other = rr * n + row_other_col;

                // Badamy wierzchołek ER od strony kolumny
                const uint64_t col_m = sp.fish_col_masks[cc];
                if (std::popcount(col_m) != 2 || (col_m & (1ULL << st.topo->cell_row[col_cell])) == 0ULL) continue;
                
                const uint64_t col_other_mask = col_m & ~(1ULL << st.topo->cell_row[col_cell]);
                if (col_other_mask == 0ULL) continue;
                const int col_other_row = config::bit_ctz_u64(col_other_mask);
                const int col_other = col_other_row * n + cc;
                
                if (row_other == col_other) continue;

                // Sprawdzamy wzajemne powiązanie w miejscu krzyżowania zewnętrznych wypustek (Z)
                const int p0 = st.topo->peer_offsets[row_other];
                const int p1 = st.topo->peer_offsets[row_other + 1];
                for (int pi = p0; pi < p1; ++pi) {
                    const int t = st.topo->peers_flat[pi];
                    if (t == row_other || t == col_other) continue;
                    
                    if (!st.is_peer(t, col_other)) continue;
                    
                    const ApplyResult er = st.eliminate(t, bit);
                    if (er == ApplyResult::Contradiction) { 
                        s.elapsed_ns += st.now_ns() - t0; 
                        return er; 
                    }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_empty_rectangle = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p4_hard



==============================================================================
PLIK: Sources\logic\p4_hard\fish_basic.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: fish_basic.h (Poziom 4)
// Opis: Algorytmy szukające X-Wing oraz Swordfish. 
//       Wykorzystanie szybkiego bitboardu w celu optymalizacji O(N^3).
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p4_hard {

// Zunifikowany algorytm X-Wing (szuka 2x2 kwadratów dla rzędów i kolumn)
inline ApplyResult apply_x_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);
        
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        // Faza X-Wing na rzędach
        for (int r1 = 0; r1 < n; ++r1) {
            const uint64_t m1 = sp.fish_row_masks[r1];
            if (std::popcount(m1) != 2) continue; // Wymagamy dokładnie 2 kandydatów
            
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                // Czy drugi rząd ma takie same kandydatury na kolumnach?
                if (sp.fish_row_masks[r2] != m1) continue;
                
                // Znalazlismy X-Wing. Eliminujemy w tych 2 kolumnach dla wszystkich innych rzędów.
                uint64_t w = m1;
                while (w != 0ULL) {
                    const int c = config::bit_ctz_u64(w);
                    w = config::bit_clear_lsb_u64(w);
                    
                    for (int rr = 0; rr < n; ++rr) {
                        if (rr == r1 || rr == r2) continue;
                        
                        const ApplyResult er = st.eliminate(rr * n + c, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        // Faza X-Wing na kolumnach
        for (int c1 = 0; c1 < n; ++c1) {
            const uint64_t m1 = sp.fish_col_masks[c1];
            if (std::popcount(m1) != 2) continue;
            
            for (int c2 = c1 + 1; c2 < n; ++c2) {
                if (sp.fish_col_masks[c2] != m1) continue;
                
                uint64_t w = m1;
                while (w != 0ULL) {
                    const int rr = config::bit_ctz_u64(w);
                    w = config::bit_clear_lsb_u64(w);
                    
                    for (int cc = 0; cc < n; ++cc) {
                        if (cc == c1 || cc == c2) continue;
                        
                        const ApplyResult er = st.eliminate(rr * n + cc, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_x_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

// Zunifikowany algorytm Swordfish (Ryba rozmiaru 3x3)
inline ApplyResult apply_swordfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();
    
    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);

        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        int row_count = 0;
        int col_count = 0;
        
        // Zbieramy tylko te linie, w których kandydat pojawia się 2 do 3 razy
        for (int rr = 0; rr < n; ++rr) {
            const int cnt = std::popcount(sp.fish_row_masks[rr]);
            if (cnt >= 2 && cnt <= 3) sp.active_rows[row_count++] = rr;
        }
        for (int cc = 0; cc < n; ++cc) {
            const int cnt = std::popcount(sp.fish_col_masks[cc]);
            if (cnt >= 2 && cnt <= 3) sp.active_cols[col_count++] = cc;
        }

        // Swordfish dla Rzędów (szukamy 3 rzędów, których złączone wystąpienia obejmują max 3 kolumny)
        for (int i = 0; i < row_count; ++i) {
            const int r1 = sp.active_rows[i];
            const uint64_t m1 = sp.fish_row_masks[r1];
            for (int j = i + 1; j < row_count; ++j) {
                const int r2 = sp.active_rows[j];
                const uint64_t m12 = m1 | sp.fish_row_masks[r2];
                if (std::popcount(m12) > 3) continue;
                
                for (int k = j + 1; k < row_count; ++k) {
                    const int r3 = sp.active_rows[k];
                    const uint64_t cols_union = m12 | sp.fish_row_masks[r3];
                    if (std::popcount(cols_union) != 3) continue;
                    
                    uint64_t w = cols_union;
                    while (w != 0ULL) {
                        const int cc = config::bit_ctz_u64(w);
                        w = config::bit_clear_lsb_u64(w);
                        for (int rr = 0; rr < n; ++rr) {
                            if (rr == r1 || rr == r2 || rr == r3) continue;
                            
                            const ApplyResult er = st.eliminate(rr * n + cc, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }

        // Swordfish dla Kolumn
        for (int i = 0; i < col_count; ++i) {
            const int c1 = sp.active_cols[i];
            const uint64_t m1 = sp.fish_col_masks[c1];
            for (int j = i + 1; j < col_count; ++j) {
                const int c2 = sp.active_cols[j];
                const uint64_t m12 = m1 | sp.fish_col_masks[c2];
                if (std::popcount(m12) > 3) continue;
                
                for (int k = j + 1; k < col_count; ++k) {
                    const int c3 = sp.active_cols[k];
                    const uint64_t rows_union = m12 | sp.fish_col_masks[c3];
                    if (std::popcount(rows_union) != 3) continue;
                    
                    uint64_t w = rows_union;
                    while (w != 0ULL) {
                        const int rr = config::bit_ctz_u64(w);
                        w = config::bit_clear_lsb_u64(w);
                        for (int cc = 0; cc < n; ++cc) {
                            if (cc == c1 || cc == c2 || cc == c3) continue;
                            
                            const ApplyResult er = st.eliminate(rr * n + cc, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_swordfish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p4_hard



==============================================================================
PLIK: Sources\logic\p4_hard\skyscraper_kite.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: skyscraper_kite.h (Poziom 4)
// Opis: Algorytmy Skyscraper oraz 2-String Kite korzystające z połamanych 
//       powiązań x-wing. Oba wykorzystują Scratchpada do zero-allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p4_hard {

inline ApplyResult apply_skyscraper(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);

        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        // Row Skyscraper
        for (int r1 = 0; r1 < n; ++r1) {
            const uint64_t m1 = sp.fish_row_masks[r1];
            if (std::popcount(m1) != 2) continue;
            
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                const uint64_t m2 = sp.fish_row_masks[r2];
                if (std::popcount(m2) != 2) continue;
                
                const uint64_t common = m1 & m2;
                if (std::popcount(common) != 1) continue; // Wymaga dokładnie jednego wspólnego "dachu"
                
                const uint64_t e1 = m1 & ~common;
                const uint64_t e2 = m2 & ~common;
                if (e1 == 0ULL || e2 == 0ULL) continue;
                
                const int c1 = config::bit_ctz_u64(e1);
                const int c2 = config::bit_ctz_u64(e2);
                const int a = r1 * n + c1;
                const int b = r2 * n + c2;
                
                const int ap0 = st.topo->peer_offsets[a];
                const int ap1 = st.topo->peer_offsets[a + 1];
                
                for (int p = ap0; p < ap1; ++p) {
                    const int t = st.topo->peers_flat[p];
                    if (t == a || t == b) continue;
                    // Skyscraper uderza tam gdzie A widzi cel oraz B widzi cel
                    if (!st.is_peer(t, b)) continue;
                    
                    const ApplyResult er = st.eliminate(t, bit);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }

        // Col Skyscraper
        for (int c1 = 0; c1 < n; ++c1) {
            const uint64_t m1 = sp.fish_col_masks[c1];
            if (std::popcount(m1) != 2) continue;
            
            for (int c2 = c1 + 1; c2 < n; ++c2) {
                const uint64_t m2 = sp.fish_col_masks[c2];
                if (std::popcount(m2) != 2) continue;
                
                const uint64_t common = m1 & m2;
                if (std::popcount(common) != 1) continue;
                
                const uint64_t e1 = m1 & ~common;
                const uint64_t e2 = m2 & ~common;
                if (e1 == 0ULL || e2 == 0ULL) continue;
                
                const int r1 = config::bit_ctz_u64(e1);
                const int r2 = config::bit_ctz_u64(e2);
                const int a = r1 * n + c1;
                const int b = r2 * n + c2;
                
                const int ap0 = st.topo->peer_offsets[a];
                const int ap1 = st.topo->peer_offsets[a + 1];
                
                for (int p = ap0; p < ap1; ++p) {
                    const int t = st.topo->peers_flat[p];
                    if (t == a || t == b) continue;
                    if (!st.is_peer(t, b)) continue;
                    
                    const ApplyResult er = st.eliminate(t, bit);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_skyscraper = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_two_string_kite(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);

        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        for (int row = 0; row < n; ++row) {
            const uint64_t rm = sp.fish_row_masks[row];
            if (std::popcount(rm) != 2) continue; // Wymaga silnego powiązania
            
            uint64_t ra = rm & (~rm + 1ULL);
            uint64_t rb = rm ^ ra;
            const int c1 = config::bit_ctz_u64(ra);
            const int c2 = config::bit_ctz_u64(rb);
            const int row_a = row * n + c1;
            const int row_b = row * n + c2;

            for (int col = 0; col < n; ++col) {
                const uint64_t cm = sp.fish_col_masks[col];
                if (std::popcount(cm) != 2) continue; // Wymaga drugiego silnego powiązania
                
                uint64_t ca = cm & (~cm + 1ULL);
                uint64_t cb = cm ^ ca;
                const int r1 = config::bit_ctz_u64(ca);
                const int r2 = config::bit_ctz_u64(cb);
                const int col_a = r1 * n + col;
                const int col_b = r2 * n + col;

                struct Choice {
                    int row_pivot;
                    int row_end;
                    int col_pivot;
                    int col_end;
                };
                
                // Sprawdzamy wszystkie warianty połączeń między silnym rzędem i kolumną
                const std::array<Choice, 4> choices = {{
                    {row_a, row_b, col_a, col_b},
                    {row_a, row_b, col_b, col_a},
                    {row_b, row_a, col_a, col_b},
                    {row_b, row_a, col_b, col_a},
                }};
                
                for (const auto& ch : choices) {
                    if (ch.row_pivot == ch.col_pivot) continue;
                    // Oba złączenia muszą być w tym samym bloku by utworzyć 2-String Kite
                    if (st.topo->cell_box[ch.row_pivot] != st.topo->cell_box[ch.col_pivot]) continue;
                    
                    // Uderzenie eliminacji tam, gdzie końcówki widzą wspólną komórkę
                    const int p0 = st.topo->peer_offsets[ch.row_end];
                    const int p1 = st.topo->peer_offsets[ch.row_end + 1];
                    for (int p = p0; p < p1; ++p) {
                        const int t = st.topo->peers_flat[p];
                        if (t == ch.row_end || t == ch.col_end || t == ch.row_pivot || t == ch.col_pivot) continue;
                        if (!st.is_peer(t, ch.col_end)) continue;
                        
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_two_string_kite = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p4_hard



==============================================================================
PLIK: Sources\logic\p4_hard\y_wing_remote_pairs.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: y_wing_remote_pairs.h (Poziom 4)
// Opis: Algorytmy bazujące na dwukandydatowych komórkach (bivalue). 
//       - Y-Wing szuka pivotu z dwoma "skrzydłami".
//       - Remote Pairs przechodzi BFS-em po wszystkich spiętych parach.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p4_hard {

inline ApplyResult apply_y_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    bool progress = false;

    // Iteracja po potencjalnych "Pivotach"
    for (int pivot = 0; pivot < st.topo->nn; ++pivot) {
        if (st.board->values[pivot] != 0) continue;
        
        const uint64_t mp = st.cands[pivot];
        if (std::popcount(mp) != 2) continue; // Pivot musi być bivalue np. AB

        // Iteracja po "widocznych" rówieśnikach pivota dla pierwszego skrzydła
        const int p0 = st.topo->peer_offsets[pivot];
        const int p1 = st.topo->peer_offsets[pivot + 1];
        
        for (int i = p0; i < p1; ++i) {
            const int a = st.topo->peers_flat[i];
            if (st.board->values[a] != 0) continue;
            
            const uint64_t ma = st.cands[a];
            if (std::popcount(ma) != 2) continue;
            
            const uint64_t shared_a = ma & mp;
            if (std::popcount(shared_a) != 1) continue; // Posiadają dokładnie 1 wspólną cyfrę (np. A)
            
            const uint64_t z = ma & ~mp;
            if (std::popcount(z) != 1) continue; // Pozostała cyfra z skrzydła to nasze 'Z' (Z -> eliminacja)

            // Szukamy drugiego skrzydła na pozostałych widocznych węzłach pivota
            for (int j = i + 1; j < p1; ++j) {
                const int b = st.topo->peers_flat[j];
                if (st.board->values[b] != 0) continue;
                
                const uint64_t mb = st.cands[b];
                if (std::popcount(mb) != 2) continue;
                
                const uint64_t shared_b = mb & mp;
                // Drugie skrzydło musi dzielić z pivotem pozostałą cyfrę (np. B)
                if (std::popcount(shared_b) != 1 || shared_b == shared_a) continue;
                
                const uint64_t z2 = mb & ~mp;
                // Drugie skrzydło musi wycelować w to samo z (np. BZ)
                if (z2 != z || std::popcount(z2) != 1) continue;

                // Eliminacja 'Z' u wszystkich co widzą oba skrzydła A i B
                const int ap0 = st.topo->peer_offsets[a];
                const int ap1 = st.topo->peer_offsets[a + 1];
                for (int p = ap0; p < ap1; ++p) {
                    const int t = st.topo->peers_flat[p];
                    if (t == pivot || t == a || t == b) continue;
                    if (!st.is_peer(t, b)) continue; // t widzi już A przez zewnętrzną pętlę, musi też widzieć B
                    
                    const ApplyResult er = st.eliminate(t, z);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_y_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_remote_pairs(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int nn = st.topo->nn;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    // Wykorzystujemy aliasy pamięci z ExactPatternScratchpad jako tablice lokalne dla BFS
    // Zapobiega to alokacji vectora i fałszywemu dzieleniu cache.
    int* component = sp.cell_to_node;      // wielkosc NN
    int* parity = sp.node_to_cell;         // wielkosc NN, re-used jako uint8_t parity indicator
    int* in_component = sp.node_degree;    // wielkosc NN
    int* seen_parity0 = sp.adj_cursor;     // wielkosc NN
    int* seen_parity1 = sp.visited;        // wielkosc NN

    std::fill_n(component, nn, -1);
    
    // Szukamy dostępnych masek typu Pair (np. komórki zawierające wył. "1 i 2")
    // Ponieważ potrzebujemy unikalnych wartości pair_mask, zapiszemy je tymczasowo na końcu bufora
    int pair_mask_count = 0;
    uint64_t* pair_masks = reinterpret_cast<uint64_t*>(sp.adj_flat);
    
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        const uint64_t m = st.cands[idx];
        if (std::popcount(m) == 2) {
            pair_masks[pair_mask_count++] = m;
        }
    }
    
    // Unikalne maski do zbadania BFS-em
    std::sort(pair_masks, pair_masks + pair_mask_count);
    uint64_t* new_end = std::unique(pair_masks, pair_masks + pair_mask_count);
    pair_mask_count = static_cast<int>(new_end - pair_masks);

    for (int p_idx = 0; p_idx < pair_mask_count; ++p_idx) {
        const uint64_t current_pair_mask = pair_masks[p_idx];
        
        std::fill_n(component, nn, -1);
        std::fill_n(parity, nn, 0);
        int comp_id = 0;

        for (int start = 0; start < nn; ++start) {
            if (st.board->values[start] != 0) continue;
            if (st.cands[start] != current_pair_mask) continue;
            if (component[start] != -1) continue; // Już odwiedzone w innej sieci
            
            int qh = 0;
            int qt = 0;
            
            sp.bfs_queue[qt++] = start;
            component[start] = comp_id;
            parity[start] = 0;

            // Przeszukiwanie wszerz sieci powiązanych par
            while (qh < qt) {
                const int cur = sp.bfs_queue[qh++];
                const int p_off0 = st.topo->peer_offsets[cur];
                const int p_off1 = st.topo->peer_offsets[cur + 1];
                
                for (int p = p_off0; p < p_off1; ++p) {
                    const int nxt = st.topo->peers_flat[p];
                    if (st.board->values[nxt] != 0) continue;
                    if (st.cands[nxt] != current_pair_mask) continue;
                    
                    if (component[nxt] == -1) {
                        component[nxt] = comp_id;
                        parity[nxt] = parity[cur] ^ 1;
                        if (qt < ExactPatternScratchpad::MAX_BFS) {
                            sp.bfs_queue[qt++] = nxt;
                        }
                    }
                }
            }
            ++comp_id;
        }

        // Faza ewaluacji eliminacji z poszczególnych komponentów (niezależnych sieci)
        for (int cid = 0; cid < comp_id; ++cid) {
            int node_count_in_comp = 0;
            for (int idx = 0; idx < nn; ++idx) {
                if (component[idx] == cid) {
                    sp.als_cells[node_count_in_comp++] = idx; // używamy wolnego bufora ALS
                }
            }
            
            // Remote Pairs potrzebuje co najmniej 4 węzłów w cyklu, by mogło rzucać cień
            if (node_count_in_comp < 4) continue;

            std::fill_n(in_component, nn, 0);
            std::fill_n(seen_parity0, nn, 0);
            std::fill_n(seen_parity1, nn, 0);
            
            for (int i = 0; i < node_count_in_comp; ++i) {
                const int idx = sp.als_cells[i];
                in_component[idx] = 1;
                
                const int p_off0 = st.topo->peer_offsets[idx];
                const int p_off1 = st.topo->peer_offsets[idx + 1];
                
                int* const target_seen = (parity[idx] == 0) ? seen_parity0 : seen_parity1;
                for (int p = p_off0; p < p_off1; ++p) {
                    target_seen[st.topo->peers_flat[p]] = 1;
                }
            }

            // Eliminacja tam, gdzie cel widzi na raz node o obu parytetach z naszej sieci par.
            for (int t = 0; t < nn; ++t) {
                if (in_component[t] != 0) continue;
                if (st.board->values[t] != 0) continue;
                if (seen_parity0[t] == 0 || seen_parity1[t] == 0) continue;
                
                const ApplyResult er = st.eliminate(t, current_pair_mask);
                if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                progress = progress || (er == ApplyResult::Progress);
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_remote_pairs = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p4_hard



==============================================================================
PLIK: Sources\logic\p5_expert\bug_plus_one.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: bug_plus_one.h (Poziom 5 - Expert)
// Opis: Wykrywa Bivalue Universal Grave + 1 (BUG+1). 
//       Jeżeli wszystkie nieodkryte komórki prócz jednej mają 2 kandydatów 
//       (i ta jedna posiada ich 3), oznacza to śmiertelny wzorzec, w którym
//       tylko jedna dedukcja "ratuje" planszę przed wielokrotnym rozwiązaniem.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p5_expert {

inline ApplyResult apply_bug_plus_one(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Strategie oparte o Unikalność i Prostokąty wymagają siatek posiadających konwencjonalne bloki 
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    int bug_idx = -1;
    int tri_count = 0;
    
    // Skan wszystkich pustych komórek, by sprawdzić warunek BUG (wszystko bivalue + 1 trivalue)
    for (int idx = 0; idx < st.topo->nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        
        const int cnt = std::popcount(st.cands[idx]);
        if (cnt < 2 || cnt > 3) {
            // Natychmiastowe wyjście: Mamy komórkę o popcount >= 4 lub <= 1
            s.elapsed_ns += st.now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        
        if (cnt == 3) {
            bug_idx = idx;
            ++tri_count;
            if (tri_count > 1) {
                // BUG wymaga dokładnie JEDNEJ komórki tri-value (pozostałe muszą być bivalue)
                s.elapsed_ns += st.now_ns() - t0;
                return ApplyResult::NoProgress;
            }
        }
    }
    
    // BUG+1 nie wystąpił
    if (tri_count != 1 || bug_idx < 0) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    // Znaleziono siatkę w stanie BUG+1. Analizujemy węzeł (Pivot), w którym są 3 cyfry.
    const int bug_row = st.topo->cell_row[bug_idx];
    const int bug_col = st.topo->cell_col[bug_idx];
    const int bug_box = st.topo->cell_box[bug_idx];
    const uint64_t m = st.cands[bug_idx];
    
    // Weryfikujemy każdą z trzech cyfr tego węzła. Tylko jedna z nich pozwala
    // na złamanie pętli BUG'a (taka, która występuje nieparzyście w rejonach p-ta)
    uint64_t w = m;
    while (w != 0ULL) {
        const uint64_t bit = config::bit_ctz_u64(w);
        w = config::bit_clear_lsb_u64(w);
        
        const int d = static_cast<int>(bit) + 1;
        int cnt_row = 0;
        int cnt_col = 0;
        int cnt_box = 0;

        for (int c = 0; c < st.topo->n; ++c) {
            const int idx = bug_row * st.topo->n + c;
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & (1ULL << bit)) != 0ULL) ++cnt_row;
        }
        for (int rr = 0; rr < st.topo->n; ++rr) {
            const int idx = rr * st.topo->n + bug_col;
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & (1ULL << bit)) != 0ULL) ++cnt_col;
        }
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.topo->cell_box[idx] != bug_box) continue;
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & (1ULL << bit)) != 0ULL) ++cnt_box;
        }
        
        // Ratunkiem dla BUG jest ta cyfra, która zaburza parzystość wystąpień we 
        // wszystkich trzech domkach (rzędzie, kolumnie i bloku)
        if ((cnt_row % 2 == 1) && (cnt_col % 2 == 1) && (cnt_box % 2 == 1)) {
            if (!st.place(bug_idx, d)) { 
                s.elapsed_ns += st.now_ns() - t0; 
                return ApplyResult::Contradiction; 
            }
            
            ++s.hit_count;
            ++s.placements;
            ++r.steps;
            r.used_bug_plus_one = true;
            
            s.elapsed_ns += st.now_ns() - t0;
            return ApplyResult::Progress;
        }
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p5_expert



==============================================================================
PLIK: Sources\logic\p5_expert\finned_fish.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: finned_fish.h (Poziom 5 - Expert)
// Opis: Implementacja Finned X-Wing oraz Sashimi X-Wing.
//       Strategie te szukają struktury X-Wing, w której jeden z węzłów 
//       rozlał się na dodatkowe komórki (płetwy/fins), ale wszystkie te 
//       dodatkowe komórki znajdują się w obrębie jednego bloku (Box).
//       Zero-allocation z użyciem ExactPatternScratchpad.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p5_expert {

inline ApplyResult apply_finned_x_wing_sashimi(
    CandidateState& st, 
    StrategyStats& s, 
    GenericLogicCertifyResult& r) {
    
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Strategia ryb z płetwami wymaga podziału na bloki
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        
        // Reset bitboardów dla rzędów i kolumn
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);
        
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        // --------------------------------------------------------------------
        // Szukanie w ujęciu Rzędów (Row-based Finned/Sashimi X-Wing)
        // --------------------------------------------------------------------
        for (int r1 = 0; r1 < n; ++r1) {
            const uint64_t m1 = sp.fish_row_masks[r1];
            const int c1 = std::popcount(m1);
            if (c1 < 2 || c1 > 4) continue; // max 2 bazowe + 2 płetwy (bo box max width/height w standardzie to zwykle mało, dla N=64 akceptujemy małe płetwy heurystycznie)
            
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                const uint64_t m2 = sp.fish_row_masks[r2];
                const int c2 = std::popcount(m2);
                if (c2 < 2 || c2 > 4) continue;
                
                const uint64_t common = m1 & m2;
                if (std::popcount(common) != 2) continue; // Muszą współdzielić dokładnie 2 kolumny docelowe
                
                const uint64_t e1 = m1 & ~common; // Płetwy w r1
                const uint64_t e2 = m2 & ~common; // Płetwy w r2
                
                // Tylko jeden z rzędów może mieć płetwy (XOR)
                if ((e1 == 0ULL) == (e2 == 0ULL)) continue;

                const int fin_row = (e1 != 0ULL) ? r1 : r2;
                const uint64_t fin_mask = (e1 != 0ULL) ? e1 : e2;
                
                // Iterujemy po wspólnych kolumnach (Target columns)
                uint64_t wc = common;
                while (wc != 0ULL) {
                    const int base_col = config::bit_ctz_u64(wc);
                    wc = config::bit_clear_lsb_u64(wc);
                    
                    const int base_box = st.topo->cell_box[fin_row * n + base_col];
                    
                    // Sprawdzamy czy wszystkie płetwy leżą w tym samym bloku co base_col
                    bool has_fin_in_box = false;
                    bool invalid_fin = false;
                    
                    uint64_t wf = fin_mask;
                    while (wf != 0ULL) {
                        const int fin_col = config::bit_ctz_u64(wf);
                        wf = config::bit_clear_lsb_u64(wf);
                        
                        if (st.topo->cell_box[fin_row * n + fin_col] == base_box) {
                            has_fin_in_box = true;
                        } else {
                            invalid_fin = true;
                            break;
                        }
                    }
                    
                    if (invalid_fin || !has_fin_in_box) continue;

                    // Eliminacja: Kandydat 'd' usuwamy z komórek, które są w tym samym bloku co płetwy
                    // ORAZ są w kolumnie bazowej (ale nie należą do rzędów ryby).
                    for (int rr = 0; rr < n; ++rr) {
                        if (rr == r1 || rr == r2) continue;
                        
                        const int t = rr * n + base_col;
                        if (st.topo->cell_box[t] != base_box) continue;
                        
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { 
                            s.elapsed_ns += st.now_ns() - t0; 
                            return er; 
                        }
                        if (er == ApplyResult::Progress) {
                            ++s.hit_count;
                            r.used_finned_x_wing_sashimi = true;
                            progress = true;
                        }
                    }
                }
            }
        }

        // --------------------------------------------------------------------
        // Szukanie w ujęciu Kolumn (Col-based Finned/Sashimi X-Wing)
        // --------------------------------------------------------------------
        for (int c1 = 0; c1 < n; ++c1) {
            const uint64_t m1 = sp.fish_col_masks[c1];
            const int r1_cnt = std::popcount(m1);
            if (r1_cnt < 2 || r1_cnt > 4) continue;
            
            for (int c2 = c1 + 1; c2 < n; ++c2) {
                const uint64_t m2 = sp.fish_col_masks[c2];
                const int r2_cnt = std::popcount(m2);
                if (r2_cnt < 2 || r2_cnt > 4) continue;
                
                const uint64_t common = m1 & m2;
                if (std::popcount(common) != 2) continue;
                
                const uint64_t e1 = m1 & ~common; // Płetwy w c1
                const uint64_t e2 = m2 & ~common; // Płetwy w c2
                
                // Tylko jedna kolumna posiada płetwy
                if ((e1 == 0ULL) == (e2 == 0ULL)) continue;

                const int fin_col = (e1 != 0ULL) ? c1 : c2;
                const uint64_t fin_mask = (e1 != 0ULL) ? e1 : e2;
                
                uint64_t wr = common;
                while (wr != 0ULL) {
                    const int base_row = config::bit_ctz_u64(wr);
                    wr = config::bit_clear_lsb_u64(wr);
                    
                    const int base_box = st.topo->cell_box[base_row * n + fin_col];
                    
                    bool has_fin_in_box = false;
                    bool invalid_fin = false;
                    
                    uint64_t wf = fin_mask;
                    while (wf != 0ULL) {
                        const int f_row = config::bit_ctz_u64(wf);
                        wf = config::bit_clear_lsb_u64(wf);
                        
                        if (st.topo->cell_box[f_row * n + fin_col] == base_box) {
                            has_fin_in_box = true;
                        } else {
                            invalid_fin = true;
                            break;
                        }
                    }
                    
                    if (invalid_fin || !has_fin_in_box) continue;

                    // Eliminacja: w rzędzie bazowym, w bloku płetw, z wykluczeniem kolumn ryby
                    for (int cc = 0; cc < n; ++cc) {
                        if (cc == c1 || cc == c2) continue;
                        
                        const int t = base_row * n + cc;
                        if (st.topo->cell_box[t] != base_box) continue;
                        
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { 
                            s.elapsed_ns += st.now_ns() - t0; 
                            return er; 
                        }
                        if (er == ApplyResult::Progress) {
                            ++s.hit_count;
                            r.used_finned_x_wing_sashimi = true;
                            progress = true;
                        }
                    }
                }
            }
        }
    }

    s.elapsed_ns += st.now_ns() - t0;
    return progress ? ApplyResult::Progress : ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p5_expert



==============================================================================
PLIK: Sources\logic\p5_expert\simple_coloring.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: simple_coloring.h (Poziom 5 - Expert)
// Opis: Algorytm Simple Coloring korzystający z węzłów w powiązaniach silnych.
//       Rozwiązuje metodą przydzielania 2 kolorów z weryfikacją dwudzielności 
//       grafu i dedukcją (Rules: Color Trap & Color Wrap). Zero-allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/link_graph_builder.h"

namespace sudoku_hpc::logic::p5_expert {

inline ApplyResult apply_simple_coloring(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    bool any_progress = false;

    auto& sp = shared::exact_pattern_scratchpad();

    // Re-use tablic z exact_pattern_scratchpad jako zmienne kolorowania i kolejki
    int* color = sp.visited;        // Wielkość: MAX_NN (odwiedzono = pomalowano)
    int* queue = sp.bfs_queue;      // Wielkość: MAX_BFS
    int* comp_nodes = sp.chain_cell; // Wielkość: MAX_CHAIN
    
    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        
        // Zbudowanie grafu dla bieżącej cyfry. Moduł tworzy sp.dyn_strong_adj.
        if (!shared::build_grouped_link_graph_for_digit(st, d, sp)) continue;
        
        // Brak silnych powiązań -> brak możliwości użycia Simple Coloring
        if (sp.dyn_strong_edge_count == 0) continue;

        std::fill_n(color, sp.dyn_node_count, -1);

        for (int start_node = 0; start_node < sp.dyn_node_count; ++start_node) {
            // Pomijaj node'y bez powiązań silnych lub już pokolorowane
            if (sp.dyn_strong_degree[start_node] == 0) continue;
            if (color[start_node] != -1) continue;

            int qh = 0;
            int qt = 0;
            int comp_size = 0;
            
            bool conflict0 = false;
            bool conflict1 = false;

            color[start_node] = 0;
            queue[qt++] = start_node;
            
            // Faza 1: BFS - Pokolorowanie komponentu (Sieć silnych powiązań)
            while (qh < qt) {
                const int u = queue[qh++];
                if (comp_size < ExactPatternScratchpad::MAX_CHAIN) {
                    comp_nodes[comp_size++] = u;
                }
                
                const int my_color = color[u];
                const int opp_color = 1 - my_color;

                const int off_begin = sp.dyn_strong_offsets[u];
                const int off_end = sp.dyn_strong_offsets[u + 1];
                
                for (int e = off_begin; e < off_end; ++e) {
                    const int v = sp.dyn_strong_adj[e];
                    
                    if (color[v] == -1) {
                        color[v] = opp_color;
                        if (qt < ExactPatternScratchpad::MAX_BFS) {
                            queue[qt++] = v;
                        }
                    } else if (color[v] == my_color) {
                        // Color Trap: znaleziono dwa węzły tego samego koloru powiązane relacją silną.
                        // Graf przestaje być dwudzielny. Zatem 'my_color' na 100% wskazuje na fałszywą cyfrę.
                        if (my_color == 0) conflict0 = true;
                        else conflict1 = true;
                    }
                }
            }

            // Faza 2: Obsługa Color Trap (Eliminacja wewnętrzna w grupie)
            if (conflict0 || conflict1) {
                const int bad_color = conflict0 ? 0 : 1;
                
                for (int i = 0; i < comp_size; ++i) {
                    const int u = comp_nodes[i];
                    if (color[u] != bad_color) continue;
                    
                    const int cell = sp.dyn_node_to_cell[u];
                    const ApplyResult er = st.eliminate(cell, bit);
                    if (er == ApplyResult::Contradiction) { 
                        s.elapsed_ns += st.now_ns() - t0; 
                        return er; 
                    }
                    if (er == ApplyResult::Progress) {
                        ++s.hit_count;
                        r.used_simple_coloring = true;
                        any_progress = true;
                    }
                }
                // Jeśli usunęliśmy bad_color, to reszta planszy została zdestabilizowana,
                // więc kontynuacja analizy małej sieci może wywołać fałszywe redukcje.
                continue; 
            }

            // Faza 3: Obsługa Color Wrap (Rule 2 - Twice in a House)
            // Zbieramy komórki przypisane do kolorów 0 oraz 1
            int c0_count = 0;
            int c1_count = 0;
            int* const c0_cells = sp.bfs_depth;  // Używamy buforów BFS jako tempów
            int* const c1_cells = sp.bfs_parent;

            for (int i = 0; i < comp_size; ++i) {
                const int u = comp_nodes[i];
                if (color[u] == 0) c0_cells[c0_count++] = sp.dyn_node_to_cell[u];
                else c1_cells[c1_count++] = sp.dyn_node_to_cell[u];
            }

            // Szukamy niezwiązanych z naszą siecią komórek kandydujących, które widzą
            // przynajmniej jednego reprezentanta koloru 0 ORAZ koloru 1.
            // Skoro kolor 0 xor kolor 1 muszą stanowić rozwiązanie, to t-cell jest fałszywy.
            for (int i = 0; i < sp.dyn_digit_cell_count; ++i) {
                const int t_cell = sp.dyn_digit_cells[i];
                const int t_node = sp.dyn_cell_to_node[t_cell];
                
                // Jeśli ten node jest pomalowany w naszej bieżącej iteracji - omiń (zajęliśmy się nim wyżej)
                if (t_node >= 0 && color[t_node] != -1) continue;
                
                bool sees_0 = false;
                for (int k = 0; k < c0_count; ++k) {
                    if (st.is_peer(t_cell, c0_cells[k])) {
                        sees_0 = true;
                        break;
                    }
                }
                if (!sees_0) continue;

                bool sees_1 = false;
                for (int k = 0; k < c1_count; ++k) {
                    if (st.is_peer(t_cell, c1_cells[k])) {
                        sees_1 = true;
                        break;
                    }
                }
                if (!sees_1) continue;

                // Znaleziono komórkę spiętą (wraps). Posiada ona wspólną widoczność dla c0 i c1
                const ApplyResult er = st.eliminate(t_cell, bit);
                if (er == ApplyResult::Contradiction) { 
                    s.elapsed_ns += st.now_ns() - t0; 
                    return er; 
                }
                if (er == ApplyResult::Progress) {
                    ++s.hit_count;
                    r.used_simple_coloring = true;
                    any_progress = true;
                }
            }
        }
    }

    s.elapsed_ns += st.now_ns() - t0;
    return any_progress ? ApplyResult::Progress : ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p5_expert



==============================================================================
PLIK: Sources\logic\p5_expert\unique_rectangle_t1.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: unique_rectangle_t1.h (Poziom 5 - Expert)
// Opis: Wykrywa podstawowy typ Unique Rectangle (Type 1). 
//       Zapobiega powstaniu Dead Patternu (4 komórki bivalue w 2 blokach), 
//       eliminując kandydatów tworzących ten wzorzec z komórki celującej.
//       Zero-allocation - pętle rygorystycznie oparte na bitboardach.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>
#include <array>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p5_expert {

inline ApplyResult apply_unique_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Oparta o geometrię bloku, zatem odrzuca proste rury i wektory 1D
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int n = st.topo->n;
    bool progress = false;
    
    // Szukamy potencjalnych par komórek, by stworzyć narożniki (corners)
    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const int a = r1 * n + c1;
                    const int b = r1 * n + c2;
                    const int c = r2 * n + c1;
                    const int d = r2 * n + c2;
                    
                    // Wszystkie narożniki muszą być nieodkryte
                    if (st.board->values[a] != 0 ||
                        st.board->values[b] != 0 ||
                        st.board->values[c] != 0 ||
                        st.board->values[d] != 0) {
                        continue;
                    }
                    
                    const std::array<int, 4> cells = {a, b, c, d};
                    const std::array<uint64_t, 4> masks = {
                        st.cands[a],
                        st.cands[b],
                        st.cands[c],
                        st.cands[d],
                    };
                    
                    // Muszą współdzielić tę samą parę jako bazę UR
                    const uint64_t pair = masks[0] & masks[1] & masks[2] & masks[3];
                    if (std::popcount(pair) != 2) continue;
                    
                    // Upewnienie się, że rdzeń cyfr bivalue znajduje się w każdym narożniku
                    bool valid_mask = true;
                    for (int i = 0; i < 4; ++i) {
                        if ((masks[i] & pair) != pair) {
                            valid_mask = false;
                            break;
                        }
                    }
                    if (!valid_mask) continue;
                    
                    // Aby był to poprawny Deadly Pattern zagrażający logice, 
                    // całe 4 komórki muszą dzielić DOKŁADNIE DWA BLOKI (2 boxes).
                    std::array<int, 4> boxes = {
                        st.topo->cell_box[a],
                        st.topo->cell_box[b],
                        st.topo->cell_box[c],
                        st.topo->cell_box[d],
                    };
                    
                    // Prosty trick na usunięcie duplikatów ze stacka 
                    // (zamiast std::set bez lokowania w 2 operacjach)
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    if (boxes[1] > boxes[2]) std::swap(boxes[1], boxes[2]);
                    if (boxes[2] > boxes[3]) std::swap(boxes[2], boxes[3]);
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    if (boxes[1] > boxes[2]) std::swap(boxes[1], boxes[2]);
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    
                    int unique_boxes = 1;
                    for (int i = 1; i < 4; ++i) {
                        if (boxes[i] != boxes[i - 1]) ++unique_boxes;
                    }
                    if (unique_boxes != 2) continue;
                    
                    // Szukamy Type 1 (3 komórki to CZYSTE bivalue dla tej pary) 
                    // 4-ta komórka (target) posiada coś więcej. Z tej celującej komórki
                    // odcinamy `pair`, zapobiegając wytworzeniu martwego prostokąta.
                    int exact_pair_count = 0;
                    int target_idx = -1;
                    
                    for (int i = 0; i < 4; ++i) {
                        if (masks[i] == pair) {
                            ++exact_pair_count;
                        } else if (std::popcount(masks[i]) > 2) {
                            target_idx = cells[i];
                        }
                    }
                    
                    if (exact_pair_count == 3 && target_idx >= 0) {
                        const ApplyResult er = st.eliminate(target_idx, pair);
                        if (er == ApplyResult::Contradiction) { 
                            s.elapsed_ns += st.now_ns() - t0; 
                            return er; 
                        }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
    }
    
    if (progress) {
        ++s.hit_count;
        r.used_unique_rectangle = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p5_expert



==============================================================================
PLIK: Sources\logic\p5_expert\xyz_w_wing.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: xyz_w_wing.h (Poziom 5 - Expert)
// Opis: Implementacja strategii skrzydeł (Wings) dla Poziomu 5:
//       - XYZ-Wing: trójelementowy pivot (XYZ) + dwa bivalue.
//       - W-Wing: 2x bivalue sprzęgnięte oddalonym "Strong Linkiem".
//       System Zero-Allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p5_expert {

inline ApplyResult apply_xyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    bool progress = false;

    // XYZ-Wing szuka w pierwszej kolejności Pivota (węzła o równej liczbie 3 kandydatów, np. {X, Y, Z})
    for (int pivot = 0; pivot < st.topo->nn; ++pivot) {
        if (st.board->values[pivot] != 0) continue;
        const uint64_t mp = st.cands[pivot];
        if (std::popcount(mp) != 3) continue;

        // Szukamy pierwszego skrzydła widocznego dla Pivota
        const int p0 = st.topo->peer_offsets[pivot];
        const int p1 = st.topo->peer_offsets[pivot + 1];
        
        for (int i = p0; i < p1; ++i) {
            const int a = st.topo->peers_flat[i];
            if (st.board->values[a] != 0) continue;
            
            const uint64_t ma = st.cands[a];
            // Skrzydło musi być Bivalue i być podzbiorem masek Pivota (np. {X, Z})
            if (std::popcount(ma) != 2 || (ma & ~mp) != 0ULL) continue;

            // Szukamy drugiego skrzydła widocznego dla Pivota
            for (int j = i + 1; j < p1; ++j) {
                const int b = st.topo->peers_flat[j];
                if (st.board->values[b] != 0) continue;
                
                const uint64_t mb = st.cands[b];
                // Drugie skrzydło również musi być podzbiorem (np. {Y, Z})
                if (std::popcount(mb) != 2 || (mb & ~mp) != 0ULL) continue;

                // Razem, A i B muszą rekonstruować całą maskę MP Pivota (np. XZ | YZ = XYZ)
                if ((ma | mb) != mp) continue;
                
                // Element "Z" do wyeliminowania to część wspólna masek obu skrzydeł (np. Z z {X, Z} i {Y, Z})
                const uint64_t z = ma & mb;
                if (std::popcount(z) != 1) continue;

                // Szukamy targetu: Komórka, z której będziemy uderzać (eliminować), musi 
                // widzieć JEDNOCZEŚNIE pivota oraz OBA skrzydła (w przeciwieństwie do Y-Wing).
                const int ap0 = st.topo->peer_offsets[a];
                const int ap1 = st.topo->peer_offsets[a + 1];
                for (int p = ap0; p < ap1; ++p) {
                    const int t = st.topo->peers_flat[p];
                    if (t == pivot || t == a || t == b) continue;
                    
                    if (!st.is_peer(t, b)) continue;
                    if (!st.is_peer(t, pivot)) continue;
                    
                    const ApplyResult er = st.eliminate(t, z);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_xyz_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_w_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    // 1. Zbudowanie bufora silnych powiązań (Strong Links) per cyfra d.
    // Używamy zintegrowanych tablic 2D (zero alloc) z shared/exact_pattern_scratchpad.
    for (int d = 1; d <= n; ++d) {
        sp.strong_count[d] = 0;
        const uint64_t bit = (1ULL << (d - 1));
        
        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h];
            const int p1 = st.topo->house_offsets[h + 1];
            int a = -1, b = -1, cnt = 0;
            
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[p];
                if (st.board->values[idx] != 0) continue;
                if ((st.cands[idx] & bit) == 0ULL) continue;
                
                if (cnt == 0) a = idx;
                else if (cnt == 1) b = idx;
                
                ++cnt;
                if (cnt > 2) break;
            }
            // Jeśli występuje tylko 2 razy - silne powiązanie (Strong Link)
            if (cnt == 2 && a >= 0 && b >= 0) {
                int at = sp.strong_count[d];
                if (at < ExactPatternScratchpad::MAX_STRONG_LINKS_PER_DIGIT) {
                    sp.strong_a[d][at] = a;
                    sp.strong_b[d][at] = b;
                    ++sp.strong_count[d];
                }
            }
        }
    }

    // 2. Zebranie komórek bivalue w płaską listę, aby nie robić N^2 skanów
    sp.als_cell_count = 0; 
    for (int idx = 0; idx < st.topo->nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 2) {
            sp.als_cells[sp.als_cell_count++] = idx;
        }
    }

    const int bn = sp.als_cell_count;
    for (int i = 0; i < bn; ++i) {
        const int a = sp.als_cells[i];
        const uint64_t ma = st.cands[a];
        
        for (int j = i + 1; j < bn; ++j) {
            const int b = sp.als_cells[j];
            
            // W-Wing dotyczy komórek o identycznych maskach, które się NIE widzą
            if (st.is_peer(a, b)) continue;
            const uint64_t mb = st.cands[b];
            
            if (ma != mb) continue;
            
            uint64_t bit1 = ma & (~ma + 1ULL);
            uint64_t bit2 = ma ^ bit1;
            
            const std::array<uint64_t, 2> z_bits = {bit1, bit2};
            
            // Próbujemy spiąć cyfrą 'z', by dokonać eliminacji drugiej cyfry ('other')
            for (const uint64_t z : z_bits) {
                if (z == 0ULL) continue;
                
                const uint64_t other = ma ^ z;
                const int zd = config::bit_ctz_u64(z) + 1;
                if (zd < 1 || zd > n) continue;
                
                bool linked = false;
                // Sprawdzenie powiązań z bufora zero-alloc
                for (int li = 0; li < sp.strong_count[zd]; ++li) {
                    const int u = sp.strong_a[zd][li];
                    const int v = sp.strong_b[zd][li];
                    
                    // Most (Bridge) wymaga silnego powiązania, którego dwa końce 
                    // widzą jedno i drugie ramię bivalue.
                    if ((st.is_peer(a, u) && st.is_peer(b, v)) ||
                        (st.is_peer(a, v) && st.is_peer(b, u))) {
                        linked = true;
                        break;
                    }
                }
                
                if (!linked) continue;
                
                // Dokonano dowodu łączności W-Winga, redukujemy 'other' ze stref skrzyżowania A i B.
                const int p0 = st.topo->peer_offsets[a];
                const int p1 = st.topo->peer_offsets[a + 1];
                for (int p = p0; p < p1; ++p) {
                    const int t = st.topo->peers_flat[p];
                    if (t == a || t == b) continue;
                    
                    if (!st.is_peer(t, b)) continue; // Tylko intersekcje
                    
                    const ApplyResult er = st.eliminate(t, other);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_w_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p5_expert



==============================================================================
PLIK: Sources\logic\p6_diabolical\als_xz.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: als_xz.h (Poziom 6 - Diabolical)
// Opis: Algorytm ALS-XZ. Oparty o zbiory Almost Locked Sets.
//       Rozwiązuje dylematy węzłów ograniczonych silnymi powiązaniami, 
//       eliminując cyfry z rejonów przecinających widoczność.
//       Gwarancja zero-allocation dzięki wykorzystaniu ExactPatternScratchpad.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/als_builder.h"

namespace sudoku_hpc::logic::p6_diabolical {

inline ApplyResult apply_als_xz(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    bool progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    // Wyczyszczenie silnych powiązań na potrzeby Restriced Common (X)
    for (int d = 0; d <= n; ++d) {
        sp.strong_count[d] = 0;
    }
    
    // Budujemy listę powiązań silnych dla każdej cyfry.
    // Jeśli w którymkolwiek domku (house) dana cyfra występuje DOKŁADNIE 2 razy, 
    // mówimy, że te 2 komórki są spięte "Strong Linkiem".
    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        
        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h];
            const int p1 = st.topo->house_offsets[h + 1];
            int a = -1;
            int b = -1;
            int cnt = 0;
            
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[p];
                if (st.board->values[idx] != 0) continue;
                if ((st.cands[idx] & bit) == 0ULL) continue;
                
                if (cnt == 0) a = idx;
                else if (cnt == 1) b = idx;
                
                ++cnt;
                if (cnt > 2) break;
            }
            if (cnt == 2 && a >= 0 && b >= 0) {
                const int at = sp.strong_count[d];
                if (at < ExactPatternScratchpad::MAX_STRONG_LINKS_PER_DIGIT) {
                    sp.strong_a[d][at] = a;
                    sp.strong_b[d][at] = b;
                    ++sp.strong_count[d];
                }
            }
        }
    }

    // Budujemy globalną tablicę ALS dostępną dla aktualnej iteracji.
    // Ustawiamy limit 2-4 komórek, by nie utonąć w nieskończonych permutacji
    // gigantycznych plansz (co niszczyłoby Performance w 64x64).
    const int als_cnt = shared::build_als_list(st, 2, 4);
    if (als_cnt < 2) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    // Przeszukiwanie par ALS-ów (A i B)
    for (int i = 0; i < als_cnt; ++i) {
        const shared::ALS& a = sp.als_list[i];
        
        for (int j = i + 1; j < als_cnt; ++j) {
            const shared::ALS& b = sp.als_list[j];
            
            // Dwa ALS nie mogą mieć nakładających się komórek.
            bool overlapping = false;
            for (int w = 0; w < ((nn + 63) >> 6); ++w) {
                if ((a.cell_mask[w] & b.cell_mask[w]) != 0ULL) {
                    overlapping = true;
                    break;
                }
            }
            if (overlapping) continue;

            const uint64_t common = a.digit_mask & b.digit_mask;
            // Muszą współdzielić co najmniej 2 cyfry: "X" (Restricted Common) i "Z" (cel eliminacji)
            if (std::popcount(common) < 2) continue;

            // Iterujemy, zakładając każdą wspólną cyfrę jako "X"
            uint64_t wx = common;
            while (wx != 0ULL) {
                const uint64_t x = config::bit_lsb(wx);
                wx = config::bit_clear_lsb_u64(wx);
                
                const int xd = config::bit_ctz_u64(x) + 1;
                if (xd < 1 || xd > n) continue;

                // Aby "X" był Restricted Common, komórki ALS A i ALS B zawierające "X" muszą się "widzieć".
                // Najsilniejszym dowodem na to jest występowanie Strong Linka między nimi, lub po prostu
                // wzajemna widoczność w tym samym domku (house).
                bool x_is_restricted = false;
                
                // Sprawdzanie widoczności cyfry "X" między ALS A i B
                int a_x_cell = -1;
                int b_x_cell = -1;
                
                // Zlokalizuj komórkę z ALS 'A' zawierającą kandydata X
                for (int w = 0; w < ((nn + 63) >> 6) && a_x_cell == -1; ++w) {
                    uint64_t mask_w = a.cell_mask[w];
                    while (mask_w != 0ULL) {
                        const int cell_idx = (w << 6) + config::bit_ctz_u64(mask_w);
                        if ((st.cands[cell_idx] & x) != 0ULL) {
                            a_x_cell = cell_idx;
                            break;
                        }
                        mask_w = config::bit_clear_lsb_u64(mask_w);
                    }
                }
                
                // Zlokalizuj komórkę z ALS 'B' zawierającą kandydata X
                for (int w = 0; w < ((nn + 63) >> 6) && b_x_cell == -1; ++w) {
                    uint64_t mask_w = b.cell_mask[w];
                    while (mask_w != 0ULL) {
                        const int cell_idx = (w << 6) + config::bit_ctz_u64(mask_w);
                        if ((st.cands[cell_idx] & x) != 0ULL) {
                            b_x_cell = cell_idx;
                            break;
                        }
                        mask_w = config::bit_clear_lsb_u64(mask_w);
                    }
                }

                // Są w relacji zablokowanej jeśli po prostu się widzą (zatem oba nie mogą naraz przyjąć "X")
                if (a_x_cell >= 0 && b_x_cell >= 0 && st.is_peer(a_x_cell, b_x_cell)) {
                    x_is_restricted = true;
                }
                
                if (!x_is_restricted) continue;

                // Sukces: "X" jest zablokowane. Pozostałe wspólnie dzielone maski (Z) 
                // mogą służyć do uderzeń w planszę.
                const uint64_t zmask = common & ~x;
                uint64_t wz = zmask;
                
                while (wz != 0ULL) {
                    const uint64_t z = config::bit_lsb(wz);
                    wz = config::bit_clear_lsb_u64(wz);
                    
                    // Szukamy potencjalnej komórki docelowej do eliminacji 'Z'
                    for (int t = 0; t < nn; ++t) {
                        if (st.board->values[t] != 0) continue;
                        if ((st.cands[t] & z) == 0ULL) continue;
                        
                        // Nie możemy niszczyć macierzy wewnątrz naszych testowanych ALS-ów
                        if (shared::als_cell_in(a, t) || shared::als_cell_in(b, t)) continue;

                        // Target (t) musi widzieć WSZYSTKIE wystąpienia 'Z' w ALS A oraz w ALS B.
                        bool sees_all_a = true;
                        for (int w_a = 0; w_a < ((nn + 63) >> 6) && sees_all_a; ++w_a) {
                            uint64_t mask_w = a.cell_mask[w_a];
                            while (mask_w != 0ULL) {
                                const int cell_idx = (w_a << 6) + config::bit_ctz_u64(mask_w);
                                if ((st.cands[cell_idx] & z) != 0ULL && !st.is_peer(t, cell_idx)) {
                                    sees_all_a = false;
                                    break;
                                }
                                mask_w = config::bit_clear_lsb_u64(mask_w);
                            }
                        }
                        if (!sees_all_a) continue;

                        bool sees_all_b = true;
                        for (int w_b = 0; w_b < ((nn + 63) >> 6) && sees_all_b; ++w_b) {
                            uint64_t mask_w = b.cell_mask[w_b];
                            while (mask_w != 0ULL) {
                                const int cell_idx = (w_b << 6) + config::bit_ctz_u64(mask_w);
                                if ((st.cands[cell_idx] & z) != 0ULL && !st.is_peer(t, cell_idx)) {
                                    sees_all_b = false;
                                    break;
                                }
                                mask_w = config::bit_clear_lsb_u64(mask_w);
                            }
                        }
                        if (!sees_all_b) continue;
                        
                        // Eliminacja
                        const ApplyResult er = st.eliminate(t, z);
                        if (er == ApplyResult::Contradiction) { 
                            s.elapsed_ns += st.now_ns() - t0; 
                            return er; 
                        }
                        if (er == ApplyResult::Progress) {
                            ++s.hit_count;
                            r.used_als_xz = true;
                            progress = true;
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\borescoper_qiu.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: borescoper_qiu.h (Poziom 6 - Diabolical)
// Opis: Implementacja strategii z rodziny "Deadly Patterns" - ze szczegĂłlnym 
//       uwzglÄ™dnieniem Borescoper's Deadly Pattern oraz Qiu's Deadly Pattern.
//       SÄ… to zĹ‚oĹĽone ukĹ‚ady 4 wierzchoĹ‚kĂłw na rĂłĹĽnych blokach, ktĂłrych 
//       doprowadzenie do 2 cyfr rujnuje unikalnoĹ›Ä‡ planszy.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>
#include <array>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

// DoĹ‚Ä…czamy narzÄ™dzia niezbÄ™dne do analizy kompozytowej
#include "ur_extended.h"
#include "bug_variants.h"
#include "../p7_nightmare/aic_grouped_aic.h"

namespace sudoku_hpc::logic::p6_diabolical {

// ============================================================================
// Borescoper's Deadly Pattern / Qiu's Deadly Pattern
// Kombinacja twardej heurystyki oraz zestawu zagnieĹĽdĹĽonych wywoĹ‚aĹ„
// z wariantĂłw UR/BUG (Composite).
// ============================================================================
inline ApplyResult apply_borescoper_qiu_deadly_pattern(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    // Heurystyka wczesnego wyjĹ›cia - brak blokĂłw (brak geometrii UR) lub plansza jest zbyt pusta
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    StrategyStats tmp{};

    // Krok 1: Wiele z tych struktur matematycznie objawia siÄ™ jako rozszerzone 
    // Unique Rectangles (Type 2-6) - z tÄ… rĂłĹĽnicÄ…, ĹĽe sÄ… mocniej rozrzucone.
    ApplyResult ar = apply_ur_extended(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar; 
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // Krok 2: Odrzucenie ukrytych skrzyĹĽowaĹ„ (Hidden UR), co matematycznie 
    // pokrywa czÄ™Ĺ›Ä‡ Qiu's Deadly Pattern.
    ar = apply_hidden_ur(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar; 
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // Krok 3: Analiza BUG (Bivalue Universal Grave)
    ar = apply_bug_type2(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; return ar; }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    ar = apply_bug_type3(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; return ar; }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    ar = apply_bug_type4(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; return ar; }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // ------------------------------------------------------------------------
    // Krok 4: Extra Deadly check (Twarda detekcja Borescoper's/Qiu's DP)
    //         JeĹĽeli ZEWNÄTRZNA komĂłrka (spoza struktury) potrafi wygenerowaÄ‡ 
    //         sprzecznoĹ›Ä‡ dla 4 komĂłrek UR i widzi je wszystkie jednoczeĹ›nie
    //         z parÄ… cyfr - purguje zaporÄ™.
    // ------------------------------------------------------------------------
    const int n = st.topo->n;
    bool progress = false;

    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const int a = r1 * n + c1;
                    const int b = r1 * n + c2;
                    const int c = r2 * n + c1;
                    const int d = r2 * n + c2;
                    
                    if (st.board->values[a] != 0 ||
                        st.board->values[b] != 0 ||
                        st.board->values[c] != 0 ||
                        st.board->values[d] != 0) {
                        continue;
                    }
                    
                    // Badamy przeciÄ™cie czterech komĂłrek by znaleĹşÄ‡ parÄ™ Ĺ›miercionoĹ›nÄ…
                    const uint64_t pair = st.cands[a] & st.cands[b] & st.cands[c] & st.cands[d];
                    if (std::popcount(pair) != 2) continue; // DP wymaga pary cyfr
                    
                    // Cel ataku (target) to inna komĂłrka na planszy widzÄ…ca w peĹ‚ni kwartet
                    for (int t = 0; t < st.topo->nn; ++t) {
                        if (t == a || t == b || t == c || t == d) continue;
                        if (st.board->values[t] != 0) continue;
                        
                        // Czy target widzi wszystkie komĂłrki struktury Borescoper?
                        if (!st.is_peer(t, a) || !st.is_peer(t, b) || 
                            !st.is_peer(t, c) || !st.is_peer(t, d)) {
                            continue;
                        }
                        
                        // Wyeliminowanie 'pary' by nie zamknÄ…Ä‡ pÄ™tli
                        const ApplyResult er = st.eliminate(t, pair);
                        if (er == ApplyResult::Contradiction) { 
                            s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
                            return er; 
                        }
                        if (er == ApplyResult::Progress) {
                            progress = true;
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_borescoper_qiu_deadly_pattern = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\bug_variants.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: bug_variants.h (Poziom 6 - Diabolical)
// Opis: Implementacja zaawansowanych wariantów Bivalue Universal Grave 
//       (BUG Type 2, BUG Type 3, BUG Type 4). Służą do eliminacji kandydatów 
//       na krawędzi Deadly Pattern'u, gdy występuje więcej niż jedna komórka 
//       typu trivalue.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p6_diabolical {

// ============================================================================
// BUG Type 2
// Szuka dwóch komórek (trivalue), które mają identyczne maski i się "widzą" 
// na planszy opanowanej przez komórki bivalue. Współdzielona "trzecia" cyfra 
// zostaje usunięta z ich wspólnej strefy widzenia.
// ============================================================================
inline ApplyResult apply_bug_type2(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Heurystyka odrzucająca wczesny etap (BUG wymaga dużej gęstości planszy)
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int nn = st.topo->nn;
    int tri[64]{};
    int tc = 0;
    
    // Filtrujemy planszę w poszukiwaniu komórek trivalue
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 3) {
            if (tc < 64) tri[tc++] = idx;
        }
    }
    
    bool progress = false;
    for (int i = 0; i < tc; ++i) {
        const int a = tri[i];
        const uint64_t ma = st.cands[a];
        
        for (int j = i + 1; j < tc; ++j) {
            const int b = tri[j];
            if (!st.is_peer(a, b)) continue; // Muszą być we wspólnym "domku"
            
            const uint64_t mb = st.cands[b];
            const uint64_t shared = ma & mb;
            
            // Warunek: Dwie wspólne "oryginalne" cyfry BUG-a, oraz trzecia "obca"
            if (std::popcount(shared) != 2) continue;
            
            // "Obca" cyfra z poza pary shared to nasza cyfra X. Musi zostać w A lub B.
            // BUG Type 2 uderza we wspólne cele tych dwóch komórek i usuwa stamtąd cyfrę X.
            // Dla ułatwienia operacji, w C++ "st.keep_only(..., shared)" eliminuje wszystkie
            // INNE cyfry (w tym cyfrę X) dla komórek widzących a i b, które nie są częścią BUG'a.
            
            // Jednak to nie jest w 100% bezpieczne dla asymetrycznych siatek bez głębokiej walidacji.
            // Bardziej ortodoksyjna wersja Type 2: My wymuszamy, że cyfra X musi być 
            // prawdziwa dla A lub dla B. Wobec tego każdy 'target' widzący i A i B 
            // nie może być X.
            
            uint64_t xa = ma & ~shared;
            uint64_t xb = mb & ~shared;
            
            if (xa == 0ULL || xa != xb) continue; // Cyfra wykraczająca poza układ BUG musi być TĄ SAMĄ
            
            const uint64_t extra_digit = xa;
            
            // Eliminacja z intersection A i B
            const int p0 = st.topo->peer_offsets[a];
            const int p1 = st.topo->peer_offsets[a + 1];
            for (int p = p0; p < p1; ++p) {
                const int t = st.topo->peers_flat[p];
                if (t == a || t == b) continue;
                if (!st.is_peer(t, b)) continue; // Musi widzieć oba węzły
                
                const ApplyResult er = st.eliminate(t, extra_digit);
                if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                progress = progress || (er == ApplyResult::Progress);
            }
        }
    }
    
    if (progress) {
        ++s.hit_count;
        r.used_bug_type2 = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}


// ============================================================================
// BUG Type 3
// Przekłada poszukiwanie z komórek na "domki". Jeżeli te same trivalue cells 
// dzielą wspólny domek i ich wspólne unikalne cyfry występują w tym domku tylko
// w tych specyficznych komórkach, redukuje bivalues.
// (Uproszczona, zoptymalizowana hybryda skanu dla HPC).
// ============================================================================
inline ApplyResult apply_bug_type3(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    int tri[64]{};
    int tc = 0;
    
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 3 && tc < 64) {
            tri[tc++] = idx;
        }
    }
    if (tc == 0) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    for (int ti = 0; ti < tc; ++ti) {
        const int idx = tri[ti];
        const int rr = st.topo->cell_row[idx];
        const int cc = st.topo->cell_col[idx];
        const int bb = st.topo->cell_box[idx];
        const uint64_t m = st.cands[idx];
        
        uint64_t w = m;
        while (w != 0ULL) {
            const uint64_t bit = config::bit_lsb(w);
            w = config::bit_clear_lsb_u64(w);
            
            int row_cnt = 0;
            int col_cnt = 0;
            int box_cnt = 0;
            
            for (int c = 0; c < n; ++c) {
                const int t = rr * n + c;
                if (st.board->values[t] == 0 && (st.cands[t] & bit) != 0ULL) ++row_cnt;
            }
            for (int r0 = 0; r0 < n; ++r0) {
                const int t = r0 * n + cc;
                if (st.board->values[t] == 0 && (st.cands[t] & bit) != 0ULL) ++col_cnt;
            }
            for (int t = 0; t < nn; ++t) {
                if (st.topo->cell_box[t] != bb) continue;
                if (st.board->values[t] == 0 && (st.cands[t] & bit) != 0ULL) ++box_cnt;
            }
            
            // Warunek rozwiązujący "True Value" paradoksu
            if ((row_cnt & 1) == 1 && (col_cnt & 1) == 1 && (box_cnt & 1) == 1) {
                const int d = config::bit_ctz_u64(bit) + 1;
                if (!st.place(idx, d)) {
                    s.elapsed_ns += st.now_ns() - t0;
                    return ApplyResult::Contradiction;
                }
                
                ++s.hit_count;
                ++s.placements;
                ++r.steps;
                r.used_bug_type3 = true;
                
                s.elapsed_ns += st.now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}


// ============================================================================
// BUG Type 4
// Skomplikowane powiązanie krzyżowe między dwiema komórkami trivalue, 
// bazujące na wspólnym kandydującym duecie połączonym ze słabym ogniwem.
// ============================================================================
inline ApplyResult apply_bug_type4(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int nn = st.topo->nn;
    int tri[64]{};
    int tc = 0;
    
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 3 && tc < 64) {
            tri[tc++] = idx;
        }
    }
    
    bool progress = false;
    for (int i = 0; i < tc; ++i) {
        const int a = tri[i];
        const uint64_t ma = st.cands[a];
        
        for (int j = i + 1; j < tc; ++j) {
            const int b = tri[j];
            const uint64_t mb = st.cands[b];
            
            // Szukamy pary trivalue współdzielącej wyłącznie jeden, specyficzny "słaby" punkt
            const uint64_t common = ma & mb;
            if (std::popcount(common) != 1) continue;
            
            // Muszą się widzieć z oboma trivalue węzłami
            for (int t = 0; t < nn; ++t) {
                if (t == a || t == b) continue;
                if (st.board->values[t] != 0) continue;
                if (!st.is_peer(t, a) || !st.is_peer(t, b)) continue;
                
                // Redukcja wspólnego ułamka z targetu
                const ApplyResult er = st.eliminate(t, common);
                if (er == ApplyResult::Contradiction) { 
                    s.elapsed_ns += st.now_ns() - t0; 
                    return er; 
                }
                progress = progress || (er == ApplyResult::Progress);
            }
        }
    }
    
    if (progress) {
        ++s.hit_count;
        r.used_bug_type4 = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\chains_basic.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: chains_basic.h (Poziom 6 - Diabolical)
// Opis: Algorytmy oparte na łańcuchach logicznych: X-Chain i XY-Chain.
//       Wszystkie analizy działają na spłaszczonych drzewach (BFS) w
//       buforze exact_pattern_scratchpad by uniknąć the memory overhead.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/link_graph_builder.h"

namespace sudoku_hpc::logic::p6_diabolical {

// ============================================================================
// X-Chain (Single Digit Alternating Inference Chain)
// Szuka łańcuchów Strong-Weak-Strong... gdzie dwa końce prowadzą do eliminacji 
// danej cyfry w punkcie "zbiegu" wzroku obu krańców łańcucha.
// ============================================================================
inline ApplyResult apply_x_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    bool progress = false;
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        
        // Zbieramy komórki dla tej konkretnej cyfry w tablicy als_cells (jako temp)
        int digit_cell_count = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) != 0ULL) {
                sp.als_cells[digit_cell_count++] = idx;
            }
        }
        
        // Łańcuch wymaga przynajmniej 4 elementów (Start -> W1 -> S1 -> End)
        if (digit_cell_count < 4) continue;

        // Tworzymy graf silnych/słabych powiązań tylko dla tej cyfry 'd'
        if (!shared::build_grouped_link_graph_for_digit(st, d, sp)) continue;
        if (sp.dyn_node_count < 4 || sp.dyn_strong_edge_count == 0) continue;

        // BFS poszukujący naprzemiennych łańcuchów
        for (int start = 0; start < sp.dyn_node_count; ++start) {
            
            std::fill_n(sp.visited, sp.dyn_node_count, -1);
            int qh = 0;
            int qt = 0;
            
            // Inicjalizujemy węzeł startowy
            sp.bfs_queue[qt++] = start;
            sp.visited[start] = 0; // Odległość 0

            // Rozwijanie łańcucha wszerz (BFS) - przeplatane z wykorzystaniem sp.visited jako znacznika głębokości
            while (qh < qt) {
                const int u = sp.bfs_queue[qh++];
                const int du = sp.visited[u];
                
                // Silne/Słabe krawędzie mamy w tablicach dyn_strong_adj i dyn_weak_adj, 
                // ale X-Chain zadowoli się po prostu silnymi powiązaniami w węzłach nieparzystych.
                // Aby ułatwić i przyspieszyć, idziemy wprost po wybudowanym mapowaniu.
                
                // UWAGA: X-Chain wykorzystuje przeplatanie (Alternating Inference). Zatem:
                // Krok od 0 (Start) wymaga powiązania SILNEGO (->1).
                // Krok z 1 może być powiązaniem SŁABYM lub SILNYM (->2).
                // Generalnie dla prostego X-Chain iterujemy poprzez silne łącza traktując je jako nośniki.
                const int off_begin = sp.dyn_strong_offsets[u];
                const int off_end = sp.dyn_strong_offsets[u + 1];
                
                for (int ei = off_begin; ei < off_end; ++ei) {
                    const int v = sp.dyn_strong_adj[ei];
                    if (sp.visited[v] != -1) continue;
                    
                    sp.visited[v] = du + 1;
                    if (qt < ExactPatternScratchpad::MAX_BFS) {
                        sp.bfs_queue[qt++] = v;
                    }
                }
            }

            const int start_cell = sp.dyn_node_to_cell[start];
            
            // Szukamy końcówki łańcucha (End), który dzieli nieparzystą liczbę skoków i widzi Start
            for (int end = 0; end < sp.dyn_node_count; ++end) {
                const int de = sp.visited[end];
                // Wymagamy minimum 3 skoków i długości nieparzystej dla klasycznego powiązania (S-W-S)
                // W tej mocno zoptymalizowanej wersji przeszukujemy po silnych komponentach 
                // więc skok o 3 oznacza (Start -> Node1 -> Node2 -> End).
                if (de < 3 || (de & 1) == 0) continue;
                
                const int end_cell = sp.dyn_node_to_cell[end];
                
                // Start i End muszą się widzieć (tzw. "X-Chain loop" albo zbieżność) lub my
                // uderzamy w komórkę, która widzi oba.
                if (!st.is_peer(start_cell, end_cell)) continue;
                
                // Znajdujemy cel `idx`, z którego można usunąć naszą cyfrę (bit)
                for (int di = 0; di < digit_cell_count; ++di) {
                    const int idx = sp.als_cells[di];
                    if (idx == start_cell || idx == end_cell) continue;
                    
                    if (!st.is_peer(idx, start_cell) || !st.is_peer(idx, end_cell)) continue;
                    
                    const ApplyResult er = st.eliminate(idx, bit);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    if (er == ApplyResult::Progress) {
                        ++s.hit_count;
                        r.used_x_chain = true;
                        progress = true;
                    }
                }
            }
        }
    }

    if (progress) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}


// ============================================================================
// XY-Chain 
// Łańcuch oparty o powiązania węzłów typu "Bivalue" (2 kandydatów).
// Szukamy ścieżki: xy -> yz -> zw -> wx. 
// Eliminujemy cyfrę wspólną dla końców w miejscu ich skrzyżowania.
// ============================================================================
inline ApplyResult apply_xy_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int nn = st.topo->nn;
    
    // Zapobiegamy eksplozji przeszukiwań (szukamy do ustalonej głębokości)
    const int max_depth = (st.topo->n <= 16) ? 8 : 6;
    
    auto& sp = shared::exact_pattern_scratchpad();
    int bivalue_count = 0;
    
    // Zbieramy komórki dwukandydatowe
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 2) {
            sp.als_cells[bivalue_count++] = idx;
        }
    }
    
    if (bivalue_count < 3) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    // Prosta funkcja pomocnicza: weryfikuje czy węzeł jest już w bieżącym łańcuchu
    auto path_contains_cell = [&](int node_idx, int cell) -> bool {
        int cur = node_idx;
        while (cur >= 0) {
            if (sp.chain_cell[cur] == cell) return true;
            cur = sp.chain_parent[cur];
        }
        return false;
    };

    bool any_progress = false;

    for (int bi = 0; bi < bivalue_count; ++bi) {
        const int start = sp.als_cells[bi];
        const uint64_t start_mask = st.cands[start];
        
        // Rozgałęzienie startowe - w którą stronę uderzamy po łańcuchu?
        uint64_t wz = start_mask;
        while (wz != 0ULL) {
            const uint64_t zbit = config::bit_lsb(wz);
            wz = config::bit_clear_lsb_u64(wz);
            
            if ((start_mask ^ zbit) == 0ULL) continue;

            sp.chain_count = 1;
            sp.chain_cell[0] = start;
            sp.chain_enter_bit[0] = zbit; // Cyfra użyta do wyjścia z pierwszej komórki
            sp.chain_parent[0] = -1;
            sp.chain_depth[0] = 0;

            // Przeszukiwanie łańcucha (zmodyfikowany BFS dla tras bivalue)
            for (int ni = 0; ni < sp.chain_count; ++ni) {
                const int cur_cell = sp.chain_cell[ni];
                const uint64_t cur_enter = sp.chain_enter_bit[ni];
                const uint64_t cur_mask = st.cands[cur_cell];
                
                // Awaryjne weryfikacje (np. z powodu symulacji wyższego rzędu)
                if (std::popcount(cur_mask) != 2 || (cur_mask & cur_enter) == 0ULL) continue;
                
                const uint64_t exit_bit = cur_mask ^ cur_enter;
                if (exit_bit == 0ULL) continue;
                if (sp.chain_depth[ni] >= max_depth) continue;

                // Sprawdzamy sąsiadów bieżącego węzła
                const int p0 = st.topo->peer_offsets[cur_cell];
                const int p1 = st.topo->peer_offsets[cur_cell + 1];
                for (int p = p0; p < p1; ++p) {
                    const int nxt = st.topo->peers_flat[p];
                    if (st.board->values[nxt] != 0) continue;
                    
                    const uint64_t nxt_mask = st.cands[nxt];
                    if (std::popcount(nxt_mask) != 2) continue;
                    
                    // Kolejne "ogniwo" musi akceptować wyjście naszego węzła
                    if ((nxt_mask & exit_bit) == 0ULL) continue;
                    if (path_contains_cell(ni, nxt)) continue; // Zapobiega pętlom wstecznym

                    const uint64_t nxt_other = nxt_mask ^ exit_bit;
                    if (nxt_other == 0ULL) continue;

                    const int next_depth = static_cast<int>(sp.chain_depth[ni]) + 1;
                    
                    // Czy łańcuch zamknął pełną sieć logiki i "wyszliśmy" tą samą cyfrą z którą weszliśmy do startu?
                    if (next_depth >= 2 && nxt_other == zbit) {
                        for (int t = 0; t < nn; ++t) {
                            if (t == start || t == nxt) continue;
                            if (st.board->values[t] != 0) continue;
                            if ((st.cands[t] & zbit) == 0ULL) continue;
                            
                            // Cel ataku musi widzieć OBA krańce łańcucha
                            if (!st.is_peer(t, start) || !st.is_peer(t, nxt)) continue;
                            
                            const ApplyResult er = st.eliminate(t, zbit);
                            if (er == ApplyResult::Contradiction) { 
                                s.elapsed_ns += st.now_ns() - t0; 
                                return er; 
                            }
                            if (er == ApplyResult::Progress) {
                                ++s.hit_count;
                                r.used_xy_chain = true;
                                any_progress = true;
                            }
                        }
                    }

                    // Jeśli mamy wciąż miejsce, dokładamy łańcuch do dalszej propagacji
                    if (sp.chain_count >= ExactPatternScratchpad::MAX_CHAIN) continue;
                    sp.chain_cell[sp.chain_count] = nxt;
                    sp.chain_enter_bit[sp.chain_count] = exit_bit;
                    sp.chain_parent[sp.chain_count] = ni;
                    sp.chain_depth[sp.chain_count] = static_cast<uint8_t>(next_depth);
                    ++sp.chain_count;
                }
            }
        }
    }

    if (any_progress) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\finned_jelly_sword.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: finned_jelly_sword.h (Level 6 - Diabolical)
// Description: Jellyfish and direct finned Swordfish/Jellyfish passes,
// zero-allocation.
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

#include "../p5_expert/finned_fish.h"
#include "../p4_hard/fish_basic.h"

namespace sudoku_hpc::logic::p6_diabolical {

inline ApplyResult apply_jellyfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    if (n < 5) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    auto& sp = shared::exact_pattern_scratchpad();
    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);

        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        int row_count = 0;
        int col_count = 0;
        for (int rr = 0; rr < n; ++rr) {
            const int cnt = std::popcount(sp.fish_row_masks[rr]);
            if (cnt >= 2 && cnt <= 4) sp.active_rows[row_count++] = rr;
        }
        for (int cc = 0; cc < n; ++cc) {
            const int cnt = std::popcount(sp.fish_col_masks[cc]);
            if (cnt >= 2 && cnt <= 4) sp.active_cols[col_count++] = cc;
        }

        for (int i = 0; i + 3 < row_count; ++i) {
            const int r1 = sp.active_rows[i];
            const uint64_t u1 = sp.fish_row_masks[r1];
            for (int j = i + 1; j + 2 < row_count; ++j) {
                const int r2 = sp.active_rows[j];
                const uint64_t u2 = u1 | sp.fish_row_masks[r2];
                if (std::popcount(u2) > 4) continue;
                for (int k = j + 1; k + 1 < row_count; ++k) {
                    const int r3 = sp.active_rows[k];
                    const uint64_t u3 = u2 | sp.fish_row_masks[r3];
                    if (std::popcount(u3) > 4) continue;
                    for (int l = k + 1; l < row_count; ++l) {
                        const int r4 = sp.active_rows[l];
                        const uint64_t cols_union = u3 | sp.fish_row_masks[r4];
                        if (std::popcount(cols_union) != 4) continue;
                        for (uint64_t w = cols_union; w != 0ULL; w &= (w - 1ULL)) {
                            const int cc = config::bit_ctz_u64(w);
                            for (int rr = 0; rr < n; ++rr) {
                                if (rr == r1 || rr == r2 || rr == r3 || rr == r4) continue;
                                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                if (er == ApplyResult::Contradiction) {
                                    s.elapsed_ns += st.now_ns() - t0;
                                    return er;
                                }
                                if (er == ApplyResult::Progress) {
                                    ++s.hit_count;
                                    r.used_jellyfish = true;
                                    s.elapsed_ns += st.now_ns() - t0;
                                    return ApplyResult::Progress;
                                }
                            }
                        }
                    }
                }
            }
        }

        for (int i = 0; i + 3 < col_count; ++i) {
            const int c1 = sp.active_cols[i];
            const uint64_t u1 = sp.fish_col_masks[c1];
            for (int j = i + 1; j + 2 < col_count; ++j) {
                const int c2 = sp.active_cols[j];
                const uint64_t u2 = u1 | sp.fish_col_masks[c2];
                if (std::popcount(u2) > 4) continue;
                for (int k = j + 1; k + 1 < col_count; ++k) {
                    const int c3 = sp.active_cols[k];
                    const uint64_t u3 = u2 | sp.fish_col_masks[c3];
                    if (std::popcount(u3) > 4) continue;
                    for (int l = k + 1; l < col_count; ++l) {
                        const int c4 = sp.active_cols[l];
                        const uint64_t rows_union = u3 | sp.fish_col_masks[c4];
                        if (std::popcount(rows_union) != 4) continue;
                        for (uint64_t w = rows_union; w != 0ULL; w &= (w - 1ULL)) {
                            const int rr = config::bit_ctz_u64(w);
                            for (int cc = 0; cc < n; ++cc) {
                                if (cc == c1 || cc == c2 || cc == c3 || cc == c4) continue;
                                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                if (er == ApplyResult::Contradiction) {
                                    s.elapsed_ns += st.now_ns() - t0;
                                    return er;
                                }
                                if (er == ApplyResult::Progress) {
                                    ++s.hit_count;
                                    r.used_jellyfish = true;
                                    s.elapsed_ns += st.now_ns() - t0;
                                    return ApplyResult::Progress;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_finned_fish_direct(
    CandidateState& st,
    int fish_size,
    bool row_based,
    bool& progress,
    StrategyStats& s,
    uint64_t t0) {
    const int n = st.topo->n;
    if (fish_size < 3 || fish_size > 4 || n < fish_size + 1 || n > 64) {
        return ApplyResult::NoProgress;
    }

    auto& sp = shared::exact_pattern_scratchpad();
    int active_lines[64]{};
    uint64_t line_masks[64]{};
    int line_count = 0;
    int combo_checks = 0;
    const int combo_cap = (fish_size == 3) ? 10000 : 7000;

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        line_count = 0;

        for (int line = 0; line < n; ++line) {
            uint64_t mask = 0ULL;
            for (int orth = 0; orth < n; ++orth) {
                const int idx = row_based ? (line * n + orth) : (orth * n + line);
                if (st.board->values[idx] != 0) continue;
                if ((st.cands[idx] & bit) == 0ULL) continue;
                const int cover = row_based ? st.topo->cell_col[idx] : st.topo->cell_row[idx];
                mask |= (1ULL << cover);
            }
            const int pc = std::popcount(mask);
            if (pc < 2 || pc > fish_size + 1) continue;
            if (line_count < 64) {
                active_lines[line_count] = line;
                line_masks[line_count] = mask;
                ++line_count;
            }
        }

        if (line_count < fish_size) continue;
        if (line_count > 20) continue;

        for (int i0 = 0; i0 < line_count; ++i0) {
            for (int i1 = i0 + 1; i1 < line_count; ++i1) {
                if (fish_size == 3) {
                    for (int i2 = i1 + 1; i2 < line_count; ++i2) {
                        if (++combo_checks > combo_cap) return ApplyResult::NoProgress;
                        const uint64_t u = line_masks[i0] | line_masks[i1] | line_masks[i2];
                        if (std::popcount(u) != fish_size + 1) continue;

                        int lines[3] = {active_lines[i0], active_lines[i1], active_lines[i2]};
                        uint64_t masks[3] = {line_masks[i0], line_masks[i1], line_masks[i2]};

                        for (uint64_t w = u; w != 0ULL; w &= (w - 1ULL)) {
                            const int fin_cover = config::bit_ctz_u64(w);
                            int fin_line = -1;
                            int fin_cnt = 0;
                            for (int k = 0; k < 3; ++k) {
                                if ((masks[k] & (1ULL << fin_cover)) == 0ULL) continue;
                                ++fin_cnt;
                                fin_line = lines[k];
                            }
                            if (fin_cnt != 1 || fin_line < 0) continue;

                            const int fin_idx = row_based ? (fin_line * n + fin_cover) : (fin_cover * n + fin_line);
                            const int fin_box = st.topo->cell_box[fin_idx];

                            for (uint64_t wc = u; wc != 0ULL; wc &= (wc - 1ULL)) {
                                const int cover = config::bit_ctz_u64(wc);
                                if (cover == fin_cover) continue;
                                for (int orth = 0; orth < n; ++orth) {
                                    const int idx = row_based ? (orth * n + cover) : (cover * n + orth);
                                    if (st.board->values[idx] != 0) continue;
                                    if ((st.cands[idx] & bit) == 0ULL) continue;
                                    if (st.topo->cell_box[idx] != fin_box) continue;

                                    const int idx_line = row_based ? st.topo->cell_row[idx] : st.topo->cell_col[idx];
                                    bool in_base = false;
                                    for (int k = 0; k < 3; ++k) {
                                        if (idx_line == lines[k]) {
                                            in_base = true;
                                            break;
                                        }
                                    }
                                    if (in_base) continue;

                                    const ApplyResult er = st.eliminate(idx, bit);
                                    if (er == ApplyResult::Contradiction) {
                                        s.elapsed_ns += st.now_ns() - t0;
                                        return er;
                                    }
                                    progress = progress || (er == ApplyResult::Progress);
                                }
                            }
                        }
                    }
                } else {
                    for (int i2 = i1 + 1; i2 < line_count; ++i2) {
                        for (int i3 = i2 + 1; i3 < line_count; ++i3) {
                            if (++combo_checks > combo_cap) return ApplyResult::NoProgress;
                            const uint64_t u = line_masks[i0] | line_masks[i1] | line_masks[i2] | line_masks[i3];
                            if (std::popcount(u) != fish_size + 1) continue;

                            int lines[4] = {active_lines[i0], active_lines[i1], active_lines[i2], active_lines[i3]};
                            uint64_t masks[4] = {line_masks[i0], line_masks[i1], line_masks[i2], line_masks[i3]};

                            for (uint64_t w = u; w != 0ULL; w &= (w - 1ULL)) {
                                const int fin_cover = config::bit_ctz_u64(w);
                                int fin_line = -1;
                                int fin_cnt = 0;
                                for (int k = 0; k < 4; ++k) {
                                    if ((masks[k] & (1ULL << fin_cover)) == 0ULL) continue;
                                    ++fin_cnt;
                                    fin_line = lines[k];
                                }
                                if (fin_cnt != 1 || fin_line < 0) continue;

                                const int fin_idx = row_based ? (fin_line * n + fin_cover) : (fin_cover * n + fin_line);
                                const int fin_box = st.topo->cell_box[fin_idx];

                                for (uint64_t wc = u; wc != 0ULL; wc &= (wc - 1ULL)) {
                                    const int cover = config::bit_ctz_u64(wc);
                                    if (cover == fin_cover) continue;
                                    for (int orth = 0; orth < n; ++orth) {
                                        const int idx = row_based ? (orth * n + cover) : (cover * n + orth);
                                        if (st.board->values[idx] != 0) continue;
                                        if ((st.cands[idx] & bit) == 0ULL) continue;
                                        if (st.topo->cell_box[idx] != fin_box) continue;

                                        const int idx_line = row_based ? st.topo->cell_row[idx] : st.topo->cell_col[idx];
                                        bool in_base = false;
                                        for (int k = 0; k < 4; ++k) {
                                            if (idx_line == lines[k]) {
                                                in_base = true;
                                                break;
                                            }
                                        }
                                        if (in_base) continue;

                                        const ApplyResult er = st.eliminate(idx, bit);
                                        if (er == ApplyResult::Contradiction) {
                                            s.elapsed_ns += st.now_ns() - t0;
                                            return er;
                                        }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult apply_finned_swordfish_jellyfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    StrategyStats tmp{};
    bool progress = false;
    const int n = st.topo->n;
    const int nn = st.topo->nn;

    // Heavy direct finned-fish scan only in later board phase.
    if (st.board->empty_cells <= (nn - 4 * n)) {
        ApplyResult ar = apply_finned_fish_direct(st, 3, true, progress, s, t0);
        if (ar == ApplyResult::Contradiction) return ar;
        ar = apply_finned_fish_direct(st, 3, false, progress, s, t0);
        if (ar == ApplyResult::Contradiction) return ar;
        ar = apply_finned_fish_direct(st, 4, true, progress, s, t0);
        if (ar == ApplyResult::Contradiction) return ar;
        ar = apply_finned_fish_direct(st, 4, false, progress, s, t0);
        if (ar == ApplyResult::Contradiction) return ar;
        if (progress) {
            ++s.hit_count;
            r.used_finned_swordfish_jellyfish = true;
            s.elapsed_ns += st.now_ns() - t0;
            return ApplyResult::Progress;
        }
    }

    ApplyResult ar = logic::p5_expert::apply_finned_x_wing_sashimi(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_finned_swordfish_jellyfish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    ar = logic::p4_hard::apply_swordfish(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_finned_swordfish_jellyfish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    ar = apply_jellyfish(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_finned_swordfish_jellyfish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\jellyfish.h
==============================================================================

﻿#pragma once

#include "finned_jelly_sword.h"



==============================================================================
PLIK: Sources\logic\p6_diabolical\unique_loop_avoidable_oddagon.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: unique_loop_avoidable_oddagon.h (Level 6 - Diabolical)
// Description: Direct detectors for Unique Loop, Avoidable Rectangle and
// Bivalue Oddagon (zero-allocation, asymmetric geometry compatible).
// ============================================================================

#pragma once

#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p6_diabolical {

inline constexpr int kMaxNN = 64 * 64;

inline bool rectangle_same_two_boxes(const CandidateState& st, int i1, int i2, int i3, int i4) {
    // Proper UR/AR rectangle uses exactly two boxes (works for asym boxes too).
    int b1 = st.topo->cell_box[i1];
    int b2 = st.topo->cell_box[i2];
    int b3 = st.topo->cell_box[i3];
    int b4 = st.topo->cell_box[i4];
    int unique = 1;
    if (b2 != b1) ++unique;
    if (b3 != b1 && b3 != b2) ++unique;
    if (b4 != b1 && b4 != b2 && b4 != b3) ++unique;
    return unique == 2;
}

inline ApplyResult apply_unique_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    const int n = st.topo->n;
    bool progress = false;
    bool contradiction = false;

    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const int i1 = r1 * n + c1;
                    const int i2 = r1 * n + c2;
                    const int i3 = r2 * n + c1;
                    const int i4 = r2 * n + c2;

                    if (!rectangle_same_two_boxes(st, i1, i2, i3, i4)) continue;
                    if (st.board->values[i1] != 0 || st.board->values[i2] != 0 ||
                        st.board->values[i3] != 0 || st.board->values[i4] != 0) {
                        continue;
                    }

                    const int cells[4] = {i1, i2, i3, i4};
                    for (int p = 0; p < 4; ++p) {
                        const uint64_t pair_mask = st.cands[cells[p]];
                        if (std::popcount(pair_mask) != 2) continue;

                        int exact_pair_cnt = 0;
                        int extra_idx = -1;
                        bool valid = true;

                        for (int k = 0; k < 4; ++k) {
                            const uint64_t cm = st.cands[cells[k]];
                            if ((cm & pair_mask) != pair_mask) {
                                valid = false;
                                break;
                            }
                            if (cm == pair_mask) {
                                ++exact_pair_cnt;
                            } else {
                                if (extra_idx != -1) {
                                    valid = false;
                                    break;
                                }
                                extra_idx = cells[k];
                            }
                        }

                        if (!valid || exact_pair_cnt != 3 || extra_idx < 0) continue;

                        const ApplyResult er = st.eliminate(extra_idx, pair_mask);
                        if (er == ApplyResult::Contradiction) {
                            s.elapsed_ns += st.now_ns() - t0;
                            return er;
                        }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_unique_loop = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_avoidable_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    const int n = st.topo->n;
    bool progress = false;
    bool contradiction = false;

    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const int i1 = r1 * n + c1;
                    const int i2 = r1 * n + c2;
                    const int i3 = r2 * n + c1;
                    const int i4 = r2 * n + c2;

                    if (!rectangle_same_two_boxes(st, i1, i2, i3, i4)) continue;

                    auto check_diag = [&](int s1, int s2, int u1, int u2) {
                        if (contradiction) return;
                        const int v1 = st.board->values[s1];
                        const int v2 = st.board->values[s2];
                        if (v1 == 0 || v2 == 0 || v1 == v2) return;
                        if (st.board->values[u1] != 0 || st.board->values[u2] != 0) return;

                        const uint64_t pair = (1ULL << (v1 - 1)) | (1ULL << (v2 - 1));
                        const uint64_t m1 = st.cands[u1];
                        const uint64_t m2 = st.cands[u2];
                        if ((m1 & pair) != pair || (m2 & pair) != pair) return;

                        if (m1 == pair && m2 != pair) {
                            const ApplyResult er = st.eliminate(u2, pair);
                            if (er == ApplyResult::Contradiction) {
                                contradiction = true;
                                return;
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        } else if (m2 == pair && m1 != pair) {
                            const ApplyResult er = st.eliminate(u1, pair);
                            if (er == ApplyResult::Contradiction) {
                                contradiction = true;
                                return;
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    };

                    check_diag(i1, i4, i2, i3);
                    check_diag(i2, i3, i1, i4);
                    if (contradiction) {
                        s.elapsed_ns += st.now_ns() - t0;
                        return ApplyResult::Contradiction;
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_avoidable_rectangle = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline bool odd_length_path_between_strict_nodes(
    const CandidateState& st,
    const int* strict_cells,
    int strict_count,
    const int* cell_to_node,
    int start_node,
    int target_node) {
    int qnode[kMaxNN]{};
    int qpar[kMaxNN]{};
    int vis0[kMaxNN]{};
    int vis1[kMaxNN]{};

    for (int i = 0; i < strict_count; ++i) {
        vis0[i] = 0;
        vis1[i] = 0;
    }

    int qh = 0;
    int qt = 0;
    qnode[qt] = start_node;
    qpar[qt] = 0;
    ++qt;
    vis0[start_node] = 1;

    while (qh < qt) {
        const int u = qnode[qh];
        const int par = qpar[qh];
        ++qh;

        const int cell = strict_cells[u];
        const int p0 = st.topo->peer_offsets[cell];
        const int p1 = st.topo->peer_offsets[cell + 1];
        for (int p = p0; p < p1; ++p) {
            const int v_cell = st.topo->peers_flat[p];
            const int v = cell_to_node[v_cell];
            if (v < 0) continue;
            const int npar = 1 - par;
            if (v == target_node && npar == 1) {
                return true; // odd number of edges
            }
            int* vis = (npar == 0) ? vis0 : vis1;
            if (vis[v] != 0) continue;
            vis[v] = 1;
            qnode[qt] = v;
            qpar[qt] = npar;
            ++qt;
            if (qt >= strict_count * 2) break;
        }
    }
    return false;
}

inline ApplyResult apply_bivalue_oddagon(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    const int nn = st.topo->nn;
    bool progress = false;

    int strict_cells[kMaxNN]{};
    int cell_to_node[kMaxNN]{};
    int pivot_neighbors[kMaxNN]{};

    for (int pivot = 0; pivot < nn; ++pivot) {
        if (st.board->values[pivot] != 0) continue;
        const uint64_t pm = st.cands[pivot];
        if (std::popcount(pm) < 3) continue;

        uint64_t w1 = pm;
        while (w1 != 0ULL) {
            const uint64_t b1 = w1 & (~w1 + 1ULL);
            w1 &= (w1 - 1ULL);
            uint64_t w2 = w1;
            while (w2 != 0ULL) {
                const uint64_t b2 = w2 & (~w2 + 1ULL);
                w2 &= (w2 - 1ULL);
                const uint64_t pair = b1 | b2;

                for (int i = 0; i < nn; ++i) {
                    cell_to_node[i] = -1;
                }

                int strict_count = 0;
                for (int idx = 0; idx < nn; ++idx) {
                    if (st.board->values[idx] != 0) continue;
                    if (st.cands[idx] != pair) continue;
                    cell_to_node[idx] = strict_count;
                    strict_cells[strict_count++] = idx;
                }
                if (strict_count < 3) continue;

                int neigh_cnt = 0;
                const int p0 = st.topo->peer_offsets[pivot];
                const int p1 = st.topo->peer_offsets[pivot + 1];
                for (int p = p0; p < p1; ++p) {
                    const int v_cell = st.topo->peers_flat[p];
                    const int v = cell_to_node[v_cell];
                    if (v < 0) continue;
                    pivot_neighbors[neigh_cnt++] = v;
                }
                if (neigh_cnt < 2) continue;

                bool elim_pair_from_pivot = false;
                for (int a = 0; a < neigh_cnt && !elim_pair_from_pivot; ++a) {
                    for (int b = a + 1; b < neigh_cnt && !elim_pair_from_pivot; ++b) {
                        if (odd_length_path_between_strict_nodes(
                                st,
                                strict_cells,
                                strict_count,
                                cell_to_node,
                                pivot_neighbors[a],
                                pivot_neighbors[b])) {
                            elim_pair_from_pivot = true;
                        }
                    }
                }

                if (elim_pair_from_pivot) {
                    const ApplyResult er = st.eliminate(pivot, pair);
                    if (er == ApplyResult::Contradiction) {
                        s.elapsed_ns += st.now_ns() - t0;
                        return er;
                    }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_bivalue_oddagon = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\ur_extended.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: ur_extended.h (Poziom 6 - Diabolical)
// Opis: Algorytmy rozwiÄ…zujÄ…ce warianty Unique Rectangle Types 2, 3, 4, 5, 6
//       oraz Hidden Unique Rectangle. Chroni przed Deadly Pattern.
//       Zero-allocation dziÄ™ki zaawansowanemu maskowaniu 64-bitowemu.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>
#include <array>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p6_diabolical {

inline ApplyResult apply_ur_extended(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Zabezpieczenie przed dziwnymi asymetrycznymi rurkami
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    bool progress = false;
    
    // Poszukiwania naroĹĽnikĂłw tworzÄ…cych potencjalny prostokÄ…t UR
    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const int a = r1 * n + c1;
                    const int b = r1 * n + c2;
                    const int c = r2 * n + c1;
                    const int d = r2 * n + c2;
                    
                    if (st.board->values[a] != 0 || st.board->values[b] != 0 ||
                        st.board->values[c] != 0 || st.board->values[d] != 0) {
                        continue;
                    }
                    
                    const std::array<int, 4> cells = {a, b, c, d};
                    const std::array<uint64_t, 4> masks = {
                        st.cands[a],
                        st.cands[b],
                        st.cands[c],
                        st.cands[d]
                    };

                    const uint64_t pair = masks[0] & masks[1] & masks[2] & masks[3];
                    if (std::popcount(pair) != 2) continue; // Wymagamy dokĹ‚adnie dwĂłch wspĂłĹ‚dzielonych cyfr bazowych
                    
                    // KaĹĽdy z naroĹĽnikĂłw musi zawieraÄ‡ te dwie bazowe cyfry jako podzbiĂłr
                    bool all_superset = true;
                    for (int i = 0; i < 4; ++i) {
                        if ((masks[i] & pair) != pair) {
                            all_superset = false;
                            break;
                        }
                    }
                    if (!all_superset) continue;

                    // Typ UR wymaga by cztery wierzchoĹ‚ki dzieliĹ‚y DOKĹADNIE DWA BLOKI (2 boxes)
                    std::array<int, 4> boxes = {
                        st.topo->cell_box[a], st.topo->cell_box[b],
                        st.topo->cell_box[c], st.topo->cell_box[d]
                    };
                    
                    // Szybki sort i unikalizacja by policzyÄ‡ ile mamy boxĂłw (bez alokacji std::set)
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    if (boxes[1] > boxes[2]) std::swap(boxes[1], boxes[2]);
                    if (boxes[2] > boxes[3]) std::swap(boxes[2], boxes[3]);
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    if (boxes[1] > boxes[2]) std::swap(boxes[1], boxes[2]);
                    if (boxes[0] > boxes[1]) std::swap(boxes[0], boxes[1]);
                    
                    int unique_boxes = 1;
                    for (int i = 1; i < 4; ++i) {
                        if (boxes[i] != boxes[i - 1]) ++unique_boxes;
                    }
                    if (unique_boxes != 2) continue;

                    // ----------------------------------------------------------------
                    // Analiza "nadwyĹĽki" (extra) wzglÄ™dem pary bazowej 
                    // ----------------------------------------------------------------
                    int extra_count = 0;
                    int extra_idx[4]{-1, -1, -1, -1};
                    uint64_t extra_union = 0ULL;
                    
                    for (int i = 0; i < 4; ++i) {
                        const uint64_t extra = masks[i] & ~pair;
                        if (extra == 0ULL) continue;
                        extra_idx[extra_count++] = i;
                        extra_union |= extra;
                    }
                    
                    // JeĹ›li extra_count == 0 to mamy Deadly Pattern i zagadka jest nieunikalna, 
                    // lub Type 1 (ale tym zajmuje siÄ™ P5_expert).
                    if (extra_count == 0) continue;

                    // ----------------------------------------------------------------
                    // Eliminacje lokalne dla wariantĂłw UR Type 2-6
                    // ----------------------------------------------------------------
                    // 1. ZwykĹ‚a eliminacja: JeĹ›li sÄ… "nadwyĹĽki", moĹĽemy prĂłbowaÄ‡
                    // wykluczyÄ‡ ich niespĂłjnoĹ›ci lub zmuszaÄ‡ by nie staĹ‚y siÄ™ bivalue.
                    for (int ei = 0; ei < extra_count; ++ei) {
                        const int ci = extra_idx[ei];
                        const uint64_t rm = masks[ci] & ~pair;
                        if (rm == 0ULL) continue;
                        
                        // Zabezpieczenie przed redukcjÄ…, ktĂłra zabiĹ‚aby siatkÄ™:
                        // Typy te uderzajÄ… "na okoĹ‚o" prostokÄ…ta, jednak 
                        // uderzamy lokalnie, aby bezpiecznie wykryÄ‡ sprzecznoĹ›Ä‡
                        const ApplyResult er = st.eliminate(cells[ci], rm);
                        if (er == ApplyResult::Contradiction) {
                            s.elapsed_ns += st.now_ns() - t0;
                            return er;
                        }
                        if (er == ApplyResult::Progress) {
                            progress = true;
                        }
                    }

                    // 2. WĹ‚aĹ›ciwa twarda eliminacja "Widokowa"
                    // JeĹ›li konkretna cyfra-nadwyĹĽka wystÄ™puje w 2 lub wiÄ™cej wierzchoĹ‚kach,
                    // usuĹ„ tÄ™ cyfrÄ™ z komĂłrek "obcych", ktĂłre JEDNOCZEĹšNIE widzÄ… wszystkie te wierzchoĹ‚ki.
                    uint64_t wx = extra_union;
                    while (wx != 0ULL) {
                        const uint64_t x = config::bit_lsb(wx);
                        wx = config::bit_clear_lsb_u64(wx);
                        
                        int holders[4]{-1, -1, -1, -1};
                        int hc = 0;
                        for (int i = 0; i < 4; ++i) {
                            if ((masks[i] & x) != 0ULL) {
                                holders[hc++] = cells[i];
                            }
                        }
                        
                        if (hc < 2) continue; // Musi wystÄ…piÄ‡ co najmniej w 2 naroĹĽnikach
                        
                        for (int t = 0; t < nn; ++t) {
                            if (st.board->values[t] != 0) continue;
                            if ((st.cands[t] & x) == 0ULL) continue;
                            
                            // Czy jest to ktĂłryĹ› z naszych naroĹĽnikĂłw? (Omijamy samych siebie)
                            bool is_rect = false;
                            for (int i = 0; i < 4; ++i) {
                                if (cells[i] == t) {
                                    is_rect = true;
                                    break;
                                }
                            }
                            if (is_rect) continue;
                            
                            // Czy "obca" komĂłrka widzi WSZYSTKIE wierzchoĹ‚ki w 'holders'?
                            bool sees_all = true;
                            for (int i = 0; i < hc; ++i) {
                                if (!st.is_peer(t, holders[i])) {
                                    sees_all = false;
                                    break;
                                }
                            }
                            if (!sees_all) continue;
                            
                            const ApplyResult er = st.eliminate(t, x);
                            if (er == ApplyResult::Contradiction) {
                                s.elapsed_ns += st.now_ns() - t0;
                                return er;
                            }
                            if (er == ApplyResult::Progress) {
                                progress = true;
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (progress) {
        ++s.hit_count;
        r.used_ur_extended = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}


// ============================================================================
// HIDDEN UNIQUE RECTANGLE
// Strategia unikajÄ…ca Deadly Pattern. Eliminuje "nieistotnÄ…" cyfrÄ™ bazowÄ… z pary
// w wÄ™Ĺşle, ktĂłry jest mocno powiÄ…zany i stwarza ryzyko "rozpadu" prostokÄ…ta.
// ============================================================================
inline ApplyResult apply_hidden_ur(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int n = st.topo->n;
    bool progress = false;

    // Przeszukanie wszystkich par 2 cyfr d1, d2
    for (int d1 = 1; d1 <= n; ++d1) {
        const uint64_t b1 = (1ULL << (d1 - 1));
        for (int d2 = d1 + 1; d2 <= n; ++d2) {
            const uint64_t b2 = (1ULL << (d2 - 1));
            const uint64_t pair = b1 | b2;
            
            // Definiujemy geometriÄ™
            for (int r1 = 0; r1 < n; ++r1) {
                for (int r2 = r1 + 1; r2 < n; ++r2) {
                    for (int c1 = 0; c1 < n; ++c1) {
                        for (int c2 = c1 + 1; c2 < n; ++c2) {
                            const int a = r1 * n + c1;
                            const int b = r1 * n + c2;
                            const int c = r2 * n + c1;
                            const int d = r2 * n + c2;
                            
                            if (st.board->values[a] != 0 || st.board->values[b] != 0 ||
                                st.board->values[c] != 0 || st.board->values[d] != 0) {
                                continue;
                            }
                            
                            const std::array<int, 4> cells = {a, b, c, d};
                            bool all_have_pair = true;
                            for (int i = 0; i < 4; ++i) {
                                const uint64_t m = st.cands[cells[i]];
                                // W Hidden UR nie wszystkie muszÄ… byÄ‡ idealnym nadzbiorem "pair", 
                                // ale muszÄ… co najmniej zahaczaÄ‡ o pair
                                if ((m & pair) == 0ULL) {
                                    all_have_pair = false;
                                    break;
                                }
                            }
                            if (!all_have_pair) continue;

                            // WymĂłg unikalnoĹ›ci: w obrÄ™bie danego rzÄ™du, te cyfry nie mogÄ…
                            // uciec gdzie indziej - "Strong Links"
                            int row_hits_d1 = 0;
                            int row_hits_d2 = 0;
                            for (int cc = 0; cc < n; ++cc) {
                                const int i1 = r1 * n + cc;
                                const int i2 = r2 * n + cc;
                                if (st.board->values[i1] == 0 && (st.cands[i1] & b1) != 0ULL) ++row_hits_d1;
                                if (st.board->values[i2] == 0 && (st.cands[i2] & b1) != 0ULL) ++row_hits_d1;
                                if (st.board->values[i1] == 0 && (st.cands[i1] & b2) != 0ULL) ++row_hits_d2;
                                if (st.board->values[i2] == 0 && (st.cands[i2] & b2) != 0ULL) ++row_hits_d2;
                            }
                            // JeĹ›li ktĂłraĹ› z cyfr w obrÄ™bie tych dwĂłch rzÄ™dĂłw "wystaje" poza naroĹĽniki, nie jest to strict Hidden UR
                            if (row_hits_d1 > 4 || row_hits_d2 > 4) continue;

                            for (int i = 0; i < 4; ++i) {
                                const int idx = cells[i];
                                const uint64_t m = st.cands[idx];
                                
                                // Eliminacja reszty z komĂłrki, ktĂłra musi zostaÄ‡ rozwiÄ…zaniem 
                                // by nie spaliÄ‡ Deadly Pattern (pozostawiamy jÄ… "czystÄ…")
                                if ((m & pair) == pair && (m & ~pair) != 0ULL) {
                                    const ApplyResult er = st.eliminate(idx, m & ~pair);
                                    if (er == ApplyResult::Contradiction) {
                                        s.elapsed_ns += st.now_ns() - t0;
                                        return er;
                                    }
                                    if (er == ApplyResult::Progress) {
                                        progress = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_hidden_ur = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p6_diabolical\wxyz_wing.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: wxyz_wing.h (Poziom 6 - Diabolical)
// Opis: Algorytm wyszukujący 4-kandydatowy WXYZ-Wing.
//       Potężne skrzydło łączące węzeł centralny (Pivot) z aż trzeba skrzydłami
//       Bivalue rekonstruującymi całą binarową strukturę pivota. Zero-allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p6_diabolical {

inline ApplyResult apply_wxyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    const int nn = st.topo->nn;
    bool progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    // Szukamy potencjalnego pivota: Posiada dokładnie 4 różne możliwości cyfr.
    for (int pivot = 0; pivot < nn; ++pivot) {
        if (st.board->values[pivot] != 0) continue;
        const uint64_t mp = st.cands[pivot];
        if (std::popcount(mp) != 4) continue;

        sp.wing_count = 0;
        
        // Zbieramy komórki (skrzydła) widoczne z pivota
        const int p0 = st.topo->peer_offsets[pivot];
        const int p1 = st.topo->peer_offsets[pivot + 1];
        for (int p = p0; p < p1; ++p) {
            const int w = st.topo->peers_flat[p];
            if (st.board->values[w] != 0) continue;
            
            const uint64_t mw = st.cands[w];
            // Skrzydło to komórka bivalue posiadająca cyfry należące do masek Pivota
            if (std::popcount(mw) != 2) continue;
            if ((mw & ~mp) != 0ULL) continue;
            
            if (sp.wing_count < nn) {
                sp.wing_cells[sp.wing_count++] = w;
            }
        }
        
        // Wymagamy dokładnie 3 takich bivalue-"skrzydeł"
        if (sp.wing_count < 3) continue;

        // Szukamy kombinacji 3 skrzydeł do stworzenia zatoru WXYZ
        for (int i = 0; i + 2 < sp.wing_count; ++i) {
            const int a = sp.wing_cells[i];
            const uint64_t ma = st.cands[a];
            
            for (int j = i + 1; j + 1 < sp.wing_count; ++j) {
                const int b = sp.wing_cells[j];
                const uint64_t mb = st.cands[b];
                
                for (int k = j + 1; k < sp.wing_count; ++k) {
                    const int c = sp.wing_cells[k];
                    const uint64_t mc = st.cands[c];
                    
                    // Skrzydła muszą ODTWARZAĆ dokładnie taką samą powłokę co pivot
                    // Np. (1,2) + (2,3) + (3,4) + pivot(1,2,3,4)
                    if ((ma | mb | mc | mp) != mp) continue;
                    
                    // Cyfry "targetu" (te do wyeliminowania) to te, które występują 
                    // we wszystkich 3 skrzydłach tworzących węzeł zaporowy
                    const uint64_t zmask = ma & mb & mc;
                    if (zmask == 0ULL) continue;

                    uint64_t wz = zmask;
                    while (wz != 0ULL) {
                        const uint64_t z = config::bit_lsb(wz);
                        wz = config::bit_clear_lsb_u64(wz);
                        
                        // Eliminacja! 
                        // Target(y) musi widzieć pivot ORAZ wszystkie 3 skrzydła 
                        for (int t = 0; t < nn; ++t) {
                            if (t == pivot || t == a || t == b || t == c) continue;
                            if (st.board->values[t] != 0) continue;
                            if ((st.cands[t] & z) == 0ULL) continue;
                            
                            if (!st.is_peer(t, pivot) || !st.is_peer(t, a) || !st.is_peer(t, b) || !st.is_peer(t, c)) continue;
                            
                            const ApplyResult er = st.eliminate(t, z);
                            if (er == ApplyResult::Contradiction) { 
                                s.elapsed_ns += st.now_ns() - t0; 
                                return er; 
                            }
                            if (er == ApplyResult::Progress) {
                                ++s.hit_count;
                                r.used_wxyz_wing = true;
                                progress = true;
                            }
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p6_diabolical



==============================================================================
PLIK: Sources\logic\p7_nightmare\aic_grouped_aic.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: aic_grouped_aic.h (Level 7 - Nightmare)
// Description: Direct Alternating Inference Chains (AIC) and Grouped AIC
// on strong/weak candidate graphs per digit, zero-allocation.
// ============================================================================

#pragma once

#include <algorithm>
#include <chrono>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/link_graph_builder.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline uint64_t get_current_time_ns() {
    return static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
        std::chrono::steady_clock::now().time_since_epoch()).count());
}

inline bool aic_is_strong_neighbor(const shared::ExactPatternScratchpad& sp, int u, int v) {
    const int p0 = sp.dyn_strong_offsets[u];
    const int p1 = sp.dyn_strong_offsets[u + 1];
    for (int p = p0; p < p1; ++p) {
        if (sp.dyn_strong_adj[p] == v) return true;
    }
    return false;
}

inline int aic_collect_neighbors(
    const shared::ExactPatternScratchpad& sp,
    int u,
    int edge_type, // 1=strong, 0=weak-only
    int* out) {
    int cnt = 0;
    if (edge_type == 1) {
        const int p0 = sp.dyn_strong_offsets[u];
        const int p1 = sp.dyn_strong_offsets[u + 1];
        for (int p = p0; p < p1; ++p) {
            out[cnt++] = sp.dyn_strong_adj[p];
        }
        return cnt;
    }

    const int p0 = sp.dyn_weak_offsets[u];
    const int p1 = sp.dyn_weak_offsets[u + 1];
    for (int p = p0; p < p1; ++p) {
        const int v = sp.dyn_weak_adj[p];
        if (aic_is_strong_neighbor(sp, u, v)) continue;
        out[cnt++] = v;
    }
    return cnt;
}

inline ApplyResult aic_eliminate_common_peers(
    CandidateState& st,
    const shared::ExactPatternScratchpad& sp,
    uint64_t bit,
    int a_cell,
    int b_cell) {
    for (int i = 0; i < sp.dyn_digit_cell_count; ++i) {
        const int idx = sp.dyn_digit_cells[i];
        if (idx == a_cell || idx == b_cell) continue;
        if (!st.is_peer(idx, a_cell) || !st.is_peer(idx, b_cell)) continue;
        const ApplyResult er = st.eliminate(idx, bit);
        if (er != ApplyResult::NoProgress) return er;
    }
    return ApplyResult::NoProgress;
}

inline ApplyResult alternating_chain_core(
    CandidateState& st,
    int depth_cap,
    bool allow_weak_start,
    bool& used_flag) {
    auto& sp = shared::exact_pattern_scratchpad();
    const int n = st.topo->n;
    int neighbors[256]{};

    int* const vis_even = sp.visited;
    int* const vis_odd = sp.bfs_depth;
    int* const queue_state = sp.bfs_queue;
    int* const queue_depth = sp.bfs_parent;

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        if (!shared::build_grouped_link_graph_for_digit(st, d, sp)) continue;
        if (sp.dyn_node_count < 4 || sp.dyn_strong_edge_count == 0) continue;

        for (int start = 0; start < sp.dyn_node_count; ++start) {
            const int start_cell = sp.dyn_node_to_cell[start];
            if (st.board->values[start_cell] != 0) continue;

            for (int first_type = 1; first_type >= 0; --first_type) {
                if (first_type == 0 && !allow_weak_start) continue;

                std::fill_n(vis_even, sp.dyn_node_count, 0);
                std::fill_n(vis_odd, sp.dyn_node_count, 0);

                int qh = 0;
                int qt = 0;

                const int first_cnt = aic_collect_neighbors(sp, start, first_type, neighbors);
                for (int i = 0; i < first_cnt; ++i) {
                    if (qt >= shared::ExactPatternScratchpad::MAX_BFS) break;
                    const int v = neighbors[i];
                    queue_state[qt] = (v << 1) | first_type;
                    queue_depth[qt] = 1;
                    ++qt;
                    if (first_type == 0) vis_even[v] = 1;
                    else vis_odd[v] = 1;
                }

                while (qh < qt) {
                    const int state = queue_state[qh];
                    const int dep = queue_depth[qh];
                    ++qh;

                    const int u = (state >> 1);
                    const int last_type = (state & 1);
                    const int next_type = 1 - last_type;
                    if (dep >= depth_cap) continue;

                    const int next_cnt = aic_collect_neighbors(sp, u, next_type, neighbors);
                    for (int i = 0; i < next_cnt; ++i) {
                        const int v = neighbors[i];
                        const int nd = dep + 1;

                        if (v == start) {
                            // Start-closure inferences are handled in dedicated
                            // Nice Loop strategy to keep AIC core conservative.
                            continue;
                        }

                        // Odd-length alternating chain endpoints seeing each other
                        // force elimination in the intersection of their peers.
                        if (first_type == 1 && nd >= 3 && (nd & 1) == 1) {
                            const int end_cell = sp.dyn_node_to_cell[v];
                            if (st.is_peer(start_cell, end_cell)) {
                                const ApplyResult er = aic_eliminate_common_peers(st, sp, bit, start_cell, end_cell);
                                if (er == ApplyResult::Contradiction) return er;
                                if (er == ApplyResult::Progress) {
                                    used_flag = true;
                                    return er;
                                }
                            }
                        }

                        int* const vis = (next_type == 0) ? vis_even : vis_odd;
                        if (vis[v] != 0) continue;
                        vis[v] = 1;
                        if (qt >= shared::ExactPatternScratchpad::MAX_BFS) continue;
                        queue_state[qt] = (v << 1) | next_type;
                        queue_depth[qt] = nd;
                        ++qt;
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

// Lightweight implication driver used across P7/P8.
inline ApplyResult bounded_implication_core(
    CandidateState& st,
    StrategyStats& s,
    GenericLogicCertifyResult& r,
    int max_iters,
    bool& used_flag) {
    (void)r;
    const uint64_t t0 = get_current_time_ns();
    ++s.use_count;

    const int depth_cap = std::clamp(max_iters, 6, 28);
    const bool allow_weak_start = false;

    const ApplyResult ar = alternating_chain_core(st, depth_cap, allow_weak_start, used_flag);
    s.elapsed_ns += get_current_time_ns() - t0;
    return ar;
}

// Backward-compatible alias for older modules.
inline ApplyResult bounded_implication_proxy(
    CandidateState& st,
    StrategyStats& s,
    GenericLogicCertifyResult& r,
    int max_iters,
    bool& used_flag) {
    return bounded_implication_core(st, s, r, max_iters, used_flag);
}

inline ApplyResult apply_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    bool used = false;
    const ApplyResult res = bounded_implication_core(st, s, r, 8, used);
    if (res == ApplyResult::Progress && used) {
        ++s.hit_count;
        r.used_aic = true;
    }
    return res;
}

inline ApplyResult apply_grouped_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    bool used = false;
    const ApplyResult res = bounded_implication_core(st, s, r, 14, used);
    if (res == ApplyResult::Progress && used) {
        ++s.hit_count;
        r.used_grouped_aic = true;
    }
    return res;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\aligned_exclusion.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: aligned_exclusion.h (Poziom 7 - Nightmare)
// Opis: Implementacja Aligned Pair Exclusion (APE) i Aligned Triple Exclusion (ATE).
//       Eliminuje pary lub trójki cyfr w komórkach kandydujących, jeżeli wszystkie
//       ich legalne kombinacje zmuszają "cel" (target) do złamania reguł.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p7_nightmare {

// ============================================================================
// Aligned Pair Exclusion (APE)
// ============================================================================
inline ApplyResult apply_aligned_pair_exclusion(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    // Optymalizacja wczesnego wyjścia (w siatkach gęstych to się nie wydarzy)
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int nn = st.topo->nn;
    bool progress = false;

    // Przeszukiwanie wszystkich możliwych par komórek, które się nawzajem widzą (Aligned)
    for (int a = 0; a < nn; ++a) {
        if (st.board->values[a] != 0) continue;
        const uint64_t ma = st.cands[a];
        if (ma == 0ULL) continue;
        
        for (int b = a + 1; b < nn; ++b) {
            if (st.board->values[b] != 0) continue;
            // Warunek zestrojenia - komórki "Aligned" muszą się widzieć
            if (!st.is_peer(a, b)) continue;
            
            const uint64_t mb = st.cands[b];
            if (mb == 0ULL) continue;

            uint64_t bad_a = 0ULL;
            uint64_t bad_b = 0ULL;
            
            // ----------------------------------------------------------------
            // Ewaluacja dla komórki A: szukamy cyfry, która NIE MA kompatybilnego 
            // sąsiada w komórce B, by mogły współistnieć w otoczeniu planszy.
            // ----------------------------------------------------------------
            uint64_t wa = ma;
            while (wa != 0ULL) {
                const uint64_t ba = config::bit_lsb(wa);
                wa = config::bit_clear_lsb_u64(wa);
                const int da = config::bit_ctz_u64(ba) + 1;
                
                bool valid_for_a = false;
                uint64_t wb = mb;
                while (wb != 0ULL) {
                    const uint64_t bb = config::bit_lsb(wb);
                    wb = config::bit_clear_lsb_u64(wb);
                    const int db = config::bit_ctz_u64(bb) + 1;
                    
                    if (da == db) continue; // Aligned Pair nie pozwala na te same cyfry (bo się widzą)
                    
                    // Sprawdzamy czy para (da w a) oraz (db w b) jest legalna względem ogólnych reguł planszy
                    if (st.board->can_place(a, da) && st.board->can_place(b, db)) {
                        valid_for_a = true;
                        break;
                    }
                }
                if (!valid_for_a) bad_a |= ba;
            }

            // ----------------------------------------------------------------
            // Ewaluacja dla komórki B (Lustrzana operacja w locie)
            // ----------------------------------------------------------------
            uint64_t wb = mb;
            while (wb != 0ULL) {
                const uint64_t bb = config::bit_lsb(wb);
                wb = config::bit_clear_lsb_u64(wb);
                const int db = config::bit_ctz_u64(bb) + 1;
                
                bool valid_for_b = false;
                uint64_t waa = ma;
                while (waa != 0ULL) {
                    const uint64_t ba = config::bit_lsb(waa);
                    waa = config::bit_clear_lsb_u64(waa);
                    const int da = config::bit_ctz_u64(ba) + 1;
                    
                    if (da == db) continue;
                    
                    if (st.board->can_place(a, da) && st.board->can_place(b, db)) {
                        valid_for_b = true;
                        break;
                    }
                }
                if (!valid_for_b) bad_b |= bb;
            }

            // Aplikacja potencjalnych uderzeń
            if (bad_a != 0ULL) {
                const ApplyResult er = st.eliminate(a, bad_a);
                if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                progress = progress || (er == ApplyResult::Progress);
            }
            if (bad_b != 0ULL) {
                const ApplyResult er = st.eliminate(b, bad_b);
                if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                progress = progress || (er == ApplyResult::Progress);
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_aligned_pair_exclusion = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}


// ============================================================================
// Aligned Triple Exclusion (ATE)
// ============================================================================
inline ApplyResult apply_aligned_triple_exclusion(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    const int nn = st.topo->nn;
    bool progress = false;

    for (int a = 0; a < nn; ++a) {
        if (st.board->values[a] != 0) continue;
        const uint64_t ma = st.cands[a];
        // Heurystyczne cięcie wydajnościowe: nie wchodzimy w duże trójki
        if (ma == 0ULL || std::popcount(ma) > 8) continue;
        
        for (int b = a + 1; b < nn; ++b) {
            if (st.board->values[b] != 0) continue;
            if (!st.is_peer(a, b)) continue;
            
            const uint64_t mb = st.cands[b];
            if (mb == 0ULL || std::popcount(mb) > 8) continue;
            
            for (int c = b + 1; c < nn; ++c) {
                if (st.board->values[c] != 0) continue;
                // C musi widzieć A ORAZ B
                if (!st.is_peer(a, c) || !st.is_peer(b, c)) continue;
                
                const uint64_t mc = st.cands[c];
                if (mc == 0ULL || std::popcount(mc) > 8) continue;

                uint64_t bad_a = 0ULL;
                
                // Trójpoziomowa kombinatoryka (działa szybko dzięki maskom, max 8*8*8 = 512 iteracji lokalnie)
                uint64_t wa = ma;
                while (wa != 0ULL) {
                    const uint64_t ba = config::bit_lsb(wa);
                    wa = config::bit_clear_lsb_u64(wa);
                    const int da = config::bit_ctz_u64(ba) + 1;
                    
                    bool valid = false;
                    uint64_t wb = mb;
                    
                    while (wb != 0ULL && !valid) {
                        const uint64_t bb = config::bit_lsb(wb);
                        wb = config::bit_clear_lsb_u64(wb);
                        const int db = config::bit_ctz_u64(bb) + 1;
                        if (db == da) continue;
                        
                        uint64_t wc = mc;
                        while (wc != 0ULL) {
                            const uint64_t bc = config::bit_lsb(wc);
                            wc = config::bit_clear_lsb_u64(wc);
                            const int dc = config::bit_ctz_u64(bc) + 1;
                            if (dc == da || dc == db) continue;
                            
                            // Czy trójka cyfr może legalnie bytować w siatce?
                            if (st.board->can_place(a, da) && st.board->can_place(b, db) && st.board->can_place(c, dc)) {
                                valid = true;
                                break; // Szybkie zwolnienie
                            }
                        }
                    }
                    if (!valid) bad_a |= ba;
                }

                if (bad_a != 0ULL) {
                    const ApplyResult er = st.eliminate(a, bad_a);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += st.now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
                
                // Eliminacja B i C pominięta dla oszczędności symetrii operacji 
                // Pętla nadrzędna O(N^3) zajmie się zbadaniem b i c jako potencjalne 'a' w kolejnych iteracjach,
                // co uodparnia logikę na powielanie kodu (HPC Cache Friendly).
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_aligned_triple_exclusion = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }
    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\als_xy_wing_chain.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: als_xy_wing_chain.h (Level 7 - Nightmare)
// Description: Direct zero-allocation passes for ALS-XY-Wing, ALS-Chain and
// ALS-AIC style eliminations, with conservative fallback composition.
// ============================================================================

#pragma once

#include <algorithm>
#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/als_builder.h"
#include "../shared/exact_pattern_scratchpad.h"

#include "../p6_diabolical/als_xz.h"
#include "../p5_expert/xyz_w_wing.h"
#include "../p6_diabolical/chains_basic.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline bool als_deep_pass_allowed(const CandidateState& st) {
    if (st.topo->n > 32) return false;
    return st.board->empty_cells <= (st.topo->nn - st.topo->n);
}

inline bool als_overlap(const shared::ALS& a, const shared::ALS& b, int words) {
    for (int w = 0; w < words; ++w) {
        if ((a.cell_mask[w] & b.cell_mask[w]) != 0ULL) return true;
    }
    return false;
}

inline int als_collect_holders_for_digit(
    const CandidateState& st,
    const shared::ALS& als,
    uint64_t bit,
    int* out) {
    const int nn = st.topo->nn;
    const int words = (nn + 63) >> 6;
    int cnt = 0;
    for (int w = 0; w < words; ++w) {
        uint64_t m = als.cell_mask[w];
        while (m != 0ULL) {
            const uint64_t lsb = config::bit_lsb(m);
            const int b = config::bit_ctz_u64(lsb);
            const int idx = (w << 6) + b;
            if (idx < nn && (st.cands[idx] & bit) != 0ULL) {
                out[cnt++] = idx;
            }
            m = config::bit_clear_lsb_u64(m);
        }
    }
    return cnt;
}

inline bool holders_fully_cross_peer(
    const CandidateState& st,
    const int* left,
    int left_cnt,
    const int* right,
    int right_cnt) {
    if (left_cnt <= 0 || right_cnt <= 0) return false;
    for (int i = 0; i < left_cnt; ++i) {
        for (int j = 0; j < right_cnt; ++j) {
            if (!st.is_peer(left[i], right[j])) return false;
        }
    }
    return true;
}

inline bool als_restricted_common(
    const CandidateState& st,
    const shared::ALS& a,
    const shared::ALS& b,
    uint64_t bit,
    int* a_holders,
    int& a_cnt,
    int* b_holders,
    int& b_cnt) {
    a_cnt = als_collect_holders_for_digit(st, a, bit, a_holders);
    b_cnt = als_collect_holders_for_digit(st, b, bit, b_holders);
    if (a_cnt <= 0 || b_cnt <= 0) return false;
    return holders_fully_cross_peer(st, a_holders, a_cnt, b_holders, b_cnt);
}

inline ApplyResult eliminate_from_seen_intersection(
    CandidateState& st,
    uint64_t bit,
    const int* h1,
    int h1_cnt,
    const int* h2,
    int h2_cnt,
    const shared::ALS* s1,
    const shared::ALS* s2,
    const shared::ALS* s3 = nullptr,
    const shared::ALS* s4 = nullptr) {
    const int nn = st.topo->nn;
    for (int t = 0; t < nn; ++t) {
        if (st.board->values[t] != 0) continue;
        if ((st.cands[t] & bit) == 0ULL) continue;
        if (shared::als_cell_in(*s1, t) || shared::als_cell_in(*s2, t) ||
            (s3 != nullptr && shared::als_cell_in(*s3, t)) ||
            (s4 != nullptr && shared::als_cell_in(*s4, t))) {
            continue;
        }

        bool sees_all = true;
        for (int i = 0; i < h1_cnt; ++i) {
            if (!st.is_peer(t, h1[i])) {
                sees_all = false;
                break;
            }
        }
        if (!sees_all) continue;
        for (int i = 0; i < h2_cnt; ++i) {
            if (!st.is_peer(t, h2[i])) {
                sees_all = false;
                break;
            }
        }
        if (!sees_all) continue;

        const ApplyResult er = st.eliminate(t, bit);
        if (er != ApplyResult::NoProgress) return er;
    }
    return ApplyResult::NoProgress;
}

inline ApplyResult direct_als_xy_wing_pass(CandidateState& st) {
    auto& sp = shared::exact_pattern_scratchpad();
    const int als_cnt = shared::build_als_list(st, 2, 4);
    if (als_cnt < 3) return ApplyResult::NoProgress;

    const int nn = st.topo->nn;
    const int words = (nn + 63) >> 6;
    const int limit = std::min(als_cnt, 128);

    int p_x[8]{}, w1_x[8]{}, p_y[8]{}, w2_y[8]{}, w1_z[8]{}, w2_z[8]{};
    int p_xc = 0, w1_xc = 0, p_yc = 0, w2_yc = 0, w1_zc = 0, w2_zc = 0;

    for (int ip = 0; ip < limit; ++ip) {
        const shared::ALS& pivot = sp.als_list[ip];
        for (int i1 = 0; i1 < limit; ++i1) {
            if (i1 == ip) continue;
            const shared::ALS& wing1 = sp.als_list[i1];
            if (als_overlap(pivot, wing1, words)) continue;

            const uint64_t common_p1 = pivot.digit_mask & wing1.digit_mask;
            if (common_p1 == 0ULL) continue;

            for (int i2 = i1 + 1; i2 < limit; ++i2) {
                if (i2 == ip) continue;
                const shared::ALS& wing2 = sp.als_list[i2];
                if (als_overlap(pivot, wing2, words) || als_overlap(wing1, wing2, words)) continue;

                const uint64_t common_p2 = pivot.digit_mask & wing2.digit_mask;
                if (common_p2 == 0ULL) continue;

                uint64_t wx = common_p1;
                while (wx != 0ULL) {
                    const uint64_t x = config::bit_lsb(wx);
                    wx = config::bit_clear_lsb_u64(wx);
                    if (!als_restricted_common(st, pivot, wing1, x, p_x, p_xc, w1_x, w1_xc)) continue;

                    uint64_t wy = common_p2 & ~x;
                    while (wy != 0ULL) {
                        const uint64_t y = config::bit_lsb(wy);
                        wy = config::bit_clear_lsb_u64(wy);
                        if (!als_restricted_common(st, pivot, wing2, y, p_y, p_yc, w2_y, w2_yc)) continue;

                        uint64_t zmask = (wing1.digit_mask & wing2.digit_mask) & ~(x | y);
                        while (zmask != 0ULL) {
                            const uint64_t z = config::bit_lsb(zmask);
                            zmask = config::bit_clear_lsb_u64(zmask);
                            w1_zc = als_collect_holders_for_digit(st, wing1, z, w1_z);
                            w2_zc = als_collect_holders_for_digit(st, wing2, z, w2_z);
                            if (w1_zc <= 0 || w2_zc <= 0) continue;
                            const ApplyResult er = eliminate_from_seen_intersection(
                                st, z, w1_z, w1_zc, w2_z, w2_zc, &pivot, &wing1, &wing2);
                            if (er != ApplyResult::NoProgress) return er;
                        }
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult direct_als_chain_pass(CandidateState& st) {
    auto& sp = shared::exact_pattern_scratchpad();
    const int als_cnt = shared::build_als_list(st, 2, 4);
    if (als_cnt < 3) return ApplyResult::NoProgress;

    const int nn = st.topo->nn;
    const int words = (nn + 63) >> 6;
    const int limit = std::min(als_cnt, 96);

    int a_x[8]{}, b_x[8]{}, b_y[8]{}, c_y[8]{}, a_z[8]{}, c_z[8]{};
    int a_xc = 0, b_xc = 0, b_yc = 0, c_yc = 0, a_zc = 0, c_zc = 0;

    for (int ia = 0; ia < limit; ++ia) {
        const shared::ALS& a = sp.als_list[ia];
        for (int ib = 0; ib < limit; ++ib) {
            if (ib == ia) continue;
            const shared::ALS& b = sp.als_list[ib];
            if (als_overlap(a, b, words)) continue;

            uint64_t xmask = a.digit_mask & b.digit_mask;
            while (xmask != 0ULL) {
                const uint64_t x = config::bit_lsb(xmask);
                xmask = config::bit_clear_lsb_u64(xmask);
                if (!als_restricted_common(st, a, b, x, a_x, a_xc, b_x, b_xc)) continue;

                for (int ic = 0; ic < limit; ++ic) {
                    if (ic == ia || ic == ib) continue;
                    const shared::ALS& c = sp.als_list[ic];
                    if (als_overlap(a, c, words) || als_overlap(b, c, words)) continue;

                    uint64_t ymask = (b.digit_mask & c.digit_mask) & ~x;
                    while (ymask != 0ULL) {
                        const uint64_t y = config::bit_lsb(ymask);
                        ymask = config::bit_clear_lsb_u64(ymask);
                        if (!als_restricted_common(st, b, c, y, b_y, b_yc, c_y, c_yc)) continue;

                        uint64_t zmask = (a.digit_mask & c.digit_mask) & ~(x | y);
                        while (zmask != 0ULL) {
                            const uint64_t z = config::bit_lsb(zmask);
                            zmask = config::bit_clear_lsb_u64(zmask);
                            a_zc = als_collect_holders_for_digit(st, a, z, a_z);
                            c_zc = als_collect_holders_for_digit(st, c, z, c_z);
                            if (a_zc <= 0 || c_zc <= 0) continue;
                            const ApplyResult er = eliminate_from_seen_intersection(
                                st, z, a_z, a_zc, c_z, c_zc, &a, &b, &c);
                            if (er != ApplyResult::NoProgress) return er;
                        }
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult direct_als_aic_pass(CandidateState& st) {
    auto& sp = shared::exact_pattern_scratchpad();
    const int als_cnt = shared::build_als_list(st, 2, 4);
    if (als_cnt < 4) return ApplyResult::NoProgress;

    const int nn = st.topo->nn;
    const int words = (nn + 63) >> 6;
    const int limit = std::min(als_cnt, 48);

    int a_h[8]{}, b_h[8]{}, c_h[8]{}, d_h[8]{}, az[8]{}, dz[8]{};
    int a_hc = 0, b_hc = 0, c_hc = 0, d_hc = 0, azc = 0, dzc = 0;

    for (int ia = 0; ia < limit; ++ia) {
        const shared::ALS& a = sp.als_list[ia];
        for (int ib = 0; ib < limit; ++ib) {
            if (ib == ia) continue;
            const shared::ALS& b = sp.als_list[ib];
            if (als_overlap(a, b, words)) continue;

            uint64_t xmask = a.digit_mask & b.digit_mask;
            while (xmask != 0ULL) {
                const uint64_t x = config::bit_lsb(xmask);
                xmask = config::bit_clear_lsb_u64(xmask);
                if (!als_restricted_common(st, a, b, x, a_h, a_hc, b_h, b_hc)) continue;

                for (int ic = 0; ic < limit; ++ic) {
                    if (ic == ia || ic == ib) continue;
                    const shared::ALS& c = sp.als_list[ic];
                    if (als_overlap(a, c, words) || als_overlap(b, c, words)) continue;

                    uint64_t ymask = (b.digit_mask & c.digit_mask) & ~x;
                    while (ymask != 0ULL) {
                        const uint64_t y = config::bit_lsb(ymask);
                        ymask = config::bit_clear_lsb_u64(ymask);
                        if (!als_restricted_common(st, b, c, y, b_h, b_hc, c_h, c_hc)) continue;

                        for (int id = 0; id < limit; ++id) {
                            if (id == ia || id == ib || id == ic) continue;
                            const shared::ALS& d = sp.als_list[id];
                            if (als_overlap(a, d, words) || als_overlap(b, d, words) || als_overlap(c, d, words)) continue;

                            uint64_t wmask = (c.digit_mask & d.digit_mask) & ~(x | y);
                            while (wmask != 0ULL) {
                                const uint64_t w = config::bit_lsb(wmask);
                                wmask = config::bit_clear_lsb_u64(wmask);
                                if (!als_restricted_common(st, c, d, w, c_h, c_hc, d_h, d_hc)) continue;

                                uint64_t zmask = (a.digit_mask & d.digit_mask) & ~(x | y | w);
                                while (zmask != 0ULL) {
                                    const uint64_t z = config::bit_lsb(zmask);
                                    zmask = config::bit_clear_lsb_u64(zmask);
                                    azc = als_collect_holders_for_digit(st, a, z, az);
                                    dzc = als_collect_holders_for_digit(st, d, z, dz);
                                    if (azc <= 0 || dzc <= 0) continue;
                                    const ApplyResult er = eliminate_from_seen_intersection(
                                        st, z, az, azc, dz, dzc, &a, &b, &c, &d);
                                    if (er != ApplyResult::NoProgress) return er;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult apply_als_xy_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    ApplyResult ar;

    StrategyStats tmp{};
    ar = p6_diabolical::apply_als_xz(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_xy_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    ar = p5_expert::apply_xyz_wing(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_xy_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    if (!als_deep_pass_allowed(st)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    ar = direct_als_xy_wing_pass(st);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_xy_wing = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_als_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    ApplyResult ar;

    StrategyStats tmp{};
    ar = p6_diabolical::apply_als_xz(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_chain = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    ar = p6_diabolical::apply_xy_chain(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_chain = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    if (!als_deep_pass_allowed(st)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    ar = direct_als_chain_pass(st);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_chain = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_als_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    ApplyResult ar;

    StrategyStats tmp{};
    ar = p6_diabolical::apply_x_chain(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_aic = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    ar = direct_als_chain_pass(st);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_aic = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    if (!als_deep_pass_allowed(st)) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    ar = direct_als_aic_pass(st);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_als_aic = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ar;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\continuous_nice_loop.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: continuous_nice_loop.h (Level 7 - Nightmare)
// Description: Direct alternating strong/weak loop search with discontinuity
// inference (strong-strong => true, weak-weak => false).
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/link_graph_builder.h"
#include "aic_grouped_aic.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline bool cnl_is_strong_neighbor(const shared::ExactPatternScratchpad& sp, int u, int v) {
    const int p0 = sp.dyn_strong_offsets[u];
    const int p1 = sp.dyn_strong_offsets[u + 1];
    for (int p = p0; p < p1; ++p) {
        if (sp.dyn_strong_adj[p] == v) return true;
    }
    return false;
}

inline int cnl_collect_neighbors(
    const shared::ExactPatternScratchpad& sp,
    int u,
    int edge_type, // 1=strong, 0=weak-only
    int* out) {
    int cnt = 0;
    if (edge_type == 1) {
        const int p0 = sp.dyn_strong_offsets[u];
        const int p1 = sp.dyn_strong_offsets[u + 1];
        for (int p = p0; p < p1; ++p) {
            out[cnt++] = sp.dyn_strong_adj[p];
        }
        return cnt;
    }

    const int p0 = sp.dyn_weak_offsets[u];
    const int p1 = sp.dyn_weak_offsets[u + 1];
    for (int p = p0; p < p1; ++p) {
        const int v = sp.dyn_weak_adj[p];
        if (cnl_is_strong_neighbor(sp, u, v)) continue;
        out[cnt++] = v;
    }
    return cnt;
}

inline ApplyResult apply_continuous_nice_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    bool any_progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    int* const vis_even = sp.visited;    // visited by (node, parity 0)
    int* const vis_odd = sp.bfs_depth;   // visited by (node, parity 1)
    int* const queue = sp.bfs_queue;     // state = node * 2 + last_edge_type
    int* const depth = sp.bfs_parent;    // state depth in edges
    int neighbors[256]{};

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        if (!shared::build_grouped_link_graph_for_digit(st, d, sp)) continue;
        if (sp.dyn_node_count < 3 || sp.dyn_strong_edge_count == 0) continue;

        const int max_depth = std::clamp(8 + st.board->empty_cells / std::max(1, n), 10, 22);

        for (int start = 0; start < sp.dyn_node_count; ++start) {
            const int start_cell = sp.dyn_node_to_cell[start];
            if (st.board->values[start_cell] != 0) continue;

            for (int first_type = 0; first_type <= 1; ++first_type) {
                // first_type: 1=strong, 0=weak-only
                std::fill_n(vis_even, sp.dyn_node_count, 0);
                std::fill_n(vis_odd, sp.dyn_node_count, 0);

                int qh = 0;
                int qt = 0;

                const int first_cnt = cnl_collect_neighbors(sp, start, first_type, neighbors);
                for (int i = 0; i < first_cnt; ++i) {
                    const int v = neighbors[i];
                    const int state = (v << 1) | first_type; // last edge type used
                    queue[qt] = state;
                    depth[qt] = 1;
                    ++qt;
                    if (first_type == 0) vis_even[v] = 1;
                    else vis_odd[v] = 1;
                }

                bool inferred = false;
                while (qh < qt && !inferred) {
                    const int state = queue[qh];
                    const int dep = depth[qh];
                    ++qh;

                    const int u = (state >> 1);
                    const int last_type = (state & 1);
                    const int next_type = 1 - last_type;
                    if (dep >= max_depth) continue;

                    const int next_cnt = cnl_collect_neighbors(sp, u, next_type, neighbors);
                    for (int i = 0; i < next_cnt; ++i) {
                        const int v = neighbors[i];
                        if (v == start) {
                            // Discontinuous loop at start:
                            // same type at both ends of start => inference on start candidate.
                            if (next_type == first_type && dep >= 2) {
                                if (first_type == 1) {
                                    if (!st.place(start_cell, d)) {
                                        s.elapsed_ns += get_current_time_ns() - t0;
                                        return ApplyResult::Contradiction;
                                    }
                                } else {
                                    const ApplyResult er = st.eliminate(start_cell, bit);
                                    if (er == ApplyResult::Contradiction) {
                                        s.elapsed_ns += get_current_time_ns() - t0;
                                        return er;
                                    }
                                    if (er == ApplyResult::NoProgress) {
                                        // no inference from this loop
                                        continue;
                                    }
                                }
                                any_progress = true;
                                inferred = true;
                                break;
                            }
                            continue;
                        }

                        int* vis = (next_type == 0) ? vis_even : vis_odd;
                        if (vis[v] != 0) continue;
                        vis[v] = 1;
                        queue[qt] = (v << 1) | next_type;
                        depth[qt] = dep + 1;
                        ++qt;
                        if (qt >= shared::ExactPatternScratchpad::MAX_BFS) break;
                    }
                }
            }
        }
    }

    if (any_progress) {
        ++s.hit_count;
        r.used_continuous_nice_loop = true;
        s.elapsed_ns += get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare




==============================================================================
PLIK: Sources\logic\p7_nightmare\death_blossom.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: death_blossom.h (Level 7 - Nightmare)
// Description: Direct stem+petals Death Blossom detector (zero-allocation).
// ============================================================================

#pragma once

#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline int other_digit_in_bivalue(uint64_t bivalue_mask, int known_digit) {
    if (std::popcount(bivalue_mask) != 2) {
        return 0;
    }
    const uint64_t known_bit = 1ULL << (known_digit - 1);
    if ((bivalue_mask & known_bit) == 0ULL) {
        return 0;
    }
    const uint64_t other = bivalue_mask & ~known_bit;
    if (std::popcount(other) != 1) {
        return 0;
    }
    return static_cast<int>(std::countr_zero(other)) + 1;
}

inline ApplyResult apply_death_blossom(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    bool progress = false;

    // petals[digit-1][] keeps peer bivalue cells containing this pivot digit.
    int petals[64][192]{};
    int petal_cnt[64]{};
    int pivot_digits[64]{};

    for (int pivot = 0; pivot < nn; ++pivot) {
        if (st.board->values[pivot] != 0) continue;

        const uint64_t pivot_mask = st.cands[pivot];
        const int pivot_pc = std::popcount(pivot_mask);
        if (pivot_pc < 3 || pivot_pc > 6) continue;

        for (int i = 0; i < n; ++i) {
            petal_cnt[i] = 0;
        }

        int pivot_digit_cnt = 0;
        uint64_t w = pivot_mask;
        while (w != 0ULL && pivot_digit_cnt < n) {
            const uint64_t bit = w & (~w + 1ULL);
            w &= (w - 1ULL);
            const int d = static_cast<int>(std::countr_zero(bit)) + 1;
            pivot_digits[pivot_digit_cnt++] = d;
        }

        const int p0 = st.topo->peer_offsets[pivot];
        const int p1 = st.topo->peer_offsets[pivot + 1];
        for (int p = p0; p < p1; ++p) {
            const int peer = st.topo->peers_flat[p];
            if (st.board->values[peer] != 0) continue;
            const uint64_t pm = st.cands[peer];
            if (std::popcount(pm) != 2) continue;

            for (int di = 0; di < pivot_digit_cnt; ++di) {
                const int d = pivot_digits[di];
                const uint64_t bit = 1ULL << (d - 1);
                if ((pm & bit) == 0ULL) continue;
                int& cnt = petal_cnt[d - 1];
                if (cnt < 192) {
                    petals[d - 1][cnt++] = peer;
                }
            }
        }

        for (int ia = 0; ia < pivot_digit_cnt; ++ia) {
            const int da = pivot_digits[ia];
            const int ca = petal_cnt[da - 1];
            if (ca == 0) continue;

            for (int ib = ia + 1; ib < pivot_digit_cnt; ++ib) {
                const int db = pivot_digits[ib];
                const int cb = petal_cnt[db - 1];
                if (cb == 0) continue;

                for (int pa = 0; pa < ca; ++pa) {
                    const int petal_a = petals[da - 1][pa];
                    const int z_a = other_digit_in_bivalue(st.cands[petal_a], da);
                    if (z_a == 0) continue;

                    for (int pb = 0; pb < cb; ++pb) {
                        const int petal_b = petals[db - 1][pb];
                        if (petal_b == petal_a) continue;
                        const int z_b = other_digit_in_bivalue(st.cands[petal_b], db);
                        if (z_b == 0 || z_b != z_a) continue;

                        const uint64_t elim_bit = 1ULL << (z_a - 1);
                        const int q0 = st.topo->peer_offsets[petal_a];
                        const int q1 = st.topo->peer_offsets[petal_a + 1];
                        for (int q = q0; q < q1; ++q) {
                            const int target = st.topo->peers_flat[q];
                            if (target == pivot || target == petal_a || target == petal_b) continue;
                            if (!st.is_peer(target, petal_b)) continue;
                            if (st.board->values[target] != 0) continue;

                            const ApplyResult er = st.eliminate(target, elim_bit);
                            if (er == ApplyResult::Contradiction) {
                                s.elapsed_ns += st.now_ns() - t0;
                                return er;
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_death_blossom = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare




==============================================================================
PLIK: Sources\logic\p7_nightmare\franken_mutant_fish.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: franken_mutant_fish.h (Level 7 - Nightmare)
// Description: Direct mixed fish detector with both orientations:
// row+box bases vs column covers and col+box bases vs row covers.
// ============================================================================

#pragma once

#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline bool cell_in_mixed_base(
    const CandidateState& st,
    int idx,
    const int* base_ids,
    int base_count,
    bool line_is_row) {
    const int line = line_is_row ? st.topo->cell_row[idx] : st.topo->cell_col[idx];
    const int box = st.topo->cell_box[idx];
    for (int i = 0; i < base_count; ++i) {
        const int b = base_ids[i];
        if (b < st.topo->n) {
            if (line == b) return true;
        } else {
            if (box == (b - st.topo->n)) return true;
        }
    }
    return false;
}

inline bool build_line_box_base_masks(
    const CandidateState& st,
    int digit,
    int fish_size,
    bool line_is_row,
    int* out_ids,
    uint64_t* out_masks,
    int& out_count) {
    const int n = st.topo->n;
    const uint64_t bit = 1ULL << (digit - 1);
    out_count = 0;

    // Line houses as bases (rows or cols).
    for (int line = 0; line < n; ++line) {
        uint64_t cover_mask = 0ULL;
        for (int orth = 0; orth < n; ++orth) {
            const int idx = line_is_row ? (line * n + orth) : (orth * n + line);
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            const int cover = line_is_row ? st.topo->cell_col[idx] : st.topo->cell_row[idx];
            cover_mask |= (1ULL << cover);
        }
        const int pc = std::popcount(cover_mask);
        if (pc >= 2 && pc <= fish_size) {
            out_ids[out_count] = line;
            out_masks[out_count] = cover_mask;
            ++out_count;
        }
    }

    // Boxes as bases.
    for (int b = 0; b < n; ++b) {
        const int h = 2 * n + b;
        const int p0 = st.topo->house_offsets[h];
        const int p1 = st.topo->house_offsets[h + 1];
        uint64_t cover_mask = 0ULL;
        for (int p = p0; p < p1; ++p) {
            const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            const int cover = line_is_row ? st.topo->cell_col[idx] : st.topo->cell_row[idx];
            cover_mask |= (1ULL << cover);
        }
        const int pc = std::popcount(cover_mask);
        if (pc >= 2 && pc <= fish_size) {
            out_ids[out_count] = n + b;
            out_masks[out_count] = cover_mask;
            ++out_count;
        }
    }

    return out_count >= fish_size;
}

inline ApplyResult apply_mixed_row_box_vs_col_fish(
    CandidateState& st,
    int fish_size,
    bool line_is_row,
    bool& progress,
    StrategyStats& s,
    uint64_t t0) {
    const int n = st.topo->n;
    if (n > 64 || fish_size < 2 || fish_size > 4) {
        return ApplyResult::NoProgress;
    }

    int base_ids[128]{};
    uint64_t base_masks[128]{};
    int selected[4]{};

    for (int d = 1; d <= n; ++d) {
        int base_count = 0;
        if (!build_line_box_base_masks(st, d, fish_size, line_is_row, base_ids, base_masks, base_count)) {
            continue;
        }
        const uint64_t d_bit = 1ULL << (d - 1);

        for (int i0 = 0; i0 < base_count; ++i0) {
            selected[0] = i0;
            const int i1_start = (fish_size >= 2) ? (i0 + 1) : base_count;
            const int i1_end = (fish_size >= 2) ? base_count : (i0 + 1);
            for (int i1 = i1_start; i1 < i1_end; ++i1) {
                if (fish_size >= 2) selected[1] = i1;
                const int i2_start = (fish_size >= 3) ? (i1 + 1) : i1_end;
                const int i2_end = (fish_size >= 3) ? base_count : (i1 + 1);
                for (int i2 = i2_start; i2 < i2_end; ++i2) {
                    if (fish_size >= 3) selected[2] = i2;
                    const int i3_start = (fish_size >= 4) ? (i2 + 1) : i2_end;
                    const int i3_end = (fish_size >= 4) ? base_count : (i2 + 1);
                    for (int i3 = i3_start; i3 < i3_end; ++i3) {
                        if (fish_size >= 4) selected[3] = i3;

                        uint64_t cover_cols = 0ULL;
                        for (int k = 0; k < fish_size; ++k) {
                            cover_cols |= base_masks[selected[k]];
                        }
                        if (std::popcount(cover_cols) != fish_size) {
                            continue;
                        }

                        int chosen_base_ids[4]{};
                        for (int k = 0; k < fish_size; ++k) {
                            chosen_base_ids[k] = base_ids[selected[k]];
                        }

                        for (int cover = 0; cover < n; ++cover) {
                            if ((cover_cols & (1ULL << cover)) == 0ULL) continue;
                            for (int orth = 0; orth < n; ++orth) {
                                const int idx = line_is_row ? (orth * n + cover) : (cover * n + orth);
                                if (st.board->values[idx] != 0) continue;
                                if ((st.cands[idx] & d_bit) == 0ULL) continue;
                                if (cell_in_mixed_base(st, idx, chosen_base_ids, fish_size, line_is_row)) continue;

                                const ApplyResult er = st.eliminate(idx, d_bit);
                                if (er == ApplyResult::Contradiction) {
                                    s.elapsed_ns += st.now_ns() - t0;
                                    return er;
                                }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult apply_franken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    bool progress = false;
    ApplyResult ar = apply_mixed_row_box_vs_col_fish(st, 3, true, progress, s, t0);
    if (ar == ApplyResult::Contradiction) return ar;
    ar = apply_mixed_row_box_vs_col_fish(st, 3, false, progress, s, t0);
    if (ar == ApplyResult::Contradiction) {
        return ar;
    }
    if (progress) {
        ++s.hit_count;
        r.used_franken_fish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_mutant_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    bool progress = false;
    ApplyResult ar = apply_mixed_row_box_vs_col_fish(st, 4, true, progress, s, t0);
    if (ar == ApplyResult::Contradiction) return ar;
    ar = apply_mixed_row_box_vs_col_fish(st, 4, false, progress, s, t0);
    if (ar == ApplyResult::Contradiction) {
        return ar;
    }
    if (progress) {
        ++s.hit_count;
        r.used_mutant_fish = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\grouped_x_cycle.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: grouped_x_cycle.h (Level 7 - Nightmare)
// Description: Direct grouped X-Cycle style elimination on strong/weak graph
// per digit (zero-allocation).
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../shared/link_graph_builder.h"
#include "aic_grouped_aic.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline bool gx_is_strong_neighbor(const shared::ExactPatternScratchpad& sp, int u, int v) {
    const int p0 = sp.dyn_strong_offsets[u];
    const int p1 = sp.dyn_strong_offsets[u + 1];
    for (int p = p0; p < p1; ++p) {
        if (sp.dyn_strong_adj[p] == v) return true;
    }
    return false;
}

inline ApplyResult apply_grouped_x_cycle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    bool any_progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    int* const color = sp.visited;       // -1/0/1 for current digit graph nodes
    int* const queue = sp.bfs_queue;     // BFS queue over node ids
    int* const comp_nodes = sp.chain_cell;
    int* const comp_mark = sp.bfs_depth; // marks node in current component

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        if (!shared::build_grouped_link_graph_for_digit(st, d, sp)) continue;
        if (sp.dyn_node_count < 4 || sp.dyn_strong_edge_count < 2) continue;

        std::fill_n(color, sp.dyn_node_count, -1);

        for (int start = 0; start < sp.dyn_node_count; ++start) {
            if (sp.dyn_strong_degree[start] == 0 || color[start] != -1) continue;

            std::fill_n(comp_mark, sp.dyn_node_count, 0);
            int qh = 0;
            int qt = 0;
            int comp_size = 0;
            bool color_conflict[2] = {false, false};

            color[start] = 0;
            queue[qt++] = start;
            comp_mark[start] = 1;

            // Color component by strong links.
            while (qh < qt) {
                const int u = queue[qh++];
                if (comp_size < shared::ExactPatternScratchpad::MAX_CHAIN) {
                    comp_nodes[comp_size++] = u;
                }

                const int c_u = color[u];
                const int opp = 1 - c_u;
                const int p0 = sp.dyn_strong_offsets[u];
                const int p1 = sp.dyn_strong_offsets[u + 1];
                for (int p = p0; p < p1; ++p) {
                    const int v = sp.dyn_strong_adj[p];
                    if (color[v] == -1) {
                        color[v] = opp;
                        if (!comp_mark[v]) {
                            comp_mark[v] = 1;
                            queue[qt++] = v;
                        }
                    } else if (color[v] == c_u) {
                        color_conflict[c_u] = true;
                    }
                }
            }

            // Need a loop-like component.
            int comp_strong_edges_twice = 0;
            for (int i = 0; i < comp_size; ++i) {
                const int u = comp_nodes[i];
                comp_strong_edges_twice += sp.dyn_strong_degree[u];
            }
            const bool has_cycle = (comp_strong_edges_twice / 2) >= comp_size;
            if (!has_cycle && !color_conflict[0] && !color_conflict[1]) continue;

            // Wrap-style elimination: same-color contradiction.
            for (int bad_color = 0; bad_color <= 1; ++bad_color) {
                if (!color_conflict[bad_color]) continue;
                for (int i = 0; i < comp_size; ++i) {
                    const int u = comp_nodes[i];
                    if (color[u] != bad_color) continue;
                    const int cell = sp.dyn_node_to_cell[u];
                    const ApplyResult er = st.eliminate(cell, bit);
                    if (er == ApplyResult::Contradiction) {
                        s.elapsed_ns += get_current_time_ns() - t0;
                        return er;
                    }
                    any_progress = any_progress || (er == ApplyResult::Progress);
                }
            }

            // Additional wrap signal: weak edge between same color nodes.
            bool weak_same_color[2] = {false, false};
            for (int i = 0; i < comp_size; ++i) {
                const int u = comp_nodes[i];
                const int wu0 = sp.dyn_weak_offsets[u];
                const int wu1 = sp.dyn_weak_offsets[u + 1];
                for (int p = wu0; p < wu1; ++p) {
                    const int v = sp.dyn_weak_adj[p];
                    if (!comp_mark[v] || u >= v) continue;
                    if (gx_is_strong_neighbor(sp, u, v)) continue; // strong already handled
                    if (color[u] == color[v]) {
                        weak_same_color[color[u]] = true;
                    }
                }
            }
            for (int bad_color = 0; bad_color <= 1; ++bad_color) {
                if (!weak_same_color[bad_color]) continue;
                for (int i = 0; i < comp_size; ++i) {
                    const int u = comp_nodes[i];
                    if (color[u] != bad_color) continue;
                    const int cell = sp.dyn_node_to_cell[u];
                    const ApplyResult er = st.eliminate(cell, bit);
                    if (er == ApplyResult::Contradiction) {
                        s.elapsed_ns += get_current_time_ns() - t0;
                        return er;
                    }
                    any_progress = any_progress || (er == ApplyResult::Progress);
                }
            }

            // Trap-style elimination: external node seeing both colors.
            for (int i = 0; i < sp.dyn_digit_cell_count; ++i) {
                const int t_cell = sp.dyn_digit_cells[i];
                const int t_node = sp.dyn_cell_to_node[t_cell];
                if (t_node >= 0 && comp_mark[t_node]) continue;

                bool sees0 = false;
                bool sees1 = false;
                for (int k = 0; k < comp_size; ++k) {
                    const int u = comp_nodes[k];
                    const int u_cell = sp.dyn_node_to_cell[u];
                    if (!st.is_peer(t_cell, u_cell)) continue;
                    if (color[u] == 0) sees0 = true;
                    else sees1 = true;
                    if (sees0 && sees1) break;
                }
                if (!(sees0 && sees1)) continue;

                const ApplyResult er = st.eliminate(t_cell, bit);
                if (er == ApplyResult::Contradiction) {
                    s.elapsed_ns += get_current_time_ns() - t0;
                    return er;
                }
                any_progress = any_progress || (er == ApplyResult::Progress);
            }
        }
    }

    if (any_progress) {
        ++s.hit_count;
        r.used_grouped_x_cycle = true;
        s.elapsed_ns += get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare




==============================================================================
PLIK: Sources\logic\p7_nightmare\kraken_fish.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: kraken_fish.h (Level 7 - Nightmare)
// Description: Kraken Fish as a combination of finned fish body detection
// and deep alternating tentacle chains (zero-allocation).
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"
#include "../p6_diabolical/finned_jelly_sword.h"
#include "aic_grouped_aic.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline ApplyResult apply_kraken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = get_current_time_ns();
    ++s.use_count;

    // Kraken patterns become useful in late game where fish body + tentacles
    // are constrained enough to produce deterministic eliminations.
    if (st.board->empty_cells > (st.topo->nn - st.topo->n / 2)) {
        s.elapsed_ns += get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    // Step 1: fish body
    StrategyStats tmp{};
    ApplyResult ar = p6_diabolical::apply_finned_swordfish_jellyfish(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_kraken_fish = true;
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }

    // Step 2: deep tentacles
    bool used = false;
    const int depth_cap = std::clamp(14 + (st.board->empty_cells / std::max(1, st.topo->n)), 16, 26);
    ar = alternating_chain_core(st, depth_cap, false, used);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress && used) {
        ++s.hit_count;
        r.used_kraken_fish = true;
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }

    s.elapsed_ns += get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\medusa_3d.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: medusa_3d.h (Level 7 - Nightmare)
// Description: 3D Medusa-oriented chain coloring pass focused on boards with
// rich bivalue structure (zero-allocation).
// ============================================================================

#pragma once

#include <algorithm>
#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"
#include "aic_grouped_aic.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline ApplyResult apply_medusa_3d(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = get_current_time_ns();
    ++s.use_count;

    const int nn = st.topo->nn;
    const int n = st.topo->n;

    int bivalue_count = 0;
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[idx] != 0) continue;
        if (std::popcount(st.cands[idx]) == 2) ++bivalue_count;
    }
    if (bivalue_count < 3) {
        s.elapsed_ns += get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    const int depth_cap = std::clamp(8 + (bivalue_count / std::max(1, n / 2)), 10, 18);
    bool used = false;
    const ApplyResult ar = alternating_chain_core(st, depth_cap, false, used);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress && used) {
        ++s.hit_count;
        r.used_medusa_3d = true;
        s.elapsed_ns += get_current_time_ns() - t0;
        return ar;
    }

    s.elapsed_ns += get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\squirmbag.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Moduł: squirmbag.h (Poziom 7 - Nightmare)
// Opis: Implementacja strategii Squirmbag (Starfish). Jest to "ryba" rzędu 5x5.
//       Bardzo obciążająca matematycznie kombinatoryka, oparta o rygorystyczne 
//       bitboardowanie i sprzężone skanowanie (Zero-Allocation).
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

namespace sudoku_hpc::logic::p7_nightmare {

inline ApplyResult apply_squirmbag(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;
    const int n = st.topo->n;
    
    // Optymalizacja wczesnego wyjścia:
    // Starfish na planszach poniżej 5x5 matematycznie nie ma racji bytu
    if (n < 5) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    auto& sp = shared::exact_pattern_scratchpad();

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        std::fill_n(sp.fish_row_masks, n, 0ULL);
        std::fill_n(sp.fish_col_masks, n, 0ULL);
        
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            
            const int rr = st.topo->cell_row[idx];
            const int cc = st.topo->cell_col[idx];
            sp.fish_row_masks[rr] |= (1ULL << cc);
            sp.fish_col_masks[cc] |= (1ULL << rr);
        }

        int row_count = 0;
        int col_count = 0;
        
        // Zbieramy użyteczne linie (takie gdzie ryba w ogóle ma sens)
        for (int rr = 0; rr < n; ++rr) {
            const int cnt = std::popcount(sp.fish_row_masks[rr]);
            if (cnt >= 2 && cnt <= 5) sp.active_rows[row_count++] = rr;
        }
        for (int cc = 0; cc < n; ++cc) {
            const int cnt = std::popcount(sp.fish_col_masks[cc]);
            if (cnt >= 2 && cnt <= 5) sp.active_cols[col_count++] = cc;
        }

        // ====================================================================
        // Faza 1: Szukanie po rzędach (Row-based Squirmbag / Starfish)
        // ====================================================================
        for (int i = 0; i + 4 < row_count; ++i) {
            const int r1 = sp.active_rows[i];
            const uint64_t u1 = sp.fish_row_masks[r1];
            
            for (int j = i + 1; j + 3 < row_count; ++j) {
                const int r2 = sp.active_rows[j];
                const uint64_t u2 = u1 | sp.fish_row_masks[r2];
                if (std::popcount(u2) > 5) continue;
                
                for (int k = j + 1; k + 2 < row_count; ++k) {
                    const int r3 = sp.active_rows[k];
                    const uint64_t u3 = u2 | sp.fish_row_masks[r3];
                    if (std::popcount(u3) > 5) continue;
                    
                    for (int l = k + 1; l + 1 < row_count; ++l) {
                        const int r4 = sp.active_rows[l];
                        const uint64_t u4 = u3 | sp.fish_row_masks[r4];
                        if (std::popcount(u4) > 5) continue;
                        
                        for (int m = l + 1; m < row_count; ++m) {
                            const int r5 = sp.active_rows[m];
                            const uint64_t cols_union = u4 | sp.fish_row_masks[r5];
                            
                            // Musi idealnie nakładać się na maksymalnie 5 kolumn
                            if (std::popcount(cols_union) != 5) continue;
                            
                            // Uderzenie eliminujące po kolumnach
                            for (uint64_t w = cols_union; w != 0ULL; w &= (w - 1ULL)) {
                                const int cc = config::bit_ctz_u64(w);
                                for (int rr = 0; rr < n; ++rr) {
                                    if (rr == r1 || rr == r2 || rr == r3 || rr == r4 || rr == r5) continue;
                                    
                                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                    if (er == ApplyResult::Contradiction) { 
                                        s.elapsed_ns += st.now_ns() - t0; 
                                        return er; 
                                    }
                                    if (er == ApplyResult::Progress) {
                                        ++s.hit_count;
                                        r.used_squirmbag = true;
                                        s.elapsed_ns += st.now_ns() - t0;
                                        return ApplyResult::Progress;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // ====================================================================
        // Faza 2: Szukanie po kolumnach (Col-based Squirmbag / Starfish)
        // ====================================================================
        for (int i = 0; i + 4 < col_count; ++i) {
            const int c1 = sp.active_cols[i];
            const uint64_t u1 = sp.fish_col_masks[c1];
            
            for (int j = i + 1; j + 3 < col_count; ++j) {
                const int c2 = sp.active_cols[j];
                const uint64_t u2 = u1 | sp.fish_col_masks[c2];
                if (std::popcount(u2) > 5) continue;
                
                for (int k = j + 1; k + 2 < col_count; ++k) {
                    const int c3 = sp.active_cols[k];
                    const uint64_t u3 = u2 | sp.fish_col_masks[c3];
                    if (std::popcount(u3) > 5) continue;
                    
                    for (int l = k + 1; l + 1 < col_count; ++l) {
                        const int c4 = sp.active_cols[l];
                        const uint64_t u4 = u3 | sp.fish_col_masks[c4];
                        if (std::popcount(u4) > 5) continue;
                        
                        for (int m = l + 1; m < col_count; ++m) {
                            const int c5 = sp.active_cols[m];
                            const uint64_t rows_union = u4 | sp.fish_col_masks[c5];
                            
                            if (std::popcount(rows_union) != 5) continue;
                            
                            for (uint64_t w = rows_union; w != 0ULL; w &= (w - 1ULL)) {
                                const int rr = config::bit_ctz_u64(w);
                                for (int cc = 0; cc < n; ++cc) {
                                    if (cc == c1 || cc == c2 || cc == c3 || cc == c4 || cc == c5) continue;
                                    
                                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                    if (er == ApplyResult::Contradiction) { 
                                        s.elapsed_ns += st.now_ns() - t0; 
                                        return er; 
                                    }
                                    if (er == ApplyResult::Progress) {
                                        ++s.hit_count;
                                        r.used_squirmbag = true;
                                        s.elapsed_ns += st.now_ns() - t0;
                                        return ApplyResult::Progress;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p7_nightmare\sue_de_coq.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: sue_de_coq.h (Level 7 - Nightmare)
// Description: Full Sue de Coq implementation for row-box and col-box
// intersections. Zero-allocation, fixed-size local buffers only.
// ============================================================================

#pragma once

#include <algorithm>
#include <bit>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../logic_result.h"

namespace sudoku_hpc::logic::p7_nightmare {

template <class Fn>
inline void for_each_combo_up_to3(int count, int choose, const Fn& fn) {
    if (choose == 1) {
        for (int a = 0; a < count; ++a) {
            fn(a, -1, -1);
        }
        return;
    }
    if (choose == 2) {
        for (int a = 0; a < count; ++a) {
            for (int b = a + 1; b < count; ++b) {
                fn(a, b, -1);
            }
        }
        return;
    }
    if (choose == 3) {
        for (int a = 0; a < count; ++a) {
            for (int b = a + 1; b < count; ++b) {
                for (int c = b + 1; c < count; ++c) {
                    fn(a, b, c);
                }
            }
        }
    }
}

inline uint64_t pool_mask_from_selection(
    const CandidateState& st,
    const int* pool,
    int i1,
    int i2,
    int i3) {
    uint64_t m = 0ULL;
    if (i1 >= 0) m |= st.cands[pool[i1]];
    if (i2 >= 0) m |= st.cands[pool[i2]];
    if (i3 >= 0) m |= st.cands[pool[i3]];
    return m;
}

inline bool idx_equals_any_selected(int idx, const int* pool, int i1, int i2, int i3) {
    return (i1 >= 0 && idx == pool[i1]) || (i2 >= 0 && idx == pool[i2]) || (i3 >= 0 && idx == pool[i3]);
}

inline ApplyResult scan_row_box_intersections(CandidateState& st, bool& progress, StrategyStats& s, uint64_t t0) {
    const int n = st.topo->n;
    bool contradiction = false;

    for (int brg = 0; brg < st.topo->box_rows_count; ++brg) {
        for (int bcg = 0; bcg < st.topo->box_cols_count; ++bcg) {
            const int r0 = brg * st.topo->box_rows;
            const int c0 = bcg * st.topo->box_cols;

            for (int dr = 0; dr < st.topo->box_rows; ++dr) {
                const int intersect_row = r0 + dr;

                int a_cells[64]{};
                int a_cnt = 0;
                uint64_t ma = 0ULL;
                for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                    const int idx = intersect_row * n + (c0 + dc);
                    if (st.board->values[idx] == 0) {
                        a_cells[a_cnt++] = idx;
                        ma |= st.cands[idx];
                    }
                }
                if (a_cnt < 2) continue;

                int b_pool[64]{};
                int b_pool_cnt = 0;
                for (int c = 0; c < n; ++c) {
                    if (c >= c0 && c < c0 + st.topo->box_cols) continue;
                    const int idx = intersect_row * n + c;
                    if (st.board->values[idx] == 0) {
                        b_pool[b_pool_cnt++] = idx;
                    }
                }

                int c_pool[64]{};
                int c_pool_cnt = 0;
                for (int b_dr = 0; b_dr < st.topo->box_rows; ++b_dr) {
                    if (b_dr == dr) continue;
                    for (int b_dc = 0; b_dc < st.topo->box_cols; ++b_dc) {
                        const int idx = (r0 + b_dr) * n + (c0 + b_dc);
                        if (st.board->values[idx] == 0) {
                            c_pool[c_pool_cnt++] = idx;
                        }
                    }
                }

                const int b_limit = std::min(b_pool_cnt, 3);
                const int c_limit = std::min(c_pool_cnt, 3);
                if (b_limit <= 0 || c_limit <= 0) continue;

                for (int b_choose = 1; b_choose <= b_limit; ++b_choose) {
                    for (int c_choose = 1; c_choose <= c_limit; ++c_choose) {
                        const int target_cands = a_cnt + b_choose + c_choose;
                        if (std::popcount(ma) > target_cands) continue;

                        for_each_combo_up_to3(b_pool_cnt, b_choose, [&](int bi1, int bi2, int bi3) {
                            if (contradiction) return;
                            const uint64_t mb = pool_mask_from_selection(st, b_pool, bi1, bi2, bi3);
                            if ((mb & ~ma) != 0ULL) return;

                            for_each_combo_up_to3(c_pool_cnt, c_choose, [&](int ci1, int ci2, int ci3) {
                                if (contradiction) return;
                                const uint64_t mc = pool_mask_from_selection(st, c_pool, ci1, ci2, ci3);
                                if ((mc & ~ma) != 0ULL) return;

                                const uint64_t union_mask = ma | mb | mc;
                                if (std::popcount(union_mask) != target_cands) return;

                                if (mb != 0ULL) {
                                    for (int c = 0; c < n; ++c) {
                                        if (c >= c0 && c < c0 + st.topo->box_cols) continue;
                                        const int idx = intersect_row * n + c;
                                        if (st.board->values[idx] != 0) continue;
                                        if (idx_equals_any_selected(idx, b_pool, bi1, bi2, bi3)) continue;
                                        const ApplyResult er = st.eliminate(idx, mb);
                                        if (er == ApplyResult::Contradiction) {
                                            contradiction = true;
                                            return;
                                        }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }

                                if (mc != 0ULL) {
                                    for (int b_dr = 0; b_dr < st.topo->box_rows; ++b_dr) {
                                        if (b_dr == dr) continue;
                                        for (int b_dc = 0; b_dc < st.topo->box_cols; ++b_dc) {
                                            const int idx = (r0 + b_dr) * n + (c0 + b_dc);
                                            if (st.board->values[idx] != 0) continue;
                                            if (idx_equals_any_selected(idx, c_pool, ci1, ci2, ci3)) continue;
                                            const ApplyResult er = st.eliminate(idx, mc);
                                            if (er == ApplyResult::Contradiction) {
                                                contradiction = true;
                                                return;
                                            }
                                            progress = progress || (er == ApplyResult::Progress);
                                        }
                                    }
                                }
                            });
                        });
                        if (contradiction) return ApplyResult::Contradiction;
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult scan_col_box_intersections(CandidateState& st, bool& progress, StrategyStats& s, uint64_t t0) {
    const int n = st.topo->n;
    bool contradiction = false;

    for (int brg = 0; brg < st.topo->box_rows_count; ++brg) {
        for (int bcg = 0; bcg < st.topo->box_cols_count; ++bcg) {
            const int r0 = brg * st.topo->box_rows;
            const int c0 = bcg * st.topo->box_cols;

            for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                const int intersect_col = c0 + dc;

                int a_cells[64]{};
                int a_cnt = 0;
                uint64_t ma = 0ULL;
                for (int dr = 0; dr < st.topo->box_rows; ++dr) {
                    const int idx = (r0 + dr) * n + intersect_col;
                    if (st.board->values[idx] == 0) {
                        a_cells[a_cnt++] = idx;
                        ma |= st.cands[idx];
                    }
                }
                if (a_cnt < 2) continue;

                int b_pool[64]{};
                int b_pool_cnt = 0;
                for (int r = 0; r < n; ++r) {
                    if (r >= r0 && r < r0 + st.topo->box_rows) continue;
                    const int idx = r * n + intersect_col;
                    if (st.board->values[idx] == 0) {
                        b_pool[b_pool_cnt++] = idx;
                    }
                }

                int c_pool[64]{};
                int c_pool_cnt = 0;
                for (int b_dr = 0; b_dr < st.topo->box_rows; ++b_dr) {
                    for (int b_dc = 0; b_dc < st.topo->box_cols; ++b_dc) {
                        if (b_dc == dc) continue;
                        const int idx = (r0 + b_dr) * n + (c0 + b_dc);
                        if (st.board->values[idx] == 0) {
                            c_pool[c_pool_cnt++] = idx;
                        }
                    }
                }

                const int b_limit = std::min(b_pool_cnt, 3);
                const int c_limit = std::min(c_pool_cnt, 3);
                if (b_limit <= 0 || c_limit <= 0) continue;

                for (int b_choose = 1; b_choose <= b_limit; ++b_choose) {
                    for (int c_choose = 1; c_choose <= c_limit; ++c_choose) {
                        const int target_cands = a_cnt + b_choose + c_choose;
                        if (std::popcount(ma) > target_cands) continue;

                        for_each_combo_up_to3(b_pool_cnt, b_choose, [&](int bi1, int bi2, int bi3) {
                            if (contradiction) return;
                            const uint64_t mb = pool_mask_from_selection(st, b_pool, bi1, bi2, bi3);
                            if ((mb & ~ma) != 0ULL) return;

                            for_each_combo_up_to3(c_pool_cnt, c_choose, [&](int ci1, int ci2, int ci3) {
                                if (contradiction) return;
                                const uint64_t mc = pool_mask_from_selection(st, c_pool, ci1, ci2, ci3);
                                if ((mc & ~ma) != 0ULL) return;

                                const uint64_t union_mask = ma | mb | mc;
                                if (std::popcount(union_mask) != target_cands) return;

                                if (mb != 0ULL) {
                                    for (int r = 0; r < n; ++r) {
                                        if (r >= r0 && r < r0 + st.topo->box_rows) continue;
                                        const int idx = r * n + intersect_col;
                                        if (st.board->values[idx] != 0) continue;
                                        if (idx_equals_any_selected(idx, b_pool, bi1, bi2, bi3)) continue;
                                        const ApplyResult er = st.eliminate(idx, mb);
                                        if (er == ApplyResult::Contradiction) {
                                            contradiction = true;
                                            return;
                                        }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }

                                if (mc != 0ULL) {
                                    for (int b_dr = 0; b_dr < st.topo->box_rows; ++b_dr) {
                                        for (int b_dc = 0; b_dc < st.topo->box_cols; ++b_dc) {
                                            if (b_dc == dc) continue;
                                            const int idx = (r0 + b_dr) * n + (c0 + b_dc);
                                            if (st.board->values[idx] != 0) continue;
                                            if (idx_equals_any_selected(idx, c_pool, ci1, ci2, ci3)) continue;
                                            const ApplyResult er = st.eliminate(idx, mc);
                                            if (er == ApplyResult::Contradiction) {
                                                contradiction = true;
                                                return;
                                            }
                                            progress = progress || (er == ApplyResult::Progress);
                                        }
                                    }
                                }
                            });
                        });
                        if (contradiction) return ApplyResult::Contradiction;
                    }
                }
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult apply_sue_de_coq(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = st.now_ns();
    ++s.use_count;

    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    bool progress = false;
    {
        const ApplyResult rr = scan_row_box_intersections(st, progress, s, t0);
        if (rr == ApplyResult::Contradiction) {
            s.elapsed_ns += st.now_ns() - t0;
            return rr;
        }
        const ApplyResult rc = scan_col_box_intersections(st, progress, s, t0);
        if (rc == ApplyResult::Contradiction) {
            s.elapsed_ns += st.now_ns() - t0;
            return rc;
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_sue_de_coq = true;
        s.elapsed_ns += st.now_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += st.now_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p7_nightmare



==============================================================================
PLIK: Sources\logic\p8_theoretical\exocet_family.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: exocet_family.h (Level 8 - Theoretical)
// Description: Exocet and Senior Exocet with direct structural probing
// on detected base/target layouts, zero-allocation.
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"
#include "../p7_nightmare/aic_grouped_aic.h"

namespace sudoku_hpc::logic::p8_theoretical {

inline bool exocet_propagate_singles(CandidateState& st, int max_steps) {
    const int nn = st.topo->nn;
    for (int iter = 0; iter < max_steps; ++iter) {
        bool changed = false;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            const uint64_t m = st.cands[idx];
            if (m == 0ULL) return false;
            const int sd = config::single_digit_from_mask(m);
            if (sd == 0) continue;
            if (!st.place(idx, sd)) return false;
            changed = true;
        }
        if (!changed) break;
    }
    return true;
}

inline bool exocet_probe_candidate_contradiction(
    CandidateState& st,
    int idx,
    int digit,
    int max_steps,
    shared::ExactPatternScratchpad& sp) {
    const int nn = st.topo->nn;
    std::copy_n(st.cands, nn, sp.dyn_cands_backup);
    std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
    sp.dyn_empty_backup = st.board->empty_cells;

    bool contradiction = false;
    if (!st.place(idx, digit)) {
        contradiction = true;
    } else if (!exocet_propagate_singles(st, max_steps)) {
        contradiction = true;
    }

    std::copy_n(sp.dyn_cands_backup, nn, st.cands);
    std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
    st.board->empty_cells = sp.dyn_empty_backup;
    return contradiction;
}

inline ApplyResult exocet_structural_probe(
    CandidateState& st,
    int pattern_cap,
    int max_steps,
    bool senior_mode) {
    if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
        return ApplyResult::NoProgress;
    }

    const int n = st.topo->n;
    auto& sp = shared::exact_pattern_scratchpad();
    int patterns = 0;
    int box_cells[64]{};

    for (int b = 0; b < n; ++b) {
        const int h = 2 * n + b;
        const int p0 = st.topo->house_offsets[h];
        const int p1 = st.topo->house_offsets[h + 1];
        int bc = 0;

        for (int p = p0; p < p1; ++p) {
            const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
            if (st.board->values[idx] != 0) continue;
            const int pc = std::popcount(st.cands[idx]);
            if (pc < 2 || pc > 6) continue;
            if (bc < 64) box_cells[bc++] = idx;
        }
        if (bc < 2) continue;

        for (int i = 0; i < bc; ++i) {
            const int base1 = box_cells[i];
            const int r1 = st.topo->cell_row[base1];
            const int c1 = st.topo->cell_col[base1];
            const uint64_t m1 = st.cands[base1];

            for (int j = i + 1; j < bc; ++j) {
                if (patterns >= pattern_cap) return ApplyResult::NoProgress;
                const int base2 = box_cells[j];
                const int r2 = st.topo->cell_row[base2];
                const int c2 = st.topo->cell_col[base2];
                if (r1 == r2 || c1 == c2) continue;

                const uint64_t m2 = st.cands[base2];
                const uint64_t core = m1 & m2;
                if (std::popcount(core) < 2) continue;

                const int t1 = r1 * n + c2;
                const int t2 = r2 * n + c1;
                if (st.board->values[t1] != 0 || st.board->values[t2] != 0) continue;

                const uint64_t mt1 = st.cands[t1];
                const uint64_t mt2 = st.cands[t2];
                if ((mt1 & core) == 0ULL || (mt2 & core) == 0ULL) continue;

                const int extra_pc = std::popcount((mt1 | mt2) & ~core);
                if (extra_pc > (senior_mode ? 6 : 4)) continue;

                ++patterns;
                const int scope[4] = {base1, base2, t1, t2};
                for (int s = 0; s < 4; ++s) {
                    const int idx = scope[s];
                    uint64_t probe = st.cands[idx];
                    const int per_cell_budget = senior_mode ? 3 : 2;
                    int tested = 0;

                    while (probe != 0ULL && tested < per_cell_budget) {
                        const uint64_t bit = config::bit_lsb(probe);
                        probe = config::bit_clear_lsb_u64(probe);
                        ++tested;
                        const int d = config::bit_ctz_u64(bit) + 1;
                        if (!exocet_probe_candidate_contradiction(st, idx, d, max_steps, sp)) continue;

                        const ApplyResult er = st.eliminate(idx, bit);
                        if (er == ApplyResult::Contradiction) return er;
                        if (er == ApplyResult::Progress) return er;
                    }
                }
            }
        }
    }
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_exocet_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 4 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    const int pattern_cap = std::clamp(4 + n / 3, 6, 16);
    const int max_steps = std::clamp(6 + n / 4, 8, 14);

    const ApplyResult ar = exocet_structural_probe(st, pattern_cap, max_steps, false);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 5 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    StrategyStats tmp{};
    ApplyResult ar = apply_exocet_exact(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    bool used = false;
    const int depth_cap = std::clamp(8 + st.board->empty_cells / std::max(1, n), 10, 16);
    ar = p7_nightmare::bounded_implication_core(st, tmp, r, depth_cap, used);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    ar = p7_nightmare::apply_grouped_aic(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

inline ApplyResult apply_senior_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 6 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    StrategyStats tmp{};
    const int pattern_cap = std::clamp(6 + n / 2, 8, 22);
    const int max_steps = std::clamp(10 + n / 3, 12, 20);

    ApplyResult ar = exocet_structural_probe(st, pattern_cap, max_steps, true);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_senior_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    bool used = false;
    const int depth_cap = std::clamp(12 + st.board->empty_cells / std::max(1, n), 14, 24);
    ar = p7_nightmare::bounded_implication_core(st, tmp, r, depth_cap, used);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_senior_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    ar = apply_exocet(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_senior_exocet = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p8_theoretical



==============================================================================
PLIK: Sources\logic\p8_theoretical\forcing_chains_dynamic.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: forcing_chains_dynamic.h (Poziom 8 - Theoretical)
// Opis: Algorytmy Forcing Chains oraz Dynamic Forcing Chains.
//       Eksploracja zaĹ‚oĹĽeĹ„ z wymuszaniem i zagnieĹĽdĹĽonym Ĺ›rodowiskiem symulacji.
//       RozwiÄ…zanie Zero-Allocation operujÄ…ce na tablicach "zrzutĂłw" 
//       znajdujÄ…cych siÄ™ we wspĂłĹ‚dzielonym Scratchpadzie (do gĹ‚Ä™bokoĹ›ci N).
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

// DoĹ‚Ä…czamy komponent wykorzystywany do silnej weryfikacji powiÄ…zaĹ„ w DFC
#include "../p7_nightmare/aic_grouped_aic.h"

namespace sudoku_hpc::logic::p8_theoretical {

// ============================================================================
// Wymuszenia Dynamiczne (Dynamic Forcing Assumption)
// NajciÄ™ĹĽsza metoda (P8). Dokonuje "Nishio Probing" na wÄ™zĹ‚ach bivalue/trivalue.
// Tworzy gaĹ‚Ä™zie i weryfikuje ich stabilnoĹ›Ä‡ (bez peĹ‚nego drzewa DLX).
// ============================================================================
inline ApplyResult apply_dynamic_forcing_assumption(CandidateState& st, bool& used_flag) {
    const int nn = st.topo->nn;
    const int n = st.topo->n;
    auto& sp = shared::exact_pattern_scratchpad();

    // Ograniczamy budĹĽet hipotez: najpierw bivalue, potem trivalue.
    const int pivot_budget = std::clamp(8 + (n / 2), 8, 40);
    const int max_steps = std::clamp(6 + (n / 3), 8, 20);
    int tested_pivots = 0;

    for (int pass_pc = 2; pass_pc <= 3; ++pass_pc) {
        for (int pivot = 0; pivot < nn; ++pivot) {
            if (tested_pivots >= pivot_budget) return ApplyResult::NoProgress;
            if (st.board->values[pivot] != 0) continue;
            const uint64_t mask = st.cands[pivot];
            const int pc = std::popcount(mask);
            if (pc != pass_pc) continue;
            ++tested_pivots;

            const int digit_budget = (pc == 2) ? 2 : 2;
            int tested_digits = 0;

            for (uint64_t w = mask; w != 0ULL; w &= (w - 1ULL)) {
                if (tested_digits >= digit_budget) break;
                ++tested_digits;

                const uint64_t test_bit = config::bit_lsb(w);
                const int test_digit = config::bit_ctz_u64(test_bit) + 1;

                std::copy_n(st.cands, nn, sp.dyn_cands_backup);
                std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
                sp.dyn_empty_backup = st.board->empty_cells;

                bool contradiction = false;
                if (!st.place(pivot, test_digit)) {
                    contradiction = true;
                } else {
                    int iters = 0;
                    bool changed = true;
                    while (changed && iters < max_steps) {
                        changed = false;
                        ++iters;
                        for (int idx = 0; idx < nn; ++idx) {
                            if (st.board->values[idx] != 0) continue;
                            const uint64_t m = st.cands[idx];
                            if (m == 0ULL) {
                                contradiction = true;
                                break;
                            }
                            const int sd = config::single_digit_from_mask(m);
                            if (sd == 0) continue;
                            if (!st.place(idx, sd)) {
                                contradiction = true;
                                break;
                            }
                            changed = true;
                        }
                        if (contradiction) break;
                    }
                }

                std::copy_n(sp.dyn_cands_backup, nn, st.cands);
                std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
                st.board->empty_cells = sp.dyn_empty_backup;

                if (!contradiction) continue;

                const ApplyResult er = st.eliminate(pivot, test_bit);
                if (er == ApplyResult::Contradiction) return er;
                if (er == ApplyResult::Progress) {
                    used_flag = true;
                    return ApplyResult::Progress;
                }
            }
        }
    }
    return ApplyResult::NoProgress;
}

// ============================================================================
// GĹĂ“WNY INTERFEJS Forcing Chains
// ============================================================================
inline ApplyResult apply_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    // Heurystyka odcinajÄ…ca (Tylko w pĂłĹşnych fazach ma to sens)
    if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    bool used_dynamic = false;

    // Faza 1: Ograniczone hipotezy wymuszeĹ„ (Nishio-style).
    const ApplyResult ar_assumption = apply_dynamic_forcing_assumption(st, used_dynamic);
    
    if (ar_assumption == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar_assumption; 
    }
    if (ar_assumption == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_forcing_chains = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // Faza 2: GĹ‚Ä™bokie zejĹ›cia AIC na grafie implikacji.
    const int depth_cap = std::clamp(14 + (st.board->empty_cells / std::max(1, st.topo->n)), 16, 28);
    
    const ApplyResult dyn = p7_nightmare::bounded_implication_core(st, s, r, depth_cap, used_dynamic);
    if (dyn == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return dyn; 
    }
    if (dyn == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_forcing_chains = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

// ============================================================================
// DYNAMIC FORCING CHAINS
// Ewolucja zagnieĹĽdĹĽenia - wywoĹ‚anie jeszcze wiÄ™kszej iloĹ›ci wirtualnych BFS'Ăłw.
// ============================================================================
inline ApplyResult apply_dynamic_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    // UĹĽywamy tego samego jÄ…dra co w klasycznym Forcing Chains, poniewaĹĽ
    // bounded_implication_core i dynamic_forcing_assumption operujÄ… na
    // grafach budowanych dynamicznie per-cyfra.
    StrategyStats tmp{};
    const ApplyResult dyn_exact = apply_forcing_chains(st, tmp, r);
    
    if (dyn_exact == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return dyn_exact; 
    }
    if (dyn_exact == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_dynamic_forcing_chains = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p8_theoretical



==============================================================================
PLIK: Sources\logic\p8_theoretical\msls.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// Module: msls.h (Level 8 - Theoretical)
// Description: MSLS (Multi-Sector Locked Sets) with direct sector-cluster
// probing and bounded composite fallback, zero-allocation.
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

#include "../p7_nightmare/aic_grouped_aic.h"
#include "../p7_nightmare/grouped_x_cycle.h"
#include "../p7_nightmare/als_xy_wing_chain.h"
#include "../p7_nightmare/kraken_fish.h"

namespace sudoku_hpc::logic::p8_theoretical {

inline bool msls_propagate_singles(CandidateState& st, int max_steps) {
    const int nn = st.topo->nn;
    for (int step = 0; step < max_steps; ++step) {
        bool changed = false;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            const uint64_t m = st.cands[idx];
            if (m == 0ULL) return false;
            const int sd = config::single_digit_from_mask(m);
            if (sd == 0) continue;
            if (!st.place(idx, sd)) return false;
            changed = true;
        }
        if (!changed) break;
    }
    return true;
}

inline bool msls_probe_candidate_contradiction(
    CandidateState& st,
    int idx,
    int d,
    int max_steps,
    shared::ExactPatternScratchpad& sp) {
    const int nn = st.topo->nn;
    std::copy_n(st.cands, nn, sp.dyn_cands_backup);
    std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
    sp.dyn_empty_backup = st.board->empty_cells;

    bool contradiction = false;
    if (!st.place(idx, d)) {
        contradiction = true;
    } else if (!msls_propagate_singles(st, max_steps)) {
        contradiction = true;
    }

    std::copy_n(sp.dyn_cands_backup, nn, st.cands);
    std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
    st.board->empty_cells = sp.dyn_empty_backup;
    return contradiction;
}

inline int msls_relation_mask(const CandidateState& st, int a, int b) {
    int mask = 0;
    if (st.topo->cell_row[a] == st.topo->cell_row[b]) mask |= 1;
    if (st.topo->cell_col[a] == st.topo->cell_col[b]) mask |= 2;
    if (st.topo->cell_box[a] == st.topo->cell_box[b]) mask |= 4;
    return mask;
}

inline ApplyResult apply_msls_direct(CandidateState& st) {
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (n < 6 || n > 40) return ApplyResult::NoProgress;
    if (st.board->empty_cells > (nn - 6 * n)) return ApplyResult::NoProgress;

    auto& sp = shared::exact_pattern_scratchpad();
    int cand_cells[512]{};
    int cluster[64]{};
    int in_cluster[4096]{};

    const int anchor_cap = std::clamp(6 + n / 3, 8, 18);
    const int pattern_cap = std::clamp(8 + n / 2, 10, 28);
    const int probe_steps = std::clamp(6 + n / 4, 8, 14);
    int pattern_count = 0;
    int probe_budget = std::clamp(8 + n / 2, 10, 26);

    for (int d = 1; d <= n; ++d) {
        const uint64_t bit = (1ULL << (d - 1));
        int cc = 0;
        for (int idx = 0; idx < nn && cc < 512; ++idx) {
            if (st.board->values[idx] != 0) continue;
            if ((st.cands[idx] & bit) == 0ULL) continue;
            cand_cells[cc++] = idx;
        }
        if (cc < 8) continue;

        const int anchors = std::min(cc, anchor_cap);
        for (int ai = 0; ai < anchors; ++ai) {
            if (pattern_count >= pattern_cap || probe_budget <= 0) return ApplyResult::NoProgress;
            const int anchor = cand_cells[ai];
            const int ar = st.topo->cell_row[anchor];
            const int ac = st.topo->cell_col[anchor];
            const int ab = st.topo->cell_box[anchor];

            std::fill_n(in_cluster, nn, 0);
            int cl = 0;
            for (int i = 0; i < cc && cl < 64; ++i) {
                const int idx = cand_cells[i];
                if (st.topo->cell_row[idx] == ar ||
                    st.topo->cell_col[idx] == ac ||
                    st.topo->cell_box[idx] == ab) {
                    in_cluster[idx] = 1;
                    cluster[cl++] = idx;
                }
            }
            if (cl < 5 || cl > 16) continue;

            int row_seen[64]{}, col_seen[64]{}, box_seen[64]{};
            int ru = 0, cu = 0, bu = 0;
            for (int i = 0; i < cl; ++i) {
                const int idx = cluster[i];
                const int rr = st.topo->cell_row[idx];
                const int ccv = st.topo->cell_col[idx];
                const int bb = st.topo->cell_box[idx];
                if (!row_seen[rr]) {
                    row_seen[rr] = 1;
                    ++ru;
                }
                if (!col_seen[ccv]) {
                    col_seen[ccv] = 1;
                    ++cu;
                }
                if (!box_seen[bb]) {
                    box_seen[bb] = 1;
                    ++bu;
                }
            }
            if (ru < 2 || cu < 2 || bu < 2) continue;
            ++pattern_count;

            for (int ti = 0; ti < cc && probe_budget > 0; ++ti) {
                const int t = cand_cells[ti];
                if (in_cluster[t]) continue;

                int seen_cells = 0;
                int rel_mask = 0;
                for (int ci = 0; ci < cl; ++ci) {
                    const int cidx = cluster[ci];
                    if (!st.is_peer(t, cidx)) continue;
                    ++seen_cells;
                    rel_mask |= msls_relation_mask(st, t, cidx);
                    if (seen_cells >= 3 && std::popcount(static_cast<unsigned int>(rel_mask)) >= 2) break;
                }
                if (seen_cells < 2) continue;
                if (std::popcount(static_cast<unsigned int>(rel_mask)) < 2) continue;

                --probe_budget;
                if (!msls_probe_candidate_contradiction(st, t, d, probe_steps, sp)) continue;
                const ApplyResult er = st.eliminate(t, bit);
                if (er != ApplyResult::NoProgress) return er;
            }
        }
    }

    return ApplyResult::NoProgress;
}

inline ApplyResult apply_msls(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;

    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 5 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    StrategyStats tmp{};

    ApplyResult ar = apply_msls_direct(st);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_msls = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    const int depth_cap = std::clamp(8 + (st.board->empty_cells / std::max(1, n)), 10, 16);
    bool used_dynamic = false;
    ar = p7_nightmare::bounded_implication_core(st, tmp, r, depth_cap, used_dynamic);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_msls = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    ar = p7_nightmare::apply_grouped_x_cycle(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_msls = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    ar = p7_nightmare::apply_als_chain(st, tmp, r);
    if (ar == ApplyResult::Contradiction) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_msls = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ar;
    }

    // Kraken fallback only for very late boards.
    if (st.board->empty_cells <= (nn - 7 * n)) {
        ar = p7_nightmare::apply_kraken_fish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) {
            s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
            return ar;
        }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_msls = true;
            s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
            return ar;
        }
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p8_theoretical



==============================================================================
PLIK: Sources\logic\p8_theoretical\pattern_overlay.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: pattern_overlay.h (Poziom 8 - Theoretical)
// Opis: Algorytm Pattern Overlay Method (POM). Przeszukuje czÄ™Ĺ›ciowe, 
//       wolne od sprzecznoĹ›ci nakĹ‚adki dla pojedynczej cyfry i eliminuje 
//       kandydatĂłw, ktĂłrzy nigdy nie wejdÄ… w skĹ‚ad prawidĹ‚owego rozwiÄ…zania.
//       RozwiÄ…zanie Zero-Allocation operujÄ…ce na pĹ‚ytkim wirtualnym stosie.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

// DoĹ‚Ä…czamy wymagane moduły dla POM 
#include "msls.h"

namespace sudoku_hpc::logic::p8_theoretical {

inline bool pom_propagate_singles(CandidateState& st, int max_steps) {
    const int nn = st.topo->nn;
    for (int step = 0; step < max_steps; ++step) {
        bool changed = false;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            const uint64_t m = st.cands[idx];
            if (m == 0ULL) return false;
            const int sd = config::single_digit_from_mask(m);
            if (sd == 0) continue;
            if (!st.place(idx, sd)) return false;
            changed = true;
        }
        if (!changed) break;
    }
    return true;
}

inline bool pom_probe_candidate_contradiction(
    CandidateState& st,
    int idx,
    int d,
    int max_steps,
    shared::ExactPatternScratchpad& sp) {
    const int nn = st.topo->nn;
    std::copy_n(st.cands, nn, sp.dyn_cands_backup);
    std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
    sp.dyn_empty_backup = st.board->empty_cells;

    bool contradiction = false;
    if (!st.place(idx, d)) {
        contradiction = true;
    } else if (!pom_propagate_singles(st, max_steps)) {
        contradiction = true;
    }

    std::copy_n(sp.dyn_cands_backup, nn, st.cands);
    std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
    st.board->empty_cells = sp.dyn_empty_backup;
    return contradiction;
}

// ============================================================================
// WĹ‚aĹ›ciwy silnik sprawdzania nakĹ‚adek (Bounded Pattern Overlay Method)
// Operuje na pĹ‚ytkim drzewie DFS dla wybranej, najbardziej ograniczonej komĂłrki.
// ============================================================================
inline ApplyResult apply_pom_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    auto& sp = shared::exact_pattern_scratchpad();
    const int nn = st.topo->nn;
    const int n = st.topo->n;
    if (st.board->empty_cells > (nn - 6 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    const int pivot_budget = std::clamp(4 + n / 3, 6, 12);
    int pivots[64]{};
    int pivot_cnt = 0;
    for (int pc = 2; pc <= 4; ++pc) {
        for (int idx = 0; idx < nn; ++idx) {
            if (pivot_cnt >= pivot_budget) break;
            if (st.board->values[idx] != 0) continue;
            if (std::popcount(st.cands[idx]) != pc) continue;
            pivots[pivot_cnt++] = idx;
        }
        if (pivot_cnt >= pivot_budget) break;
    }
    if (pivot_cnt == 0) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    const int hyp_steps = std::clamp(6 + n / 4, 8, 12);
    const int probe_steps = std::clamp(6 + n / 3, 8, 14);
    for (int pi = 0; pi < pivot_cnt; ++pi) {
        const int pivot = pivots[pi];
        const uint64_t pm = st.cands[pivot];
        if (pm == 0ULL) continue;

        std::copy_n(st.cands, nn, sp.dyn_cands_backup);
        std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
        sp.dyn_empty_backup = st.board->empty_cells;

        uint64_t inter_cands[shared::ExactPatternScratchpad::MAX_NN]{};
        for (int i = 0; i < nn; ++i) inter_cands[i] = ~0ULL;
        uint64_t contradiction_mask = 0ULL;
        int valid_hyp = 0;

        int digit_budget = 0;
        for (uint64_t w = pm; w != 0ULL; w = config::bit_clear_lsb_u64(w)) {
            if (digit_budget >= 2) break;
            ++digit_budget;
            const uint64_t bit = config::bit_lsb(w);
            const int d = config::bit_ctz_u64(bit) + 1;

            std::copy_n(sp.dyn_cands_backup, nn, st.cands);
            std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
            st.board->empty_cells = sp.dyn_empty_backup;

            bool contradiction = false;
            if (!st.place(pivot, d)) {
                contradiction = true;
            } else if (!pom_propagate_singles(st, hyp_steps)) {
                contradiction = true;
            }

            if (contradiction) {
                contradiction_mask |= bit;
                continue;
            }

            ++valid_hyp;
            for (int i = 0; i < nn; ++i) {
                uint64_t cur = st.cands[i];
                if (st.board->values[i] != 0) {
                    cur = (1ULL << (st.board->values[i] - 1));
                }
                inter_cands[i] &= cur;
            }
        }

        std::copy_n(sp.dyn_cands_backup, nn, st.cands);
        std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
        st.board->empty_cells = sp.dyn_empty_backup;

        if (contradiction_mask != 0ULL) {
            const ApplyResult er = st.eliminate(pivot, contradiction_mask);
            if (er == ApplyResult::Contradiction) {
                s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                return er;
            }
            if (er == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_pattern_overlay_method = true;
                s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                return ApplyResult::Progress;
            }
        }

        // Intersection-driven candidates are additionally validated by
        // contradiction probing before elimination.
        if (valid_hyp >= 2) {
            int probe_budget = std::clamp(4 + n / 3, 6, 12);
            for (int idx = 0; idx < nn && probe_budget > 0; ++idx) {
                if (st.board->values[idx] != 0) continue;
                const uint64_t base = st.cands[idx];
                const uint64_t keep = inter_cands[idx] & base;
                if (keep == 0ULL) continue;
                uint64_t rm = base & ~keep;
                while (rm != 0ULL && probe_budget > 0) {
                    const uint64_t bit = config::bit_lsb(rm);
                    rm = config::bit_clear_lsb_u64(rm);
                    --probe_budget;
                    const int d = config::bit_ctz_u64(bit) + 1;
                    if (!pom_probe_candidate_contradiction(st, idx, d, probe_steps, sp)) continue;
                    const ApplyResult er = st.eliminate(idx, bit);
                    if (er == ApplyResult::Contradiction) {
                        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                        return er;
                    }
                    if (er == ApplyResult::Progress) {
                        ++s.hit_count;
                        r.used_pattern_overlay_method = true;
                        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                        return ApplyResult::Progress;
                    }
                }
            }
        }
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

// ============================================================================
// GĹ‚Ăłwny kontroler Ĺ‚Ä…czÄ…cy nakĹ‚adanie masek z kompozycjÄ… MSLS i Ryb (P8)
// ============================================================================
inline ApplyResult apply_pattern_overlay_method(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 7 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }

    StrategyStats tmp{};
    
    // Krok 1: Aplikacja czystego POM (szybki overlay)
    const ApplyResult exact = apply_pom_exact(st, tmp, r);
    if (exact == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return exact; 
    }
    if (exact == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_pattern_overlay_method = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }
    
    // Krok 2: Adaptacyjne dynamiczne Ĺ›ledzenie zatorĂłw za pomocÄ… Ĺ‚aĹ„cuchĂłw (GĹ‚Ä™bokoĹ›Ä‡ P8)
    const int depth_cap = std::clamp(8 + (st.board->empty_cells / std::max(1, st.topo->n)), 10, 14);
    bool used_dynamic = false;

    ApplyResult dyn = p7_nightmare::bounded_implication_core(st, s, r, depth_cap, used_dynamic);
    if (dyn == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return dyn; 
    }
    if (dyn == ApplyResult::Progress && used_dynamic) {
        ++s.hit_count;
        r.used_pattern_overlay_method = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // Krok 3: Kaskada z P8 - MSLS generuje wielkie nakĹ‚adki matryc
    ApplyResult ar = apply_msls(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar; 
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_pattern_overlay_method = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p8_theoretical




==============================================================================
PLIK: Sources\logic\p8_theoretical\sk_loop.h
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: sk_loop.h (Poziom 8 - Theoretical)
// Opis: Algorytm rozwiÄ…zujÄ…cy cykle oparte na SK-Loop (Stephen Kurz Loop).
//       Sprawdza zamkniÄ™te prostokÄ…ty z dedykowanym "Core" i "Extra" masek,
//       wspierajÄ…c siÄ™ kompozycjami gĹ‚Ä™bokich pÄ™tli w razie braku dokĹ‚adnego
//       dopasowania klasycznego wzorca. Zoptymalizowany dla Zero-Allocation.
// ============================================================================

#pragma once

#include <cstdint>
#include <algorithm>
#include <array>

#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"
#include "../logic_result.h"
#include "../shared/exact_pattern_scratchpad.h"

// ModuĹ‚y pomocnicze (kompozytu do SK Loop)
#include "../p7_nightmare/continuous_nice_loop.h"
#include "../p7_nightmare/grouped_x_cycle.h"
#include "../p7_nightmare/aic_grouped_aic.h"

namespace sudoku_hpc::logic::p8_theoretical {

inline bool sk_loop_propagate_singles(CandidateState& st, int max_steps) {
    const int nn = st.topo->nn;
    for (int step = 0; step < max_steps; ++step) {
        bool changed = false;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            const uint64_t m = st.cands[idx];
            if (m == 0ULL) return false;
            const int sd = config::single_digit_from_mask(m);
            if (sd == 0) continue;
            if (!st.place(idx, sd)) return false;
            changed = true;
        }
        if (!changed) break;
    }
    return true;
}

inline bool sk_loop_probe_contradiction(
    CandidateState& st,
    int idx,
    int d,
    int max_steps,
    shared::ExactPatternScratchpad& sp) {
    const int nn = st.topo->nn;
    std::copy_n(st.cands, nn, sp.dyn_cands_backup);
    std::copy_n(st.board->values.data(), nn, sp.dyn_values_backup);
    sp.dyn_empty_backup = st.board->empty_cells;

    bool contradiction = false;
    if (!st.place(idx, d)) {
        contradiction = true;
    } else if (!sk_loop_propagate_singles(st, max_steps)) {
        contradiction = true;
    }

    std::copy_n(sp.dyn_cands_backup, nn, st.cands);
    std::copy_n(sp.dyn_values_backup, nn, st.board->values.data());
    st.board->empty_cells = sp.dyn_empty_backup;
    return contradiction;
}

// ============================================================================
// SK LOOP EXACT
// Klasyczne podejĹ›cie "twardej geometrii": prostokÄ…t, w ktĂłrym 4 komĂłrki
// dzielÄ… 2 cyfry rdzeniowe ("Core"), oraz kaĹĽda/niektĂłre majÄ… nadmiar,
// co pozwala na skrzyĹĽowanÄ… eliminacjÄ™ cyfr wyjĹ›ciowych z reszty rzÄ™du/kolumny.
// ============================================================================
inline ApplyResult apply_sk_loop_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 6 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }
    const int pattern_cap = std::clamp(2 + n / 3, 4, 10);
    const int probe_steps = std::clamp(6 + n / 4, 8, 12);
    int patterns = 0;
    bool progress = false;
    auto& sp = shared::exact_pattern_scratchpad();

    // Przeszukiwanie wierzchoĹ‚kĂłw dla SK Loop
    for (int r1 = 0; r1 < n; ++r1) {
        for (int r2 = r1 + 1; r2 < n; ++r2) {
            for (int c1 = 0; c1 < n; ++c1) {
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    if (patterns >= pattern_cap) {
                        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                        return ApplyResult::NoProgress;
                    }
                    const int a = r1 * n + c1;
                    const int b = r1 * n + c2;
                    const int c = r2 * n + c1;
                    const int d = r2 * n + c2;
                    
                    // Wszystkie punkty cyklu muszÄ… byÄ‡ nieustalone
                    if (st.board->values[a] != 0 ||
                        st.board->values[b] != 0 ||
                        st.board->values[c] != 0 ||
                        st.board->values[d] != 0) {
                        continue;
                    }

                    const uint64_t ma = st.cands[a];
                    const uint64_t mb = st.cands[b];
                    const uint64_t mc = st.cands[c];
                    const uint64_t md = st.cands[d];
                    
                    // Szukamy "Rdzenia" (Core) â€“ 2 cyfr dzielonych przez wszystkie wierzchoĹ‚ki
                    const uint64_t core = ma & mb & mc & md;
                    if (std::popcount(core) != 2) continue;

                    // Pobieramy "Nadmiary" (Extra candidates) wykraczajÄ…ce poza cykl gĹ‚Ăłwny
                    const uint64_t exa = ma & ~core;
                    const uint64_t exb = mb & ~core;
                    const uint64_t exc = mc & ~core;
                    const uint64_t exd = md & ~core;
                    
                    const uint64_t extra_union = exa | exb | exc | exd;
                    if (extra_union == 0ULL) continue; // W peĹ‚ni czysty DP (Deadly Pattern), obsĹ‚ugiwane w P6 UR
                    ++patterns;

                    // Sprawdzamy kaĹĽdÄ… wyodrÄ™bnionÄ… cyfrÄ™ "Z" i usuwamy z przeciÄ™Ä‡ wzroku
                    uint64_t wx = extra_union;
                    while (wx != 0ULL) {
                        const uint64_t x = config::bit_lsb(wx);
                        wx = config::bit_clear_lsb_u64(wx);
                        
                        int holders[4]{};
                        int hc = 0;
                        
                        if ((exa & x) != 0ULL) holders[hc++] = a;
                        if ((exb & x) != 0ULL) holders[hc++] = b;
                        if ((exc & x) != 0ULL) holders[hc++] = c;
                        if ((exd & x) != 0ULL) holders[hc++] = d;
                        
                        // Zjawisko musi wystÄ…piÄ‡ w minimum 2 komĂłrkach cyklu, by mĂłc celowaÄ‡ "poza"
                        if (hc < 2) continue;
                        
                        for (int t = 0; t < st.topo->nn; ++t) {
                            if (t == a || t == b || t == c || t == d) continue;
                            if (st.board->values[t] != 0) continue;
                            
                            // Target "T" musi widzieÄ‡ WSZYSTKIE wierzchoĹ‚ki cyklu zawierajÄ…ce "X"
                            bool sees_all = true;
                            for (int i = 0; i < hc; ++i) {
                                if (!st.is_peer(t, holders[i])) {
                                    sees_all = false;
                                    break;
                                }
                            }
                            if (!sees_all) continue;
                            
                            const ApplyResult er = st.eliminate(t, x);
                            if (er == ApplyResult::Contradiction) { 
                                s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
                                return er; 
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }

                    // Local probing for corner extras in SK layout.
                    const int corners[4] = {a, b, c, d};
                    const uint64_t extras[4] = {exa, exb, exc, exd};
                    for (int ci = 0; ci < 4; ++ci) {
                        uint64_t probe = extras[ci];
                        int tested = 0;
                        while (probe != 0ULL && tested < 2) {
                            const uint64_t bit = config::bit_lsb(probe);
                            probe = config::bit_clear_lsb_u64(probe);
                            ++tested;
                            const int digit = config::bit_ctz_u64(bit) + 1;
                            if (!sk_loop_probe_contradiction(st, corners[ci], digit, probe_steps, sp)) continue;
                            const ApplyResult er = st.eliminate(corners[ci], bit);
                            if (er == ApplyResult::Contradiction) {
                                s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
                                return er;
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }
    }

    if (progress) {
        ++s.hit_count;
        r.used_sk_loop = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }
    
    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

// ============================================================================
// SK LOOP (PeĹ‚ny silnik logiczny)
// Integruje Exact z mocÄ… gĹ‚Ä™bokiego zastÄ™pstwa silnikiem P7
// ============================================================================
inline ApplyResult apply_sk_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
    const uint64_t t0 = p7_nightmare::get_current_time_ns();
    ++s.use_count;
    const int n = st.topo->n;
    const int nn = st.topo->nn;
    if (st.board->empty_cells > (nn - 5 * n)) {
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::NoProgress;
    }
    
    StrategyStats tmp{};
    
    // 1. Twarda struktura Exact (szybka)
    const ApplyResult exact = apply_sk_loop_exact(st, tmp, r);
    if (exact == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return exact; 
    }
    if (exact == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_sk_loop = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // Adaptacyjne gĹ‚Ä™bokie skanowanie (P8) - Skokowa propagacja dla siatek
    const int depth_cap = std::clamp(8 + (st.board->empty_cells / std::max(1, st.topo->n)), 10, 14);
    bool used_dynamic = false;

    // 2. Szukanie zdeformowanych cykli przez Bounded Implication (Nishio Forcing)
    ApplyResult dyn = p7_nightmare::bounded_implication_core(st, s, r, depth_cap, used_dynamic);
    if (dyn == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return dyn; 
    }
    if (dyn == ApplyResult::Progress && used_dynamic) {
        ++s.hit_count;
        r.used_sk_loop = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // 3. Fallback w poszukiwaniu klasycznej pÄ™tli Nice Loop
    ApplyResult ar = p7_nightmare::apply_continuous_nice_loop(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar; 
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_sk_loop = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    // 4. Fallback X-Cycle dla uĹ‚oĹĽonych siatek
    ar = p7_nightmare::apply_grouped_x_cycle(st, tmp, r);
    if (ar == ApplyResult::Contradiction) { 
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0; 
        return ar; 
    }
    if (ar == ApplyResult::Progress) {
        ++s.hit_count;
        r.used_sk_loop = true;
        s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
        return ApplyResult::Progress;
    }

    s.elapsed_ns += p7_nightmare::get_current_time_ns() - t0;
    return ApplyResult::NoProgress;
}

} // namespace sudoku_hpc::logic::p8_theoretical





==============================================================================
PLIK: Sources\logic\shared\als_builder.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE SHARED
// Moduł: als_builder.h
// Opis: Algorytm wyszukujący zbiory Almost Locked Sets (ALS).
//       Kompletnie Zero-Allocation, bazuje na płaskich tablicach Scratchpada.
// ============================================================================

#pragma once

#include <algorithm>
#include <cstdint>

#include "exact_pattern_scratchpad.h"
#include "../../core/candidate_state.h"
#include "../../config/bit_utils.h"

namespace sudoku_hpc::logic::shared {

inline void als_clear_cell_mask(ALS& als, int words) {
    for (int w = 0; w < words; ++w) {
        als.cell_mask[w] = 0ULL;
    }
}

inline bool als_cell_in(const ALS& als, int idx) {
    const int w = (idx >> 6);
    const int b = (idx & 63);
    return (als.cell_mask[w] & (1ULL << b)) != 0ULL;
}

inline void als_add_cell(ALS& als, int idx) {
    const int w = (idx >> 6);
    const int b = (idx & 63);
    als.cell_mask[w] |= (1ULL << b);
}

inline void als_push_record(
    ExactPatternScratchpad& sp,
    int words,
    int house,
    const int* cells,
    int cell_count,
    uint64_t digit_mask) {
    
    if (sp.als_count >= ExactPatternScratchpad::MAX_NN) return;
    
    ALS& rec = sp.als_list[sp.als_count++];
    als_clear_cell_mask(rec, words);
    
    for (int i = 0; i < cell_count; ++i) {
        als_add_cell(rec, cells[i]);
    }
    
    rec.digit_mask = digit_mask;
    rec.size = static_cast<uint8_t>(cell_count);
    // Stopień swobody (z definicji ALS wynosi 1, gdyż N komórek ma N+1 cyfr)
    rec.degree = static_cast<uint8_t>(std::popcount(digit_mask) - cell_count); 
    rec.house = static_cast<uint16_t>(std::max(0, house));
}

// Zwraca ilość znalezionych struktur ALS
inline int build_als_list(const CandidateState& st, int min_size = 2, int max_size = 4) {
    auto& sp = exact_pattern_scratchpad();
    sp.als_count = 0;
    
    const int nn = st.topo->nn;
    const int n = st.topo->n;
    const int words = (nn + 63) >> 6;
    const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
    
    const int lo = std::clamp(min_size, 2, 6);
    const int hi = std::clamp(max_size, lo, 6);

    int house_cells[64]{};
    uint64_t house_masks[64]{};

    // Przeszukiwanie każdego z "domków" (Houses - wiersz, kolumna lub blok)
    for (int h = 0; h < house_count; ++h) {
        const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
        const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
        int hc = 0;
        
        for (int p = p0; p < p1; ++p) {
            const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            
            const uint64_t m = st.cands[static_cast<size_t>(idx)];
            const int pc = std::popcount(m);
            // Wykluczenie gołych jedynek i nadmiarowych list
            if (pc < 2 || pc > n) continue;
            
            house_cells[hc] = idx;
            house_masks[hc] = m;
            ++hc;
            if (hc >= 64) break;
        }
        if (hc < lo) continue;

        // Budowanie kombinacji w obrębie znalezionego domku
        for (int a = 0; a < hc; ++a) {
            if (lo <= 1 && hi >= 1) {
                const uint64_t dm = house_masks[a];
                if (std::popcount(dm) == 2) {
                    const int cells[1] = {house_cells[a]};
                    als_push_record(sp, words, h, cells, 1, dm);
                }
            }
            for (int b = a + 1; b < hc; ++b) {
                const uint64_t dm2 = house_masks[a] | house_masks[b];
                if (lo <= 2 && hi >= 2 && std::popcount(dm2) == 3) {
                    const int cells2[2] = {house_cells[a], house_cells[b]};
                    als_push_record(sp, words, h, cells2, 2, dm2);
                }
                if (hi < 3) continue;
                
                for (int c = b + 1; c < hc; ++c) {
                    const uint64_t dm3 = dm2 | house_masks[c];
                    if (lo <= 3 && hi >= 3 && std::popcount(dm3) == 4) {
                        const int cells3[3] = {house_cells[a], house_cells[b], house_cells[c]};
                        als_push_record(sp, words, h, cells3, 3, dm3);
                    }
                    if (hi < 4) continue;
                    
                    for (int d = c + 1; d < hc; ++d) {
                        const uint64_t dm4 = dm3 | house_masks[d];
                        if (lo <= 4 && hi >= 4 && std::popcount(dm4) == 5) {
                            const int cells4[4] = {house_cells[a], house_cells[b], house_cells[c], house_cells[d]};
                            als_push_record(sp, words, h, cells4, 4, dm4);
                        }
                    }
                }
            }
        }
    }

    return sp.als_count;
}

} // namespace sudoku_hpc::logic::shared



==============================================================================
PLIK: Sources\logic\shared\exact_pattern_scratchpad.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE SHARED
// Moduł: exact_pattern_scratchpad.h
// Opis: Mózg Zero-Allocation Policy dla całego silnika Certyfikatora.
//       Płaskie bufory Thread-Local dla wszystkich grafów, kolejek i tablic.
//       Rozmiary stałe dostosowane pod N=64. Unikamy false-sharingu cache.
// ============================================================================

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>

namespace sudoku_hpc::logic {

// ============================================================================
// STRUKTURY DANYCH WSPÓŁDZIELONE (np. Almost Locked Sets)
// ============================================================================
struct ALS {
    uint64_t cell_mask[64]{};
    uint64_t digit_mask = 0ULL;
    uint8_t size = 0;
    uint8_t degree = 0;
    uint16_t house = 0;
};

// Struktura na potrzeby POM (Pattern Overlay Method) w P8
struct PomFrame {
    int cell_idx = -1;
    uint64_t pending_mask = 0ULL;
    uint64_t tried_mask = 0ULL;
};

// ============================================================================
// GŁÓWNY BUFOR WORKERA
// Wyrównanie w pamięci na 64 bajty by zabezpieczyć linię pamięci Cache przed
// degradacją w wyniku pracy wielu workerów.
// ============================================================================
struct alignas(64) ExactPatternScratchpad {
    static constexpr int MAX_N = 64;
    static constexpr int MAX_NN = MAX_N * MAX_N;          // do 4096 dla 64x64
    static constexpr int MAX_HOUSES = MAX_N * 3;          // 64 rzędy, 64 kolumny, 64 bloki
    static constexpr int MAX_STRONG_LINKS_PER_DIGIT = MAX_HOUSES;
    static constexpr int MAX_EDGES = MAX_HOUSES;
    static constexpr int MAX_ADJ = MAX_NN * 128;
    static constexpr int MAX_BFS = MAX_NN * 4;
    static constexpr int MAX_CHAIN = MAX_NN * 8;
    static constexpr int MAX_LINK_EDGES = MAX_NN * 48;

    // ------------------------------------------------------------------------
    // Pamięć współdzielona (General BFS)
    // ------------------------------------------------------------------------
    int bfs_queue[MAX_BFS]{};
    int bfs_depth[MAX_BFS]{};
    int bfs_parent[MAX_BFS]{};
    int visited[MAX_NN]{};

    // ------------------------------------------------------------------------
    // Pamięć współdzielona dla Grafów (Mapowania węzłów dla Chains)
    // ------------------------------------------------------------------------
    int cell_to_node[MAX_NN]{};
    int node_to_cell[MAX_NN]{};
    int node_degree[MAX_NN]{};
    int adj_offsets[MAX_NN + 1]{};
    int adj_cursor[MAX_NN]{};
    int adj_flat[MAX_ADJ]{};
    int edge_u[MAX_EDGES]{};
    int edge_v[MAX_EDGES]{};
    int edge_count = 0;
    int node_count = 0;

    // ------------------------------------------------------------------------
    // Struktury specyficzne dla Łańcuchów (Chains i Cycles)
    // ------------------------------------------------------------------------
    int chain_cell[MAX_CHAIN]{};
    uint64_t chain_enter_bit[MAX_CHAIN]{};
    int chain_parent[MAX_CHAIN]{};
    uint8_t chain_depth[MAX_CHAIN]{};
    int chain_count = 0;

    // ------------------------------------------------------------------------
    // Bufor dla technik podstawowych P4-P5 (Ryby i Skrzydła)
    // ------------------------------------------------------------------------
    uint64_t fish_row_masks[MAX_N]{};
    uint64_t fish_col_masks[MAX_N]{};
    int active_rows[MAX_N]{};
    int active_cols[MAX_N]{};
    int wing_cells[MAX_NN]{};
    int wing_count = 0;

    // ------------------------------------------------------------------------
    // Tablice dedykowane strukturom ALS
    // ------------------------------------------------------------------------
    ALS als_list[MAX_NN]{};
    int als_count = 0;
    int als_cells[MAX_NN]{};
    int als_cell_count = 0;
    
    // Tablice powiązań silnych per-cyfra
    int strong_count[MAX_N + 1]{};
    int strong_a[MAX_N + 1][MAX_STRONG_LINKS_PER_DIGIT]{};
    int strong_b[MAX_N + 1][MAX_STRONG_LINKS_PER_DIGIT]{};

    // ------------------------------------------------------------------------
    // Grafy Dynamiczne dla silników połączonych P8 (Dynamic Forcing / MSLS)
    // Używane do budowania map powiązań słabych/silnych w locie.
    // ------------------------------------------------------------------------
    int dyn_cell_to_node[MAX_NN]{};
    int dyn_node_to_cell[MAX_NN]{};
    int dyn_node_count = 0;
    int dyn_digit_cells[MAX_NN]{};
    int dyn_digit_cell_count = 0;

    int dyn_strong_edge_u[MAX_HOUSES * 2]{};
    int dyn_strong_edge_v[MAX_HOUSES * 2]{};
    int dyn_strong_edge_count = 0;
    int dyn_weak_edge_u[MAX_LINK_EDGES]{};
    int dyn_weak_edge_v[MAX_LINK_EDGES]{};
    int dyn_weak_edge_count = 0;

    int dyn_strong_degree[MAX_NN]{};
    int dyn_weak_degree[MAX_NN]{};
    int dyn_strong_offsets[MAX_NN + 1]{};
    int dyn_weak_offsets[MAX_NN + 1]{};
    int dyn_strong_cursor[MAX_NN]{};
    int dyn_weak_cursor[MAX_NN]{};
    int dyn_strong_adj[MAX_ADJ]{};
    int dyn_weak_adj[MAX_ADJ]{};

    // ------------------------------------------------------------------------
    // Rozszerzenie P8: Bufor Stanu Zrzutów (Zastępuje Rekurencję Stosu)
    // ------------------------------------------------------------------------
    int dyn_state_depth[MAX_NN * 2]{};
    int dyn_state_parent[MAX_NN * 2]{};
    int dyn_state_queue[MAX_NN * 2]{};
    int dyn_prop_queue[MAX_NN]{};
    
    // Odtwarzanie układu mask kandydatów po nieudanej/udanej propagacji 
    // dla Forcing Chains. Gwarantuje stan czystości do 2-8 poziomów zagnieżdżenia.
    uint64_t dyn_cands_backup[MAX_NN]{};
    uint16_t dyn_values_backup[MAX_NN]{};
    int dyn_empty_backup = 0;

    // Struktura zrzutu dla Pattern Overlay Method (DFS fallback P8)
    std::array<PomFrame, MAX_N> pom_stack{};
    int pom_depth = 0;

    // ========================================================================
    // Metody narzędziowe ułatwiające czyszczenie pamięci przed weryfikacją
    // ========================================================================
    void reset_node_maps(int nn) {
        std::fill_n(cell_to_node, nn, -1);
        node_count = 0;
        edge_count = 0;
    }

    void reset_graph(int node_n) {
        std::fill_n(node_degree, node_n, 0);
        std::fill_n(adj_offsets, node_n + 1, 0);
        std::fill_n(adj_cursor, node_n, 0);
    }

    void reset_dynamic_graph(int nn) {
        std::fill_n(dyn_cell_to_node, nn, -1);
        dyn_node_count = 0;
        dyn_digit_cell_count = 0;
        dyn_strong_edge_count = 0;
        dyn_weak_edge_count = 0;
    }

    void reset_dynamic_adjacency(int node_n) {
        std::fill_n(dyn_strong_degree, node_n, 0);
        std::fill_n(dyn_weak_degree, node_n, 0);
        std::fill_n(dyn_strong_offsets, node_n + 1, 0);
        std::fill_n(dyn_weak_offsets, node_n + 1, 0);
        std::fill_n(dyn_strong_cursor, node_n, 0);
        std::fill_n(dyn_weak_cursor, node_n, 0);
    }
    
    void reset_pom() {
        pom_depth = 0;
        for (auto& f : pom_stack) {
            f.cell_idx = -1;
            f.pending_mask = 0ULL;
            f.tried_mask = 0ULL;
        }
    }
};

// Szybki dostęp globalny dla wątku 
inline ExactPatternScratchpad& exact_pattern_scratchpad() {
    thread_local ExactPatternScratchpad scratch;
    return scratch;
}

} // namespace sudoku_hpc::logic

namespace sudoku_hpc::logic::shared {

using ::sudoku_hpc::logic::ALS;
using ::sudoku_hpc::logic::PomFrame;
using ::sudoku_hpc::logic::ExactPatternScratchpad;

inline ExactPatternScratchpad& exact_pattern_scratchpad() {
    return ::sudoku_hpc::logic::exact_pattern_scratchpad();
}

} // namespace sudoku_hpc::logic::shared



==============================================================================
PLIK: Sources\logic\shared\link_graph_builder.h
==============================================================================

// ============================================================================
// SUDOKU HPC - LOGIC ENGINE SHARED
// Moduł: link_graph_builder.h
// Opis: System wyznaczania i utrzymywania sieci powiązań pomiędzy
//       komórkami w relacjach typu "Strong" oraz "Weak" per konkretna cyfra.
//       Kluczowe dla metod X-Cycles i Forcing Chains.
// ============================================================================

#pragma once

#include <cstdint>

#include "exact_pattern_scratchpad.h"
#include "../../core/candidate_state.h"

namespace sudoku_hpc::logic::shared {

inline bool dyn_has_strong_edge(const ExactPatternScratchpad& sp, int u, int v) {
    for (int i = 0; i < sp.dyn_strong_edge_count; ++i) {
        const int a = sp.dyn_strong_edge_u[i];
        const int b = sp.dyn_strong_edge_v[i];
        if ((a == u && b == v) || (a == v && b == u)) return true;
    }
    return false;
}

inline void dyn_add_strong_edge(ExactPatternScratchpad& sp, int u, int v) {
    if (u == v) return;
    if (dyn_has_strong_edge(sp, u, v)) return;
    if (sp.dyn_strong_edge_count >= (ExactPatternScratchpad::MAX_HOUSES * 2)) return;
    
    sp.dyn_strong_edge_u[sp.dyn_strong_edge_count] = u;
    sp.dyn_strong_edge_v[sp.dyn_strong_edge_count] = v;
    ++sp.dyn_strong_edge_count;
}

inline void dyn_add_weak_edge(ExactPatternScratchpad& sp, int u, int v) {
    if (u == v) return;
    // Słabe powiązania uzupełniają silne, ale silne jest już automatycznie "słabym".
    if (dyn_has_strong_edge(sp, u, v)) return;
    if (sp.dyn_weak_edge_count >= ExactPatternScratchpad::MAX_LINK_EDGES) return;
    
    sp.dyn_weak_edge_u[sp.dyn_weak_edge_count] = u;
    sp.dyn_weak_edge_v[sp.dyn_weak_edge_count] = v;
    ++sp.dyn_weak_edge_count;
}

// Konstruuje cały graf wzajemnych oddziaływań dla konkretnej cyfry w jednym przebiegu.
inline bool build_grouped_link_graph_for_digit(const CandidateState& st, int digit, ExactPatternScratchpad& sp) {
    const int nn = st.topo->nn;
    const uint64_t bit = (1ULL << (digit - 1));
    sp.reset_dynamic_graph(nn);

    // Krok 1: Identyfikacja wszystkich węzłów (komórek), gdzie kandydat występuje
    for (int idx = 0; idx < nn; ++idx) {
        if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
        if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
        
        if (sp.dyn_node_count >= nn) break;
        sp.dyn_cell_to_node[idx] = sp.dyn_node_count;
        sp.dyn_node_to_cell[sp.dyn_node_count] = idx;
        sp.dyn_digit_cells[sp.dyn_digit_cell_count++] = idx;
        ++sp.dyn_node_count;
    }
    if (sp.dyn_node_count < 2) return false;

    // Krok 2: Poszukiwanie "Strong Links" - występuje tylko w 2 pozycjach w rzędzie/kolumnie/boxie
    const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
    for (int h = 0; h < house_count; ++h) {
        const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
        const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
        int a = -1;
        int b = -1;
        int cnt = 0;
        
        for (int p = p0; p < p1; ++p) {
            const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
            
            if (cnt == 0) a = idx;
            else if (cnt == 1) b = idx;
            ++cnt;
            if (cnt > 2) break;
        }
        // Jeśli cyfra występuje dokładnie w 2 miejscach - to jest Powiązanie Silne
        if (cnt == 2 && a >= 0 && b >= 0) {
            const int na = sp.dyn_cell_to_node[a];
            const int nb = sp.dyn_cell_to_node[b];
            if (na >= 0 && nb >= 0) {
                dyn_add_strong_edge(sp, na, nb);
            }
        }
    }

    // Krok 3: Dodanie "Weak Links" dla pozostałych komórek widzących się wzajemnie
    for (int ni = 0; ni < sp.dyn_node_count; ++ni) {
        const int cell = sp.dyn_node_to_cell[ni];
        const int p0 = st.topo->peer_offsets[static_cast<size_t>(cell)];
        const int p1 = st.topo->peer_offsets[static_cast<size_t>(cell + 1)];
        
        for (int p = p0; p < p1; ++p) {
            const int peer = st.topo->peers_flat[static_cast<size_t>(p)];
            if (peer <= cell) continue; // Uniknięcie podwójnego skanowania tego samego rzędu
            
            const int nj = sp.dyn_cell_to_node[peer];
            if (nj < 0) continue;
            dyn_add_weak_edge(sp, ni, nj);
        }
    }
    
    if (sp.dyn_strong_edge_count == 0 && sp.dyn_weak_edge_count == 0) return false;

    // Krok 4: Transformacja z listy wskaźników na zoptymalizowaną strukturę CSR (Compressed Sparse Row) dla szybkiego BFS.
    sp.reset_dynamic_adjacency(sp.dyn_node_count);
    
    for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
        const int u = sp.dyn_strong_edge_u[e];
        const int v = sp.dyn_strong_edge_v[e];
        ++sp.dyn_strong_degree[u];
        ++sp.dyn_strong_degree[v];
        ++sp.dyn_weak_degree[u];
        ++sp.dyn_weak_degree[v];
    }
    for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
        const int u = sp.dyn_weak_edge_u[e];
        const int v = sp.dyn_weak_edge_v[e];
        ++sp.dyn_weak_degree[u];
        ++sp.dyn_weak_degree[v];
    }

    int strong_total = 0;
    int weak_total = 0;
    for (int i = 0; i < sp.dyn_node_count; ++i) {
        sp.dyn_strong_offsets[i] = strong_total;
        sp.dyn_weak_offsets[i] = weak_total;
        strong_total += sp.dyn_strong_degree[i];
        weak_total += sp.dyn_weak_degree[i];
    }
    sp.dyn_strong_offsets[sp.dyn_node_count] = strong_total;
    sp.dyn_weak_offsets[sp.dyn_node_count] = weak_total;
    
    if (strong_total > ExactPatternScratchpad::MAX_ADJ || weak_total > ExactPatternScratchpad::MAX_ADJ) {
        return false;
    }

    for (int i = 0; i < sp.dyn_node_count; ++i) {
        sp.dyn_strong_cursor[i] = sp.dyn_strong_offsets[i];
        sp.dyn_weak_cursor[i] = sp.dyn_weak_offsets[i];
    }

    for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
        const int u = sp.dyn_strong_edge_u[e];
        const int v = sp.dyn_strong_edge_v[e];
        sp.dyn_strong_adj[sp.dyn_strong_cursor[u]++] = v;
        sp.dyn_strong_adj[sp.dyn_strong_cursor[v]++] = u;
        sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
        sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
    }
    for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
        const int u = sp.dyn_weak_edge_u[e];
        const int v = sp.dyn_weak_edge_v[e];
        sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
        sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
    }
    return true;
}

} // namespace sudoku_hpc::logic::shared



==============================================================================
PLIK: Sources\logic\sudoku_logic_engine.h
==============================================================================

﻿
// ============================================================================
// SUDOKU HPC - LOGIC ENGINE
// ModuĹ‚: sudoku_logic_engine.h
// Opis: Centralny dyspozytor logiki (Fasada). Deleguje testy Ĺ‚amigĹ‚Ăłwki 
//       do poszczegĂłlnych moduĹ‚Ăłw. ĹÄ…czy nowÄ…, rozbitÄ… architekturÄ™ w caĹ‚oĹ›Ä‡.
//       Gwarantuje wywoĹ‚ania strategii od Poziomu 1 (Easy) do Poziomu 8 
//       (Theoretical) bez ominiÄ™cia ĹĽadnego wariantu. Zero-Allocation.
// ============================================================================
//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>
#include <vector>

#include "../config/run_config.h"
#include "../core/board.h"
#include "../core/candidate_state.h"
#include "../generator/core_engines/dlx_solver.h" // dla SearchAbortControl
#include "logic_result.h"

// ============================================================================
// DOĹÄ„CZENIE WSZYSTKICH SPECJALISTYCZNYCH MODUĹĂ“W (P1 - P8)
// ============================================================================
#include "p1_easy/naked_hidden_single.h"
#include "p2_intersections/intersections.h"
#include "p3_subsets/house_subsets.h"
#include "p4_hard/fish_basic.h"
#include "p4_hard/skyscraper_kite.h"
#include "p4_hard/empty_rectangle.h"
#include "p4_hard/y_wing_remote_pairs.h"
#include "p5_expert/finned_fish.h"
#include "p5_expert/simple_coloring.h"
#include "p5_expert/bug_plus_one.h"
#include "p5_expert/unique_rectangle_t1.h"
#include "p5_expert/xyz_w_wing.h"
#include "p6_diabolical/finned_jelly_sword.h" // Zawiera Jellyfish
#include "p6_diabolical/chains_basic.h"
#include "p6_diabolical/wxyz_wing.h"
#include "p6_diabolical/als_xz.h"
#include "p6_diabolical/unique_loop_avoidable_oddagon.h" // Nowe uzupeĹ‚nienia
#include "p6_diabolical/ur_extended.h"
#include "p6_diabolical/bug_variants.h"
#include "p6_diabolical/borescoper_qiu.h"
#include "p7_nightmare/medusa_3d.h"
#include "p7_nightmare/aic_grouped_aic.h"
#include "p7_nightmare/grouped_x_cycle.h"
#include "p7_nightmare/continuous_nice_loop.h"
#include "p7_nightmare/als_xy_wing_chain.h" // Zawiera ALS-AIC
#include "p7_nightmare/sue_de_coq.h"
#include "p7_nightmare/death_blossom.h"
#include "p7_nightmare/franken_mutant_fish.h"
#include "p7_nightmare/kraken_fish.h"
#include "p7_nightmare/squirmbag.h" // Nowa ryba 5x5
#include "p7_nightmare/aligned_exclusion.h"
#include "p8_theoretical/msls.h"
#include "p8_theoretical/exocet_family.h"
#include "p8_theoretical/sk_loop.h"
#include "p8_theoretical/pattern_overlay.h"
#include "p8_theoretical/forcing_chains_dynamic.h"

namespace sudoku_hpc::logic {

struct GenericLogicCertify {
    enum StrategySlot : size_t {
        SlotNakedSingle = 0,
        SlotHiddenSingle = 1,
        SlotPointingPairs = 2,
        SlotBoxLineReduction = 3,
        SlotNakedPair = 4,
        SlotHiddenPair = 5,
        SlotNakedTriple = 6,
        SlotHiddenTriple = 7,
        SlotNakedQuad = 8,
        SlotHiddenQuad = 9,
        SlotXWing = 10,
        SlotYWing = 11,
        SlotSkyscraper = 12,
        SlotTwoStringKite = 13,
        SlotEmptyRectangle = 14,
        SlotRemotePairs = 15,
        SlotSwordfish = 16,
        SlotFinnedXWingSashimi = 17,
        SlotSimpleColoring = 18,
        SlotBUGPlusOne = 19,
        SlotUniqueRectangle = 20,
        SlotXYZWing = 21,
        SlotWWing = 22,
        SlotJellyfish = 23,
        SlotXChain = 24,
        SlotXYChain = 25,
        SlotWXYZWing = 26,
        SlotFinnedSwordfishJellyfish = 27,
        SlotALSXZ = 28,
        SlotUniqueLoop = 29,
        SlotAvoidableRectangle = 30,
        SlotBivalueOddagon = 31,
        SlotMedusa3D = 32,
        SlotAIC = 33,
        SlotGroupedAIC = 34,
        SlotGroupedXCycle = 35,
        SlotContinuousNiceLoop = 36,
        SlotALSXYWing = 37,
        SlotALSChain = 38,
        SlotSueDeCoq = 39,
        SlotDeathBlossom = 40,
        SlotFrankenFish = 41,
        SlotMutantFish = 42,
        SlotKrakenFish = 43,
        SlotMSLS = 44,
        SlotExocet = 45,
        SlotSeniorExocet = 46,
        SlotSKLoop = 47,
        SlotPatternOverlayMethod = 48,
        SlotForcingChains = 49,
        SlotSquirmbag = 50,
        SlotURExtended = 51,
        SlotHiddenUR = 52,
        SlotBUGType2 = 53,
        SlotBUGType3 = 54,
        SlotBUGType4 = 55,
        SlotBorescoperQiuDeadlyPattern = 56,
        SlotAlignedPairExclusion = 57,
        SlotAlignedTripleExclusion = 58,
        SlotALSAIC = 59,
        SlotDynamicForcingChains = 60
    };

    struct StrategyMeta {
        const char* id = "unknown";
        uint8_t level = 0;
        StrategyImplTier impl_tier = StrategyImplTier::Disabled;
        bool supports_asymmetric = true;
        uint8_t max_n_verified = 64;
        const char* proof_tag = "none";
    };

    static const StrategyMeta& strategy_meta_for_slot(size_t slot) {
        static constexpr std::array<StrategyMeta, kStrategySlotCount> kMeta = {{
            {"NakedSingle", 1, StrategyImplTier::Full, true, 64, "P1.NakedSingle"},
            {"HiddenSingle", 1, StrategyImplTier::Full, true, 64, "P1.HiddenSingle"},
            {"PointingPairs", 2, StrategyImplTier::Full, true, 64, "P2.PointingPairs"},
            {"BoxLineReduction", 2, StrategyImplTier::Full, true, 64, "P2.BoxLineReduction"},
            {"NakedPair", 2, StrategyImplTier::Full, true, 64, "P2.NakedPair"},
            {"HiddenPair", 2, StrategyImplTier::Full, true, 64, "P2.HiddenPair"},
            {"NakedTriple", 2, StrategyImplTier::Full, true, 64, "P2.NakedTriple"},
            {"HiddenTriple", 2, StrategyImplTier::Full, true, 64, "P2.HiddenTriple"},
            {"NakedQuad", 4, StrategyImplTier::Full, true, 64, "P3.NakedQuad"},
            {"HiddenQuad", 4, StrategyImplTier::Full, true, 64, "P3.HiddenQuad"},
            {"XWing", 4, StrategyImplTier::Full, true, 64, "P3.XWing"},
            {"YWing", 4, StrategyImplTier::Full, true, 64, "P3.YWing"},
            {"Skyscraper", 4, StrategyImplTier::Full, true, 64, "P3.Skyscraper"},
            {"TwoStringKite", 4, StrategyImplTier::Full, true, 64, "P3.TwoStringKite"},
            {"EmptyRectangle", 4, StrategyImplTier::Full, true, 64, "P3.EmptyRectangle"},
            {"RemotePairs", 4, StrategyImplTier::Full, true, 64, "P3.RemotePairs"},
            {"Swordfish", 5, StrategyImplTier::Full, true, 64, "P4.Swordfish"},
            {"FinnedXWingSashimi", 5, StrategyImplTier::Full, true, 64, "P4.FinnedXWingSashimi"},
            {"SimpleColoring", 5, StrategyImplTier::Full, true, 64, "P4.SimpleColoring"},
            {"BUGPlusOne", 5, StrategyImplTier::Full, true, 64, "P4.BUGPlusOne"},
            {"UniqueRectangle", 5, StrategyImplTier::Full, true, 64, "P4.UniqueRectangle"},
            {"XYZWing", 5, StrategyImplTier::Full, true, 64, "P4.XYZWing"},
            {"WWing", 5, StrategyImplTier::Full, true, 64, "P4.WWing"},
            {"Jellyfish", 6, StrategyImplTier::Full, true, 64, "P5.Jellyfish"},
            {"XChain", 6, StrategyImplTier::Full, true, 64, "P5.XChain"},
            {"XYChain", 6, StrategyImplTier::Full, true, 64, "P5.XYChain"},
            {"WXYZWing", 6, StrategyImplTier::Full, true, 64, "P5.WXYZWing"},
            {"FinnedSwordfishJellyfish", 6, StrategyImplTier::Full, true, 64, "P5.FinnedSwordfishJellyfish"},
            {"ALSXZ", 6, StrategyImplTier::Full, true, 64, "P5.ALSXZ"},
            {"UniqueLoop", 6, StrategyImplTier::Full, true, 64, "P5.UniqueLoop"},
            {"AvoidableRectangle", 6, StrategyImplTier::Full, true, 64, "P5.AvoidableRectangle"},
            {"BivalueOddagon", 6, StrategyImplTier::Full, true, 64, "P5.BivalueOddagon"},
            {"Medusa3D", 7, StrategyImplTier::Hybrid, true, 64, "P6.Medusa3D"},
            {"AIC", 7, StrategyImplTier::Full, true, 64, "P6.AIC"},
            {"GroupedAIC", 7, StrategyImplTier::Full, true, 64, "P6.GroupedAIC"},
            {"GroupedXCycle", 7, StrategyImplTier::Full, true, 64, "P6.GroupedXCycle"},
            {"ContinuousNiceLoop", 7, StrategyImplTier::Full, true, 64, "P6.ContinuousNiceLoop"},
            {"ALSXYWing", 7, StrategyImplTier::Hybrid, true, 64, "P6.ALSXYWing"},
            {"ALSChain", 7, StrategyImplTier::Hybrid, true, 64, "P6.ALSChain"},
            {"SueDeCoq", 7, StrategyImplTier::Hybrid, true, 64, "P6.SueDeCoq"},
            {"DeathBlossom", 7, StrategyImplTier::Hybrid, true, 64, "P6.DeathBlossom"},
            {"FrankenFish", 7, StrategyImplTier::Full, true, 64, "P6.FrankenFish"},
            {"MutantFish", 7, StrategyImplTier::Full, true, 64, "P6.MutantFish"},
            {"KrakenFish", 7, StrategyImplTier::Hybrid, true, 64, "P6.KrakenFish"},
            {"MSLS", 8, StrategyImplTier::Hybrid, true, 64, "P7.MSLS"},
            {"Exocet", 8, StrategyImplTier::Hybrid, true, 64, "P7.Exocet"},
            {"SeniorExocet", 8, StrategyImplTier::Hybrid, true, 64, "P7.SeniorExocet"},
            {"SKLoop", 8, StrategyImplTier::Hybrid, true, 64, "P7.SKLoop"},
            {"PatternOverlayMethod", 8, StrategyImplTier::Hybrid, true, 64, "P7.PatternOverlay"},
            {"ForcingChains", 8, StrategyImplTier::Hybrid, true, 64, "P7.ForcingChains"},
            {"Squirmbag", 7, StrategyImplTier::Hybrid, true, 64, "P6.Squirmbag"},
            {"URExtended", 6, StrategyImplTier::Full, true, 64, "P5.URExtended"},
            {"HiddenUR", 6, StrategyImplTier::Full, true, 64, "P5.HiddenUR"},
            {"BUGType2", 6, StrategyImplTier::Full, true, 64, "P5.BUGType2"},
            {"BUGType3", 6, StrategyImplTier::Full, true, 64, "P5.BUGType3"},
            {"BUGType4", 6, StrategyImplTier::Full, true, 64, "P5.BUGType4"},
            {"BorescoperQiuDeadlyPattern", 6, StrategyImplTier::Full, true, 64, "P5.BorescoperQiu"},
            {"AlignedPairExclusion", 7, StrategyImplTier::Hybrid, true, 64, "P6.AlignedPairExclusion"},
            {"AlignedTripleExclusion", 7, StrategyImplTier::Hybrid, true, 64, "P6.AlignedTripleExclusion"},
            {"ALSAIC", 7, StrategyImplTier::Hybrid, true, 64, "P6.ALSAIC"},
            {"DynamicForcingChains", 8, StrategyImplTier::Hybrid, true, 64, "P7.DynamicForcingChains"},
        }};
        if (slot >= kMeta.size()) {
            static constexpr StrategyMeta kInvalid{"invalid", 0, StrategyImplTier::Disabled, false, 0, "invalid"};
            return kInvalid;
        }
        return kMeta[slot];
    }

    static StrategyImplTier strategy_impl_tier_for_slot(size_t slot) {
        return strategy_meta_for_slot(slot).impl_tier;
    }

    static bool is_proxy_slot(size_t slot) {
        const StrategyImplTier tier = strategy_impl_tier_for_slot(slot);
        return tier == StrategyImplTier::Proxy || tier == StrategyImplTier::Disabled;
    }

    static bool is_full_canonical_slot(size_t slot) {
        return strategy_impl_tier_for_slot(slot) == StrategyImplTier::Full;
    }

    static bool slot_from_required_strategy(RequiredStrategy rs, size_t& out_slot) {
        switch (rs) {
            case RequiredStrategy::NakedSingle: out_slot = SlotNakedSingle; return true;
            case RequiredStrategy::HiddenSingle: out_slot = SlotHiddenSingle; return true;
            case RequiredStrategy::PointingPairs: out_slot = SlotPointingPairs; return true;
            case RequiredStrategy::BoxLineReduction: out_slot = SlotBoxLineReduction; return true;
            case RequiredStrategy::NakedPair: out_slot = SlotNakedPair; return true;
            case RequiredStrategy::HiddenPair: out_slot = SlotHiddenPair; return true;
            case RequiredStrategy::NakedTriple: out_slot = SlotNakedTriple; return true;
            case RequiredStrategy::HiddenTriple: out_slot = SlotHiddenTriple; return true;
            case RequiredStrategy::NakedQuad: out_slot = SlotNakedQuad; return true;
            case RequiredStrategy::HiddenQuad: out_slot = SlotHiddenQuad; return true;
            case RequiredStrategy::XWing: out_slot = SlotXWing; return true;
            case RequiredStrategy::YWing: out_slot = SlotYWing; return true;
            case RequiredStrategy::Skyscraper: out_slot = SlotSkyscraper; return true;
            case RequiredStrategy::TwoStringKite: out_slot = SlotTwoStringKite; return true;
            case RequiredStrategy::EmptyRectangle: out_slot = SlotEmptyRectangle; return true;
            case RequiredStrategy::RemotePairs: out_slot = SlotRemotePairs; return true;
            case RequiredStrategy::Swordfish: out_slot = SlotSwordfish; return true;
            case RequiredStrategy::FinnedXWingSashimi: out_slot = SlotFinnedXWingSashimi; return true;
            case RequiredStrategy::SimpleColoring: out_slot = SlotSimpleColoring; return true;
            case RequiredStrategy::BUGPlusOne: out_slot = SlotBUGPlusOne; return true;
            case RequiredStrategy::UniqueRectangle: out_slot = SlotUniqueRectangle; return true;
            case RequiredStrategy::XYZWing: out_slot = SlotXYZWing; return true;
            case RequiredStrategy::WWing: out_slot = SlotWWing; return true;
            case RequiredStrategy::Jellyfish: out_slot = SlotJellyfish; return true;
            case RequiredStrategy::XChain: out_slot = SlotXChain; return true;
            case RequiredStrategy::XYChain: out_slot = SlotXYChain; return true;
            case RequiredStrategy::WXYZWing: out_slot = SlotWXYZWing; return true;
            case RequiredStrategy::FinnedSwordfishJellyfish: out_slot = SlotFinnedSwordfishJellyfish; return true;
            case RequiredStrategy::ALSXZ: out_slot = SlotALSXZ; return true;
            case RequiredStrategy::UniqueLoop: out_slot = SlotUniqueLoop; return true;
            case RequiredStrategy::AvoidableRectangle: out_slot = SlotAvoidableRectangle; return true;
            case RequiredStrategy::BivalueOddagon: out_slot = SlotBivalueOddagon; return true;
            case RequiredStrategy::UniqueRectangleExtended: out_slot = SlotURExtended; return true;
            case RequiredStrategy::HiddenUniqueRectangle: out_slot = SlotHiddenUR; return true;
            case RequiredStrategy::BUGType2: out_slot = SlotBUGType2; return true;
            case RequiredStrategy::BUGType3: out_slot = SlotBUGType3; return true;
            case RequiredStrategy::BUGType4: out_slot = SlotBUGType4; return true;
            case RequiredStrategy::BorescoperQiuDeadlyPattern: out_slot = SlotBorescoperQiuDeadlyPattern; return true;
            case RequiredStrategy::Medusa3D: out_slot = SlotMedusa3D; return true;
            case RequiredStrategy::AIC: out_slot = SlotAIC; return true;
            case RequiredStrategy::GroupedAIC: out_slot = SlotGroupedAIC; return true;
            case RequiredStrategy::GroupedXCycle: out_slot = SlotGroupedXCycle; return true;
            case RequiredStrategy::ContinuousNiceLoop: out_slot = SlotContinuousNiceLoop; return true;
            case RequiredStrategy::ALSXYWing: out_slot = SlotALSXYWing; return true;
            case RequiredStrategy::ALSChain: out_slot = SlotALSChain; return true;
            case RequiredStrategy::AlignedPairExclusion: out_slot = SlotAlignedPairExclusion; return true;
            case RequiredStrategy::AlignedTripleExclusion: out_slot = SlotAlignedTripleExclusion; return true;
            case RequiredStrategy::ALSAIC: out_slot = SlotALSAIC; return true;
            case RequiredStrategy::SueDeCoq: out_slot = SlotSueDeCoq; return true;
            case RequiredStrategy::DeathBlossom: out_slot = SlotDeathBlossom; return true;
            case RequiredStrategy::FrankenFish: out_slot = SlotFrankenFish; return true;
            case RequiredStrategy::MutantFish: out_slot = SlotMutantFish; return true;
            case RequiredStrategy::KrakenFish: out_slot = SlotKrakenFish; return true;
            case RequiredStrategy::Squirmbag: out_slot = SlotSquirmbag; return true;
            case RequiredStrategy::MSLS: out_slot = SlotMSLS; return true;
            case RequiredStrategy::Exocet: out_slot = SlotExocet; return true;
            case RequiredStrategy::SeniorExocet: out_slot = SlotSeniorExocet; return true;
            case RequiredStrategy::SKLoop: out_slot = SlotSKLoop; return true;
            case RequiredStrategy::PatternOverlayMethod: out_slot = SlotPatternOverlayMethod; return true;
            case RequiredStrategy::ForcingChains: out_slot = SlotForcingChains; return true;
            case RequiredStrategy::DynamicForcingChains: out_slot = SlotDynamicForcingChains; return true;
            case RequiredStrategy::None:
            case RequiredStrategy::Backtracking:
                return false;
        }
        return false;
    }

private:
    static inline void note_strategy_slot(GenericLogicCertifyResult& result, size_t slot, ApplyResult ar) {
        if (ar == ApplyResult::NoProgress) {
            return;
        }
        const StrategyMeta& meta = strategy_meta_for_slot(slot);
        result.record_step(
            static_cast<uint16_t>(slot),
            meta.impl_tier,
            ar,
            0,
            0,
            meta.proof_tag);
    }

    // GĹĂ“WNA PÄTLA CERTYFIKATORA LOGICZNEGO
    static ApplyResult apply_round_up_to_level(CandidateState& st, GenericLogicCertifyResult& result, int max_level) {
        
        // ====================================================================
        // POZIOM 1: EASY
        // ====================================================================
        ApplyResult ar = p1_easy::apply_naked_single(st, result.strategy_stats[SlotNakedSingle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotNakedSingle, ar); return ar; }
        ar = p1_easy::apply_hidden_single(st, result.strategy_stats[SlotHiddenSingle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotHiddenSingle, ar); return ar; }
        
        if (max_level <= 1) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 2: MEDIUM
        // ====================================================================
        ar = p2_intersections::apply_pointing_and_boxline(st, result.strategy_stats[SlotPointingPairs], result.strategy_stats[SlotBoxLineReduction], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotPointingPairs, ar); return ar; }
        
        // Zgodnie z oficjalnÄ… klasyfikacjÄ…: Podzbiory 2, 3 elementowe wchodzÄ… tu jako medium
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotNakedPair], result, 2, false);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotNakedPair, ar); return ar; }
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotHiddenPair], result, 2, true);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotHiddenPair, ar); return ar; }
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotNakedTriple], result, 3, false);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotNakedTriple, ar); return ar; }
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotHiddenTriple], result, 3, true);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotHiddenTriple, ar); return ar; }

        if (max_level <= 2) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 3/4: HARD / EXPERT (Wg wytycznych poĹ‚Ä…czone jako P3/P4 w silniku)
        // ====================================================================
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotNakedQuad], result, 4, false);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotNakedQuad, ar); return ar; }
        ar = p3_subsets::apply_house_subset(st, result.strategy_stats[SlotHiddenQuad], result, 4, true);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotHiddenQuad, ar); return ar; }
        
        ar = p4_hard::apply_x_wing(st, result.strategy_stats[SlotXWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotXWing, ar); return ar; }
        ar = p4_hard::apply_y_wing(st, result.strategy_stats[SlotYWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotYWing, ar); return ar; }
        ar = p4_hard::apply_skyscraper(st, result.strategy_stats[SlotSkyscraper], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSkyscraper, ar); return ar; }
        ar = p4_hard::apply_two_string_kite(st, result.strategy_stats[SlotTwoStringKite], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotTwoStringKite, ar); return ar; }
        ar = p4_hard::apply_empty_rectangle(st, result.strategy_stats[SlotEmptyRectangle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotEmptyRectangle, ar); return ar; }
        ar = p4_hard::apply_remote_pairs(st, result.strategy_stats[SlotRemotePairs], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotRemotePairs, ar); return ar; }
        
        if (max_level <= 4) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 5: DIABOLICAL / EXPERT (ZĹ‚oĹĽone Ryby, W-Wing, Coloring)
        // ====================================================================
        ar = p4_hard::apply_swordfish(st, result.strategy_stats[SlotSwordfish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSwordfish, ar); return ar; }
        ar = p5_expert::apply_finned_x_wing_sashimi(st, result.strategy_stats[SlotFinnedXWingSashimi], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotFinnedXWingSashimi, ar); return ar; }
        ar = p5_expert::apply_simple_coloring(st, result.strategy_stats[SlotSimpleColoring], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSimpleColoring, ar); return ar; }
        ar = p5_expert::apply_bug_plus_one(st, result.strategy_stats[SlotBUGPlusOne], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBUGPlusOne, ar); return ar; }
        ar = p5_expert::apply_unique_rectangle(st, result.strategy_stats[SlotUniqueRectangle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotUniqueRectangle, ar); return ar; }
        ar = p5_expert::apply_xyz_wing(st, result.strategy_stats[SlotXYZWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotXYZWing, ar); return ar; }
        ar = p5_expert::apply_w_wing(st, result.strategy_stats[SlotWWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotWWing, ar); return ar; }
        
        if (max_level <= 5) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 6: NIGHTMARE / DIABOLICAL (ĹaĹ„cuchy, Rozszerzone Deadly Patterns)
        // ====================================================================
        ar = p6_diabolical::apply_jellyfish(st, result.strategy_stats[SlotJellyfish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotJellyfish, ar); return ar; }
        ar = p6_diabolical::apply_x_chain(st, result.strategy_stats[SlotXChain], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotXChain, ar); return ar; }
        ar = p6_diabolical::apply_xy_chain(st, result.strategy_stats[SlotXYChain], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotXYChain, ar); return ar; }
        ar = p6_diabolical::apply_wxyz_wing(st, result.strategy_stats[SlotWXYZWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotWXYZWing, ar); return ar; }
        ar = p6_diabolical::apply_finned_swordfish_jellyfish(st, result.strategy_stats[SlotFinnedSwordfishJellyfish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotFinnedSwordfishJellyfish, ar); return ar; }
        ar = p6_diabolical::apply_als_xz(st, result.strategy_stats[SlotALSXZ], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotALSXZ, ar); return ar; }
        
        // NOWE PODPIÄCIA - UzupeĹ‚nione Deadly Patterns
        ar = p6_diabolical::apply_unique_loop(st, result.strategy_stats[SlotUniqueLoop], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotUniqueLoop, ar); return ar; }
        ar = p6_diabolical::apply_avoidable_rectangle(st, result.strategy_stats[SlotAvoidableRectangle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotAvoidableRectangle, ar); return ar; }
        ar = p6_diabolical::apply_bivalue_oddagon(st, result.strategy_stats[SlotBivalueOddagon], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBivalueOddagon, ar); return ar; }
        
        ar = p6_diabolical::apply_ur_extended(st, result.strategy_stats[SlotURExtended], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotURExtended, ar); return ar; }
        ar = p6_diabolical::apply_hidden_ur(st, result.strategy_stats[SlotHiddenUR], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotHiddenUR, ar); return ar; }
        ar = p6_diabolical::apply_bug_type2(st, result.strategy_stats[SlotBUGType2], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBUGType2, ar); return ar; }
        ar = p6_diabolical::apply_bug_type3(st, result.strategy_stats[SlotBUGType3], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBUGType3, ar); return ar; }
        ar = p6_diabolical::apply_bug_type4(st, result.strategy_stats[SlotBUGType4], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBUGType4, ar); return ar; }
        ar = p6_diabolical::apply_borescoper_qiu_deadly_pattern(st, result.strategy_stats[SlotBorescoperQiuDeadlyPattern], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotBorescoperQiuDeadlyPattern, ar); return ar; }
        
        if (max_level <= 6) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 7: NIGHTMARE / THEORETICAL (Grupy ALS, Mutanty, APE)
        // ====================================================================
        ar = p7_nightmare::apply_medusa_3d(st, result.strategy_stats[SlotMedusa3D], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotMedusa3D, ar); return ar; }
        ar = p7_nightmare::apply_aic(st, result.strategy_stats[SlotAIC], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotAIC, ar); return ar; }
        ar = p7_nightmare::apply_grouped_aic(st, result.strategy_stats[SlotGroupedAIC], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotGroupedAIC, ar); return ar; }
        
        // PODPIÄCIA BRAKUJÄ„CYCH "SIEROT" P7
        ar = p7_nightmare::apply_grouped_x_cycle(st, result.strategy_stats[SlotGroupedXCycle], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotGroupedXCycle, ar); return ar; }
        ar = p7_nightmare::apply_continuous_nice_loop(st, result.strategy_stats[SlotContinuousNiceLoop], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotContinuousNiceLoop, ar); return ar; }
        ar = p7_nightmare::apply_als_xy_wing(st, result.strategy_stats[SlotALSXYWing], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotALSXYWing, ar); return ar; }
        ar = p7_nightmare::apply_als_chain(st, result.strategy_stats[SlotALSChain], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotALSChain, ar); return ar; }
        
        ar = p7_nightmare::apply_sue_de_coq(st, result.strategy_stats[SlotSueDeCoq], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSueDeCoq, ar); return ar; }
        
        // PODPIÄCIA BRAKUJÄ„CYCH "SIEROT" P7 cd.
        ar = p7_nightmare::apply_death_blossom(st, result.strategy_stats[SlotDeathBlossom], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotDeathBlossom, ar); return ar; }
        ar = p7_nightmare::apply_franken_fish(st, result.strategy_stats[SlotFrankenFish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotFrankenFish, ar); return ar; }
        ar = p7_nightmare::apply_mutant_fish(st, result.strategy_stats[SlotMutantFish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotMutantFish, ar); return ar; }
        ar = p7_nightmare::apply_kraken_fish(st, result.strategy_stats[SlotKrakenFish], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotKrakenFish, ar); return ar; }
        
        // NOWA RYBA
        ar = p7_nightmare::apply_squirmbag(st, result.strategy_stats[SlotSquirmbag], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSquirmbag, ar); return ar; }
        
        ar = p7_nightmare::apply_aligned_pair_exclusion(st, result.strategy_stats[SlotAlignedPairExclusion], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotAlignedPairExclusion, ar); return ar; }
        ar = p7_nightmare::apply_aligned_triple_exclusion(st, result.strategy_stats[SlotAlignedTripleExclusion], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotAlignedTripleExclusion, ar); return ar; }
        
        // PODPIÄCIE ALS-AIC
        ar = p7_nightmare::apply_als_aic(st, result.strategy_stats[SlotALSAIC], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotALSAIC, ar); return ar; }
        
        if (max_level <= 7) return ApplyResult::NoProgress;

        // ====================================================================
        // POZIOM 8: THEORETICAL / BRUTE FORCE (Wzorcowe Maski, MSLS)
        // ====================================================================
        
        // PODPIÄCIA BRAKUJÄ„CYCH "SIEROT" P8
        ar = p8_theoretical::apply_msls(st, result.strategy_stats[SlotMSLS], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotMSLS, ar); return ar; }
        ar = p8_theoretical::apply_exocet(st, result.strategy_stats[SlotExocet], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotExocet, ar); return ar; }
        ar = p8_theoretical::apply_senior_exocet(st, result.strategy_stats[SlotSeniorExocet], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSeniorExocet, ar); return ar; }
        ar = p8_theoretical::apply_sk_loop(st, result.strategy_stats[SlotSKLoop], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotSKLoop, ar); return ar; }
        ar = p8_theoretical::apply_pattern_overlay_method(st, result.strategy_stats[SlotPatternOverlayMethod], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotPatternOverlayMethod, ar); return ar; }
        
        ar = p8_theoretical::apply_forcing_chains(st, result.strategy_stats[SlotForcingChains], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotForcingChains, ar); return ar; }
        ar = p8_theoretical::apply_dynamic_forcing_chains(st, result.strategy_stats[SlotDynamicForcingChains], result);
        if (ar != ApplyResult::NoProgress) { note_strategy_slot(result, SlotDynamicForcingChains, ar); return ar; }

        return ApplyResult::NoProgress;
    }

public:
    GenericLogicCertifyResult certify(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        core_engines::SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        return certify_up_to_level(puzzle, topo, 8, budget, capture_solution_grid);
    }

    GenericLogicCertifyResult certify_up_to_level(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        int max_level,
        core_engines::SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        
        GenericLogicCertifyResult result{};
        const bool has_budget = (budget != nullptr);
        const int level_limit = std::clamp(max_level, 1, 8);

        // Bufor dla planszy (zero-alloc miÄ™dzy wykonaniami poszczegĂłlnych komĂłrek)
        static thread_local GenericBoard board;
        board.topo = &topo;
        if (!board.init_from_puzzle(puzzle, false)) return result;

        // PĹ‚aski bufor dla tablicy masek (zero-alloc), wprowadzany do CandidateState
        // Zapas 4096 pozwala na bezproblemowÄ… operacjÄ™ na ekstremalnych siatkach (np. 64x64).
        static thread_local uint64_t tls_cands[4096];
        
        CandidateState st{};
        if (!st.init(board, topo, tls_cands)) return result;

        // GĹ‚Ăłwna pÄ™tla dyspozytora. KaĹĽdy powrĂłt "Progress" sprawia, ĹĽe zaczynamy 
        // przeczesywaÄ‡ strategie od najszybszych i najprostszych (P1).
        while (board.empty_cells != 0) {
            if (has_budget && !budget->step()) {
                result.timed_out = true;
                result.solved = false;
                return result;
            }
            
            const ApplyResult ar = apply_round_up_to_level(st, result, level_limit);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            
            // Ĺ»adna ze strategii na dozwolonym poziomie nie odnalazĹ‚a dedukcji (WÄ…skie gardĹ‚o nierozwiÄ…zane)
            break;
        }

        result.solved = (board.empty_cells == 0);
        if (capture_solution_grid) {
            result.solved_grid = board.values;
        }
        
        // Zapis flag dla testĂłw mikro-profilujÄ…cych
        result.naked_single_scanned = result.strategy_stats[SlotNakedSingle].use_count > 0;
        result.hidden_single_scanned = result.strategy_stats[SlotHiddenSingle].use_count > 0;
        
        return result;
    }
};

} // namespace sudoku_hpc::logic






==============================================================================
PLIK: Sources\monitor.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)
#pragma once

#include <algorithm>
#include <array>
#include <atomic>
#include <chrono>
#include <cstdint>
#include <iomanip>
#include <mutex>
#include <shared_mutex>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

#include "utils/logging.h"

namespace sudoku_hpc {

struct MonitorTotalsSnapshot {
    uint64_t target = 0;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t analyzed_required_strategy = 0;
    uint64_t required_strategy_hits = 0;
    uint64_t written_required_strategy = 0;
    uint64_t rejected = 0;
    uint64_t active_workers = 0;
    uint64_t reseeds = 0;
};

struct WorkerRow {
    std::string worker = "worker_00";
    int clues = 0;
    uint64_t seed = 0;
    uint64_t last_reseed_steady_ns = 0;
    uint64_t resets = 0;
    uint64_t applied = 0;
    double reset_lag = 0.0;
    double lag_max = 0.0;
    double reset_in_s = 0.0;
    std::string status = "idle";
    uint64_t dead_ends = 0;
    uint64_t max_depth = 0;
    double avg_node_ms = 0.0;
    double cpu_load_pct = 0.0;
    double ram_current_mb = 0.0;
    double ram_peak_mb = 0.0;
    int reseed_interval_s = 0;
    double attempt_time_budget_s = 0.0;
    uint64_t attempt_node_budget = 0;
    double stage_solved_ms = 0.0;
    double stage_dig_ms = 0.0;
    double stage_prefilter_ms = 0.0;
    double stage_logic_ms = 0.0;
    double stage_uniqueness_ms = 0.0;
    double avg_attempt_ms = 0.0;
    double success_rate_pct = 0.0;
    uint64_t backtrack_count = 0;
};

struct StrategyRow {
    std::string strategy = "None";
    int lvl = 0;
    uint64_t max_attempts = 0;
    uint64_t analyzed = 0;
    uint64_t required_strategy_hits = 0;
    double analyzed_per_min = 0.0;
    uint64_t est_5min = 0;
    uint64_t written = 0;
    double avg_clues = 0.0;
};

class ConsoleStatsMonitor {
public:
    ConsoleStatsMonitor() {
        start_tp_ = std::chrono::steady_clock::now();
    }

    ~ConsoleStatsMonitor() {
        stop_ui_thread();
    }

    void set_target(uint64_t target) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.target = target;
    }

    void set_active_workers(int n) {
        {
            std::unique_lock<std::shared_mutex> lock(totals_mu_);
            totals_.active_workers = static_cast<uint64_t>(std::max(0, n));
        }
        std::lock_guard<std::mutex> lock(workers_mu_);
        if (static_cast<int>(workers_.size()) < n) {
            workers_.resize(static_cast<size_t>(n));
        }
    }

    void set_attempts(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.attempts = v; }
    void set_attempts_total(uint64_t v) { set_attempts(v); }
    void set_analyzed_required_strategy(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.analyzed_required_strategy = v; }
    void set_required_strategy_hits(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.required_strategy_hits = v; }
    void set_written_required_strategy(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.written_required_strategy = v; }
    void set_accepted(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.accepted = v; }
    void set_written(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.written = v; }
    void set_rejected(uint64_t v) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.rejected = v; }
    void set_totals_snapshot(const MonitorTotalsSnapshot& snapshot) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_ = snapshot; }
    void add_reseed(uint64_t inc = 1) { std::unique_lock<std::shared_mutex> lock(totals_mu_); totals_.reseeds += inc; }

    void set_worker_row(size_t worker_idx, const WorkerRow& row) {
        std::lock_guard<std::mutex> lock(workers_mu_);
        if (worker_idx >= workers_.size()) {
            workers_.resize(worker_idx + 1);
        }
        workers_[worker_idx] = row;
    }

    void update_strategy_row(const StrategyRow& row) {
        std::lock_guard<std::mutex> lock(strategies_mu_);
        for (auto& item : strategies_) {
            if (item.strategy == row.strategy && item.lvl == row.lvl) {
                item = row;
                return;
            }
        }
        strategies_.push_back(row);
    }

    void add_avg_clues_per_level(int lvl, double clues) {
        if (lvl < 0 || lvl >= static_cast<int>(clues_sum_.size())) {
            return;
        }
        std::lock_guard<std::mutex> lock(clues_mu_);
        clues_sum_[lvl] += clues;
        clues_count_[lvl] += 1;
    }

    void set_background_status(const std::string& status) {
        std::lock_guard<std::mutex> lock(status_mu_);
        background_status_ = status;
    }

    void set_profiler_summary(const std::string& summary) {
        std::lock_guard<std::mutex> lock(profiler_mu_);
        profiler_summary_ = summary;
    }

    void set_grid_info(int box_rows, int box_cols, int difficulty_level) {
        box_rows_ = box_rows;
        box_cols_ = box_cols;
        difficulty_level_ = difficulty_level;
    }

    void start_ui_thread(int refresh_rate_ms) {
        stop_ui_thread();
        ui_thread_ = std::jthread([this, refresh_rate_ms](std::stop_token st) {
            const auto interval = std::chrono::milliseconds(std::max(100, refresh_rate_ms));
            while (!st.stop_requested()) {
                std::this_thread::sleep_for(interval);
            }
        });
    }

    void stop_ui_thread() {
        if (ui_thread_.joinable()) {
            ui_thread_.request_stop();
            ui_thread_.join();
        }
    }

    std::string snapshot_text() const {
        std::ostringstream out;
        MonitorTotalsSnapshot t{};
        {
            std::shared_lock<std::shared_mutex> lock(totals_mu_);
            t = totals_;
        }

        const auto elapsed_s = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - start_tp_).count();

        out << "=== Stats (console) ===\n";
        out << "target=" << t.target
            << " accepted=" << t.accepted
            << " written=" << t.written
            << " attempts=" << t.attempts
            << " rejected=" << t.rejected
            << " workers=" << t.active_workers
            << " elapsed_s=" << elapsed_s
            << "\n";

        {
            std::lock_guard<std::mutex> lock(workers_mu_);
            for (const auto& w : workers_) {
                if (w.worker.empty()) continue;
                out << "[" << w.worker << "] status=" << w.status
                    << " clues=" << w.clues
                    << " applied=" << w.applied
                    << " solved_ms=" << std::fixed << std::setprecision(3) << w.stage_solved_ms
                    << " dig_ms=" << std::fixed << std::setprecision(3) << w.stage_dig_ms
                    << " logic_ms=" << std::fixed << std::setprecision(3) << w.stage_logic_ms
                    << " uniq_ms=" << std::fixed << std::setprecision(3) << w.stage_uniqueness_ms
                    << "\n";
            }
        }

        {
            std::lock_guard<std::mutex> lock(status_mu_);
            if (!background_status_.empty()) {
                out << background_status_ << "\n";
            }
        }

        return out.str();
    }

private:
    alignas(64) MonitorTotalsSnapshot totals_{};
    mutable std::shared_mutex totals_mu_;

    std::chrono::steady_clock::time_point start_tp_;

    mutable std::mutex workers_mu_;
    std::vector<WorkerRow> workers_;

    mutable std::mutex strategies_mu_;
    std::vector<StrategyRow> strategies_;

    mutable std::mutex clues_mu_;
    std::array<double, 10> clues_sum_{};
    std::array<uint64_t, 10> clues_count_{};

    mutable std::mutex status_mu_;
    std::string background_status_;

    mutable std::mutex profiler_mu_;
    std::string profiler_summary_;

    int box_rows_ = 0;
    int box_cols_ = 0;
    int difficulty_level_ = 0;

    std::jthread ui_thread_;
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\utils\logging.h
==============================================================================

﻿#pragma once

#include <chrono>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <mutex>
#include <sstream>
#include <string>

namespace sudoku_hpc {

class DebugLogger {
public:
    DebugLogger() {
        try {
            const auto now = std::chrono::system_clock::now();
            const auto t = std::chrono::system_clock::to_time_t(now);
            std::tm tm{};
#ifdef _WIN32
            localtime_s(&tm, &t);
#else
            localtime_r(&t, &tm);
#endif
            std::ostringstream name;
            name << "sudoku_debug_"
                 << std::put_time(&tm, "%Y%m%d_%H%M%S")
                 << ".log";
            path_ = (std::filesystem::current_path() / name.str()).string();
            stream_.open(path_, std::ios::out | std::ios::app);
        } catch (...) {
            path_ = "sudoku_debug.log";
            stream_.open(path_, std::ios::out | std::ios::app);
        }
    }

    const std::string& path() const {
        return path_;
    }

    void write(const char* level, const std::string& scope, const std::string& msg) {
        std::lock_guard<std::mutex> lock(mu_);
        if (!stream_) {
            return;
        }
        const auto now = std::chrono::system_clock::now();
        const auto t = std::chrono::system_clock::to_time_t(now);
        std::tm tm{};
#ifdef _WIN32
        localtime_s(&tm, &t);
#else
        localtime_r(&t, &tm);
#endif
        stream_ << std::put_time(&tm, "%Y-%m-%d %H:%M:%S")
                << " [" << level << "] "
                << "(" << scope << ") "
                << msg
                << "\n";
        stream_.flush();
    }

private:
    std::string path_;
    std::ofstream stream_;
    std::mutex mu_;
};

inline DebugLogger& debug_logger() {
    static DebugLogger logger;
    return logger;
}

inline void log_info(const std::string& scope, const std::string& msg) {
    debug_logger().write("INFO", scope, msg);
}

inline void log_warn(const std::string& scope, const std::string& msg) {
    debug_logger().write("WARN", scope, msg);
}

inline void log_error(const std::string& scope, const std::string& msg) {
    debug_logger().write("ERROR", scope, msg);
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sudoku Level Generator RewertynPL.cpp
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#include <atomic>
#include <chrono>
#include <cctype>
#include <cstdint>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <thread>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <io.h>
#include <conio.h>
#include <windows.h>
#endif

#include "Sources/utils/logging.h"
#include "Sources/config/run_config.h"
#include "Sources/core/geometry.h"
#include "Sources/cli/arg_parser.h"
#include "Sources/monitor.h"
#include "Sources/generator/runtime_runner.h"
#include "Sources/gui.h"

namespace sudoku_hpc {

#ifdef _WIN32
inline bool can_use_cli_hotkeys() {
    return _isatty(_fileno(stdin)) != 0 && _isatty(_fileno(stdout)) != 0;
}

inline const char* cli_state_label(bool cancel_requested, bool paused) {
    if (cancel_requested) {
        return "cancel_requested";
    }
    if (paused) {
        return "paused";
    }
    return "running";
}

inline void print_cli_hotkeys_help() {
    std::cout << "CLI controls: [P] pause/resume, [C] cancel, [Q] cancel\n";
}

inline std::jthread start_cli_hotkeys_thread(std::atomic<bool>& cancel_flag, std::atomic<bool>& pause_flag) {
    return std::jthread([&cancel_flag, &pause_flag](std::stop_token st) {
        while (!st.stop_requested()) {
            if (_kbhit() == 0) {
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                continue;
            }
            int ch = _getch();
            if (ch == 0 || ch == 224) {
                (void)_getch();
                continue;
            }
            const char key = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
            if (key == 'p') {
                const bool now_paused = !pause_flag.load(std::memory_order_relaxed);
                pause_flag.store(now_paused, std::memory_order_relaxed);
                std::cout << "\n[CLI] " << (now_paused ? "paused" : "resumed") << "\n" << std::flush;
                log_info("main.cli_hotkeys", now_paused ? "paused" : "resumed");
            } else if (key == 'c' || key == 'q') {
                pause_flag.store(false, std::memory_order_relaxed);
                cancel_flag.store(true, std::memory_order_relaxed);
                std::cout << "\n[CLI] cancel requested\n" << std::flush;
                log_info("main.cli_hotkeys", "cancel requested");
            } else if (key == 'h' || key == '?') {
                print_cli_hotkeys_help();
            }
        }
    });
}

inline std::jthread start_cli_status_thread(std::atomic<bool>& cancel_flag, std::atomic<bool>& pause_flag) {
    return std::jthread([&cancel_flag, &pause_flag](std::stop_token st) {
        while (!st.stop_requested()) {
            std::this_thread::sleep_for(std::chrono::seconds(3));
            if (st.stop_requested()) {
                break;
            }
            const bool cancel_requested = cancel_flag.load(std::memory_order_relaxed);
            const bool paused = pause_flag.load(std::memory_order_relaxed);
            std::cout << "[CLI] state=" << cli_state_label(cancel_requested, paused) << "\n" << std::flush;
        }
    });
}
#endif

inline void handle_result(const GenerateRunResult& result, const GenerateRunConfig& cfg) {
    std::cout << "\n=== Generation Summary ===\n";
    std::cout << "Accepted: " << result.accepted << "\n";
    std::cout << "Written: " << result.written << "\n";
    std::cout << "Attempts: " << result.attempts << "\n";
    std::cout << "Rejected: " << result.rejected << "\n";
    std::cout << "  - Prefilter: " << result.reject_prefilter << "\n";
    std::cout << "  - Logic: " << result.reject_logic << "\n";
    std::cout << "  - Uniqueness: " << result.reject_uniqueness << "\n";
    std::cout << "  - Strategy: " << result.reject_strategy << "\n";
    std::cout << "  - Replay: " << result.reject_replay << "\n";
    std::cout << "  - DistributionBias: " << result.reject_distribution_bias << "\n";
    std::cout << "  - UniquenessBudget: " << result.reject_uniqueness_budget << "\n";
    std::cout << "Uniqueness calls: " << result.uniqueness_calls << "\n";
    std::cout << "Uniqueness nodes: " << result.uniqueness_nodes << "\n";
    std::cout << "Uniqueness total: " << std::fixed << std::setprecision(3) << result.uniqueness_elapsed_ms << " ms\n";
    std::cout << "Uniqueness avg: " << std::fixed << std::setprecision(3) << result.uniqueness_avg_ms << " ms/call\n";
    std::cout << "CPU backend: " << result.cpu_backend_selected << "\n";
    std::cout << "Kernel time: " << std::fixed << std::setprecision(3) << result.kernel_time_ms << " ms\n";
    std::cout << "Kernel calls: " << result.kernel_calls << "\n";
    std::cout << "Backend efficiency score: " << std::fixed << std::setprecision(3) << result.backend_efficiency_score << "\n";
    std::cout << "Asymmetry efficiency index: " << std::fixed << std::setprecision(3) << result.asymmetry_efficiency_index << "\n";
    std::cout << "Logic steps total: " << result.logic_steps_total << "\n";
    std::cout << "Naked hit/use: " << result.strategy_naked_hit << "/" << result.strategy_naked_use << "\n";
    std::cout << "Hidden hit/use: " << result.strategy_hidden_hit << "/" << result.strategy_hidden_use << "\n";
    std::cout << "VIP score: " << std::fixed << std::setprecision(3) << result.vip_score << "\n";
    std::cout << "VIP grade: " << result.vip_grade << "\n";
    std::cout << "VIP contract: " << (result.vip_contract_ok ? "ok" : "fail") << "\n";
    std::cout << "VIP contract reason: " << result.vip_contract_fail_reason << "\n";
    std::cout << "Premium signature: " << result.premium_signature << "\n";
    std::cout << "Premium signature v2: " << result.premium_signature_v2 << "\n";
    std::cout << "Time: " << std::fixed << std::setprecision(2) << result.elapsed_s << "s\n";
    std::cout << "Rate: " << std::fixed << std::setprecision(2) << result.accepted_per_sec << " puzzles/s\n";

    if (cfg.pause_on_exit_windows) {
        std::cout << "\nPress Enter to exit...";
        std::cin.get();
    }
}

inline void print_production_help(std::ostream& out) {
    out << "Sudoku Generator (production)\n";
    out << "Author copyright Marcin Matysek (Rewertyn)\n";
    out << "Seed type: uint64_t (unsigned 64-bit)\n";
    out << "Usage:\n";
    out << "  sudoku_gen.exe [options]\n\n";
    out << "Common options:\n";
    out << "  --help, -h                      Show this help\n";
    out << "  --box-rows <int>                Box rows\n";
    out << "  --box-cols <int>                Box cols\n";
    out << "  --difficulty <1..9>             Difficulty level\n";
    out << "  --required-strategy <name>      Required strategy (normalized token)\n";
    out << "  --target <uint64>               Target puzzles to generate\n";
    out << "  --threads <int>                 Worker threads (0=auto)\n";
    out << "  --seed <uint64>                 RNG seed (0=random)\n";
    out << "  --output-folder <path>          Output directory\n";
    out << "  --output-file <name>            Output batch file name\n";
    out << "  --single-file-only              Disable per-puzzle files\n";
    out << "  --pattern-forcing               Enable Pattern Forcing\n";
    out << "  --mcts-digger                   Enable MCTS bottleneck digger\n";
    out << "  --mcts-profile <auto|p7|p8|off> Tuning profile for digger scoring\n";
    out << "  --strict-canonical-strategies   Require canonical (non-proxy) required strategy hits\n";
    out << "  --no-proxy-advanced             Reject proxy-only advanced strategy confirmation\n";
    out << "  --allow-proxy-advanced          Allow proxy/hybrid advanced strategy confirmation\n";
    out << "  --max-pattern-depth <0..8>      Cap advanced pattern depth (0=auto)\n";
    out << "  --fast-test                     Fast smoke mode (relaxed contracts, short budgets)\n";
    out << "  --max-total-time-s <uint64>     Global runtime timeout (0=none)\n";
    out << "  --list-geometries               Print supported geometries\n";
    out << "  --validate-geometry             Validate current --box-rows/--box-cols\n";
    out << "  --validate-geometry-catalog     Validate full geometry catalog\n";
    out << "  --gui                           Force GUI mode (Windows)\n";
    out << "  --cli                           Force CLI mode (Windows)\n\n";
    out << "Examples:\n";
    out << "  sudoku_gen.exe --box-rows 3 --box-cols 3 --difficulty 1 --target 100 --threads 16\n";
    out << "  sudoku_gen.exe --list-geometries\n";
    out << "  sudoku_gen.exe --validate-geometry --box-rows 4 --box-cols 3\n";
}

} // namespace sudoku_hpc

int main(int argc, char** argv) {
    using namespace sudoku_hpc;

    log_info("main", "program start");
    std::cout << "Debug log file: " << debug_logger().path() << "\n";
    std::cout << "Author copyright Marcin Matysek (Rewertyn)\n";
    std::cout << "Seed type: uint64_t\n";

    if (has_arg(argc, argv, "--help") || has_arg(argc, argv, "-h") || has_arg(argc, argv, "/?")) {
        print_production_help(std::cout);
        return 0;
    }

#ifdef _WIN32
    const bool force_gui = has_arg(argc, argv, "--gui");
    const bool force_cli = has_arg(argc, argv, "--cli");
    const bool force_console = has_arg(argc, argv, "--force-console");
    if ((argc == 1 || force_gui) && !force_cli) {
        log_info("main", "starting GUI mode");
        if (force_console) {
            ensure_console_attached();
        }
        return run_gui_winapi(GetModuleHandleW(nullptr));
    }
#endif

    ParseArgsResult parse_result = parse_args(argc, argv);
    GenerateRunConfig cfg = parse_result.cfg;

    if (parse_result.list_geometries) {
        std::cout << supported_geometries_text();
        return 0;
    }
    if (parse_result.validate_geometry) {
        const bool ok = print_geometry_validation(cfg.box_rows, cfg.box_cols, std::cout);
        return ok ? 0 : 1;
    }
    if (parse_result.validate_geometry_catalog) {
        const bool ok = print_geometry_catalog_validation(std::cout);
        return ok ? 0 : 1;
    }

    if (parse_result.explain_profile) {
        std::cout << explain_generation_profile_text(cfg);
        return 0;
    }

    if (parse_result.run_regression_tests ||
        parse_result.run_geometry_gate ||
        parse_result.run_quality_benchmark ||
        parse_result.run_pre_difficulty_gate ||
        parse_result.run_asym_pair_benchmark ||
        parse_result.run_vip_benchmark ||
        parse_result.run_vip_gate ||
        cfg.stage_start || cfg.stage_end || cfg.perf_ab_suite ||
        parse_result.benchmark_mode) {
        std::cout << "Selected maintenance mode is not wired in this runtime build yet. "
                  << "Running normal generation with provided config.\n";
    }

    std::atomic<bool> cancel_flag{false};
    std::atomic<bool> pause_flag{false};

#ifdef _WIN32
    std::jthread cli_hotkeys_thread;
    std::jthread cli_status_thread;
    if (can_use_cli_hotkeys()) {
        print_cli_hotkeys_help();
        cli_hotkeys_thread = start_cli_hotkeys_thread(cancel_flag, pause_flag);
        cli_status_thread = start_cli_status_thread(cancel_flag, pause_flag);
    }
#endif

    ConsoleStatsMonitor monitor;
    monitor.start_ui_thread(5000);

    auto result = run_generic_sudoku(
        cfg,
        &monitor,
        &cancel_flag,
        &pause_flag,
        nullptr,
        [&](const std::string& msg) {
            std::cout << msg << "\n";
        });

    monitor.stop_ui_thread();

#ifdef _WIN32
    if (cli_hotkeys_thread.joinable()) {
        cli_hotkeys_thread.request_stop();
        cli_hotkeys_thread.join();
    }
    if (cli_status_thread.joinable()) {
        cli_status_thread.request_stop();
        cli_status_thread.join();
    }
#endif

    handle_result(result, cfg);
    return 0;
}


