
==============================================================================
PLIK: Sources\benchmark.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {
enum class Align {
    Left,
    Right,
    Center
};

struct ColumnSpec {
    std::string header;
    Align align = Align::Right;
};

std::string pad_cell(const std::string& text, size_t width, Align align) {
    if (text.size() >= width) {
        return text;
    }
    const size_t gap = width - text.size();
    if (align == Align::Left) {
        return text + std::string(gap, ' ');
    }
    if (align == Align::Right) {
        return std::string(gap, ' ') + text;
    }
    const size_t left_pad = gap / 2;
    const size_t right_pad = gap - left_pad;
    return std::string(left_pad, ' ') + text + std::string(right_pad, ' ');
}

std::string render_table(const std::vector<ColumnSpec>& cols, const std::vector<std::vector<std::string>>& rows) {
    std::vector<size_t> widths(cols.size(), 0);
    for (size_t i = 0; i < cols.size(); ++i) {
        widths[i] = cols[i].header.size();
    }
    for (const auto& row : rows) {
        for (size_t i = 0; i < cols.size() && i < row.size(); ++i) {
            widths[i] = std::max(widths[i], row[i].size());
        }
    }

    auto separator = [&]() {
        std::ostringstream oss;
        oss << '+';
        for (size_t i = 0; i < cols.size(); ++i) {
            oss << std::string(widths[i] + 2, '-') << '+';
        }
        return oss.str();
    };

    std::ostringstream out;
    out << separator() << '\n';
    out << '|';
    for (size_t i = 0; i < cols.size(); ++i) {
        out << ' ' << pad_cell(cols[i].header, widths[i], Align::Center) << ' ' << '|';
    }
    out << '\n' << separator() << '\n';
    for (const auto& row : rows) {
        out << '|';
        for (size_t i = 0; i < cols.size(); ++i) {
            const std::string cell = (i < row.size()) ? row[i] : "";
            out << ' ' << pad_cell(cell, widths[i], cols[i].align) << ' ' << '|';
        }
        out << '\n';
    }
    out << separator();
    return out.str();
}

std::string format_fixed(double value, int precision) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(precision) << value;
    return oss.str();
}

std::string now_local_string() {
    using namespace std::chrono;
    const auto now = system_clock::now();
    const std::time_t t = system_clock::to_time_t(now);
    std::tm tm{};
#ifdef _WIN32
    localtime_s(&tm, &t);
#else
    localtime_r(&t, &tm);
#endif
    std::ostringstream oss;
    oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

std::string now_local_compact_string() {
    using namespace std::chrono;
    const auto now = system_clock::now();
    const std::time_t t = system_clock::to_time_t(now);
    std::tm tm{};
#ifdef _WIN32
    localtime_s(&tm, &t);
#else
    localtime_r(&t, &tm);
#endif
    std::ostringstream oss;
    oss << std::put_time(&tm, "%Y%m%d_%H%M%S");
    return oss.str();
}

std::string ascii_sanitize(std::string_view in) {
    std::string out;
    out.reserve(in.size());
    for (unsigned char ch : in) {
        if (ch >= 32 && ch <= 126) {
            out.push_back(static_cast<char>(ch));
        } else if (ch == '\t') {
            out.push_back('\t');
        } else {
            out.push_back('?');
        }
    }
    return out;
}

class DebugFileLogger {
public:
    DebugFileLogger() {
        std::lock_guard<std::mutex> lock(mu_);
        init_locked();
    }

    void log(std::string_view level, std::string_view scope, std::string_view message) {
        std::lock_guard<std::mutex> lock(mu_);
        if (!initialized_) {
            init_locked();
        }
        if (!out_) {
            return;
        }
        const auto tid_hash = std::hash<std::thread::id>{}(std::this_thread::get_id());
        out_ << now_local_string()
             << " [" << ascii_sanitize(level) << "]"
             << " [" << ascii_sanitize(scope) << "]"
             << " [tid=" << tid_hash << "] "
             << ascii_sanitize(message)
             << "\n";
        out_.flush();
    }

    std::string path() const {
        std::lock_guard<std::mutex> lock(mu_);
        return path_;
    }

private:
    mutable std::mutex mu_;
    bool initialized_ = false;
    std::ofstream out_;
    std::string path_;

    void init_locked() {
        initialized_ = true;
        std::error_code ec;
        std::filesystem::create_directories("debug", ec);
        std::ostringstream name;
        name << "sudoku_debug_" << now_local_compact_string();
#ifdef _WIN32
        name << "_pid" << GetCurrentProcessId();
#endif
        name << ".txt";
        std::filesystem::path p = std::filesystem::path("debug") / name.str();
        path_ = p.string();
        out_.open(path_, std::ios::out | std::ios::app);
        if (!out_) {
            return;
        }
        out_ << "=== Sudoku HPC Debug Log ===\n";
        out_ << "Started: " << now_local_string() << "\n";
        out_ << "Path: " << path_ << "\n";
        out_ << "----------------------------------------\n";
        out_.flush();
    }
};

DebugFileLogger& debug_logger() {
    static DebugFileLogger logger;
    return logger;
}

void log_info(std::string_view scope, std::string_view message) {
    debug_logger().log("INFO", scope, message);
}

void log_warn(std::string_view scope, std::string_view message) {
    debug_logger().log("WARN", scope, message);
}

void log_error(std::string_view scope, std::string_view message) {
    debug_logger().log("ERROR", scope, message);
}

struct BenchmarkTableARow {
    int lvl = 0;
    int solved_ok = 0;
    int analyzed = 0;
    uint64_t required_use = 0;
    uint64_t required_hit = 0;
    uint64_t reject_strategy = 0;
    double avg_solved_gen_ms = 0.0;
    double avg_dig_ms = 0.0;
    double avg_analyze_ms = 0.0;
    uint64_t backtracks = 0;
    int timeouts = 0;
    double success_rate = 0.0;
};

struct BenchmarkTableA2Row {
    int lvl = 0;
    int analyzed = 0;
    uint64_t medusa_hit = 0;
    uint64_t medusa_use = 0;
    uint64_t sue_hit = 0;
    uint64_t sue_use = 0;
    uint64_t msls_hit = 0;
    uint64_t msls_use = 0;
};

struct BenchmarkTableA3Row {
    std::string strategy;
    int lvl = 0;
    uint64_t max_attempts = 0;
    uint64_t analyzed = 0;
    uint64_t required_strategy_hits = 0;
    double analyzed_per_s = 0.0;
    uint64_t est_5min = 0;
    uint64_t written = 0;
};

struct BenchmarkTableBRow {
    std::string size;
    std::array<std::string, 8> levels{};
};

struct BenchmarkTableCRow {
    std::string size;
    int lvl = 0;
    double est_analyze_s = 0.0;
    double budget_s = 0.0;
    double peak_ram_mb = 0.0;
    std::string decision;
};

struct BenchmarkTableMicroprofilingRow {
    std::string stage;  // SolvedKernel, DigKernel, etc.
    int lvl = 0;
    uint64_t call_count = 0;
    double avg_elapsed_ms = 0.0;
    double total_elapsed_ms = 0.0;
    uint64_t min_elapsed_ns = 0;
    uint64_t max_elapsed_ns = 0;
    double pct_of_total = 0.0;  // % całkowitego czasu
};

std::string format_hhmmss(uint64_t total_s);  // Forward declaration

struct BenchmarkReportData {
    std::string title = "Porownanie strategii Sudoku (poziomy 1-8)";
    std::string probe_per_level = "0";
    std::string benchmark_mode = "manual";
    std::string cpu_model = "unknown";
    std::string ram_info = "unknown";
    std::string os_info = "unknown";
    std::string runtime_info = "C++20";
    std::string threads_info = "1";
    std::vector<BenchmarkTableARow> table_a;
    std::vector<BenchmarkTableA2Row> table_a2;
    std::vector<BenchmarkTableA3Row> table_a3;
    std::vector<BenchmarkTableBRow> table_b;
    std::vector<BenchmarkTableCRow> table_c;
    std::vector<BenchmarkTableMicroprofilingRow> table_microprofiling;  // NOWE: mikroprofiling
    std::vector<std::string> rules;
    uint64_t total_execution_s = 0;

    // Quality Gate - progi regresji
    bool quality_gate_enabled = false;
    double quality_gate_min_throughput_pct = 90.0;  // minimalny % throughput względem baseline
    double quality_gate_max_reject_strategy_pct = 20.0;  // maksymalny % reject_strategy
    bool quality_gate_passed = true;
    std::string quality_gate_message;

    // Metoda serializująca do tekstu
    std::string to_text() const {
        std::ostringstream oss;
        oss << "============================================================================\n";
        oss << title << "\n";
        oss << "============================================================================\n";
        oss << "Benchmark mode: " << benchmark_mode << " | Probe: " << probe_per_level << "\n";
        oss << "Threads: " << threads_info << " | Runtime: " << runtime_info << "\n";
        oss << "CPU: " << cpu_model << "\n";
        oss << "RAM: " << ram_info << " | OS: " << os_info << "\n";
        oss << "Total execution time: " << format_hhmmss(total_execution_s) << "\n\n";
        
        oss << "TABLE A: Strategy Performance\n";
        oss << "----------------------------\n";
        for (const auto& row : table_a) {
            oss << "Lvl " << row.lvl << ": solved=" << row.solved_ok 
                << ", analyzed=" << row.analyzed 
                << ", success_rate=" << std::fixed << std::setprecision(1) << row.success_rate << "%\n";
        }
        oss << "\n";
        
        oss << "TABLE A3: Required Strategy\n";
        oss << "---------------------------\n";
        for (const auto& row : table_a3) {
            oss << row.strategy << " (L" << row.lvl << "): analyzed=" << row.analyzed 
                << ", written=" << row.written << "\n";
        }
        oss << "\n";
        
        if (!table_microprofiling.empty()) {
            oss << "MICROPROFILING\n";
            oss << "--------------\n";
            for (const auto& row : table_microprofiling) {
                oss << row.stage << " (L" << row.lvl << "): avg=" << std::fixed << std::setprecision(3) 
                    << row.avg_elapsed_ms << "ms, total=" << row.total_elapsed_ms << "ms\n";
            }
            oss << "\n";
        }
        
        if (!rules.empty()) {
            oss << "RULES:\n";
            for (const auto& rule : rules) {
                oss << "  - " << rule << "\n";
            }
        }
        
        return oss.str();
    }
};

std::string format_hhmmss(uint64_t total_s) {
    const uint64_t h = total_s / 3600;
    const uint64_t m = (total_s % 3600) / 60;
    const uint64_t s = total_s % 60;
    std::ostringstream oss;
    oss << std::setw(2) << std::setfill('0') << h << "h "
        << std::setw(2) << std::setfill('0') << m << "m "
        << std::setw(2) << std::setfill('0') << s << "s";
    return oss.str();
}

double process_current_ram_mb() {
#ifdef _WIN32
    PROCESS_MEMORY_COUNTERS_EX pmc{};
    if (GetProcessMemoryInfo(GetCurrentProcess(), reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmc), sizeof(pmc))) {
        return static_cast<double>(pmc.WorkingSetSize) / (1024.0 * 1024.0);
    }
#endif
    return 0.0;
}

double process_peak_ram_mb() {
#ifdef _WIN32
    PROCESS_MEMORY_COUNTERS_EX pmc{};
    if (GetProcessMemoryInfo(GetCurrentProcess(), reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmc), sizeof(pmc))) {
        return static_cast<double>(pmc.PeakWorkingSetSize) / (1024.0 * 1024.0);
    }
#endif
    return 0.0;
}

std::string format_mb(double mb) {
    return format_fixed(mb, 1) + " MB";
}

std::string detect_cpu_model() {
#ifdef _WIN32
    HKEY key = nullptr;
    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",
            0,
            KEY_QUERY_VALUE,
            &key) == ERROR_SUCCESS) {
        wchar_t value[256]{};
        DWORD type = 0;
        DWORD size = sizeof(value);
        const LONG rc = RegQueryValueExW(
            key,
            L"ProcessorNameString",
            nullptr,
            &type,
            reinterpret_cast<LPBYTE>(value),
            &size);
        RegCloseKey(key);
        if (rc == ERROR_SUCCESS && (type == REG_SZ || type == REG_EXPAND_SZ)) {
            const int len = WideCharToMultiByte(CP_UTF8, 0, value, -1, nullptr, 0, nullptr, nullptr);
            if (len > 1) {
                std::string out(static_cast<size_t>(len), '\0');
                WideCharToMultiByte(CP_UTF8, 0, value, -1, out.data(), len, nullptr, nullptr);
                out.resize(static_cast<size_t>(len - 1));
                return out;
            }
        }
    }
#endif
    return "unknown";
}

std::string detect_ram_info() {
#ifdef _WIN32
    MEMORYSTATUSEX msx{};
    msx.dwLength = sizeof(msx);
    if (GlobalMemoryStatusEx(&msx)) {
        const double total_mb = static_cast<double>(msx.ullTotalPhys) / (1024.0 * 1024.0);
        const double avail_mb = static_cast<double>(msx.ullAvailPhys) / (1024.0 * 1024.0);
        return "total=" + format_mb(total_mb) + ", avail=" + format_mb(avail_mb);
    }
#endif
    return "unknown";
}

std::string detect_os_info() {
#ifdef _WIN32
    using RtlGetVersionFn = LONG(WINAPI*)(PRTL_OSVERSIONINFOW);
    HMODULE ntdll = GetModuleHandleW(L"ntdll.dll");
    if (ntdll != nullptr) {
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-function-type"
#endif
        auto rtl_get_version = reinterpret_cast<RtlGetVersionFn>(GetProcAddress(ntdll, "RtlGetVersion"));
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
        if (rtl_get_version != nullptr) {
            RTL_OSVERSIONINFOW osvi{};
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (rtl_get_version(&osvi) == 0) {
                std::ostringstream oss;
                oss << "Windows " << osvi.dwMajorVersion << "." << osvi.dwMinorVersion << " build " << osvi.dwBuildNumber;
                return oss.str();
            }
        }
    }

    OSVERSIONINFOW osvi{};
    osvi.dwOSVersionInfoSize = sizeof(osvi);
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4996)
#endif
    if (GetVersionExW(&osvi)) {
#ifdef _MSC_VER
#pragma warning(pop)
#endif
        std::ostringstream oss;
        oss << "Windows " << osvi.dwMajorVersion << "." << osvi.dwMinorVersion << " build " << osvi.dwBuildNumber;
        return oss.str();
    }
#endif
    return "unknown";
}

std::string detect_runtime_info() {
#if defined(_MSC_VER)
    return std::string("C++20 / MSVC ") + std::to_string(_MSC_VER);
#elif defined(__clang__)
    return std::string("C++20 / clang ") + __clang_version__;
#elif defined(__GNUC__)
    return std::string("C++20 / GCC ") + __VERSION__;
#else
    return "C++20";
#endif
}

class BenchmarkReportWriter {
public:
    static bool write_text_report(const BenchmarkReportData& data, const std::string& path, bool append = false) {
        std::ofstream out(path, append ? (std::ios::out | std::ios::app) : std::ios::out);
        if (!out) {
            log_error("BenchmarkReportWriter", "cannot open report file: " + path);
            return false;
        }

        out << data.title << "\n";
        out << "DateTime: " << now_local_string() << "\n";
        out << "Probe na poziom: " << data.probe_per_level << "\n";
        out << "Tryb benchmarku: " << data.benchmark_mode << "\n";
        out << "CPU: " << data.cpu_model << "\n";
        out << "RAM: " << data.ram_info << "\n";
        out << "OS: " << data.os_info << "\n";
        out << "Runtime: " << data.runtime_info << "\n";
        out << "Threads: " << data.threads_info << "\n\n";

        out << "Tabela A: Czas benchmarku (geometria aktualna)\n";
        out << render_table(
                   {
                       {"lvl", Align::Right},
                       {"solved_ok", Align::Right},
                       {"analyzed", Align::Right},
                       {"required_use", Align::Right},
                       {"required_hit/use", Align::Right},
                       {"reject_strategy", Align::Right},
                       {"avg_solved_gen_ms", Align::Right},
                       {"avg_dig_ms", Align::Right},
                       {"avg_analyze_ms", Align::Right},
                       {"backtracks", Align::Right},
                       {"timeouts", Align::Right},
                       {"success_rate", Align::Right},
                   },
                   to_rows_a(data.table_a))
            << "\n\n";

        out << "Tabela A2: Ciezkie strategie (geometria aktualna)\n";
        out << render_table(
                   {
                       {"lvl", Align::Right},
                       {"analyzed", Align::Right},
                       {"3DMedusa hit/use", Align::Right},
                       {"SueDeCoq hit/use", Align::Right},
                       {"MSLS hit/use", Align::Right},
                   },
                   to_rows_a2(data.table_a2))
            << "\n\n";

        out << "Tabela A3: Wymuszony test ciezkich strategii (required_strategy)\n";
        out << render_table(
                   {
                       {"strategy", Align::Left},
                       {"lvl", Align::Right},
                       {"max_attempts", Align::Right},
                       {"analyzed", Align::Right},
                       {"hit/use", Align::Right},
                       {"analyzed/s", Align::Right},
                       {"est_5min", Align::Right},
                       {"written", Align::Right},
                   },
                   to_rows_a3(data.table_a3))
            << "\n\n";

        out << "Tabela B: Min/Max clues (4x4..64x64, poziom 1-8)\n";
        out << render_table(
                   {
                       {"size", Align::Right},
                       {"L1", Align::Right},
                       {"L2", Align::Right},
                       {"L3", Align::Right},
                       {"L4", Align::Right},
                       {"L5", Align::Right},
                       {"L6", Align::Right},
                       {"L7", Align::Right},
                       {"L8", Align::Right},
                   },
                   to_rows_b(data.table_b))
            << "\n\n";

        out << "Tabela C: Szacowane czasy analyzera i RUN/SKIP dla testow\n";
        out << render_table(
                   {
                       {"size", Align::Right},
                       {"lvl", Align::Right},
                       {"est_analyze_s", Align::Right},
                       {"budget_s", Align::Right},
                       {"peak_ram_mb", Align::Right},
                       {"decyzja", Align::Left},
                   },
                   to_rows_c(data.table_c))
            << "\n\n";

        out << "Tabela D: Mikroprofiling etapow generatora\n";
        out << render_table(
                   {
                       {"stage", Align::Left},
                       {"lvl", Align::Right},
                       {"calls", Align::Right},
                       {"avg_ms", Align::Right},
                       {"total_ms", Align::Right},
                       {"min_ns", Align::Right},
                       {"max_ns", Align::Right},
                       {"pct_total", Align::Right},
                   },
                   to_rows_microprofiling(data.table_microprofiling))
            << "\n\n";

        out << "Regula testow (zaimplementowana):\n";
        for (const std::string& rule : data.rules) {
            out << "- " << rule << "\n";
        }
        out << "\n";
        out << "Total execution time: " << format_hhmmss(data.total_execution_s) << "\n";
        if (!out) {
            log_error("BenchmarkReportWriter", "write failed for report file: " + path);
            return false;
        }
        log_info("BenchmarkReportWriter", "report written: " + path);
        return true;
    }

private:
    static std::vector<std::vector<std::string>> to_rows_a(const std::vector<BenchmarkTableARow>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            out.push_back(
                {
                    std::to_string(r.lvl),
                    std::to_string(r.solved_ok),
                    std::to_string(r.analyzed),
                    std::to_string(r.required_use),
                    std::to_string(r.required_hit) + "/" + std::to_string(r.required_use),
                    std::to_string(r.reject_strategy),
                    format_fixed(r.avg_solved_gen_ms, 3),
                    format_fixed(r.avg_dig_ms, 3),
                    format_fixed(r.avg_analyze_ms, 3),
                    std::to_string(r.backtracks),
                    std::to_string(r.timeouts),
                    format_fixed(r.success_rate, 2),
                });
        }
        return out;
    }

    static std::vector<std::vector<std::string>> to_rows_a2(const std::vector<BenchmarkTableA2Row>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            out.push_back(
                {
                    std::to_string(r.lvl),
                    std::to_string(r.analyzed),
                    std::to_string(r.medusa_hit) + "/" + std::to_string(r.medusa_use),
                    std::to_string(r.sue_hit) + "/" + std::to_string(r.sue_use),
                    std::to_string(r.msls_hit) + "/" + std::to_string(r.msls_use),
                });
        }
        return out;
    }

    static std::vector<std::vector<std::string>> to_rows_a3(const std::vector<BenchmarkTableA3Row>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            out.push_back(
                {
                    r.strategy,
                    std::to_string(r.lvl),
                    std::to_string(r.max_attempts),
                    std::to_string(r.analyzed),
                    std::to_string(r.required_strategy_hits) + "/" + std::to_string(r.analyzed),
                    format_fixed(r.analyzed_per_s, 2),
                    std::to_string(r.est_5min),
                    std::to_string(r.written),
                });
        }
        return out;
    }

    static std::vector<std::vector<std::string>> to_rows_b(const std::vector<BenchmarkTableBRow>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            std::vector<std::string> row;
            row.reserve(9);
            row.push_back(r.size);
            for (const std::string& lv : r.levels) {
                row.push_back(lv);
            }
            out.push_back(std::move(row));
        }
        return out;
    }

    static std::vector<std::vector<std::string>> to_rows_c(const std::vector<BenchmarkTableCRow>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            out.push_back(
                {
                    r.size,
                    std::to_string(r.lvl),
                    format_fixed(r.est_analyze_s, 4),
                    format_fixed(r.budget_s, 4),
                    format_fixed(r.peak_ram_mb, 2),
                    r.decision,
                });
        }
        return out;
    }

    static std::vector<std::vector<std::string>> to_rows_microprofiling(const std::vector<BenchmarkTableMicroprofilingRow>& rows) {
        std::vector<std::vector<std::string>> out;
        out.reserve(rows.size());
        for (const auto& r : rows) {
            out.push_back(
                {
                    r.stage,
                    std::to_string(r.lvl),
                    std::to_string(r.call_count),
                    format_fixed(r.avg_elapsed_ms, 4),
                    format_fixed(r.total_elapsed_ms, 2),
                    std::to_string(r.min_elapsed_ns),
                    std::to_string(r.max_elapsed_ns),
                    format_fixed(r.pct_of_total, 2),
                });
        }
        return out;
    }
};

// ============================================================================
// MIKROPROFILING - Metryki wydajności per etap i per strategia
// ============================================================================

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\benchmark_profiles.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {
struct QualityGateResult {
    bool passed = true;
    double throughput_pct = 100.0;
    double reject_strategy_pct = 0.0;
    std::string message;
};

inline BenchmarkReportData run_benchmark_quality_gate_25s(
    const GenerateRunConfig& base_cfg,
    const BenchmarkReportData* baseline_data = nullptr) {

    BenchmarkReportData data;
    data.title = "Quality Gate Benchmark - Sudoku (poziomy 1-8)";
    data.probe_per_level = "25s";
    data.benchmark_mode = "quality_gate_25s";
    data.cpu_model = detect_cpu_model();
    data.ram_info = detect_ram_info();
    data.os_info = detect_os_info();
    data.runtime_info = detect_runtime_info();
    data.quality_gate_enabled = true;
    data.quality_gate_min_throughput_pct = 90.0;
    data.quality_gate_max_reject_strategy_pct = 20.0;

    const int thread_count = base_cfg.threads > 0 ? base_cfg.threads : std::max(1u, std::thread::hardware_concurrency());
    data.threads_info = std::to_string(thread_count);

    const auto total_start = std::chrono::steady_clock::now();

    uint64_t total_accepted = 0;
    uint64_t total_attempts = 0;
    uint64_t total_reject_strategy = 0;

    const int n = std::max(1, base_cfg.box_rows) * std::max(1, base_cfg.box_cols);
    const std::string grid_label = std::to_string(n) + "x" + std::to_string(n);

    std::cout << "\n[QUALITY GATE] size=" << grid_label << ", probe=25s/level\n";

    for (int lvl = 1; lvl <= 8; ++lvl) {
        GenerateRunConfig cfg = base_cfg;
        cfg.difficulty_level_required = lvl;
        cfg.required_strategy = default_required_strategy_for_level(lvl);
        cfg.target_puzzles = std::numeric_limits<uint64_t>::max() / 2;
        cfg.max_attempts_s = 25;
        cfg.pause_on_exit_windows = false;
        cfg.write_individual_files = false;
        cfg.output_folder = base_cfg.output_folder;
        cfg.output_file = "bench_qg_lvl_" + std::to_string(lvl) + "_" + grid_label + ".txt";

        std::cout << "[LEVEL " << lvl << "/8] Running benchmark... " << std::flush;
        const auto level_start = std::chrono::steady_clock::now();

        GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, {}, {});

        const auto level_elapsed = std::chrono::duration<double>(std::chrono::steady_clock::now() - level_start).count();
        (void)level_elapsed;

        total_accepted += result.accepted;
        total_attempts += result.attempts;
        total_reject_strategy += result.reject_strategy;

        BenchmarkTableARow row_a;
        row_a.lvl = lvl;
        row_a.solved_ok = static_cast<int>(result.accepted);
        row_a.analyzed = static_cast<int>(result.attempts);
        row_a.required_use = result.analyzed_required_strategy;
        row_a.required_hit = result.required_strategy_hits;
        row_a.reject_strategy = result.reject_strategy;
        row_a.avg_solved_gen_ms = result.accepted > 0 ? (result.elapsed_s * 1000.0) / static_cast<double>(result.accepted) : 0.0;
        row_a.avg_dig_ms = 0.0;
        row_a.avg_analyze_ms = result.attempts > 0 ? (result.elapsed_s * 1000.0) / static_cast<double>(result.attempts) : 0.0;
        row_a.backtracks = result.reject_logic;
        row_a.timeouts = result.elapsed_s + 0.05 >= static_cast<double>(cfg.max_attempts_s) ? 1 : 0;
        row_a.success_rate = result.attempts > 0 ? (100.0 * static_cast<double>(result.accepted) / static_cast<double>(result.attempts)) : 0.0;
        data.table_a.push_back(row_a);

        double throughput_vs_baseline = 100.0;
        if (baseline_data != nullptr && !baseline_data->table_a.empty()) {
            const auto& baseline_row = baseline_data->table_a[static_cast<size_t>(lvl - 1)];
            if (baseline_row.solved_ok > 0) {
                throughput_vs_baseline = (100.0 * static_cast<double>(result.accepted)) / static_cast<double>(baseline_row.solved_ok);
            }
        }

        BenchmarkTableA2Row row_a2;
        row_a2.lvl = lvl;
        row_a2.analyzed = static_cast<int>(result.attempts);
        row_a2.medusa_hit = 0;
        row_a2.medusa_use = result.attempts;
        row_a2.sue_hit = 0;
        row_a2.sue_use = result.attempts;
        row_a2.msls_hit = 0;
        row_a2.msls_use = result.attempts;
        data.table_a2.push_back(row_a2);

        BenchmarkTableA3Row row_a3;
        row_a3.strategy = to_string(cfg.required_strategy);
        row_a3.lvl = lvl;
        row_a3.max_attempts = cfg.max_attempts;
        row_a3.analyzed = result.analyzed_required_strategy;
        row_a3.analyzed_per_s = result.analyzed_required_strategy > 0 ? (result.analyzed_required_strategy / result.elapsed_s) : 0.0;
        row_a3.est_5min = static_cast<uint64_t>(row_a3.analyzed_per_s * 300.0);
        row_a3.written = result.written_required_strategy;
        data.table_a3.push_back(row_a3);

        BenchmarkTableCRow row_c;
        row_c.size = grid_label;
        row_c.lvl = lvl;
        row_c.est_analyze_s = result.attempts > 0 ? (result.elapsed_s / static_cast<double>(result.attempts)) : 0.0;
        row_c.budget_s = static_cast<double>(cfg.max_attempts_s);
        row_c.peak_ram_mb = process_peak_ram_mb();
        row_c.decision = "RUN";
        data.table_c.push_back(row_c);

        std::cout << "accepted=" << result.accepted
                  << ", attempts=" << result.attempts
                  << ", throughput=" << std::fixed << std::setprecision(1) << throughput_vs_baseline << "%";
        if (throughput_vs_baseline < data.quality_gate_min_throughput_pct) {
            std::cout << " REGRESJA";
        }
        std::cout << "\n";
    }

    const double total_elapsed = std::chrono::duration<double>(std::chrono::steady_clock::now() - total_start).count();
    const double throughput = total_attempts > 0 ? (total_accepted / total_elapsed) : 0.0;
    const double reject_strategy_pct = total_attempts > 0 ? (100.0 * static_cast<double>(total_reject_strategy) / static_cast<double>(total_attempts)) : 0.0;

    double throughput_vs_baseline = 100.0;
    if (baseline_data != nullptr && !baseline_data->table_a.empty()) {
        uint64_t baseline_total = 0;
        for (const auto& row : baseline_data->table_a) {
            baseline_total += row.solved_ok;
        }
        if (baseline_total > 0) {
            throughput_vs_baseline = (100.0 * static_cast<double>(total_accepted)) / static_cast<double>(baseline_total);
        }
    }

    data.quality_gate_passed = true;
    std::ostringstream gate_msg;
    gate_msg << "Quality Gate: ";

    const bool throughput_ok = throughput_vs_baseline >= data.quality_gate_min_throughput_pct;
    const bool reject_ok = reject_strategy_pct <= data.quality_gate_max_reject_strategy_pct;

    if (!throughput_ok) {
        data.quality_gate_passed = false;
        gate_msg << "FAILED - Throughput " << std::fixed << std::setprecision(1) << throughput_vs_baseline
                 << "% < " << data.quality_gate_min_throughput_pct << "% (baseline)";
    }
    if (!reject_ok) {
        data.quality_gate_passed = false;
        if (!throughput_ok) gate_msg << "; ";
        else gate_msg << "FAILED - ";
        gate_msg << "Reject Strategy " << std::fixed << std::setprecision(1) << reject_strategy_pct
                 << "% > " << data.quality_gate_max_reject_strategy_pct << "%";
    }
    if (data.quality_gate_passed) {
        gate_msg << "PASSED - Throughput " << std::fixed << std::setprecision(1) << throughput_vs_baseline
                 << "%, Reject Strategy " << std::fixed << std::setprecision(1) << reject_strategy_pct << "%";
    }

    data.quality_gate_message = gate_msg.str();

    std::cout << "\n[QUALITY GATE SUMMARY]" << "\n";
    std::cout << "Total accepted: " << total_accepted << "\n";
    std::cout << "Total attempts: " << total_attempts << "\n";
    std::cout << "Total elapsed: " << std::fixed << std::setprecision(1) << total_elapsed << "s\n";
    std::cout << "Throughput: " << throughput << " puzzles/s\n";
    std::cout << "Throughput vs baseline: " << throughput_vs_baseline << "%\n";
    std::cout << "Reject Strategy: " << reject_strategy_pct << "%\n";
    std::cout << "Status: " << (data.quality_gate_passed ? "PASSED" : "FAILED") << "\n";

    data.rules = {
        "Quality Gate: profile 25s per poziom (8 poziomow).",
        "Przeglos regresji jesli: throughput < 90% baseline LUB reject_strategy > 20%.",
        "Unikalnosc: generic DLX limit=2.",
        "Kontrakt required_strategy: use=analyzed_required_strategy, hit=required_strategy_hits.",
    };

    data.total_execution_s = static_cast<uint64_t>(std::llround(total_elapsed));
    return data;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\board.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

#include "geometry.h"

namespace sudoku_hpc {
#if defined(__GNUC__) || defined(__clang__)
#define SUDOKU_FORCE_INLINE inline __attribute__((always_inline))
#define SUDOKU_LIKELY(x) (__builtin_expect(!!(x), 1))
#define SUDOKU_UNLIKELY(x) (__builtin_expect(!!(x), 0))
#else
#define SUDOKU_FORCE_INLINE inline
#define SUDOKU_LIKELY(x) (x)
#define SUDOKU_UNLIKELY(x) (x)
#endif

struct GenericTopology {
    int box_rows = 0;
    int box_cols = 0;
    int n = 0;
    int nn = 0;
    int box_rows_count = 0;
    int box_cols_count = 0;
    std::vector<int> cell_row;
    std::vector<int> cell_col;
    std::vector<int> cell_box;
    std::vector<uint32_t> cell_rcb_packed;
    std::vector<int> cell_center_sym;
    std::vector<int> houses_flat;
    std::vector<int> house_offsets;
    std::vector<std::vector<int>> houses;
    std::vector<std::vector<int>> peers;
    std::vector<int> peer_offsets;
    std::vector<int> peers_flat;

    static std::optional<GenericTopology> build(int box_rows, int box_cols) {
        if (box_rows <= 0 || box_cols <= 0) {
            return std::nullopt;
        }
        geometria::zainicjalizuj_geometrie();
        GenericTopology topo;
        topo.box_rows = box_rows;
        topo.box_cols = box_cols;
        topo.n = box_rows * box_cols;
        // Current runtime mask backend is uint64_t.
        if (topo.n < 4 || topo.n > 64) {
            return std::nullopt;
        }
        if (!geometria::czy_obslugiwana(topo.n, box_rows, box_cols)) {
            return std::nullopt;
        }
        topo.nn = topo.n * topo.n;
        topo.box_rows_count = topo.n / topo.box_rows;  // liczba bloków w pionie
        topo.box_cols_count = topo.n / topo.box_cols;  // liczba bloków w poziomie
        topo.cell_row.assign(static_cast<size_t>(topo.nn), 0);
        topo.cell_col.assign(static_cast<size_t>(topo.nn), 0);
        topo.cell_box.assign(static_cast<size_t>(topo.nn), 0);
        topo.cell_rcb_packed.assign(static_cast<size_t>(topo.nn), 0U);
        topo.cell_center_sym.assign(static_cast<size_t>(topo.nn), 0);
        topo.houses_flat.clear();
        topo.house_offsets.clear();
        topo.houses_flat.reserve(static_cast<size_t>(topo.n * topo.n * 3));
        topo.house_offsets.reserve(static_cast<size_t>(topo.n * 3 + 1));

        for (int idx = 0; idx < topo.nn; ++idx) {
            const int r = idx / topo.n;
            const int c = idx % topo.n;
            // Poprawny wzór na indeks bloku dla geometrii asymetrycznych
            const int b = (r / topo.box_rows) * topo.box_cols_count + (c / topo.box_cols);
            topo.cell_row[static_cast<size_t>(idx)] = r;
            topo.cell_col[static_cast<size_t>(idx)] = c;
            topo.cell_box[static_cast<size_t>(idx)] = b;
            const uint32_t packed = (static_cast<uint32_t>(r) & 63U) |
                                    ((static_cast<uint32_t>(c) & 63U) << 6U) |
                                    ((static_cast<uint32_t>(b) & 63U) << 12U);
            topo.cell_rcb_packed[static_cast<size_t>(idx)] = packed;
            const int sym_idx = (topo.n - 1 - r) * topo.n + (topo.n - 1 - c);
            topo.cell_center_sym[static_cast<size_t>(idx)] = sym_idx;
        }

        // Wiersze
        for (int r = 0; r < topo.n; ++r) {
            topo.house_offsets.push_back(static_cast<int>(topo.houses_flat.size()));
            for (int c = 0; c < topo.n; ++c) {
                topo.houses_flat.push_back(r * topo.n + c);
            }
        }
        // Kolumny
        for (int c = 0; c < topo.n; ++c) {
            topo.house_offsets.push_back(static_cast<int>(topo.houses_flat.size()));
            for (int r = 0; r < topo.n; ++r) {
                topo.houses_flat.push_back(r * topo.n + c);
            }
        }
        // Bloki
        for (int brg = 0; brg < topo.box_rows_count; ++brg) {
            for (int bcg = 0; bcg < topo.box_cols_count; ++bcg) {
                topo.house_offsets.push_back(static_cast<int>(topo.houses_flat.size()));
                for (int dr = 0; dr < topo.box_rows; ++dr) {
                    for (int dc = 0; dc < topo.box_cols; ++dc) {
                        const int r = brg * topo.box_rows + dr;
                        const int c = bcg * topo.box_cols + dc;
                        topo.houses_flat.push_back(r * topo.n + c);
                    }
                }
            }
        }
        topo.house_offsets.push_back(static_cast<int>(topo.houses_flat.size()));

        topo.peer_offsets.clear();
        topo.peers_flat.clear();
        topo.peer_offsets.reserve(static_cast<size_t>(topo.nn + 1));
        topo.peers_flat.reserve(static_cast<size_t>(topo.nn) * static_cast<size_t>(std::max(1, 3 * topo.n - 2)));
        std::vector<int> peer_mark(static_cast<size_t>(topo.nn), -1);
        int peer_stamp = 0;
        for (int idx = 0; idx < topo.nn; ++idx) {
            topo.peer_offsets.push_back(static_cast<int>(topo.peers_flat.size()));
            const int r = topo.cell_row[static_cast<size_t>(idx)];
            const int c = topo.cell_col[static_cast<size_t>(idx)];
            const int b = topo.cell_box[static_cast<size_t>(idx)];
            ++peer_stamp;
            auto push_peer = [&](int peer_idx) {
                if (peer_idx == idx) {
                    return;
                }
                int& mark = peer_mark[static_cast<size_t>(peer_idx)];
                if (mark == peer_stamp) {
                    return;
                }
                mark = peer_stamp;
                topo.peers_flat.push_back(peer_idx);
            };

            for (int c2 = 0; c2 < topo.n; ++c2) {
                push_peer(r * topo.n + c2);
            }
            for (int r2 = 0; r2 < topo.n; ++r2) {
                push_peer(r2 * topo.n + c);
            }
            const int brg = b / topo.box_cols_count;
            const int bcg = b % topo.box_cols_count;
            const int r0 = brg * topo.box_rows;
            const int c0 = bcg * topo.box_cols;
            for (int dr = 0; dr < topo.box_rows; ++dr) {
                for (int dc = 0; dc < topo.box_cols; ++dc) {
                    push_peer((r0 + dr) * topo.n + (c0 + dc));
                }
            }
        }
        topo.peer_offsets.push_back(static_cast<int>(topo.peers_flat.size()));
        return topo;
    }
};

struct alignas(64) GenericThreadScratch {
    int prepared_n = 0;
    int prepared_nn = 0;
    std::vector<int> order;
    std::vector<uint64_t> row_tmp;
    std::vector<uint64_t> col_tmp;
    std::vector<uint64_t> box_tmp;
    std::vector<int> row_count_tmp;
    std::vector<int> col_count_tmp;
    std::vector<int> box_count_tmp;
    std::vector<int> digit_count_tmp;

    void ensure(const GenericTopology& topo) {
        if (prepared_nn != topo.nn) {
            order.resize(static_cast<size_t>(topo.nn));
            prepared_nn = topo.nn;
        }
        if (prepared_n != topo.n) {
            row_tmp.resize(static_cast<size_t>(topo.n));
            col_tmp.resize(static_cast<size_t>(topo.n));
            box_tmp.resize(static_cast<size_t>(topo.n));
            row_count_tmp.resize(static_cast<size_t>(topo.n));
            col_count_tmp.resize(static_cast<size_t>(topo.n));
            box_count_tmp.resize(static_cast<size_t>(topo.n));
            digit_count_tmp.resize(static_cast<size_t>(topo.n));
            prepared_n = topo.n;
        }
    }
};

static thread_local GenericThreadScratch g_generic_tls{};

static GenericThreadScratch& generic_tls_for(const GenericTopology& topo) {
    g_generic_tls.ensure(topo);
    return g_generic_tls;
}

struct GenericBoard {
    const GenericTopology* topo = nullptr;
    uint64_t full_mask = 0;
    int empty_cells = 0;
    std::vector<uint16_t> values;
    std::vector<uint8_t> fixed;
    std::vector<uint64_t> row_used;
    std::vector<uint64_t> col_used;
    std::vector<uint64_t> box_used;

    static uint64_t full_mask_for_n(int n) {
        return n >= 64 ? ~0ULL : ((1ULL << n) - 1ULL);
    }

    static SUDOKU_FORCE_INLINE int packed_row(uint32_t rcb) {
        return static_cast<int>(rcb & 63U);
    }
    static SUDOKU_FORCE_INLINE int packed_col(uint32_t rcb) {
        return static_cast<int>((rcb >> 6U) & 63U);
    }
    static SUDOKU_FORCE_INLINE int packed_box(uint32_t rcb) {
        return static_cast<int>((rcb >> 12U) & 63U);
    }

    SUDOKU_FORCE_INLINE uint64_t used_mask_for_packed(uint32_t rcb) const {
        const int r = packed_row(rcb);
        const int c = packed_col(rcb);
        const int b = packed_box(rcb);
        return row_used[static_cast<size_t>(r)] |
               col_used[static_cast<size_t>(c)] |
               box_used[static_cast<size_t>(b)];
    }

    SUDOKU_FORCE_INLINE uint64_t candidate_mask_for_packed(uint32_t rcb) const {
        return (~used_mask_for_packed(rcb)) & full_mask;
    }

    void reset(const GenericTopology& t) {
        topo = &t;
        full_mask = full_mask_for_n(t.n);
        empty_cells = t.nn;
        values.resize(static_cast<size_t>(t.nn));
        fixed.resize(static_cast<size_t>(t.nn));
        row_used.resize(static_cast<size_t>(t.n));
        col_used.resize(static_cast<size_t>(t.n));
        box_used.resize(static_cast<size_t>(t.n));
        std::fill(values.begin(), values.end(), 0);
        std::fill(fixed.begin(), fixed.end(), 0);
        std::fill(row_used.begin(), row_used.end(), 0ULL);
        std::fill(col_used.begin(), col_used.end(), 0ULL);
        std::fill(box_used.begin(), box_used.end(), 0ULL);
    }

    SUDOKU_FORCE_INLINE uint64_t candidate_mask_for_idx(int idx) const {
        if (SUDOKU_UNLIKELY(values[static_cast<size_t>(idx)] != 0)) {
            return 0ULL;
        }
        const uint32_t rcb = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        return candidate_mask_for_packed(rcb);
    }

    SUDOKU_FORCE_INLINE bool can_place(int idx, int digit) const {
        if (SUDOKU_UNLIKELY(values[static_cast<size_t>(idx)] != 0)) return false;
        const uint64_t bit = (1ULL << (digit - 1));
        const uint32_t rcb = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        return (used_mask_for_packed(rcb) & bit) == 0ULL;
    }

    SUDOKU_FORCE_INLINE void place(int idx, int digit, bool mark_fixed = false) {
        const uint64_t bit = (1ULL << (digit - 1));
        const uint32_t rcb = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(rcb);
        const int c = packed_col(rcb);
        const int b = packed_box(rcb);
        const uint16_t prev = values[static_cast<size_t>(idx)];
        if (SUDOKU_LIKELY(prev == 0)) {
            --empty_cells;
        }
        values[static_cast<size_t>(idx)] = static_cast<uint16_t>(digit);
        row_used[static_cast<size_t>(r)] |= bit;
        col_used[static_cast<size_t>(c)] |= bit;
        box_used[static_cast<size_t>(b)] |= bit;
        if (SUDOKU_UNLIKELY(mark_fixed)) {
            fixed[static_cast<size_t>(idx)] = 1;
        }
    }

    SUDOKU_FORCE_INLINE void unplace(int idx, int digit) {
        const uint64_t bit = (1ULL << (digit - 1));
        const uint32_t rcb = topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = packed_row(rcb);
        const int c = packed_col(rcb);
        const int b = packed_box(rcb);
        if (SUDOKU_UNLIKELY(values[static_cast<size_t>(idx)] != 0)) {
            ++empty_cells;
        }
        values[static_cast<size_t>(idx)] = 0;
        row_used[static_cast<size_t>(r)] &= ~bit;
        col_used[static_cast<size_t>(c)] &= ~bit;
        box_used[static_cast<size_t>(b)] &= ~bit;
    }

    bool init_from_puzzle(const std::vector<uint16_t>& puzzle, bool mark_fixed = true) {
        if (topo == nullptr || static_cast<int>(puzzle.size()) != topo->nn) {
            return false;
        }
        const GenericTopology& t = *topo;
        full_mask = full_mask_for_n(t.n);

        values.resize(static_cast<size_t>(t.nn));
        fixed.resize(static_cast<size_t>(t.nn));
        row_used.resize(static_cast<size_t>(t.n));
        col_used.resize(static_cast<size_t>(t.n));
        box_used.resize(static_cast<size_t>(t.n));
        std::fill(row_used.begin(), row_used.end(), 0ULL);
        std::fill(col_used.begin(), col_used.end(), 0ULL);
        std::fill(box_used.begin(), box_used.end(), 0ULL);
        if (mark_fixed) {
            std::fill(fixed.begin(), fixed.end(), 0);
        }
        const uint16_t* const puzzle_ptr = puzzle.data();
        uint16_t* const values_ptr = values.data();
        uint8_t* const fixed_ptr = fixed.data();
        uint64_t* const row_ptr = row_used.data();
        uint64_t* const col_ptr = col_used.data();
        uint64_t* const box_ptr = box_used.data();
        const uint32_t* const packed_ptr = t.cell_rcb_packed.data();

        empty_cells = 0;
        if (mark_fixed) {
            for (int idx = 0; idx < t.nn; ++idx) {
                const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
                values_ptr[static_cast<size_t>(idx)] = static_cast<uint16_t>(d);
                if (d == 0) {
                    ++empty_cells;
                    continue;
                }
                if (d < 1 || d > t.n) {
                    return false;
                }
                const uint64_t bit = (1ULL << (d - 1));
                const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
                const int r = packed_row(rcb);
                const int c = packed_col(rcb);
                const int b = packed_box(rcb);
                const uint64_t used = row_ptr[static_cast<size_t>(r)] |
                                      col_ptr[static_cast<size_t>(c)] |
                                      box_ptr[static_cast<size_t>(b)];
                if ((used & bit) != 0ULL) {
                    return false;
                }
                row_ptr[static_cast<size_t>(r)] |= bit;
                col_ptr[static_cast<size_t>(c)] |= bit;
                box_ptr[static_cast<size_t>(b)] |= bit;
                fixed_ptr[static_cast<size_t>(idx)] = 1;
            }
        } else {
            for (int idx = 0; idx < t.nn; ++idx) {
                const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
                values_ptr[static_cast<size_t>(idx)] = static_cast<uint16_t>(d);
                if (d == 0) {
                    ++empty_cells;
                    continue;
                }
                if (d < 1 || d > t.n) {
                    return false;
                }
                const uint64_t bit = (1ULL << (d - 1));
                const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
                const int r = packed_row(rcb);
                const int c = packed_col(rcb);
                const int b = packed_box(rcb);
                const uint64_t used = row_ptr[static_cast<size_t>(r)] |
                                      col_ptr[static_cast<size_t>(c)] |
                                      box_ptr[static_cast<size_t>(b)];
                if ((used & bit) != 0ULL) {
                    return false;
                }
                row_ptr[static_cast<size_t>(r)] |= bit;
                col_ptr[static_cast<size_t>(c)] |= bit;
                box_ptr[static_cast<size_t>(b)] |= bit;
            }
        }
        return true;
    }

    bool all_filled() const {
        return empty_cells == 0;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\config.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {

    constexpr int kN = 9;
    constexpr int kNN = 81;
    constexpr int kBoxRows = 3;
    constexpr int kBoxCols = 3;
    constexpr uint64_t kFullMask = static_cast<uint64_t>((1ULL << kN) - 1ULL);
            
enum class RequiredStrategy {
    None,
    NakedSingle,
    HiddenSingle,
    PointingPairs,
    BoxLineReduction,
    NakedPair,
    HiddenPair,
    NakedTriple,
    HiddenTriple,
    NakedQuad,
    HiddenQuad,
    XWing,
    YWing,
    Skyscraper,
    TwoStringKite,
    EmptyRectangle,
    RemotePairs,
    Swordfish,
    FinnedXWingSashimi,
    SimpleColoring,
    BUGPlusOne,
    UniqueRectangle,
    XYZWing,
    WWing,
    Jellyfish,
    XChain,
    XYChain,
    WXYZWing,
    FinnedSwordfishJellyfish,
    ALSXZ,
    UniqueLoop,
    AvoidableRectangle,
    BivalueOddagon,
    UniqueRectangleExtended,
    HiddenUniqueRectangle,
    BUGType2,
    BUGType3,
    BUGType4,
    BorescoperQiuDeadlyPattern,
    Medusa3D,
    AIC,
    GroupedAIC,
    GroupedXCycle,
    ContinuousNiceLoop,
    ALSXYWing,
    ALSChain,
    SueDeCoq,
    DeathBlossom,
    FrankenFish,
    MutantFish,
    KrakenFish,
    AlignedPairExclusion,
    AlignedTripleExclusion,
    ALSAIC,
    MSLS,
    Exocet,
    SeniorExocet,
    SKLoop,
    PatternOverlayMethod,
    ForcingChains,
    DynamicForcingChains,
    Squirmbag,
    Backtracking
};

std::string to_string(RequiredStrategy value) {
    switch (value) {
    case RequiredStrategy::None:
        return "(none)";
    case RequiredStrategy::NakedSingle:
        return "NakedSingle";
    case RequiredStrategy::HiddenSingle:
        return "HiddenSingle";
    case RequiredStrategy::PointingPairs:
        return "PointingPairs";
    case RequiredStrategy::BoxLineReduction:
        return "BoxLineReduction";
    case RequiredStrategy::NakedPair:
        return "NakedPair";
    case RequiredStrategy::HiddenPair:
        return "HiddenPair";
    case RequiredStrategy::NakedTriple:
        return "NakedTriple";
    case RequiredStrategy::HiddenTriple:
        return "HiddenTriple";
    case RequiredStrategy::NakedQuad:
        return "NakedQuad";
    case RequiredStrategy::HiddenQuad:
        return "HiddenQuad";
    case RequiredStrategy::XWing:
        return "XWing";
    case RequiredStrategy::YWing:
        return "YWing";
    case RequiredStrategy::Skyscraper:
        return "Skyscraper";
    case RequiredStrategy::TwoStringKite:
        return "TwoStringKite";
    case RequiredStrategy::EmptyRectangle:
        return "EmptyRectangle";
    case RequiredStrategy::RemotePairs:
        return "RemotePairs";
    case RequiredStrategy::Swordfish:
        return "Swordfish";
    case RequiredStrategy::FinnedXWingSashimi:
        return "FinnedXWingSashimi";
    case RequiredStrategy::SimpleColoring:
        return "SimpleColoring";
    case RequiredStrategy::BUGPlusOne:
        return "BUGPlusOne";
    case RequiredStrategy::UniqueRectangle:
        return "UniqueRectangle";
    case RequiredStrategy::XYZWing:
        return "XYZWing";
    case RequiredStrategy::WWing:
        return "WWing";
    case RequiredStrategy::Jellyfish:
        return "Jellyfish";
    case RequiredStrategy::XChain:
        return "XChain";
    case RequiredStrategy::XYChain:
        return "XYChain";
    case RequiredStrategy::WXYZWing:
        return "WXYZWing";
    case RequiredStrategy::FinnedSwordfishJellyfish:
        return "FinnedSwordfishJellyfish";
    case RequiredStrategy::ALSXZ:
        return "ALSXZ";
    case RequiredStrategy::UniqueLoop:
        return "UniqueLoop";
    case RequiredStrategy::AvoidableRectangle:
        return "AvoidableRectangle";
    case RequiredStrategy::BivalueOddagon:
        return "BivalueOddagon";
    case RequiredStrategy::UniqueRectangleExtended:
        return "UniqueRectangleExtended";
    case RequiredStrategy::HiddenUniqueRectangle:
        return "HiddenUniqueRectangle";
    case RequiredStrategy::BUGType2:
        return "BUGType2";
    case RequiredStrategy::BUGType3:
        return "BUGType3";
    case RequiredStrategy::BUGType4:
        return "BUGType4";
    case RequiredStrategy::BorescoperQiuDeadlyPattern:
        return "BorescoperQiuDeadlyPattern";
    case RequiredStrategy::Medusa3D:
        return "Medusa3D";
    case RequiredStrategy::AIC:
        return "AIC";
    case RequiredStrategy::GroupedAIC:
        return "GroupedAIC";
    case RequiredStrategy::GroupedXCycle:
        return "GroupedXCycle";
    case RequiredStrategy::ContinuousNiceLoop:
        return "ContinuousNiceLoop";
    case RequiredStrategy::ALSXYWing:
        return "ALSXYWing";
    case RequiredStrategy::ALSChain:
        return "ALSChain";
    case RequiredStrategy::SueDeCoq:
        return "SueDeCoq";
    case RequiredStrategy::DeathBlossom:
        return "DeathBlossom";
    case RequiredStrategy::FrankenFish:
        return "FrankenFish";
    case RequiredStrategy::MutantFish:
        return "MutantFish";
    case RequiredStrategy::KrakenFish:
        return "KrakenFish";
    case RequiredStrategy::AlignedPairExclusion:
        return "AlignedPairExclusion";
    case RequiredStrategy::AlignedTripleExclusion:
        return "AlignedTripleExclusion";
    case RequiredStrategy::ALSAIC:
        return "ALSAIC";
    case RequiredStrategy::MSLS:
        return "MSLS";
    case RequiredStrategy::Exocet:
        return "Exocet";
    case RequiredStrategy::SeniorExocet:
        return "SeniorExocet";
    case RequiredStrategy::SKLoop:
        return "SKLoop";
    case RequiredStrategy::PatternOverlayMethod:
        return "PatternOverlayMethod";
    case RequiredStrategy::ForcingChains:
        return "ForcingChains";
    case RequiredStrategy::DynamicForcingChains:
        return "DynamicForcingChains";
    case RequiredStrategy::Squirmbag:
        return "Squirmbag";
    case RequiredStrategy::Backtracking:
        return "Backtracking";
    default:
        return "Unknown";
    }
}

struct GenerateRunConfig {
    int box_rows = 3;
    int box_cols = 3;
    uint64_t target_puzzles = 100;
    int min_clues = 24;
    int max_clues = 40;
    int difficulty_level_required = 1;
    RequiredStrategy required_strategy = RequiredStrategy::None;
    bool require_unique = true;
    bool strict_logical = true;
    int threads = 0;
    long long seed = 0;
    int reseed_interval_s = 1;
    double attempt_time_budget_s = 0.0;
    uint64_t attempt_node_budget = 0;
    uint64_t max_attempts = 0;
    uint64_t max_attempts_s = 0;
    uint64_t max_total_time_s = 0;  // Globalny limit czasu na caĹ‚e uruchomienie (0=bez limitu)
    bool symmetry_center = false;
    bool pause_on_exit_windows = true;
    bool write_individual_files = true;
    bool benchmark_profiles_40s = false;
    int benchmark_seconds_per_profile = 40;
    bool enable_quality_contract = true;
    bool enable_replay_validation = true;
    bool enable_distribution_filter = true;
    double uniqueness_confirm_budget_s = 1.5;
    uint64_t uniqueness_confirm_budget_nodes = 1500000;
    std::string profile_mode_policy = "adaptive";  // adaptive|full
    int full_for_n_ge = 25;  // For adaptive policy: full pipeline for n>=full_for_n_ge
    bool vip_mode = false;
    bool vip_contract_strict = false;
    std::string cpu_backend_policy = "auto";  // auto|scalar|avx2|avx512
    bool cpu_dispatch_report = false;
    std::string asym_heuristics_mode = "balanced";  // off|balanced|aggressive
    bool adaptive_budget = false;
    std::string difficulty_engine = "standard";  // standard|vip
    std::string vip_score_profile = "standard";  // standard|strict|ultra
    std::string vip_trace_level = "basic";  // basic|full
    std::string vip_min_grade_by_geometry_path = "";
    std::string vip_grade_target = "gold";  // bronze|silver|gold|platinum
    std::string difficulty_trace_out = "";
    std::string vip_signature_out = "";
    bool perf_ab_suite = false;
    std::string perf_report_out = "plikiTMP/porownania/perf_ab_suite.txt";
    std::string perf_csv_out = "plikiTMP/porownania/perf_ab_suite.csv";
    std::string perf_baseline_csv = "";
    bool stage_start = false;
    bool stage_end = false;
    std::string stage_name = "";
    std::string stage_report_out = "plikiTMP/porownania/stage_summary.txt";
    std::string benchmark_output_file = "plikiTMP/porownanie.txt";
    std::string output_folder = "generated_sudoku_files";
    std::string output_file = "generated_sudoku.txt";
    bool force_new_seed_per_attempt = true; // Zaznacz jako domyĹ›lnie wĹ‚Ä…czone
    bool pattern_forcing_enabled = false;
    int pattern_forcing_tries = 6;
    int pattern_forcing_anchor_count = 0; // 0=auto
    bool pattern_forcing_lock_anchors = true;
    bool mcts_digger_enabled = false;
    int mcts_digger_iterations = 0; // 0=auto
    double mcts_ucb_c = 1.41;
    int mcts_fail_cap = 192;
    int mcts_basic_logic_level = 5;
    std::string mcts_tuning_profile = "auto"; // auto|off|p7|p8
};

struct GenerateRunResult {
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t attempts_total = 0;
    uint64_t analyzed_required_strategy = 0;
    uint64_t required_strategy_hits = 0;
    uint64_t written_required_strategy = 0;
    uint64_t rejected = 0;
    uint64_t reject_prefilter = 0;
    uint64_t reject_logic = 0;
    uint64_t reject_uniqueness = 0;
    uint64_t reject_strategy = 0;
    uint64_t reject_replay = 0;
    uint64_t reject_distribution_bias = 0;
    uint64_t reject_uniqueness_budget = 0;
    uint64_t timeout_global = 0;  // Liczba timeoutĂłw globalnych
    uint64_t timeout_per_attempt = 0;  // Liczba timeoutĂłw per-attempt
    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    double uniqueness_elapsed_ms = 0.0;
    double uniqueness_avg_ms = 0.0;
    uint64_t logic_steps_total = 0;
    uint64_t strategy_naked_use = 0;
    uint64_t strategy_naked_hit = 0;
    uint64_t strategy_hidden_use = 0;
    uint64_t strategy_hidden_hit = 0;
    std::string cpu_backend_selected = "scalar";
    double kernel_time_ms = 0.0;
    uint64_t kernel_calls = 0;
    double backend_efficiency_score = 0.0;
    double asymmetry_efficiency_index = 0.0;
    double vip_score = 0.0;
    std::string vip_grade = "none";
    bool vip_contract_ok = true;
    std::string vip_contract_fail_reason = "";
    std::string vip_score_breakdown_json = "{}";
    uint64_t premium_signature = 0;
    uint64_t premium_signature_v2 = 0;
    double elapsed_s = 0.0;
    double accepted_per_sec = 0.0;
    double avg_clues = 0.0;
    std::array<uint64_t, 10> histogram_levels{};
    std::array<uint64_t, 64> histogram_strategies{};
};

} // namespace sudoku_hpc





==============================================================================
PLIK: Sources\dlx.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <bit>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include <vector>

#include "kernels.h"

#if defined(__x86_64__) || defined(__i386__)
#include <immintrin.h>
#endif

namespace sudoku_hpc {

struct GenericUniquenessCounter {
    static constexpr int kUnifiedMaxN = 64;

    struct UnifiedWideDlx {
        int n = 0;
        int nn = 0;
        int rows = 0;
        int cols = 0;
        int row_words = 0;
        int col_words = 0;
        int max_depth = 0;

        std::vector<std::array<uint16_t, 4>> row_cols;
        std::vector<uint64_t> col_rows_bits; // [cols * row_words]

        // Mutable state for current search run.
        std::vector<uint64_t> active_rows;    // [row_words]
        std::vector<uint64_t> uncovered_cols; // [col_words]

        // Undo logs (value snapshots).
        std::vector<uint16_t> undo_active_idx;
        std::vector<uint64_t> undo_active_old;
        std::vector<uint16_t> undo_col_idx;
        std::vector<uint64_t> undo_col_old;

        // Recursion-local best candidate rows buffer.
        // Layout: [depth0 row_words][depth1 row_words]...[depth(max_depth-1) row_words]
        std::vector<uint64_t> recursion_stack;
        std::vector<int> solution_rows;
        int solution_depth = 0;

        bool matches(const GenericTopology& topo) const {
            return n == topo.n && nn == topo.nn;
        }
    };

    mutable UnifiedWideDlx ws_;

    static int row_id_for(int n, int r, int c, int d0) {
        return ((r * n + c) * n) + d0;
    }

    static inline int bit_ctz_u64(uint64_t v) {
#if (defined(__x86_64__) || defined(__i386__)) && defined(__BMI__)
        return static_cast<int>(_tzcnt_u64(v));
#else
        return static_cast<int>(std::countr_zero(v));
#endif
    }

    static inline uint64_t bit_clear_lsb_u64(uint64_t v) {
#if (defined(__x86_64__) || defined(__i386__)) && defined(__BMI__)
        return _blsr_u64(v);
#else
        return v & (v - 1ULL);
#endif
    }

    void build_if_needed(const GenericTopology& topo) const {
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) {
            return;
        }
        if (ws_.matches(topo)) {
            return;
        }

        UnifiedWideDlx w;
        w.n = topo.n;
        w.nn = topo.nn;
        w.rows = topo.n * topo.n * topo.n;
        w.cols = 4 * topo.nn;
        w.row_words = (w.rows + 63) / 64;
        w.col_words = (w.cols + 63) / 64;
        w.max_depth = topo.nn + 1;

        w.row_cols.resize(static_cast<size_t>(w.rows));
        w.col_rows_bits.assign(static_cast<size_t>(w.cols) * static_cast<size_t>(w.row_words), 0ULL);
        w.active_rows.assign(static_cast<size_t>(w.row_words), 0ULL);
        w.uncovered_cols.assign(static_cast<size_t>(w.col_words), 0ULL);

        // Conservative reserves to reduce re-allocations during deep search.
        const size_t reserve_words = static_cast<size_t>(w.row_words) * 16ULL;
        w.undo_active_idx.reserve(reserve_words);
        w.undo_active_old.reserve(reserve_words);
        w.undo_col_idx.reserve(static_cast<size_t>(w.col_words) * 16ULL);
        w.undo_col_old.reserve(static_cast<size_t>(w.col_words) * 16ULL);

        w.recursion_stack.assign(static_cast<size_t>(w.max_depth) * static_cast<size_t>(w.row_words), 0ULL);
        w.solution_rows.assign(static_cast<size_t>(w.max_depth), -1);
        w.solution_depth = 0;

        for (int r = 0; r < topo.n; ++r) {
            for (int c = 0; c < topo.n; ++c) {
                const int b = topo.cell_box[static_cast<size_t>(r * topo.n + c)];
                for (int d0 = 0; d0 < topo.n; ++d0) {
                    const int row_id = row_id_for(topo.n, r, c, d0);
                    const int col_cell = r * topo.n + c;
                    const int col_row_digit = topo.nn + r * topo.n + d0;
                    const int col_col_digit = 2 * topo.nn + c * topo.n + d0;
                    const int col_box_digit = 3 * topo.nn + b * topo.n + d0;

                    w.row_cols[static_cast<size_t>(row_id)] = {
                        static_cast<uint16_t>(col_cell),
                        static_cast<uint16_t>(col_row_digit),
                        static_cast<uint16_t>(col_col_digit),
                        static_cast<uint16_t>(col_box_digit)};

                    const int rw = row_id >> 6;
                    const uint64_t bit = 1ULL << (row_id & 63);
                    w.col_rows_bits[static_cast<size_t>(col_cell) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_row_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_col_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                    w.col_rows_bits[static_cast<size_t>(col_box_digit) * static_cast<size_t>(w.row_words) + static_cast<size_t>(rw)] |= bit;
                }
            }
        }

        ws_ = std::move(w);
    }

    void rollback_to(size_t active_marker, size_t col_marker) const {
        while (ws_.undo_active_idx.size() > active_marker) {
            const uint16_t idx = ws_.undo_active_idx.back();
            const uint64_t old = ws_.undo_active_old.back();
            ws_.undo_active_idx.pop_back();
            ws_.undo_active_old.pop_back();
            ws_.active_rows[static_cast<size_t>(idx)] = old;
        }
        while (ws_.undo_col_idx.size() > col_marker) {
            const uint16_t idx = ws_.undo_col_idx.back();
            const uint64_t old = ws_.undo_col_old.back();
            ws_.undo_col_idx.pop_back();
            ws_.undo_col_old.pop_back();
            ws_.uncovered_cols[static_cast<size_t>(idx)] = old;
        }
    }

    bool apply_row(int row_id) const {
        const int rw = row_id >> 6;
        const uint64_t rbit = 1ULL << (row_id & 63);
        if ((ws_.active_rows[static_cast<size_t>(rw)] & rbit) == 0ULL) {
            return false;
        }

        const auto& cols4 = ws_.row_cols[static_cast<size_t>(row_id)];
        for (int k = 0; k < 4; ++k) {
            const int col = static_cast<int>(cols4[static_cast<size_t>(k)]);
            const int cw = col >> 6;
            const uint64_t cbit = 1ULL << (col & 63);
            if ((ws_.uncovered_cols[static_cast<size_t>(cw)] & cbit) == 0ULL) {
                return false;
            }
        }

        for (int k = 0; k < 4; ++k) {
            const int col = static_cast<int>(cols4[static_cast<size_t>(k)]);
            const int cw = col >> 6;
            const uint64_t cbit = 1ULL << (col & 63);

            const uint64_t old_col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            const uint64_t new_col_word = old_col_word & ~cbit;
            if (new_col_word != old_col_word) {
                ws_.undo_col_idx.push_back(static_cast<uint16_t>(cw));
                ws_.undo_col_old.push_back(old_col_word);
                ws_.uncovered_cols[static_cast<size_t>(cw)] = new_col_word;
            }

            const uint64_t* const col_rows =
                &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
            for (int w = 0; w < ws_.row_words; ++w) {
                const uint64_t old_word = ws_.active_rows[static_cast<size_t>(w)];
                const uint64_t new_word = old_word & ~col_rows[static_cast<size_t>(w)];
                if (new_word != old_word) {
                    ws_.undo_active_idx.push_back(static_cast<uint16_t>(w));
                    ws_.undo_active_old.push_back(old_word);
                    ws_.active_rows[static_cast<size_t>(w)] = new_word;
                }
            }
        }
        return true;
    }

    void initialize_state() const {
        std::fill(ws_.active_rows.begin(), ws_.active_rows.end(), ~0ULL);
        const int valid_row_bits = ws_.rows & 63;
        if (valid_row_bits != 0) {
            ws_.active_rows[static_cast<size_t>(ws_.row_words - 1)] = (1ULL << valid_row_bits) - 1ULL;
        }

        std::fill(ws_.uncovered_cols.begin(), ws_.uncovered_cols.end(), ~0ULL);
        const int valid_col_bits = ws_.cols & 63;
        if (valid_col_bits != 0) {
            ws_.uncovered_cols[static_cast<size_t>(ws_.col_words - 1)] = (1ULL << valid_col_bits) - 1ULL;
        }

        ws_.undo_active_idx.clear();
        ws_.undo_active_old.clear();
        ws_.undo_col_idx.clear();
        ws_.undo_col_old.clear();
        ws_.solution_depth = 0;
        std::fill(ws_.solution_rows.begin(), ws_.solution_rows.end(), -1);
    }

    bool restrict_rows_by_allowed_masks(const GenericTopology& topo, const std::vector<uint64_t>& allowed_masks) const {
        if (static_cast<int>(allowed_masks.size()) != topo.nn) {
            return false;
        }
        const uint64_t full_mask = (topo.n >= 64) ? ~0ULL : ((1ULL << topo.n) - 1ULL);
        for (int idx = 0; idx < topo.nn; ++idx) {
            uint64_t allowed = allowed_masks[static_cast<size_t>(idx)] & full_mask;
            if (allowed == 0ULL) {
                return false;
            }
            if (allowed == full_mask) {
                continue;
            }
            const int row_base = idx * topo.n;
            for (int d0 = 0; d0 < topo.n; ++d0) {
                const uint64_t bit = (1ULL << d0);
                if ((allowed & bit) != 0ULL) {
                    continue;
                }
                const int row_id = row_base + d0;
                const int rw = row_id >> 6;
                ws_.active_rows[static_cast<size_t>(rw)] &= ~(1ULL << (row_id & 63));
            }
        }
        return true;
    }

    bool search_find_one(SearchAbortControl* budget, int depth) const {
        if (budget != nullptr && !budget->step()) {
            return false;
        }

        bool has_uncovered = false;
        for (int cw = 0; cw < ws_.col_words; ++cw) {
            if (ws_.uncovered_cols[static_cast<size_t>(cw)] != 0ULL) {
                has_uncovered = true;
                break;
            }
        }
        if (!has_uncovered) {
            ws_.solution_depth = depth;
            return true;
        }
        if (depth < 0 || depth >= ws_.max_depth) {
            return false;
        }

        const size_t best_base = static_cast<size_t>(depth) * static_cast<size_t>(ws_.row_words);
        uint64_t* const local_best = &ws_.recursion_stack[best_base];
        int best_col = -1;
        int best_count = std::numeric_limits<int>::max();

        for (int cw = 0; cw < ws_.col_words; ++cw) {
            uint64_t col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            while (col_word != 0ULL) {
                const int bit = bit_ctz_u64(col_word);
                const int col = (cw << 6) + bit;
                col_word = bit_clear_lsb_u64(col_word);
                if (col >= ws_.cols) {
                    continue;
                }
                const uint64_t* const col_rows =
                    &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
                int cnt = 0;
                for (int w = 0; w < ws_.row_words; ++w) {
                    const uint64_t v = ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    cnt += static_cast<int>(std::popcount(v));
                }
                if (cnt == 0) {
                    return false;
                }
                if (cnt < best_count) {
                    best_count = cnt;
                    best_col = col;
                    for (int w = 0; w < ws_.row_words; ++w) {
                        local_best[static_cast<size_t>(w)] =
                            ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    }
                    if (cnt == 1) {
                        break;
                    }
                }
            }
            if (best_count == 1) {
                break;
            }
        }
        if (best_col < 0) {
            return false;
        }

        for (int w = 0; w < ws_.row_words; ++w) {
            uint64_t rows_word = local_best[static_cast<size_t>(w)];
            while (rows_word != 0ULL) {
                const int rb = bit_ctz_u64(rows_word);
                const int row_id = (w << 6) + rb;
                rows_word = bit_clear_lsb_u64(rows_word);
                if (row_id >= ws_.rows) {
                    continue;
                }
                const size_t active_marker = ws_.undo_active_idx.size();
                const size_t col_marker = ws_.undo_col_idx.size();
                ws_.solution_rows[static_cast<size_t>(depth)] = row_id;
                if (!apply_row(row_id)) {
                    rollback_to(active_marker, col_marker);
                    ws_.solution_rows[static_cast<size_t>(depth)] = -1;
                    continue;
                }
                if (search_find_one(budget, depth + 1)) {
                    return true;
                }
                rollback_to(active_marker, col_marker);
                ws_.solution_rows[static_cast<size_t>(depth)] = -1;
                if (budget != nullptr && budget->aborted()) {
                    return false;
                }
            }
        }
        return false;
    }

    bool search_with_limit(int& out_count, int limit, SearchAbortControl* budget, int depth) const {
        if (budget != nullptr && !budget->step()) {
            return false;
        }

        bool has_uncovered = false;
        for (int cw = 0; cw < ws_.col_words; ++cw) {
            if (ws_.uncovered_cols[static_cast<size_t>(cw)] != 0ULL) {
                has_uncovered = true;
                break;
            }
        }
        if (!has_uncovered) {
            ++out_count;
            return out_count >= limit;
        }

        if (depth < 0 || depth >= ws_.max_depth) {
            return false;
        }

        const size_t best_base = static_cast<size_t>(depth) * static_cast<size_t>(ws_.row_words);
        uint64_t* const local_best = &ws_.recursion_stack[best_base];

        int best_col = -1;
        int best_count = std::numeric_limits<int>::max();

        for (int cw = 0; cw < ws_.col_words; ++cw) {
            uint64_t col_word = ws_.uncovered_cols[static_cast<size_t>(cw)];
            while (col_word != 0ULL) {
                const int bit = bit_ctz_u64(col_word);
                const int col = (cw << 6) + bit;
                col_word = bit_clear_lsb_u64(col_word);
                if (col >= ws_.cols) {
                    continue;
                }

                const uint64_t* const col_rows =
                    &ws_.col_rows_bits[static_cast<size_t>(col) * static_cast<size_t>(ws_.row_words)];
                int cnt = 0;
                for (int w = 0; w < ws_.row_words; ++w) {
                    const uint64_t v = ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    cnt += static_cast<int>(std::popcount(v));
                }

                if (cnt == 0) {
                    return false;
                }

                if (cnt < best_count) {
                    best_count = cnt;
                    best_col = col;
                    for (int w = 0; w < ws_.row_words; ++w) {
                        local_best[static_cast<size_t>(w)] =
                            ws_.active_rows[static_cast<size_t>(w)] & col_rows[static_cast<size_t>(w)];
                    }
                    if (cnt == 1) {
                        break;
                    }
                }
            }
            if (best_count == 1) {
                break;
            }
        }

        if (best_col < 0) {
            return false;
        }

        for (int w = 0; w < ws_.row_words; ++w) {
            uint64_t rows_word = local_best[static_cast<size_t>(w)];
            while (rows_word != 0ULL) {
                const int rb = bit_ctz_u64(rows_word);
                const int row_id = (w << 6) + rb;
                rows_word = bit_clear_lsb_u64(rows_word);
                if (row_id >= ws_.rows) {
                    continue;
                }

                const size_t active_marker = ws_.undo_active_idx.size();
                const size_t col_marker = ws_.undo_col_idx.size();
                if (!apply_row(row_id)) {
                    rollback_to(active_marker, col_marker);
                    continue;
                }
                if (search_with_limit(out_count, limit, budget, depth + 1)) {
                    return true;
                }
                rollback_to(active_marker, col_marker);
                if (budget != nullptr && budget->aborted()) {
                    return false;
                }
            }
        }

        return false;
    }

    int count_solutions_limit(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        int limit,
        SearchAbortControl* budget = nullptr) const {
        if (limit <= 0) {
            return 0;
        }
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) {
            return 0;
        }
        if (static_cast<int>(puzzle.size()) != topo.nn) {
            return 0;
        }

        build_if_needed(topo);
        if (!ws_.matches(topo)) {
            return 0;
        }

        initialize_state();

        const uint16_t* const puzzle_ptr = puzzle.data();
        const uint32_t* const packed_ptr = topo.cell_rcb_packed.data();
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
            if (d == 0) {
                continue;
            }
            if (d < 1 || d > topo.n) {
                return 0;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int row_id = row_id_for(topo.n, r, c, d - 1);
            const size_t active_marker = ws_.undo_active_idx.size();
            const size_t col_marker = ws_.undo_col_idx.size();
            if (!apply_row(row_id)) {
                rollback_to(active_marker, col_marker);
                return 0;
            }
        }

        int out_count = 0;
        const bool finished = search_with_limit(out_count, limit, budget, 0);
        const bool aborted = budget != nullptr && budget->aborted() && !finished;
        if (aborted) {
            return -1;
        }
        return out_count;
    }

    int count_solutions_limit2(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr) const {
        return count_solutions_limit(puzzle, topo, 2, budget);
    }

    bool solve_and_capture(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        std::vector<uint16_t>& out_solution,
        SearchAbortControl* budget = nullptr,
        const std::vector<uint64_t>* allowed_masks = nullptr) const {
        if (topo.n <= 0 || topo.n > kUnifiedMaxN) {
            return false;
        }
        if (static_cast<int>(puzzle.size()) != topo.nn) {
            return false;
        }

        build_if_needed(topo);
        if (!ws_.matches(topo)) {
            return false;
        }

        initialize_state();
        if (allowed_masks != nullptr && !restrict_rows_by_allowed_masks(topo, *allowed_masks)) {
            return false;
        }

        const uint16_t* const puzzle_ptr = puzzle.data();
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
            if (d == 0) {
                continue;
            }
            if (d < 1 || d > topo.n) {
                return false;
            }
            if (allowed_masks != nullptr) {
                const uint64_t allowed = (*allowed_masks)[static_cast<size_t>(idx)] & ((topo.n >= 64) ? ~0ULL : ((1ULL << topo.n) - 1ULL));
                if ((allowed & (1ULL << (d - 1))) == 0ULL) {
                    return false;
                }
            }
            const int row_id = idx * topo.n + (d - 1);
            const size_t active_marker = ws_.undo_active_idx.size();
            const size_t col_marker = ws_.undo_col_idx.size();
            if (!apply_row(row_id)) {
                rollback_to(active_marker, col_marker);
                return false;
            }
        }

        const bool found = search_find_one(budget, 0);
        if (!found) {
            return false;
        }
        if (budget != nullptr && budget->aborted()) {
            return false;
        }

        if (out_solution.size() != static_cast<size_t>(topo.nn)) {
            out_solution.resize(static_cast<size_t>(topo.nn));
        }
        std::copy(puzzle.begin(), puzzle.end(), out_solution.begin());
        for (int i = 0; i < ws_.solution_depth; ++i) {
            const int row_id = ws_.solution_rows[static_cast<size_t>(i)];
            if (row_id < 0) {
                continue;
            }
            const int cell = row_id / topo.n;
            const int d0 = row_id % topo.n;
            out_solution[static_cast<size_t>(cell)] = static_cast<uint16_t>(d0 + 1);
        }
        for (int idx = 0; idx < topo.nn; ++idx) {
            if (out_solution[static_cast<size_t>(idx)] == 0) {
                return false;
            }
        }
        return true;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\generator\pattern_forcing_exact_templates.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

#include <array>
#include <algorithm>
#include <cstdint>
#include <random>

#include "../board.h"
#include "../config.h"

namespace sudoku_hpc::pattern_forcing {

struct ExactPatternTemplatePlan {
    bool valid = false;
    int anchor_count = 0;
    std::array<int, 64> anchor_idx{};
    std::array<uint64_t, 64> anchor_masks{};
};

inline uint64_t pf_full_mask_for_n(int n) {
    return (n >= 64) ? ~0ULL : ((1ULL << n) - 1ULL);
}

inline bool plan_add_anchor(ExactPatternTemplatePlan& plan, int idx, uint64_t mask) {
    if (idx < 0) return false;
    if (plan.anchor_count >= static_cast<int>(plan.anchor_idx.size())) return false;
    for (int i = 0; i < plan.anchor_count; ++i) {
        if (plan.anchor_idx[static_cast<size_t>(i)] == idx) return false;
    }
    plan.anchor_idx[static_cast<size_t>(plan.anchor_count)] = idx;
    plan.anchor_masks[static_cast<size_t>(plan.anchor_count)] = mask;
    ++plan.anchor_count;
    return true;
}

inline bool build_exocet_exact_template(
    const GenericTopology& topo,
    std::mt19937_64& rng,
    ExactPatternTemplatePlan& plan) {
    plan = {};
    if (topo.box_rows <= 1 || topo.box_cols <= 1) return false;
    const int n = topo.n;
    const uint64_t full = pf_full_mask_for_n(n);
    const int box = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const int house = 2 * n + box;
    const int p0 = topo.house_offsets[static_cast<size_t>(house)];
    const int p1 = topo.house_offsets[static_cast<size_t>(house + 1)];
    if (p1 - p0 < 4) return false;

    int b1 = -1;
    int b2 = -1;
    for (int i = p0; i < p1 && b1 < 0; ++i) b1 = topo.houses_flat[static_cast<size_t>(i)];
    for (int i = p1 - 1; i >= p0 && b2 < 0; --i) {
        const int c = topo.houses_flat[static_cast<size_t>(i)];
        if (b1 == c) continue;
        if (topo.cell_row[static_cast<size_t>(c)] == topo.cell_row[static_cast<size_t>(b1)]) continue;
        if (topo.cell_col[static_cast<size_t>(c)] == topo.cell_col[static_cast<size_t>(b1)]) continue;
        b2 = c;
    }
    if (b1 < 0 || b2 < 0) return false;

    const int r1 = topo.cell_row[static_cast<size_t>(b1)];
    const int c1 = topo.cell_col[static_cast<size_t>(b1)];
    const int r2 = topo.cell_row[static_cast<size_t>(b2)];
    const int c2 = topo.cell_col[static_cast<size_t>(b2)];
    const int t1 = r1 * n + c2;
    const int t2 = r2 * n + c1;

    const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int d2 = d1;
    for (int g = 0; g < 64 && d2 == d1; ++g) d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const uint64_t base_mask = (1ULL << d1) | (1ULL << d2);
    const uint64_t cross_mask = base_mask | (1ULL << static_cast<int>((d1 + 1) % n));

    plan_add_anchor(plan, b1, base_mask);
    plan_add_anchor(plan, b2, base_mask);
    plan_add_anchor(plan, t1, cross_mask & full);
    plan_add_anchor(plan, t2, cross_mask & full);

    plan.valid = (plan.anchor_count >= 4);
    return plan.valid;
}

inline bool build_sk_loop_exact_template(
    const GenericTopology& topo,
    std::mt19937_64& rng,
    ExactPatternTemplatePlan& plan) {
    plan = {};
    const int n = topo.n;
    if (n < 4) return false;
    const uint64_t full = pf_full_mask_for_n(n);
    int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int r2 = r1;
    int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c2 = c1;
    for (int g = 0; g < 64 && r2 == r1; ++g) r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    for (int g = 0; g < 64 && c2 == c1; ++g) c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    if (r1 == r2 || c1 == c2) return false;

    const int a = r1 * n + c1;
    const int b = r1 * n + c2;
    const int c = r2 * n + c1;
    const int d = r2 * n + c2;

    const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int d2 = d1;
    for (int g = 0; g < 64 && d2 == d1; ++g) d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const uint64_t core = (1ULL << d1) | (1ULL << d2);
    const uint64_t ex1 = core | (1ULL << static_cast<int>((d1 + 2) % n));
    const uint64_t ex2 = core | (1ULL << static_cast<int>((d2 + 3) % n));

    plan_add_anchor(plan, a, ex1 & full);
    plan_add_anchor(plan, b, core);
    plan_add_anchor(plan, c, core);
    plan_add_anchor(plan, d, ex2 & full);

    plan.valid = (plan.anchor_count == 4);
    return plan.valid;
}

inline bool build_forcing_chain_exact_template(
    const GenericTopology& topo,
    std::mt19937_64& rng,
    ExactPatternTemplatePlan& plan) {
    plan = {};
    const int n = topo.n;
    const uint64_t full = pf_full_mask_for_n(n);
    if (n < 4) return false;

    int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int r2 = r1;
    int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c2 = c1;
    for (int g = 0; g < 64 && r2 == r1; ++g) r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    for (int g = 0; g < 64 && c2 == c1; ++g) c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    if (r1 == r2 || c1 == c2) return false;

    const int p = r1 * n + c1;
    const int a = r1 * n + c2;
    const int b = r2 * n + c2;
    const int t = r2 * n + c1;

    const int d1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int d2 = d1;
    for (int g = 0; g < 64 && d2 == d1; ++g) d2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int d3 = d2;
    for (int g = 0; g < 64 && (d3 == d1 || d3 == d2); ++g) d3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const uint64_t m12 = (1ULL << d1) | (1ULL << d2);
    const uint64_t m23 = (1ULL << d2) | (1ULL << d3);
    const uint64_t m13 = (1ULL << d1) | (1ULL << d3);

    plan_add_anchor(plan, p, m12 & full);
    plan_add_anchor(plan, a, m23 & full);
    plan_add_anchor(plan, b, m13 & full);
    plan_add_anchor(plan, t, m12 & full);

    plan.valid = (plan.anchor_count >= 4);
    return plan.valid;
}

inline bool build_exact_pattern_template(
    const GenericTopology& topo,
    const GenerateRunConfig& cfg,
    RequiredStrategy required_strategy,
    int difficulty_level_required,
    std::mt19937_64& rng,
    ExactPatternTemplatePlan& plan) {
    (void)cfg;
    plan = {};

    switch (required_strategy) {
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
        return build_exocet_exact_template(topo, rng, plan);
    case RequiredStrategy::SKLoop:
        return build_sk_loop_exact_template(topo, rng, plan);
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
        return build_forcing_chain_exact_template(topo, rng, plan);
    default:
        break;
    }

    if (difficulty_level_required >= 8) {
        if (build_forcing_chain_exact_template(topo, rng, plan)) return true;
    }
    if (difficulty_level_required >= 7) {
        if (build_sk_loop_exact_template(topo, rng, plan)) return true;
    }
    return false;
}

}  // namespace sudoku_hpc::pattern_forcing




==============================================================================
PLIK: Sources\generator_main.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {

inline std::string grid_size_label(int box_rows, int box_cols) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    return std::to_string(n) + "x" + std::to_string(n);
}

inline BenchmarkReportData run_benchmark_profiles_40s(const GenerateRunConfig& base_cfg) {
    BenchmarkReportData data;
    data.title = "Porownanie strategii Sudoku (poziomy 1-8)";
    data.probe_per_level = std::to_string(base_cfg.benchmark_seconds_per_profile) + "s";
    data.benchmark_mode = "profiles_generic";
    data.cpu_model = detect_cpu_model();
    data.ram_info = detect_ram_info();
    data.os_info = detect_os_info();
    data.runtime_info = detect_runtime_info();

    const int thread_count = base_cfg.threads > 0 ? base_cfg.threads : std::max(1u, std::thread::hardware_concurrency());
    data.threads_info = std::to_string(thread_count);

    const auto total_start = std::chrono::steady_clock::now();

    for (int lvl = 1; lvl <= 8; ++lvl) {
        GenerateRunConfig cfg = base_cfg;
        cfg.difficulty_level_required = lvl;
        cfg.required_strategy = default_required_strategy_for_level(lvl);
        cfg.target_puzzles = std::numeric_limits<uint64_t>::max() / 2;
        cfg.max_attempts_s = static_cast<uint64_t>(std::max(1, base_cfg.benchmark_seconds_per_profile));
        cfg.pause_on_exit_windows = false;
        cfg.write_individual_files = false;
        cfg.output_folder = base_cfg.output_folder;
        cfg.output_file = "bench_lvl_" + std::to_string(lvl) + "_" + grid_size_label(cfg.box_rows, cfg.box_cols) + ".txt";

        GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, {}, {});

        BenchmarkTableARow row_a;
        row_a.lvl = lvl;
        row_a.solved_ok = static_cast<int>(result.accepted);
        row_a.analyzed = static_cast<int>(result.attempts);
        row_a.required_use = result.analyzed_required_strategy;
        row_a.required_hit = result.required_strategy_hits;
        row_a.reject_strategy = result.reject_strategy;
        row_a.avg_solved_gen_ms = result.accepted > 0 ? (result.elapsed_s * 1000.0) / static_cast<double>(result.accepted) : 0.0;
        row_a.avg_dig_ms = 0.0;
        row_a.avg_analyze_ms = result.attempts > 0 ? (result.elapsed_s * 1000.0) / static_cast<double>(result.attempts) : 0.0;
        row_a.backtracks = result.reject_logic;
        row_a.timeouts = result.elapsed_s + 0.05 >= static_cast<double>(cfg.max_attempts_s) ? 1 : 0;
        row_a.success_rate = result.attempts > 0 ? (100.0 * static_cast<double>(result.accepted) / static_cast<double>(result.attempts)) : 0.0;
        data.table_a.push_back(row_a);

        BenchmarkTableA2Row row_a2;
        row_a2.lvl = lvl;
        row_a2.analyzed = static_cast<int>(result.attempts);
        row_a2.medusa_hit = 0;
        row_a2.medusa_use = result.attempts;
        row_a2.sue_hit = 0;
        row_a2.sue_use = result.attempts;
        row_a2.msls_hit = 0;
        row_a2.msls_use = result.attempts;
        data.table_a2.push_back(row_a2);

        BenchmarkTableCRow row_c;
        row_c.size = grid_size_label(cfg.box_rows, cfg.box_cols);
        row_c.lvl = lvl;
        row_c.est_analyze_s = result.attempts > 0 ? (result.elapsed_s / static_cast<double>(result.attempts)) : 0.0;
        row_c.budget_s = static_cast<double>(cfg.max_attempts_s);
        row_c.peak_ram_mb = process_peak_ram_mb();
        row_c.decision = "RUN";
        data.table_c.push_back(row_c);
    }

    const std::array<RequiredStrategy, 3> strategy_tests = {
        RequiredStrategy::NakedSingle,
        RequiredStrategy::HiddenSingle,
        RequiredStrategy::Backtracking,
    };
    for (RequiredStrategy strategy : strategy_tests) {
        GenerateRunConfig cfg = base_cfg;
        cfg.required_strategy = strategy;
        cfg.difficulty_level_required = (strategy == RequiredStrategy::Backtracking) ? 9 : 1;
        cfg.target_puzzles = std::numeric_limits<uint64_t>::max() / 2;
        cfg.max_attempts_s = static_cast<uint64_t>(std::max(1, base_cfg.benchmark_seconds_per_profile));
        cfg.pause_on_exit_windows = false;
        cfg.write_individual_files = false;
        cfg.output_folder = base_cfg.output_folder;
        cfg.output_file = "bench_required_" + to_string(strategy) + "_" + grid_size_label(cfg.box_rows, cfg.box_cols) + ".txt";

        GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, {}, {});

        BenchmarkTableA3Row row_a3;
        row_a3.strategy = to_string(strategy);
        row_a3.lvl = cfg.difficulty_level_required;
        row_a3.max_attempts = cfg.max_attempts;
        row_a3.analyzed = result.analyzed_required_strategy;
        row_a3.required_strategy_hits = result.required_strategy_hits;
        row_a3.analyzed_per_s = result.elapsed_s > 0.0 ? static_cast<double>(row_a3.analyzed) / result.elapsed_s : 0.0;
        row_a3.est_5min = static_cast<uint64_t>(row_a3.analyzed_per_s * 300.0);
        row_a3.written = result.written_required_strategy;
        data.table_a3.push_back(row_a3);
    }

    BenchmarkTableBRow size_row;
    size_row.size = grid_size_label(base_cfg.box_rows, base_cfg.box_cols);
    for (int lvl = 1; lvl <= 8; ++lvl) {
        const ClueRange cr = clue_range_for_size_level(std::max(1, base_cfg.box_rows) * std::max(1, base_cfg.box_cols), lvl);
        size_row.levels[static_cast<size_t>(lvl - 1)] = std::to_string(cr.min_clues) + "-" + std::to_string(cr.max_clues);
    }
    data.table_b.push_back(size_row);

    data.rules = {
        "Profile uruchamiane na staly budzet czasowy per poziom (RUN).",
        "Unikalnosc: generic DLX limit=2.",
        "Kontrakt required_strategy: use=analyzed_required_strategy, hit=required_strategy_hits, reject_strategy gdy !(use&&hit).",
    };
    data.total_execution_s = static_cast<uint64_t>(std::llround(
        std::chrono::duration<double>(std::chrono::steady_clock::now() - total_start).count()));
    return data;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\generator_mcts_digger.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdint>
#include <limits>
#include <random>
#include <string>
#include <vector>

#include "board.h"
#include "config.h"
#include "dlx.h"
#include "sudoku_logic_engine.h"

namespace sudoku_hpc {

inline bool mcts_is_level7_strategy(RequiredStrategy rs) {
    switch (rs) {
    case RequiredStrategy::Medusa3D:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::ALSXYWing:
    case RequiredStrategy::ALSChain:
    case RequiredStrategy::SueDeCoq:
    case RequiredStrategy::DeathBlossom:
    case RequiredStrategy::FrankenFish:
    case RequiredStrategy::MutantFish:
    case RequiredStrategy::KrakenFish:
    case RequiredStrategy::AlignedPairExclusion:
    case RequiredStrategy::AlignedTripleExclusion:
    case RequiredStrategy::ALSAIC:
    case RequiredStrategy::Squirmbag:
        return true;
    default:
        return false;
    }
}

inline bool mcts_is_level8_strategy(RequiredStrategy rs) {
    switch (rs) {
    case RequiredStrategy::MSLS:
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
        return true;
    default:
        return false;
    }
}

inline bool mcts_required_strategy_slot(RequiredStrategy rs, size_t& out_slot) {
    switch (rs) {
    case RequiredStrategy::Medusa3D: out_slot = GenericLogicCertify::SlotMedusa3D; return true;
    case RequiredStrategy::AIC: out_slot = GenericLogicCertify::SlotAIC; return true;
    case RequiredStrategy::GroupedAIC: out_slot = GenericLogicCertify::SlotGroupedAIC; return true;
    case RequiredStrategy::GroupedXCycle: out_slot = GenericLogicCertify::SlotGroupedXCycle; return true;
    case RequiredStrategy::ContinuousNiceLoop: out_slot = GenericLogicCertify::SlotContinuousNiceLoop; return true;
    case RequiredStrategy::ALSXYWing: out_slot = GenericLogicCertify::SlotALSXYWing; return true;
    case RequiredStrategy::ALSChain: out_slot = GenericLogicCertify::SlotALSChain; return true;
    case RequiredStrategy::SueDeCoq: out_slot = GenericLogicCertify::SlotSueDeCoq; return true;
    case RequiredStrategy::DeathBlossom: out_slot = GenericLogicCertify::SlotDeathBlossom; return true;
    case RequiredStrategy::FrankenFish: out_slot = GenericLogicCertify::SlotFrankenFish; return true;
    case RequiredStrategy::MutantFish: out_slot = GenericLogicCertify::SlotMutantFish; return true;
    case RequiredStrategy::KrakenFish: out_slot = GenericLogicCertify::SlotKrakenFish; return true;
    case RequiredStrategy::AlignedPairExclusion: out_slot = GenericLogicCertify::SlotAlignedPairExclusion; return true;
    case RequiredStrategy::AlignedTripleExclusion: out_slot = GenericLogicCertify::SlotAlignedTripleExclusion; return true;
    case RequiredStrategy::ALSAIC: out_slot = GenericLogicCertify::SlotALSAIC; return true;
    case RequiredStrategy::Squirmbag: out_slot = GenericLogicCertify::SlotSquirmbag; return true;
    case RequiredStrategy::MSLS: out_slot = GenericLogicCertify::SlotMSLS; return true;
    case RequiredStrategy::Exocet: out_slot = GenericLogicCertify::SlotExocet; return true;
    case RequiredStrategy::SeniorExocet: out_slot = GenericLogicCertify::SlotSeniorExocet; return true;
    case RequiredStrategy::SKLoop: out_slot = GenericLogicCertify::SlotSKLoop; return true;
    case RequiredStrategy::PatternOverlayMethod: out_slot = GenericLogicCertify::SlotPatternOverlayMethod; return true;
    case RequiredStrategy::ForcingChains: out_slot = GenericLogicCertify::SlotForcingChains; return true;
    case RequiredStrategy::DynamicForcingChains: out_slot = GenericLogicCertify::SlotDynamicForcingChains; return true;
    default:
        return false;
    }
}

inline std::string mcts_normalize_profile(std::string raw) {
    std::string key;
    key.reserve(raw.size());
    for (unsigned char ch : raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "off" || key == "none" || key == "disabled") return "off";
    if (key == "p7" || key == "level7" || key == "nightmare") return "p7";
    if (key == "p8" || key == "level8" || key == "theoretical") return "p8";
    return "auto";
}

struct MctsAdvancedTuning {
    bool enabled = false;
    int eval_stride = 8;
    int near_window = 2;
    double p7_hit_weight = 1.5;
    double p8_hit_weight = 2.5;
    double required_hit_weight = 4.0;
    double p8_miss_penalty = 1.5;
    double min_reward = -8.0;
    bool require_p8_signal_for_stop = false;
};

inline MctsAdvancedTuning resolve_mcts_advanced_tuning(
    const GenerateRunConfig& cfg,
    const GenericTopology& topo) {
    const bool wants_p7 =
        (cfg.difficulty_level_required >= 7) ||
        mcts_is_level7_strategy(cfg.required_strategy) ||
        mcts_is_level8_strategy(cfg.required_strategy);
    const bool wants_p8 =
        (cfg.difficulty_level_required >= 8) ||
        mcts_is_level8_strategy(cfg.required_strategy);

    std::string profile = mcts_normalize_profile(cfg.mcts_tuning_profile);
    if (profile == "auto") {
        profile = wants_p8 ? "p8" : (wants_p7 ? "p7" : "off");
    }

    MctsAdvancedTuning t{};
    if (profile == "off") {
        t.enabled = false;
        return t;
    }

    t.enabled = true;
    if (profile == "p8") {
        t.eval_stride = 2;
        t.near_window = std::max(4, topo.n);
        t.p7_hit_weight = 2.0;
        t.p8_hit_weight = 5.5;
        t.required_hit_weight = 9.0;
        t.p8_miss_penalty = 3.5;
        t.min_reward = -14.0;
        t.require_p8_signal_for_stop = true;
        return t;
    }

    // p7
    t.eval_stride = 4;
    t.near_window = std::max(3, topo.n / 2);
    t.p7_hit_weight = 2.5;
    t.p8_hit_weight = 3.0;
    t.required_hit_weight = 6.0;
    t.p8_miss_penalty = wants_p8 ? 1.0 : 0.0;
    t.min_reward = -10.0;
    t.require_p8_signal_for_stop = false;
    return t;
}

struct MctsDiggerScratch {
    int prepared_nn = 0;
    std::vector<double> reward_sum;
    std::vector<uint32_t> visits;
    std::vector<int> active_cells;
    std::vector<int> active_pos;
    int active_count = 0;
    uint64_t total_visits = 0;

    void ensure(int nn) {
        if (prepared_nn == nn) {
            return;
        }
        reward_sum.assign(static_cast<size_t>(nn), 0.0);
        visits.assign(static_cast<size_t>(nn), 0U);
        active_cells.assign(static_cast<size_t>(nn), -1);
        active_pos.assign(static_cast<size_t>(nn), -1);
        prepared_nn = nn;
        active_count = 0;
        total_visits = 0;
    }

    void reset(int nn) {
        ensure(nn);
        std::fill(reward_sum.begin(), reward_sum.end(), 0.0);
        std::fill(visits.begin(), visits.end(), 0U);
        std::fill(active_pos.begin(), active_pos.end(), -1);
        active_count = 0;
        total_visits = 0;
    }

    void activate(int cell) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        if (active_pos[static_cast<size_t>(cell)] >= 0) {
            return;
        }
        const int pos = active_count++;
        active_cells[static_cast<size_t>(pos)] = cell;
        active_pos[static_cast<size_t>(cell)] = pos;
    }

    void disable(int cell) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        const int pos = active_pos[static_cast<size_t>(cell)];
        if (pos < 0 || pos >= active_count) {
            return;
        }
        const int last_pos = active_count - 1;
        const int last_cell = active_cells[static_cast<size_t>(last_pos)];
        active_cells[static_cast<size_t>(pos)] = last_cell;
        if (last_cell >= 0) {
            active_pos[static_cast<size_t>(last_cell)] = pos;
        }
        active_cells[static_cast<size_t>(last_pos)] = -1;
        active_pos[static_cast<size_t>(cell)] = -1;
        --active_count;
    }

    int select_ucb(std::mt19937_64& rng, double c_param) const {
        if (active_count <= 0) {
            return -1;
        }
        int unseen_pick = -1;
        int unseen_seen = 0;
        for (int i = 0; i < active_count; ++i) {
            const int cell = active_cells[static_cast<size_t>(i)];
            if (cell < 0) continue;
            if (visits[static_cast<size_t>(cell)] == 0U) {
                ++unseen_seen;
                if ((rng() % static_cast<uint64_t>(unseen_seen)) == 0ULL) {
                    unseen_pick = cell;
                }
            }
        }
        if (unseen_pick >= 0) {
            return unseen_pick;
        }

        const double log_total = std::log(static_cast<double>(std::max<uint64_t>(1ULL, total_visits)));
        int best_cell = -1;
        double best_score = -std::numeric_limits<double>::infinity();
        for (int i = 0; i < active_count; ++i) {
            const int cell = active_cells[static_cast<size_t>(i)];
            if (cell < 0) continue;
            const uint32_t v = visits[static_cast<size_t>(cell)];
            if (v == 0U) {
                return cell;
            }
            const double inv_v = 1.0 / static_cast<double>(v);
            const double exploit = reward_sum[static_cast<size_t>(cell)] * inv_v;
            const double explore = c_param * std::sqrt(log_total * inv_v);
            const double score = exploit + explore;
            if (score > best_score) {
                best_score = score;
                best_cell = cell;
            }
        }
        return best_cell;
    }

    void update(int cell, double reward) {
        if (cell < 0 || cell >= prepared_nn) {
            return;
        }
        reward_sum[static_cast<size_t>(cell)] += reward;
        visits[static_cast<size_t>(cell)] += 1U;
        ++total_visits;
    }
};

inline MctsDiggerScratch& tls_mcts_digger_scratch() {
    thread_local MctsDiggerScratch s{};
    return s;
}

struct GenericMctsBottleneckDigger {
    struct RunStats {
        bool used = false;
        bool bottleneck_hit = false;
        int accepted_removals = 0;
        int rejected_uniqueness = 0;
        int rejected_logic_timeout = 0;
        int iterations = 0;
        int advanced_evals = 0;
        int advanced_p7_hits = 0;
        int advanced_p8_hits = 0;
        int required_strategy_hits = 0;
    };

    bool dig_into(
        const std::vector<uint16_t>& solved,
        const GenericTopology& topo,
        const GenerateRunConfig& cfg,
        std::mt19937_64& rng,
        const GenericUniquenessCounter& uniq,
        const GenericLogicCertify& logic,
        std::vector<uint16_t>& out_puzzle,
        int& out_clues,
        const uint8_t* protected_cells = nullptr,
        SearchAbortControl* budget = nullptr,
        RunStats* stats = nullptr) const {
        if (stats != nullptr) {
            *stats = {};
            stats->used = true;
        }
        out_puzzle.resize(solved.size());
        std::copy(solved.begin(), solved.end(), out_puzzle.begin());

        int min_clues = std::clamp(cfg.min_clues, 0, topo.nn);
        int max_clues = std::clamp(cfg.max_clues, min_clues, topo.nn);
        std::uniform_int_distribution<int> pick_target(min_clues, max_clues);
        const int target_clues = pick_target(rng);

        MctsDiggerScratch& sc = tls_mcts_digger_scratch();
        sc.reset(topo.nn);
        for (int idx = 0; idx < topo.nn; ++idx) {
            if (protected_cells != nullptr && protected_cells[static_cast<size_t>(idx)] != 0) {
                continue;
            }
            sc.activate(idx);
        }

        int clues = topo.nn;
        int fail_streak = 0;
        const int fail_cap = std::max(16, cfg.mcts_fail_cap);
        const int iter_cap = (cfg.mcts_digger_iterations > 0)
            ? cfg.mcts_digger_iterations
            : std::max(256, topo.nn * 8);
        const int basic_level = std::clamp(cfg.mcts_basic_logic_level, 1, 5);
        const double ucb_c = std::clamp(cfg.mcts_ucb_c, 0.1, 4.0);
        const MctsAdvancedTuning tuning = resolve_mcts_advanced_tuning(cfg, topo);
        const int advanced_level = std::clamp(std::max(6, cfg.difficulty_level_required), 6, 8);
        const bool wants_p8 = (cfg.difficulty_level_required >= 8) || mcts_is_level8_strategy(cfg.required_strategy);
        size_t required_slot = 0;
        const bool has_required_slot = mcts_required_strategy_slot(cfg.required_strategy, required_slot);

        for (int iter = 0; iter < iter_cap; ++iter) {
            if (stats != nullptr) {
                stats->iterations = iter + 1;
            }
            if (budget != nullptr && !budget->step()) {
                return false;
            }
            if (clues <= target_clues || sc.active_count <= 0 || fail_streak >= fail_cap) {
                break;
            }

            const int idx = sc.select_ucb(rng, ucb_c);
            if (idx < 0) {
                break;
            }
            if (out_puzzle[static_cast<size_t>(idx)] == 0) {
                sc.disable(idx);
                continue;
            }

            int sym_idx = -1;
            bool remove_pair = false;
            if (cfg.symmetry_center) {
                sym_idx = topo.cell_center_sym[static_cast<size_t>(idx)];
                if (sym_idx >= 0 &&
                    sym_idx != idx &&
                    out_puzzle[static_cast<size_t>(sym_idx)] != 0 &&
                    !(protected_cells != nullptr && protected_cells[static_cast<size_t>(sym_idx)] != 0)) {
                    remove_pair = true;
                }
            }

            const int removal = remove_pair ? 2 : 1;
            if (clues - removal < target_clues) {
                sc.disable(idx);
                if (remove_pair) sc.disable(sym_idx);
                continue;
            }

            const uint16_t old_a = out_puzzle[static_cast<size_t>(idx)];
            const uint16_t old_b = (remove_pair ? out_puzzle[static_cast<size_t>(sym_idx)] : 0);
            out_puzzle[static_cast<size_t>(idx)] = 0;
            if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = 0;

            const int solutions = uniq.count_solutions_limit2(out_puzzle, topo, budget);
            if (solutions < 0) {
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                if (stats != nullptr) {
                    ++stats->rejected_logic_timeout;
                }
                return false;
            }
            if (solutions != 1) {
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                sc.update(idx, -6.0);
                sc.disable(idx);
                if (remove_pair) {
                    sc.update(sym_idx, -6.0);
                    sc.disable(sym_idx);
                }
                ++fail_streak;
                if (stats != nullptr) {
                    ++stats->rejected_uniqueness;
                }
                continue;
            }

            const GenericLogicCertifyResult basic = logic.certify_up_to_level(
                out_puzzle, topo, basic_level, budget, false);
            if (basic.timed_out) {
                out_puzzle[static_cast<size_t>(idx)] = old_a;
                if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                if (stats != nullptr) {
                    ++stats->rejected_logic_timeout;
                }
                return false;
            }

            const bool basic_solved = basic.solved;
            double reward = basic_solved
                ? (1.0 + 0.002 * static_cast<double>(std::max(0, basic.steps)))
                : (18.0 + 0.005 * static_cast<double>(std::max(0, basic.steps)));

            int p7_hits = 0;
            int p8_hits = 0;
            int required_hits = 0;
            bool advanced_signal = false;
            bool stopping_signal = !basic_solved;
            const bool do_advanced_eval =
                tuning.enabled &&
                ((!basic_solved) ||
                 ((clues - removal) <= (target_clues + tuning.near_window)) ||
                 ((iter % tuning.eval_stride) == 0));
            if (do_advanced_eval) {
                const GenericLogicCertifyResult adv = logic.certify_up_to_level(
                    out_puzzle, topo, advanced_level, budget, false);
                if (adv.timed_out) {
                    out_puzzle[static_cast<size_t>(idx)] = old_a;
                    if (remove_pair) out_puzzle[static_cast<size_t>(sym_idx)] = old_b;
                    if (stats != nullptr) {
                        ++stats->rejected_logic_timeout;
                    }
                    return false;
                }

                for (size_t slot = GenericLogicCertify::SlotMedusa3D; slot <= GenericLogicCertify::SlotKrakenFish; ++slot) {
                    p7_hits += static_cast<int>(adv.strategy_stats[slot].hit_count);
                }
                for (size_t slot = GenericLogicCertify::SlotMSLS; slot <= GenericLogicCertify::SlotDynamicForcingChains; ++slot) {
                    p8_hits += static_cast<int>(adv.strategy_stats[slot].hit_count);
                }
                if (has_required_slot) {
                    required_hits = static_cast<int>(adv.strategy_stats[required_slot].hit_count);
                }

                reward += tuning.p7_hit_weight * static_cast<double>(p7_hits);
                reward += tuning.p8_hit_weight * static_cast<double>(p8_hits);
                reward += tuning.required_hit_weight * static_cast<double>(required_hits);
                if (wants_p8 &&
                    p8_hits == 0 && required_hits == 0) {
                    reward -= tuning.p8_miss_penalty;
                }
                reward = std::max(tuning.min_reward, reward);
                advanced_signal = (p7_hits + p8_hits + required_hits) > 0;
                if (tuning.require_p8_signal_for_stop) {
                    stopping_signal = (required_hits > 0 || p8_hits > 0 || (!basic_solved && p7_hits > 0));
                } else {
                    stopping_signal = (!basic_solved || advanced_signal);
                }

                if (stats != nullptr) {
                    ++stats->advanced_evals;
                    stats->advanced_p7_hits += p7_hits;
                    stats->advanced_p8_hits += p8_hits;
                    stats->required_strategy_hits += required_hits;
                }
            }

            sc.update(idx, reward);
            if (remove_pair) {
                sc.update(sym_idx, reward);
            }
            clues -= removal;
            fail_streak = 0;
            if (stats != nullptr) {
                stats->accepted_removals += removal;
                if (stopping_signal) {
                    stats->bottleneck_hit = true;
                }
            }

            // Keep removing until clue window is reached, but once bottleneck is hit
            // and we are inside requested window, stop early for fast generation.
            if (stopping_signal && clues <= max_clues && clues >= min_clues) {
                break;
            }
        }

        out_clues = clues;
        return true;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\generator_pattern_forcing.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>
#include <random>
#include <vector>

#include "board.h"
#include "config.h"
#include "dlx.h"
#include "kernels.h"
#include "generator/pattern_forcing_exact_templates.h"
#include "sudoku_logic_engine.h"

namespace sudoku_hpc::pattern_forcing {

enum class PatternKind : uint8_t {
    None = 0,
    Chain,
    ExocetLike,
    LoopLike,
    ForcingLike
};

enum class TargetPattern : uint8_t {
    None = 0,
    XChain,
    XYChain,
    Exocet,
    MSLS
};

struct PatternSeedView {
    PatternKind kind = PatternKind::None;
    const std::vector<uint16_t>* seed_puzzle = nullptr;
    const std::vector<uint64_t>* allowed_masks = nullptr;
    const std::vector<uint8_t>* protected_cells = nullptr;
    int anchor_count = 0;
};

struct PatternScratch {
    int prepared_n = 0;
    int prepared_nn = 0;
    std::vector<uint16_t> seed_puzzle;
    std::vector<uint64_t> allowed_masks;
    std::vector<uint8_t> protected_cells;
    std::array<int, 64> anchors{};
    int anchor_count = 0;

    void ensure(const GenericTopology& topo) {
        if (prepared_nn != topo.nn) {
            seed_puzzle.assign(static_cast<size_t>(topo.nn), 0);
            allowed_masks.assign(static_cast<size_t>(topo.nn), 0ULL);
            protected_cells.assign(static_cast<size_t>(topo.nn), 0);
            prepared_nn = topo.nn;
        }
        if (prepared_n != topo.n) {
            prepared_n = topo.n;
        }
    }

    void reset(const GenericTopology& topo) {
        ensure(topo);
        std::fill(seed_puzzle.begin(), seed_puzzle.end(), 0);
        const uint64_t full = (topo.n >= 64) ? ~0ULL : ((1ULL << topo.n) - 1ULL);
        std::fill(allowed_masks.begin(), allowed_masks.end(), full);
        std::fill(protected_cells.begin(), protected_cells.end(), static_cast<uint8_t>(0));
        anchor_count = 0;
    }

    bool add_anchor(int idx) {
        if (idx < 0 || idx >= prepared_nn) return false;
        for (int i = 0; i < anchor_count; ++i) {
            if (anchors[static_cast<size_t>(i)] == idx) return false;
        }
        if (anchor_count >= static_cast<int>(anchors.size())) return false;
        anchors[static_cast<size_t>(anchor_count++)] = idx;
        return true;
    }
};

inline PatternScratch& tls_pattern_scratch() {
    thread_local PatternScratch s{};
    return s;
}

inline uint64_t full_mask_for_n(int n) {
    return (n >= 64) ? ~0ULL : ((1ULL << n) - 1ULL);
}

inline uint64_t random_digit_mask(int n, int want, std::mt19937_64& rng) {
    if (n <= 0) return 0ULL;
    const int k = std::clamp(want, 1, n);
    uint64_t m = 0ULL;
    int placed = 0;
    int guard = 0;
    while (placed < k && guard < n * 8) {
        ++guard;
        const int d0 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        const uint64_t bit = 1ULL << d0;
        if ((m & bit) != 0ULL) continue;
        m |= bit;
        ++placed;
    }
    if (m == 0ULL) {
        const int d0 = static_cast<int>(rng() % static_cast<uint64_t>(n));
        m = (1ULL << d0);
    }
    return m;
}

inline PatternKind pick_kind(RequiredStrategy required, int level) {
    switch (required) {
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
        return PatternKind::ExocetLike;
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::MSLS:
    case RequiredStrategy::PatternOverlayMethod:
        return PatternKind::LoopLike;
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
        return PatternKind::ForcingLike;
    default:
        break;
    }
    if (level >= 8) return PatternKind::ForcingLike;
    if (level >= 6) return PatternKind::Chain;
    return PatternKind::None;
}

inline bool build_chain_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (topo.n < 2) return false;
    const int n = topo.n;
    int r1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int r2 = r1;
    int c1 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c2 = c1;
    for (int t = 0; t < 64 && r2 == r1; ++t) r2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    for (int t = 0; t < 64 && c2 == c1; ++t) c2 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    if (r1 == r2 || c1 == c2) return false;
    sc.add_anchor(r1 * n + c1);
    sc.add_anchor(r1 * n + c2);
    sc.add_anchor(r2 * n + c2);
    sc.add_anchor(r2 * n + c1);
    return sc.anchor_count >= 4;
}

inline bool build_exocet_like_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (topo.box_rows <= 1 || topo.box_cols <= 1) return false;
    const int n = topo.n;
    const int box = static_cast<int>(rng() % static_cast<uint64_t>(n));
    const int house = 2 * n + box;
    const int start = topo.house_offsets[static_cast<size_t>(house)];
    const int end = topo.house_offsets[static_cast<size_t>(house + 1)];
    if (end - start < 2) return false;

    int b1 = topo.houses_flat[static_cast<size_t>(start + (rng() % static_cast<uint64_t>(end - start)))];
    int b2 = b1;
    for (int t = 0; t < 128; ++t) {
        const int c = topo.houses_flat[static_cast<size_t>(start + (rng() % static_cast<uint64_t>(end - start)))];
        if (c == b1) continue;
        if (topo.cell_row[static_cast<size_t>(c)] == topo.cell_row[static_cast<size_t>(b1)]) continue;
        if (topo.cell_col[static_cast<size_t>(c)] == topo.cell_col[static_cast<size_t>(b1)]) continue;
        b2 = c;
        break;
    }
    if (b1 == b2) return false;
    sc.add_anchor(b1);
    sc.add_anchor(b2);

    const int r1 = topo.cell_row[static_cast<size_t>(b1)];
    const int r2 = topo.cell_row[static_cast<size_t>(b2)];
    const int c1 = topo.cell_col[static_cast<size_t>(b1)];
    const int c2 = topo.cell_col[static_cast<size_t>(b2)];
    sc.add_anchor(r1 * n + c2);
    sc.add_anchor(r2 * n + c1);
    return sc.anchor_count >= 2;
}

inline bool build_loop_like_anchors(const GenericTopology& topo, PatternScratch& sc, std::mt19937_64& rng) {
    if (!build_chain_anchors(topo, sc, rng)) return false;
    const int n = topo.n;
    int r3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    int c3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    sc.add_anchor(r3 * n + c3);
    r3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    c3 = static_cast<int>(rng() % static_cast<uint64_t>(n));
    sc.add_anchor(r3 * n + c3);
    return sc.anchor_count >= 4;
}

inline int default_anchor_count(const GenericTopology& topo, PatternKind kind) {
    switch (kind) {
    case PatternKind::ExocetLike: return std::clamp(topo.n / 2, 4, 10);
    case PatternKind::LoopLike: return std::clamp(topo.n / 2 + 2, 6, 12);
    case PatternKind::ForcingLike: return std::clamp(topo.n / 2, 6, 12);
    case PatternKind::Chain: return std::clamp(topo.n / 3 + 3, 4, 10);
    default: return 0;
    }
}

inline void apply_anchor_masks(const GenericTopology& topo, PatternScratch& sc, PatternKind kind, std::mt19937_64& rng) {
    if (sc.anchor_count <= 0) return;
    const uint64_t full = full_mask_for_n(topo.n);
    uint64_t mask_a = random_digit_mask(topo.n, 2, rng);
    uint64_t mask_b = random_digit_mask(topo.n, 2, rng);
    uint64_t mask_c = random_digit_mask(topo.n, 3, rng);
    if (kind == PatternKind::ExocetLike) {
        const uint64_t shared = random_digit_mask(topo.n, 3, rng);
        if (sc.anchor_count >= 1) sc.allowed_masks[static_cast<size_t>(sc.anchors[0])] = shared;
        if (sc.anchor_count >= 2) sc.allowed_masks[static_cast<size_t>(sc.anchors[1])] = shared;
        for (int i = 2; i < sc.anchor_count; ++i) {
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = mask_c;
        }
        return;
    }
    if (kind == PatternKind::ForcingLike) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const uint64_t m = (i & 1) ? (mask_a | mask_b) : (mask_b | mask_c);
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (m & full);
        }
        return;
    }
    if (kind == PatternKind::LoopLike) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const uint64_t m = (i % 3 == 0) ? mask_c : ((i & 1) ? mask_a : mask_b);
            sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (m & full);
        }
        return;
    }
    for (int i = 0; i < sc.anchor_count; ++i) {
        sc.allowed_masks[static_cast<size_t>(sc.anchors[static_cast<size_t>(i)])] = (i & 1) ? mask_a : mask_b;
    }
}

inline bool build_seed(
    const GenericTopology& topo,
    const GenerateRunConfig& cfg,
    RequiredStrategy required_strategy,
    int difficulty_level_required,
    std::mt19937_64& rng,
    PatternSeedView& out) {
    out = {};
    if (!cfg.pattern_forcing_enabled) return false;

    PatternKind kind = pick_kind(required_strategy, difficulty_level_required);
    if (kind == PatternKind::None) return false;

    PatternScratch& sc = tls_pattern_scratch();
    sc.reset(topo);

    ExactPatternTemplatePlan exact_plan{};
    if (build_exact_pattern_template(topo, cfg, required_strategy, difficulty_level_required, rng, exact_plan) &&
        exact_plan.valid &&
        exact_plan.anchor_count > 0) {
        for (int i = 0; i < exact_plan.anchor_count; ++i) {
            const int idx = exact_plan.anchor_idx[static_cast<size_t>(i)];
            if (!sc.add_anchor(idx)) {
                continue;
            }
            uint64_t mask = exact_plan.anchor_masks[static_cast<size_t>(i)];
            if (mask == 0ULL) {
                mask = full_mask_for_n(topo.n);
            }
            sc.allowed_masks[static_cast<size_t>(idx)] = mask;
        }
        if (cfg.pattern_forcing_lock_anchors) {
            for (int i = 0; i < sc.anchor_count; ++i) {
                const int idx = sc.anchors[static_cast<size_t>(i)];
                sc.protected_cells[static_cast<size_t>(idx)] = 1;
            }
        }
        if (sc.anchor_count > 0) {
            out.kind = pick_kind(required_strategy, difficulty_level_required);
            if (out.kind == PatternKind::None) {
                out.kind = PatternKind::ForcingLike;
            }
            out.seed_puzzle = &sc.seed_puzzle;
            out.allowed_masks = &sc.allowed_masks;
            out.protected_cells = &sc.protected_cells;
            out.anchor_count = sc.anchor_count;
            return true;
        }
    }

    bool ok = false;
    switch (kind) {
    case PatternKind::ExocetLike:
        ok = build_exocet_like_anchors(topo, sc, rng);
        break;
    case PatternKind::LoopLike:
        ok = build_loop_like_anchors(topo, sc, rng);
        break;
    case PatternKind::ForcingLike:
    case PatternKind::Chain:
        ok = build_chain_anchors(topo, sc, rng);
        break;
    default:
        break;
    }
    if (!ok || sc.anchor_count <= 0) return false;

    int anchor_target = cfg.pattern_forcing_anchor_count > 0
        ? cfg.pattern_forcing_anchor_count
        : default_anchor_count(topo, kind);
    anchor_target = std::clamp(anchor_target, sc.anchor_count, std::min(topo.nn, 32));

    int guard = 0;
    while (sc.anchor_count < anchor_target && guard < topo.nn * 4) {
        ++guard;
        const int idx = static_cast<int>(rng() % static_cast<uint64_t>(topo.nn));
        sc.add_anchor(idx);
    }

    apply_anchor_masks(topo, sc, kind, rng);
    if (cfg.pattern_forcing_lock_anchors) {
        for (int i = 0; i < sc.anchor_count; ++i) {
            const int idx = sc.anchors[static_cast<size_t>(i)];
            sc.protected_cells[static_cast<size_t>(idx)] = 1;
        }
    }

    out.kind = kind;
    out.seed_puzzle = &sc.seed_puzzle;
    out.allowed_masks = &sc.allowed_masks;
    out.protected_cells = &sc.protected_cells;
    out.anchor_count = sc.anchor_count;
    return true;
}

inline RequiredStrategy target_pattern_to_required_strategy(TargetPattern p) {
    switch (p) {
    case TargetPattern::XChain: return RequiredStrategy::XChain;
    case TargetPattern::XYChain: return RequiredStrategy::XYChain;
    case TargetPattern::Exocet: return RequiredStrategy::Exocet;
    case TargetPattern::MSLS: return RequiredStrategy::MSLS;
    case TargetPattern::None:
    default:
        return RequiredStrategy::None;
    }
}

class PatternPlanter {
public:
    static bool plant_pattern(GenericBoard& board, TargetPattern pattern, std::mt19937_64& rng) {
        if (board.topo == nullptr) return false;
        if (pattern == TargetPattern::None) return true;
        GenerateRunConfig cfg{};
        cfg.pattern_forcing_enabled = true;
        cfg.pattern_forcing_lock_anchors = true;
        cfg.pattern_forcing_anchor_count = 0;
        PatternSeedView seed{};
        return build_seed(
            *board.topo,
            cfg,
            target_pattern_to_required_strategy(pattern),
            8,
            rng,
            seed);
    }
};

struct GenerateResult {
    bool success = false;
    std::vector<uint16_t> puzzle;
    int clues = 0;
    int attempts = 0;
};

class HpcAdvancedGenerator {
public:
    static GenerateResult generate(
        const GenericTopology& topo,
        const GenericUniquenessCounter& dlx_solver,
        const GenericLogicCertify& full_certifier,
        TargetPattern target_pattern,
        int target_clues,
        std::mt19937_64& rng,
        int max_attempts = 100) {
        GenerateResult out{};
        std::vector<uint16_t> empty_seed(static_cast<size_t>(topo.nn), 0);
        GenericDigKernel dig_kernel;

        GenerateRunConfig cfg{};
        cfg.box_rows = topo.box_rows;
        cfg.box_cols = topo.box_cols;
        cfg.min_clues = target_clues;
        cfg.max_clues = target_clues;
        cfg.pattern_forcing_enabled = (target_pattern != TargetPattern::None);
        cfg.pattern_forcing_lock_anchors = true;
        cfg.required_strategy = target_pattern_to_required_strategy(target_pattern);
        cfg.difficulty_level_required = (cfg.required_strategy == RequiredStrategy::None) ? 1 : 8;

        for (int attempt = 1; attempt <= std::max(1, max_attempts); ++attempt) {
            PatternSeedView seed{};
            const std::vector<uint16_t>* seed_puzzle = &empty_seed;
            const std::vector<uint64_t>* allowed_masks = nullptr;
            const uint8_t* protected_cells = nullptr;

            if (cfg.pattern_forcing_enabled) {
                if (!build_seed(topo, cfg, cfg.required_strategy, cfg.difficulty_level_required, rng, seed)) {
                    continue;
                }
                seed_puzzle = seed.seed_puzzle;
                allowed_masks = seed.allowed_masks;
                protected_cells = (seed.protected_cells != nullptr) ? seed.protected_cells->data() : nullptr;
            }

            std::vector<uint16_t> solved;
            if (!dlx_solver.solve_and_capture(*seed_puzzle, topo, solved, nullptr, allowed_masks)) {
                continue;
            }

            std::vector<uint16_t> puzzle;
            int clues = 0;
            dig_kernel.dig_into(solved, topo, cfg, rng, puzzle, clues, protected_cells);

            const GenericLogicCertifyResult cert = full_certifier.certify(puzzle, topo, nullptr, false);
            if (!cert.solved) continue;

            bool pattern_matched = false;
            switch (target_pattern) {
            case TargetPattern::Exocet:
                pattern_matched = cert.used_exocet;
                break;
            case TargetPattern::MSLS:
                pattern_matched = cert.used_msls;
                break;
            case TargetPattern::XChain:
                pattern_matched = cert.used_x_chain;
                break;
            case TargetPattern::XYChain:
                pattern_matched = cert.used_xy_chain;
                break;
            case TargetPattern::None:
            default:
                pattern_matched = true;
                break;
            }
            if (!pattern_matched) continue;

            out.success = true;
            out.puzzle = std::move(puzzle);
            out.clues = clues;
            out.attempts = attempt;
            return out;
        }

        out.attempts = std::max(1, max_attempts);
        return out;
    }
};

} // namespace sudoku_hpc::pattern_forcing

namespace sudoku_rewertyn::pattern_forcing {
using TargetPattern = sudoku_hpc::pattern_forcing::TargetPattern;
using PatternPlanter = sudoku_hpc::pattern_forcing::PatternPlanter;
using GenerateResult = sudoku_hpc::pattern_forcing::GenerateResult;
using HpcAdvancedGenerator = sudoku_hpc::pattern_forcing::HpcAdvancedGenerator;
}



==============================================================================
PLIK: Sources\generator_pipeline_v2_impl.h
==============================================================================

﻿// Author copyright Marcin Matysek (Rewertyn)
#pragma once

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>
#include <set>
#include <functional>
#include <filesystem>
#include <fstream>
#include <memory>
#include <cctype>
#include <unordered_map>
#include <cstdlib>
#include <type_traits>
#include <cstring>
#include <limits>
#include <charconv> // <-- Dodano dla Zero-Allocation Serialization
#include "generator_pattern_forcing.h"
#include "generator_mcts_digger.h"

// Forward declaration for regression tests used from parse_args
namespace sudoku_testy {
    void run_all_regression_tests(const std::string& report_path);
}

namespace sudoku_hpc {

struct GenericPuzzleCandidate {
    std::vector<uint16_t> puzzle;
    std::vector<uint16_t> solution;
    int clues = 0;
};

// ============================================================================
// OPTYMALIZACJA 1: ZERO-ALLOCATION SERIALIZATION
// Zamiast std::ostringstream uĹĽywamy bezpoĹ›redniego zapisu do bufora (std::to_chars).
// ============================================================================
static std::string serialize_line_generic(
    long long seed,
    const GenerateRunConfig& cfg,
    const GenericPuzzleCandidate& candidate,
    int nn) {
    
    std::string out;
    // Prealokacja maksymalnego rozmiaru by uniknÄ…Ä‡ realokacji
    out.resize(128 + static_cast<size_t>(nn) * 4); 
    char* ptr = out.data();
    char* end = ptr + out.size(); // <--- TUTAJ USUNIÄTO 'const'

    auto res1 = std::to_chars(ptr, end, seed); ptr = res1.ptr;
    *ptr++ = ',';
    auto res2 = std::to_chars(ptr, end, cfg.box_rows); ptr = res2.ptr;
    *ptr++ = ',';
    auto res3 = std::to_chars(ptr, end, cfg.box_cols); ptr = res3.ptr;

    const uint16_t* puz_ptr = candidate.puzzle.data();
    const uint16_t* sol_ptr = candidate.solution.data();

    for (int i = 0; i < nn; ++i) {
        *ptr++ = ',';
        const uint16_t v = puz_ptr[i];
        if (v != 0) {
            *ptr++ = 't';
            auto res = std::to_chars(ptr, end, v); ptr = res.ptr;
        } else {
            auto res = std::to_chars(ptr, end, sol_ptr[i]); ptr = res.ptr;
        }
    }
    
    // Obcinamy ciÄ…g znakĂłw do faktycznie zuĹĽytej wielkoĹ›ci
    out.resize(ptr - out.data());
    return out;
}

inline long long bounded_positive_seed_i64(uint64_t raw_seed) {
    constexpr uint64_t kSigned64Max = static_cast<uint64_t>(std::numeric_limits<long long>::max());
    const uint64_t bounded = (raw_seed % kSigned64Max) + 1ULL;
    return static_cast<long long>(bounded);
}

inline long long random_seed_i64() {
    uint64_t seed_state = static_cast<uint64_t>(std::chrono::high_resolution_clock::now().time_since_epoch().count());
    std::random_device rd;
    seed_state ^= (static_cast<uint64_t>(rd()) << 32);
    seed_state ^= static_cast<uint64_t>(rd());
    return bounded_positive_seed_i64(splitmix64(seed_state));
}

static int strategy_to_hist_idx_shared(RequiredStrategy strategy) {
    switch (strategy) {
    case RequiredStrategy::None: return 0;
    case RequiredStrategy::NakedSingle: return 1;
    case RequiredStrategy::HiddenSingle: return 2;
    case RequiredStrategy::PointingPairs: return 3;
    case RequiredStrategy::BoxLineReduction: return 4;
    case RequiredStrategy::NakedPair: return 5;
    case RequiredStrategy::HiddenPair: return 6;
    case RequiredStrategy::NakedTriple: return 7;
    case RequiredStrategy::HiddenTriple: return 8;
    case RequiredStrategy::NakedQuad: return 9;
    case RequiredStrategy::HiddenQuad: return 10;
    case RequiredStrategy::XWing: return 11;
    case RequiredStrategy::YWing: return 12;
    case RequiredStrategy::Skyscraper: return 13;
    case RequiredStrategy::TwoStringKite: return 14;
    case RequiredStrategy::EmptyRectangle: return 15;
    case RequiredStrategy::RemotePairs: return 16;
    case RequiredStrategy::Swordfish: return 17;
    case RequiredStrategy::FinnedXWingSashimi: return 18;
    case RequiredStrategy::SimpleColoring: return 19;
    case RequiredStrategy::BUGPlusOne: return 20;
    case RequiredStrategy::UniqueRectangle: return 21;
    case RequiredStrategy::XYZWing: return 22;
    case RequiredStrategy::WWing: return 23;
    case RequiredStrategy::Jellyfish: return 24;
    case RequiredStrategy::XChain: return 25;
    case RequiredStrategy::XYChain: return 26;
    case RequiredStrategy::WXYZWing: return 27;
    case RequiredStrategy::FinnedSwordfishJellyfish: return 28;
    case RequiredStrategy::ALSXZ: return 29;
    case RequiredStrategy::UniqueLoop: return 30;
    case RequiredStrategy::AvoidableRectangle: return 31;
    case RequiredStrategy::BivalueOddagon: return 32;
    case RequiredStrategy::UniqueRectangleExtended: return 53;
    case RequiredStrategy::HiddenUniqueRectangle: return 54;
    case RequiredStrategy::BUGType2: return 55;
    case RequiredStrategy::BUGType3: return 56;
    case RequiredStrategy::BUGType4: return 57;
    case RequiredStrategy::BorescoperQiuDeadlyPattern: return 58;
    case RequiredStrategy::Medusa3D: return 33;
    case RequiredStrategy::AIC: return 34;
    case RequiredStrategy::GroupedAIC: return 35;
    case RequiredStrategy::GroupedXCycle: return 36;
    case RequiredStrategy::ContinuousNiceLoop: return 37;
    case RequiredStrategy::ALSXYWing: return 38;
    case RequiredStrategy::ALSChain: return 39;
    case RequiredStrategy::SueDeCoq: return 40;
    case RequiredStrategy::DeathBlossom: return 41;
    case RequiredStrategy::FrankenFish: return 42;
    case RequiredStrategy::MutantFish: return 43;
    case RequiredStrategy::KrakenFish: return 44;
    case RequiredStrategy::AlignedPairExclusion: return 59;
    case RequiredStrategy::AlignedTripleExclusion: return 60;
    case RequiredStrategy::ALSAIC: return 61;
    case RequiredStrategy::MSLS: return 45;
    case RequiredStrategy::Exocet: return 46;
    case RequiredStrategy::SeniorExocet: return 47;
    case RequiredStrategy::SKLoop: return 48;
    case RequiredStrategy::PatternOverlayMethod: return 49;
    case RequiredStrategy::ForcingChains: return 50;
    case RequiredStrategy::DynamicForcingChains: return 62;
    case RequiredStrategy::Backtracking: return 51;
    case RequiredStrategy::Squirmbag: return 52;
    default: return 0;
    }
}

template <typename T>
struct alignas(64) PaddedAtomic {
    std::atomic<T> value;

    constexpr PaddedAtomic() noexcept : value() {}
    constexpr explicit PaddedAtomic(T init) noexcept : value(init) {}

    PaddedAtomic(const PaddedAtomic&) = delete;
    PaddedAtomic& operator=(const PaddedAtomic&) = delete;

    T load(std::memory_order order = std::memory_order_seq_cst) const noexcept {
        return value.load(order);
    }

    void store(T v, std::memory_order order = std::memory_order_seq_cst) noexcept {
        value.store(v, order);
    }

    T exchange(T v, std::memory_order order = std::memory_order_seq_cst) noexcept {
        return value.exchange(v, order);
    }

    template <typename U = T, typename = std::enable_if_t<std::is_integral_v<U> && !std::is_same_v<U, bool>>>
    U fetch_add(U v, std::memory_order order = std::memory_order_seq_cst) noexcept {
        return value.fetch_add(v, order);
    }

    template <typename U = T, typename = std::enable_if_t<std::is_integral_v<U> && !std::is_same_v<U, bool>>>
    U fetch_sub(U v, std::memory_order order = std::memory_order_seq_cst) noexcept {
        return value.fetch_sub(v, order);
    }
};

struct TelemetryDelta {
    uint64_t attempts = 0;
    uint64_t rejected = 0;
    uint64_t reject_prefilter = 0;
    uint64_t reject_logic = 0;
    uint64_t reject_uniqueness = 0;
    uint64_t reject_strategy = 0;
    uint64_t reject_replay = 0;
    uint64_t reject_distribution_bias = 0;
    uint64_t reject_uniqueness_budget = 0;
    uint64_t analyzed_required = 0;
    uint64_t required_hits = 0;
    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    uint64_t uniqueness_elapsed_ns = 0;
    uint64_t logic_steps = 0;
    uint64_t naked_use = 0;
    uint64_t naked_hit = 0;
    uint64_t hidden_use = 0;
    uint64_t hidden_hit = 0;
    uint64_t reseeds = 0;

    bool empty() const noexcept {
        return attempts == 0 && rejected == 0 && reject_prefilter == 0 &&
               reject_logic == 0 && reject_uniqueness == 0 && reject_strategy == 0 &&
               reject_replay == 0 && reject_distribution_bias == 0 &&
               reject_uniqueness_budget == 0 && analyzed_required == 0 &&
               required_hits == 0 && uniqueness_calls == 0 && uniqueness_nodes == 0 &&
               uniqueness_elapsed_ns == 0 && logic_steps == 0 && naked_use == 0 &&
               naked_hit == 0 && hidden_use == 0 && hidden_hit == 0 && reseeds == 0;
    }
};

template <size_t CapacityPow2 = 16384>
class alignas(64) TelemetryMpscRing {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "CapacityPow2 must be power-of-two");

    struct alignas(64) Slot {
        std::atomic<uint64_t> seq{0};
        TelemetryDelta payload{};
    };

public:
    TelemetryMpscRing() {
        for (size_t i = 0; i < CapacityPow2; ++i) {
            slots_[i].seq.store(static_cast<uint64_t>(i), std::memory_order_relaxed);
        }
    }

    bool try_push(const TelemetryDelta& delta) noexcept {
        uint64_t pos = head_.load(std::memory_order_relaxed);
        for (;;) {
            Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
            const uint64_t seq = slot.seq.load(std::memory_order_acquire);
            const intptr_t diff = static_cast<intptr_t>(seq) - static_cast<intptr_t>(pos);
            if (diff == 0) {
                if (head_.compare_exchange_weak(pos, pos + 1ULL, std::memory_order_relaxed, std::memory_order_relaxed)) {
                    slot.payload = delta;
                    slot.seq.store(pos + 1ULL, std::memory_order_release);
                    return true;
                }
                continue;
            }
            if (diff < 0) {
                dropped_.fetch_add(1, std::memory_order_relaxed);
                return false;
            }
            pos = head_.load(std::memory_order_relaxed);
        }
    }

    bool try_pop(TelemetryDelta& out) noexcept {
        const uint64_t pos = tail_.load(std::memory_order_relaxed);
        Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
        const uint64_t seq = slot.seq.load(std::memory_order_acquire);
        if (seq != (pos + 1ULL)) {
            return false;
        }
        out = slot.payload;
        slot.seq.store(pos + CapacityPow2, std::memory_order_release);
        tail_.store(pos + 1ULL, std::memory_order_relaxed);
        return true;
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

private:
    static constexpr uint64_t kMask = static_cast<uint64_t>(CapacityPow2 - 1);
    std::array<Slot, CapacityPow2> slots_{};
    alignas(64) std::atomic<uint64_t> head_{0};
    alignas(64) std::atomic<uint64_t> tail_{0};
    alignas(64) std::atomic<uint64_t> dropped_{0};
};

struct OutputLineEvent {
    static constexpr size_t kMaxLineBytes = 8192;
    uint64_t accepted_idx = 0;
    uint32_t len = 0;
    std::array<char, kMaxLineBytes> bytes{};
};

template <size_t CapacityPow2 = 2048>
class alignas(64) OutputLineMpscRing {
    static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "CapacityPow2 must be power-of-two");

    struct alignas(64) Slot {
        std::atomic<uint64_t> seq{0};
        OutputLineEvent payload{};
    };

public:
    OutputLineMpscRing() {
        for (size_t i = 0; i < CapacityPow2; ++i) {
            slots_[i].seq.store(static_cast<uint64_t>(i), std::memory_order_relaxed);
        }
    }

    bool try_push(uint64_t accepted_idx, const std::string& line) noexcept {
        if (line.size() > OutputLineEvent::kMaxLineBytes) {
            oversize_.fetch_add(1, std::memory_order_relaxed);
            return false;
        }
        uint64_t pos = head_.load(std::memory_order_relaxed);
        for (;;) {
            Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
            const uint64_t seq = slot.seq.load(std::memory_order_acquire);
            const intptr_t diff = static_cast<intptr_t>(seq) - static_cast<intptr_t>(pos);
            if (diff == 0) {
                if (head_.compare_exchange_weak(pos, pos + 1ULL, std::memory_order_relaxed, std::memory_order_relaxed)) {
                    slot.payload.accepted_idx = accepted_idx;
                    slot.payload.len = static_cast<uint32_t>(line.size());
                    std::memcpy(slot.payload.bytes.data(), line.data(), line.size());
                    slot.seq.store(pos + 1ULL, std::memory_order_release);
                    return true;
                }
                continue;
            }
            if (diff < 0) {
                dropped_.fetch_add(1, std::memory_order_relaxed);
                return false;
            }
            pos = head_.load(std::memory_order_relaxed);
        }
    }

    bool try_pop(OutputLineEvent& out) noexcept {
        const uint64_t pos = tail_.load(std::memory_order_relaxed);
        Slot& slot = slots_[static_cast<size_t>(pos & kMask)];
        const uint64_t seq = slot.seq.load(std::memory_order_acquire);
        if (seq != (pos + 1ULL)) {
            return false;
        }
        out = slot.payload;
        slot.seq.store(pos + CapacityPow2, std::memory_order_release);
        tail_.store(pos + 1ULL, std::memory_order_relaxed);
        return true;
    }

    bool empty() const noexcept {
        return tail_.load(std::memory_order_acquire) == head_.load(std::memory_order_acquire);
    }

    uint64_t dropped() const noexcept {
        return dropped_.load(std::memory_order_relaxed);
    }

    uint64_t oversize() const noexcept {
        return oversize_.load(std::memory_order_relaxed);
    }

private:
    static constexpr uint64_t kMask = static_cast<uint64_t>(CapacityPow2 - 1);
    std::array<Slot, CapacityPow2> slots_{};
    alignas(64) std::atomic<uint64_t> head_{0};
    alignas(64) std::atomic<uint64_t> tail_{0};
    alignas(64) std::atomic<uint64_t> dropped_{0};
    alignas(64) std::atomic<uint64_t> oversize_{0};
};

// ============================================================================
// OPTYMALIZACJA 4: EXTREME LOW-LATENCY THREAD POOL (Zero shared_ptr, uĹĽyto atomic::wait)
// ============================================================================
class PersistentThreadPool {
public:
    static PersistentThreadPool& instance() {
        static PersistentThreadPool pool;
        return pool;
    }

    void run(int task_count, const std::function<void(int)>& fn) {
        if (task_count <= 0) {
            return;
        }
        std::lock_guard<std::mutex> run_guard(run_mu_);
        ensure_workers(task_count);

        job_fn_ = &fn;
        task_count_.store(task_count, std::memory_order_relaxed);
        next_task_.store(0, std::memory_order_relaxed);
        remaining_.store(task_count, std::memory_order_release);
        
        // ZbudĹş workery korzystajÄ…c z szybkiego mechanizmu w C++20
        epoch_.fetch_add(1, std::memory_order_acq_rel);
        epoch_.notify_all();

        // Czekaj bez aktywnego spinowania aĹĽ ostatni worker zakoĹ„czy zadanie.
        while (true) {
            const int rem = remaining_.load(std::memory_order_acquire);
            if (rem <= 0) break;
            remaining_.wait(rem, std::memory_order_acquire);
        }
    }

private:
    PersistentThreadPool() = default;

    ~PersistentThreadPool() {
        stop_.store(true, std::memory_order_release);
        epoch_.fetch_add(1, std::memory_order_acq_rel);
        epoch_.notify_all();
        for (auto& t : workers_) {
            if (t.joinable()) {
                t.join();
            }
        }
    }

    void ensure_workers(int min_workers) {
        const int base = std::max(1u, std::thread::hardware_concurrency());
        const int target = std::max(base, min_workers);
        if (static_cast<int>(workers_.size()) >= target) {
            return;
        }
        workers_.reserve(static_cast<size_t>(target));
        for (int i = static_cast<int>(workers_.size()); i < target; ++i) {
            workers_.emplace_back([this]() { worker_loop(); });
        }
    }

    void worker_loop() {
        // Start od 0 zabezpiecza przed "missed wake-up" dla workerĂłw,
        // ktĂłre wystartujÄ… juĹĽ po podbiciu epoch przez pierwszy run().
        uint64_t seen_epoch = 0;
        while (true) {
            if (stop_.load(std::memory_order_acquire)) return;
            
            epoch_.wait(seen_epoch, std::memory_order_acquire);
            seen_epoch = epoch_.load(std::memory_order_acquire);
            
            if (stop_.load(std::memory_order_acquire)) return;

            while (true) {
                const int idx = next_task_.fetch_add(1, std::memory_order_relaxed);
                if (idx >= task_count_.load(std::memory_order_relaxed)) {
                    break;
                }
                
                (*job_fn_)(idx);
                
                if (remaining_.fetch_sub(1, std::memory_order_acq_rel) == 1) {
                    remaining_.notify_one();
                }
            }
        }
    }

    std::mutex run_mu_;
    std::vector<std::thread> workers_;
    
    const std::function<void(int)>* job_fn_{nullptr};
    alignas(64) std::atomic<int> task_count_{0};
    alignas(64) std::atomic<int> next_task_{0};
    alignas(64) std::atomic<int> remaining_{0};
    
    alignas(64) std::atomic<uint64_t> epoch_{0};
    alignas(64) std::atomic<bool> stop_{false};
};

struct ClueRange {
    int min_clues = 0;
    int max_clues = 0;
};

enum class GenerationMode {
    Full,
    Lite,
    TopologyOnly
};

inline const char* generation_mode_name(GenerationMode mode) {
    switch (mode) {
    case GenerationMode::Full: return "full";
    case GenerationMode::Lite: return "lite";
    case GenerationMode::TopologyOnly: return "topology_only";
    default: return "unknown";
    }
}

struct GenerationProfile {
    GenerationMode mode = GenerationMode::Full;
    ClueRange clue_range{};
    double suggested_budget_s = 0.0;
    double asymmetry_ratio = 1.0;
    bool is_symmetric = true;
    std::string reason;
};

inline double asymmetry_ratio_for_geometry(int box_rows, int box_cols) {
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    return static_cast<double>(std::max(safe_box_rows, safe_box_cols)) /
           static_cast<double>(std::min(safe_box_rows, safe_box_cols));
}

GenerationProfile resolve_generation_profile(
    int box_rows,
    int box_cols,
    int level,
    RequiredStrategy strategy,
    const GenerateRunConfig* cfg_override = nullptr);
inline bool required_strategy_runtime_ready(RequiredStrategy strategy);
inline bool required_strategy_math_supported(RequiredStrategy strategy, int box_rows, int box_cols);
inline bool required_strategy_selectable_for_geometry(RequiredStrategy strategy, int box_rows, int box_cols);
inline bool difficulty_level_runtime_ready(int level);
inline bool difficulty_level_selectable_for_geometry(int level, int box_rows, int box_cols);
int strategy_adjusted_level(int level, RequiredStrategy strategy);

inline std::string normalize_profile_mode_policy(std::string policy_raw) {
    std::string key;
    key.reserve(policy_raw.size());
    for (unsigned char ch : policy_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "full") return "full";
    return "adaptive";
}

inline std::string normalize_cpu_backend_policy(std::string policy_raw) {
    std::string key;
    key.reserve(policy_raw.size());
    for (unsigned char ch : policy_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "scalar") return "scalar";
    if (key == "avx2") return "avx2";
    if (key == "avx512" || key == "avx512f") return "avx512";
    return "auto";
}

inline std::string normalize_difficulty_engine(std::string engine_raw) {
    std::string key;
    key.reserve(engine_raw.size());
    for (unsigned char ch : engine_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "vip") return "vip";
    return "standard";
}

inline std::string normalize_asym_heuristics_mode(std::string mode_raw) {
    std::string key;
    key.reserve(mode_raw.size());
    for (unsigned char ch : mode_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "off" || key == "none") return "off";
    if (key == "aggressive" || key == "high") return "aggressive";
    return "balanced";
}

inline std::string normalize_vip_score_profile(std::string profile_raw) {
    std::string key;
    key.reserve(profile_raw.size());
    for (unsigned char ch : profile_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "strict") return "strict";
    if (key == "ultra") return "ultra";
    return "standard";
}

inline std::string normalize_vip_trace_level(std::string level_raw) {
    std::string key;
    key.reserve(level_raw.size());
    for (unsigned char ch : level_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "full" || key == "verbose") return "full";
    return "basic";
}

inline std::string normalize_vip_grade_target(std::string grade_raw) {
    std::string key;
    key.reserve(grade_raw.size());
    for (unsigned char ch : grade_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "bronze") return "bronze";
    if (key == "silver") return "silver";
    if (key == "platinum") return "platinum";
    return "gold";
}

inline std::string normalize_mcts_tuning_profile(std::string profile_raw) {
    std::string key;
    key.reserve(profile_raw.size());
    for (unsigned char ch : profile_raw) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key == "off" || key == "none" || key == "disabled") return "off";
    if (key == "p7" || key == "level7" || key == "nightmare") return "p7";
    if (key == "p8" || key == "level8" || key == "theoretical") return "p8";
    return "auto";
}

inline int vip_grade_rank(std::string grade) {
    const std::string g = normalize_vip_grade_target(std::move(grade));
    if (g == "bronze") return 1;
    if (g == "silver") return 2;
    if (g == "gold") return 3;
    if (g == "platinum") return 4;
    return 0;
}

struct RuntimeCpuContext {
    std::string requested_policy = "auto";
    std::string selected_backend = "scalar";
    bool avx2_supported = false;
    bool avx512_supported = false;
    std::string reason;
};

inline bool cpu_supports_avx2() {
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
    return __builtin_cpu_supports("avx2");
#else
    return false;
#endif
}

inline bool cpu_supports_avx512() {
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
    return __builtin_cpu_supports("avx512f");
#else
    return false;
#endif
}

inline RuntimeCpuContext resolve_runtime_cpu_context(const GenerateRunConfig& cfg) {
    RuntimeCpuContext ctx{};
    ctx.requested_policy = normalize_cpu_backend_policy(cfg.cpu_backend_policy);
    ctx.avx2_supported = cpu_supports_avx2();
    ctx.avx512_supported = cpu_supports_avx512();

    if (ctx.requested_policy == "scalar") {
        ctx.selected_backend = "scalar";
        ctx.reason = "policy=scalar";
        return ctx;
    }
    if (ctx.requested_policy == "avx2") {
        if (ctx.avx2_supported) {
            ctx.selected_backend = "avx2";
            ctx.reason = "policy=avx2_supported";
        } else {
            ctx.selected_backend = "scalar";
            ctx.reason = "policy=avx2_unsupported_fallback_scalar";
        }
        return ctx;
    }
    if (ctx.requested_policy == "avx512") {
        if (ctx.avx512_supported) {
            ctx.selected_backend = "avx512";
            ctx.reason = "policy=avx512_supported";
        } else if (ctx.avx2_supported) {
            ctx.selected_backend = "avx2";
            ctx.reason = "policy=avx512_unsupported_fallback_avx2";
        } else {
            ctx.selected_backend = "scalar";
            ctx.reason = "policy=avx512_unsupported_fallback_scalar";
        }
        return ctx;
    }

    if (ctx.avx512_supported) {
        ctx.selected_backend = "avx512";
        ctx.reason = "auto_pick_avx512";
    } else if (ctx.avx2_supported) {
        ctx.selected_backend = "avx2";
        ctx.reason = "auto_pick_avx2";
    } else {
        ctx.selected_backend = "scalar";
        ctx.reason = "auto_pick_scalar";
    }
    return ctx;
}

struct QualityMetrics {
    int clues = 0;
    int row_min = 0;
    int row_max = 0;
    int col_min = 0;
    int col_max = 0;
    int box_min = 0;
    int box_max = 0;

    int digit_min = 0;
    int digit_max = 0;
    double normalized_entropy = 0.0;
    double entropy_threshold = 0.0;
    bool symmetry_ok = true;
    bool distribution_balance_ok = true;
};

struct QualityContract {
    bool is_unique = true;
    bool logic_replay_ok = true;
    bool clue_range_ok = true;
    bool symmetry_ok = true;
    bool givens_entropy_ok = true;
    bool distribution_balance_ok = true;
    std::string generation_mode;
};

struct ReplayValidationResult {
    bool ok = false;
    bool solved = false;
    uint64_t puzzle_hash = 0;
    uint64_t expected_solution_hash = 0;
    uint64_t replay_solution_hash = 0;
    uint64_t trace_hash = 0;
};

// ============================================================================
// OPTYMALIZACJA 4: WEKTORYZACJA HASHOWANIA
// Procesor trawi pamiÄ™Ä‡ paczkami 64-bitowymi zamiast bajtami.
// ============================================================================
inline uint64_t fnv1a64_bytes(const void* data, size_t len, uint64_t seed = 1469598103934665603ULL) {
    uint64_t h = seed;
    const size_t blocks = len / 8;
    const size_t remainder = len % 8;
    const uint64_t* ptr64 = static_cast<const uint64_t*>(data);
    
    // PÄ™tla odwijana i pipelinowana przez kompilator dla 64-bitowych sĹ‚Ăłw
    for (size_t i = 0; i < blocks; ++i) {
        h ^= ptr64[i];
        h *= 1099511628211ULL;
    }
    
    // Ewentualna reszta (max 7 bajtĂłw)
    if (remainder > 0) {
        const uint8_t* ptr8 = reinterpret_cast<const uint8_t*>(ptr64 + blocks);
        for (size_t i = 0; i < remainder; ++i) {
            h ^= static_cast<uint64_t>(ptr8[i]);
            h *= 1099511628211ULL;
        }
    }
    return h;
}

inline uint64_t hash_u16_vector(const std::vector<uint16_t>& data, uint64_t seed = 1469598103934665603ULL) {
    if (data.empty()) return seed;
    return fnv1a64_bytes(data.data(), data.size() * sizeof(uint16_t), seed);
}

inline bool check_center_symmetry_givens(const std::vector<uint16_t>& puzzle, const GenericTopology& topo) {
    const auto& sym = topo.cell_center_sym;
    const uint16_t* const puzzle_ptr = puzzle.data();
    for (int idx = 0; idx < topo.nn; ++idx) {
        const int sym_idx = sym[static_cast<size_t>(idx)];
        if (idx > sym_idx) continue;
        
        const bool given_a = puzzle_ptr[static_cast<size_t>(idx)] != 0;
        const bool given_b = puzzle_ptr[static_cast<size_t>(sym_idx)] != 0;
        if (given_a != given_b) {
            return false;
        }
    }
    return true;
}

inline double entropy_threshold_for_n(int n) {
    if (n <= 12) return 0.40;
    if (n <= 24) return 0.55;
    return 0.65;
}

// ============================================================================
// OPTYMALIZACJA 2: BĹYSKAWICZNA ENTROPIA
// Tworzymy Look-Up Table (LUT) przy starcie, aby ominÄ…Ä‡ ciÄ™ĹĽkie std::log2 w pÄ™tli.
// ============================================================================
inline const std::array<double, 82>& get_c_log2_c_lut() {
    static const std::array<double, 82> lut = []() {
        std::array<double, 82> arr{};
        arr[0] = 0.0;
        for (int i = 1; i <= 81; ++i) {
            arr[i] = static_cast<double>(i) * std::log2(static_cast<double>(i));
        }
        return arr;
    }();
    return lut;
}

inline QualityMetrics evaluate_quality_metrics(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    const GenerateRunConfig& cfg) {
    QualityMetrics m{};
    GenericThreadScratch& scratch = generic_tls_for(topo);
    std::vector<int>& row_counts = scratch.row_count_tmp;
    std::vector<int>& col_counts = scratch.col_count_tmp;
    std::vector<int>& box_counts = scratch.box_count_tmp;
    std::vector<int>& digit_counts = scratch.digit_count_tmp;
    const auto& rcb = topo.cell_rcb_packed;
    std::fill(row_counts.begin(), row_counts.end(), 0);
    std::fill(col_counts.begin(), col_counts.end(), 0);
    std::fill(box_counts.begin(), box_counts.end(), 0);
    std::fill(digit_counts.begin(), digit_counts.end(), 0);
    int* const row_ptr = row_counts.data();
    int* const col_ptr = col_counts.data();
    int* const box_ptr = box_counts.data();
    int* const digit_ptr = digit_counts.data();
    const uint32_t* const packed = rcb.data();
    const uint16_t* const puzzle_ptr = puzzle.data();

    for (int idx = 0; idx < topo.nn; ++idx) {
        const int v = static_cast<int>(puzzle_ptr[static_cast<size_t>(idx)]);
        if (v <= 0) continue;
        
        ++m.clues;
        const uint32_t p = packed[static_cast<size_t>(idx)];
        const int r = GenericBoard::packed_row(p);
        const int c = GenericBoard::packed_col(p);
        const int b = GenericBoard::packed_box(p);
        ++row_ptr[static_cast<size_t>(r)];
        ++col_ptr[static_cast<size_t>(c)];
        ++box_ptr[static_cast<size_t>(b)];
        if (v <= topo.n) {
            ++digit_ptr[static_cast<size_t>(v - 1)];
        }
    }

    auto minmax_counts = [n = topo.n](const std::vector<int>& counts) -> std::pair<int, int> {
        if (n <= 0) return {0, 0};
        int mn = counts[0];
        int mx = counts[0];
        for (int i = 1; i < n; ++i) {
            const int x = counts[static_cast<size_t>(i)];
            mn = std::min(mn, x);
            mx = std::max(mx, x);
        }
        return {mn, mx};
    };

    const auto [row_min, row_max] = minmax_counts(row_counts);
    const auto [col_min, col_max] = minmax_counts(col_counts);
    const auto [box_min, box_max] = minmax_counts(box_counts);
    const auto [digit_min, digit_max] = minmax_counts(digit_counts);
    m.row_min = row_min;
    m.row_max = row_max;
    m.col_min = col_min;
    m.col_max = col_max;
    m.box_min = box_min;
    m.box_max = box_max;
    m.digit_min = digit_min;
    m.digit_max = digit_max;

    double entropy = 0.0;
    if (m.clues > 0) {
        double sum_c_log2_c = 0.0;
        const auto& lut = get_c_log2_c_lut();
        for (int c : digit_counts) {
            if (c > 0 && c <= 81) { // Chroni przed wyjĹ›ciem poza LUT w skrajnych siatkach
                sum_c_log2_c += lut[static_cast<size_t>(c)];
            }
        }
        const double T = static_cast<double>(m.clues);
        entropy = std::log2(T) - (sum_c_log2_c / T);
        
        const double max_entropy = std::log2(static_cast<double>(topo.n));
        m.normalized_entropy = max_entropy > 0.0 ? (entropy / max_entropy) : 0.0;
    }
    
    m.entropy_threshold = entropy_threshold_for_n(topo.n);
    m.symmetry_ok = (!cfg.symmetry_center) || check_center_symmetry_givens(puzzle, topo);

    const double ideal = topo.n > 0 ? static_cast<double>(m.clues) / static_cast<double>(topo.n) : 0.0;
    const double allowed_dev = std::max(2.0, ideal * 0.80);
    const auto within_dev = [ideal, allowed_dev](int x) {
        return std::abs(static_cast<double>(x) - ideal) <= (allowed_dev + 1.0);
    };
    const bool rows_ok = within_dev(m.row_min) && within_dev(m.row_max);
    const bool cols_ok = within_dev(m.col_min) && within_dev(m.col_max);
    const bool boxes_ok = within_dev(m.box_min) && within_dev(m.box_max);
    const bool digits_ok = within_dev(m.digit_min) && within_dev(m.digit_max);
    m.distribution_balance_ok = rows_ok && cols_ok && boxes_ok && digits_ok;
    return m;
}

inline ReplayValidationResult run_replay_validation(
    const std::vector<uint16_t>& puzzle,
    const std::vector<uint16_t>& expected_solution,
    const GenericTopology& topo,
    const GenericLogicCertify& logic) {
    ReplayValidationResult out{};
    out.puzzle_hash = hash_u16_vector(puzzle);
    out.expected_solution_hash = hash_u16_vector(expected_solution);
    const GenericLogicCertifyResult replay = logic.certify(puzzle, topo, nullptr, true);
    out.solved = replay.solved;
    out.replay_solution_hash = hash_u16_vector(replay.solved_grid);

    uint64_t trace_seed = 1469598103934665603ULL;
    trace_seed = fnv1a64_bytes(&replay.steps, sizeof(replay.steps), trace_seed);
    for (const auto& st : replay.strategy_stats) {
        trace_seed = fnv1a64_bytes(&st.use_count, sizeof(st.use_count), trace_seed);
        trace_seed = fnv1a64_bytes(&st.hit_count, sizeof(st.hit_count), trace_seed);
        trace_seed = fnv1a64_bytes(&st.placements, sizeof(st.placements), trace_seed);
    }
    out.trace_hash = trace_seed;
    out.ok = replay.solved && replay.solved_grid == expected_solution;
    return out;
}

inline bool quality_contract_passed(const QualityContract& c, const GenerateRunConfig& cfg) {
    if (!cfg.enable_quality_contract) return true;
    if (!c.is_unique) return false;
    if (!c.clue_range_ok || !c.symmetry_ok) return false;
    if (!c.givens_entropy_ok) return false;
    if (cfg.enable_distribution_filter && !c.distribution_balance_ok) return false;
    if (cfg.enable_replay_validation && !c.logic_replay_ok) return false;
    return true;
}

static bool evaluate_required_strategy_contract_generic(
    const GenericLogicCertifyResult& logic_result,
    RequiredStrategy required,
    RequiredStrategyAttemptInfo& strategy_info) {
    strategy_info = {};
    if (required == RequiredStrategy::None) {
        return true;
    }
    switch (required) {
    case RequiredStrategy::NakedSingle:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedSingle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedSingle].hit_count > 0;
        break;
    case RequiredStrategy::HiddenSingle:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenSingle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenSingle].hit_count > 0;
        break;
    case RequiredStrategy::PointingPairs:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotPointingPairs].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotPointingPairs].hit_count > 0;
        break;
    case RequiredStrategy::BoxLineReduction:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotBoxLineReduction].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotBoxLineReduction].hit_count > 0;
        break;
    case RequiredStrategy::NakedPair:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedPair].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedPair].hit_count > 0;
        break;
    case RequiredStrategy::HiddenPair:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenPair].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenPair].hit_count > 0;
        break;
    case RequiredStrategy::NakedTriple:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedTriple].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedTriple].hit_count > 0;
        break;
    case RequiredStrategy::HiddenTriple:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenTriple].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenTriple].hit_count > 0;
        break;
    case RequiredStrategy::NakedQuad:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedQuad].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotNakedQuad].hit_count > 0;
        break;
    case RequiredStrategy::HiddenQuad:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenQuad].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenQuad].hit_count > 0;
        break;
    case RequiredStrategy::XWing:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXWing].hit_count > 0;
        break;
    case RequiredStrategy::YWing:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotYWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotYWing].hit_count > 0;
        break;
    case RequiredStrategy::Skyscraper:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSkyscraper].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSkyscraper].hit_count > 0;
        break;
    case RequiredStrategy::TwoStringKite:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotTwoStringKite].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotTwoStringKite].hit_count > 0;
        break;
    case RequiredStrategy::EmptyRectangle:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotEmptyRectangle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotEmptyRectangle].hit_count > 0;
        break;
    case RequiredStrategy::RemotePairs:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotRemotePairs].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotRemotePairs].hit_count > 0;
        break;
    case RequiredStrategy::Swordfish:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].hit_count > 0;
        break;
    case RequiredStrategy::FinnedXWingSashimi:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotFinnedXWingSashimi].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotFinnedXWingSashimi].hit_count > 0;
        break;
    case RequiredStrategy::SimpleColoring:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSimpleColoring].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotSimpleColoring].hit_count > 0;
        break;
    case RequiredStrategy::BUGPlusOne:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotBUGPlusOne].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotBUGPlusOne].hit_count > 0;
        break;
    case RequiredStrategy::UniqueRectangle:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].hit_count > 0;
        break;
    case RequiredStrategy::XYZWing:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXYZWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXYZWing].hit_count > 0;
        break;
    case RequiredStrategy::WWing:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotWWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotWWing].hit_count > 0;
        break;
    case RequiredStrategy::Jellyfish:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].hit_count > 0;
        break;
    case RequiredStrategy::XChain:
        strategy_info.required_strategy_use_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed = logic_result.strategy_stats[GenericLogicCertify::SlotXChain].hit_count > 0;
        break;
    case RequiredStrategy::XYChain:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].hit_count > 0;
        break;
    case RequiredStrategy::WXYZWing:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotWXYZWing].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYZWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotWXYZWing].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYZWing].hit_count > 0;
        break;
    case RequiredStrategy::FinnedSwordfishJellyfish:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotFinnedSwordfishJellyfish].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotFinnedXWingSashimi].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotFinnedSwordfishJellyfish].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotFinnedXWingSashimi].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].hit_count > 0;
        break;
    case RequiredStrategy::ALSXZ:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotWWing].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotWWing].hit_count > 0;
        break;
    case RequiredStrategy::UniqueLoop:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueLoop].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueLoop].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].hit_count > 0;
        break;
    case RequiredStrategy::AvoidableRectangle:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAvoidableRectangle].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAvoidableRectangle].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotUniqueRectangle].hit_count > 0;
        break;
    case RequiredStrategy::BivalueOddagon:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBivalueOddagon].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGPlusOne].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBivalueOddagon].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGPlusOne].hit_count > 0;
        break;
    case RequiredStrategy::UniqueRectangleExtended:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotURExtended].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotURExtended].hit_count > 0;
        break;
    case RequiredStrategy::HiddenUniqueRectangle:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotHiddenUR].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotHiddenUR].hit_count > 0;
        break;
    case RequiredStrategy::BUGType2:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType2].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType2].hit_count > 0;
        break;
    case RequiredStrategy::BUGType3:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType3].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType3].hit_count > 0;
        break;
    case RequiredStrategy::BUGType4:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType4].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBUGType4].hit_count > 0;
        break;
    case RequiredStrategy::BorescoperQiuDeadlyPattern:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBorescoperQiuDeadlyPattern].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotBorescoperQiuDeadlyPattern].hit_count > 0;
        break;
    case RequiredStrategy::Medusa3D:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMedusa3D].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSimpleColoring].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMedusa3D].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSimpleColoring].hit_count > 0;
        break;
    case RequiredStrategy::AIC:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].hit_count > 0;
        break;
    case RequiredStrategy::GroupedAIC:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedAIC].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedAIC].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].hit_count > 0;
        break;
    case RequiredStrategy::GroupedXCycle:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedXCycle].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedXCycle].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].hit_count > 0;
        break;
    case RequiredStrategy::ContinuousNiceLoop:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotContinuousNiceLoop].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotContinuousNiceLoop].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].hit_count > 0;
        break;
    case RequiredStrategy::ALSXYWing:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXYWing].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXYWing].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].hit_count > 0;
        break;
    case RequiredStrategy::ALSChain:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSChain].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSChain].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].hit_count > 0;
        break;
    case RequiredStrategy::SueDeCoq:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSueDeCoq].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotPointingPairs].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSueDeCoq].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotPointingPairs].hit_count > 0;
        break;
    case RequiredStrategy::DeathBlossom:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotDeathBlossom].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotDeathBlossom].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXYChain].hit_count > 0;
        break;
    case RequiredStrategy::FrankenFish:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotFrankenFish].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotFrankenFish].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotSwordfish].hit_count > 0;
        break;
    case RequiredStrategy::MutantFish:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMutantFish].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMutantFish].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].hit_count > 0;
        break;
    case RequiredStrategy::KrakenFish:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotKrakenFish].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotKrakenFish].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotXChain].hit_count > 0;
        break;
    case RequiredStrategy::AlignedPairExclusion:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAlignedPairExclusion].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAlignedPairExclusion].hit_count > 0;
        break;
    case RequiredStrategy::AlignedTripleExclusion:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAlignedTripleExclusion].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotAlignedTripleExclusion].hit_count > 0;
        break;
    case RequiredStrategy::ALSAIC:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSAIC].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotALSAIC].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotALSXZ].hit_count > 0;
        break;
    case RequiredStrategy::MSLS:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMSLS].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotKrakenFish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotMSLS].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotKrakenFish].hit_count > 0;
        break;
    case RequiredStrategy::Exocet:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotExocet].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotExocet].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].hit_count > 0;
        break;
    case RequiredStrategy::SeniorExocet:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSeniorExocet].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotExocet].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSeniorExocet].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotExocet].hit_count > 0;
        break;
    case RequiredStrategy::SKLoop:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSKLoop].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotContinuousNiceLoop].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSKLoop].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotContinuousNiceLoop].hit_count > 0;
        break;
    case RequiredStrategy::PatternOverlayMethod:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotPatternOverlayMethod].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotMSLS].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotPatternOverlayMethod].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotMSLS].hit_count > 0;
        break;
    case RequiredStrategy::ForcingChains:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotForcingChains].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedAIC].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotForcingChains].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotAIC].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotGroupedAIC].hit_count > 0;
        break;
    case RequiredStrategy::DynamicForcingChains:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotDynamicForcingChains].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotForcingChains].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotDynamicForcingChains].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotForcingChains].hit_count > 0;
        break;
    case RequiredStrategy::Squirmbag:
        strategy_info.required_strategy_use_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSquirmbag].use_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].use_count > 0;
        strategy_info.required_strategy_hit_confirmed =
            logic_result.strategy_stats[GenericLogicCertify::SlotSquirmbag].hit_count > 0 ||
            logic_result.strategy_stats[GenericLogicCertify::SlotJellyfish].hit_count > 0;
        break;
    case RequiredStrategy::Backtracking:
        strategy_info.required_strategy_use_confirmed = !logic_result.solved;
        strategy_info.required_strategy_hit_confirmed = !logic_result.solved;
        break;
    case RequiredStrategy::None:
    default:
        break;
    }
    strategy_info.analyzed_required_strategy = strategy_info.required_strategy_use_confirmed;
    strategy_info.matched_required_strategy = strategy_info.required_strategy_use_confirmed && strategy_info.required_strategy_hit_confirmed;
    return strategy_info.matched_required_strategy;
}

static bool evaluate_difficulty_contract_generic(
    const GenericLogicCertifyResult& logic_result,
    int difficulty_level_required) {
    const int lvl = std::clamp(difficulty_level_required, 1, 9);
    if (lvl <= 1) {
        return logic_result.solved && (logic_result.used_naked_single || logic_result.used_hidden_single);
    }
    if (lvl == 2) {
        return logic_result.used_pointing_pairs || logic_result.used_box_line;
    }
    if (lvl == 3) {
        return logic_result.used_naked_pair || logic_result.used_hidden_pair ||
               logic_result.used_naked_triple || logic_result.used_hidden_triple;
    }
    if (lvl == 4) {
        return logic_result.used_naked_quad || logic_result.used_hidden_quad ||
               logic_result.used_x_wing || logic_result.used_y_wing ||
               logic_result.used_skyscraper || logic_result.used_two_string_kite ||
               logic_result.used_empty_rectangle || logic_result.used_remote_pairs;
    }
    if (lvl == 5) {
        return logic_result.used_swordfish || logic_result.used_bug_plus_one ||
               logic_result.used_finned_x_wing_sashimi || logic_result.used_simple_coloring ||
               logic_result.used_unique_rectangle || logic_result.used_xyz_wing ||
               logic_result.used_w_wing;
    }
    if (lvl == 6) {
        return logic_result.used_jellyfish || logic_result.used_x_chain ||
               logic_result.used_xy_chain || logic_result.used_wxyz_wing ||
               logic_result.used_finned_swordfish_jellyfish || logic_result.used_als_xz ||
               logic_result.used_unique_loop || logic_result.used_avoidable_rectangle ||
               logic_result.used_bivalue_oddagon || logic_result.used_ur_extended ||
               logic_result.used_hidden_ur || logic_result.used_bug_type2 ||
               logic_result.used_bug_type3 || logic_result.used_bug_type4 ||
               logic_result.used_borescoper_qiu_deadly_pattern ||
               logic_result.used_unique_rectangle || logic_result.used_bug_plus_one ||
               logic_result.used_w_wing;
    }
    if (lvl == 7) {
        return logic_result.used_medusa_3d || logic_result.used_aic || logic_result.used_grouped_aic ||
               logic_result.used_grouped_x_cycle || logic_result.used_continuous_nice_loop ||
               logic_result.used_als_xy_wing || logic_result.used_als_chain ||
               logic_result.used_sue_de_coq || logic_result.used_death_blossom ||
               logic_result.used_franken_fish || logic_result.used_mutant_fish ||
               logic_result.used_kraken_fish || logic_result.used_squirmbag ||
               logic_result.used_aligned_pair_exclusion || logic_result.used_aligned_triple_exclusion ||
               logic_result.used_als_aic;
    }
    if (lvl == 8) {
        return logic_result.used_msls || logic_result.used_exocet || logic_result.used_senior_exocet ||
               logic_result.used_sk_loop || logic_result.used_pattern_overlay_method ||
               logic_result.used_forcing_chains || logic_result.used_dynamic_forcing_chains;
    }
    // Higher levels are not yet fully implemented in runtime certifier.
    return true;
}

struct AttemptPerfStats {
    uint64_t solved_elapsed_ns = 0;
    uint64_t dig_elapsed_ns = 0;
    uint64_t prefilter_elapsed_ns = 0;
    uint64_t logic_elapsed_ns = 0;
    uint64_t uniqueness_calls = 0;
    uint64_t uniqueness_nodes = 0;
    uint64_t uniqueness_elapsed_ns = 0;
    uint64_t logic_steps = 0;
    uint64_t strategy_naked_use = 0;
    uint64_t strategy_naked_hit = 0;
    uint64_t strategy_hidden_use = 0;
    uint64_t strategy_hidden_hit = 0;
};

static bool generate_one_generic(
    const GenerateRunConfig& cfg,
    const GenericTopology& topo,
    std::mt19937_64& rng,
    GenericPuzzleCandidate& candidate,
    RejectReason& reason,
    RequiredStrategyAttemptInfo& strategy_info,
    const GenericSolvedKernel& solved,
    const GenericDigKernel& dig,
    const GenericQuickPrefilter& prefilter,
    const GenericLogicCertify& logic,
    const GenericUniquenessCounter& uniq,
    const std::atomic<bool>* force_abort_ptr = nullptr,
    bool* timed_out = nullptr,
    const std::atomic<bool>* external_cancel_ptr = nullptr,
    const std::atomic<bool>* external_pause_ptr = nullptr,
    QualityContract* quality_contract_out = nullptr,
    QualityMetrics* quality_metrics_out = nullptr,
    ReplayValidationResult* replay_out = nullptr,
    AttemptPerfStats* perf_out = nullptr) {
    
    const bool has_timed_out_ptr = (timed_out != nullptr);
    const bool has_quality_contract_out = (quality_contract_out != nullptr);
    const bool has_quality_metrics_out = (quality_metrics_out != nullptr);
    const bool has_replay_out = (replay_out != nullptr);
    const bool collect_perf = (perf_out != nullptr);
    
    if (has_timed_out_ptr) *timed_out = false;
    strategy_info = {};
    if (has_quality_contract_out) {
        *quality_contract_out = {};
        const GenerationProfile profile =
            resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
        quality_contract_out->generation_mode = generation_mode_name(profile.mode);
    }
    if (has_quality_metrics_out) *quality_metrics_out = {};
    if (has_replay_out) *replay_out = {};
    if (collect_perf) *perf_out = {};
    
    const bool quality_contract_enabled = cfg.enable_quality_contract;
    const bool distribution_filter_enabled = quality_contract_enabled && cfg.enable_distribution_filter;
    const bool replay_validation_enabled = quality_contract_enabled && cfg.enable_replay_validation;
    const bool need_quality_metrics = quality_contract_enabled || quality_contract_out != nullptr || quality_metrics_out != nullptr;
    const bool budget_enabled = cfg.attempt_time_budget_s > 0.0 || cfg.attempt_node_budget > 0 || force_abort_ptr != nullptr;
    
    SearchAbortControl budget;
    if (cfg.attempt_time_budget_s > 0.0) {
        budget.time_enabled = true;
        budget.deadline = std::chrono::steady_clock::now() + 
            std::chrono::duration_cast<std::chrono::steady_clock::duration>(std::chrono::duration<double>(cfg.attempt_time_budget_s));
    }
    if (cfg.attempt_node_budget > 0) {
        budget.node_enabled = true;
        budget.node_limit = cfg.attempt_node_budget;
    }
    if (force_abort_ptr != nullptr) budget.force_abort_ptr = force_abort_ptr;
    budget.cancel_ptr = external_cancel_ptr;
    budget.pause_ptr = external_pause_ptr;
    
    SearchAbortControl* budget_ptr = budget_enabled ? &budget : nullptr;

    const auto solved_t0 = std::chrono::steady_clock::now();
    bool solved_ok = false;
    const uint8_t* dig_protected_cells = nullptr;
    if (cfg.pattern_forcing_enabled) {
        const int pf_tries = std::max(1, cfg.pattern_forcing_tries);
        for (int pf_try = 0; pf_try < pf_tries && !solved_ok; ++pf_try) {
            pattern_forcing::PatternSeedView pf_seed{};
            if (!pattern_forcing::build_seed(
                    topo,
                    cfg,
                    cfg.required_strategy,
                    cfg.difficulty_level_required,
                    rng,
                    pf_seed)) {
                break;
            }
            if (pf_seed.seed_puzzle == nullptr || pf_seed.allowed_masks == nullptr) {
                break;
            }
            solved_ok = uniq.solve_and_capture(
                *pf_seed.seed_puzzle,
                topo,
                candidate.solution,
                budget_ptr,
                pf_seed.allowed_masks);
            if (solved_ok && cfg.pattern_forcing_lock_anchors && pf_seed.protected_cells != nullptr &&
                !pf_seed.protected_cells->empty()) {
                dig_protected_cells = pf_seed.protected_cells->data();
            }
            if (budget_ptr != nullptr && budget_ptr->aborted()) {
                break;
            }
        }
    }
    if (!solved_ok) {
        solved_ok = solved.generate(topo, rng, candidate.solution, budget_ptr);
    }
    if (collect_perf) {
        perf_out->solved_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - solved_t0)
                .count());
    }
    if (!solved_ok) {
        if (budget_ptr != nullptr && budget_ptr->aborted()) {
            if (budget_ptr->aborted_by_pause) {
                reason = RejectReason::None;
                return false;
            }
            if (has_timed_out_ptr) {
                *timed_out = budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes;
            }

        }
        reason = RejectReason::Logic;
        return false;
    }
    
    const auto dig_t0 = std::chrono::steady_clock::now();
    if (cfg.mcts_digger_enabled) {
        GenericMctsBottleneckDigger mcts_digger;
        GenericMctsBottleneckDigger::RunStats mcts_stats{};
        const bool dig_ok = mcts_digger.dig_into(
            candidate.solution,
            topo,
            cfg,
            rng,
            uniq,
            logic,
            candidate.puzzle,
            candidate.clues,
            dig_protected_cells,
            budget_ptr,
            &mcts_stats);
        if (!dig_ok) {
            if (budget_ptr != nullptr && budget_ptr->aborted()) {
                if (budget_ptr->aborted_by_pause) {
                    reason = RejectReason::None;
                    return false;
                }
                if (has_timed_out_ptr) {
                    *timed_out = budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes;
                }
            }
            reason = RejectReason::Logic;
            return false;
        }
    } else {
        dig.dig_into(candidate.solution, topo, cfg, rng, candidate.puzzle, candidate.clues, dig_protected_cells);
    }
    if (collect_perf) {
        perf_out->dig_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - dig_t0)
                .count());
    }

    const auto prefilter_t0 = std::chrono::steady_clock::now();
    const bool prefilter_ok = prefilter.check(candidate.puzzle, topo, cfg.min_clues, cfg.max_clues);
    if (collect_perf) {
        perf_out->prefilter_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - prefilter_t0)
                .count());
    }
    if (!prefilter_ok) {
        reason = RejectReason::Prefilter;
        return false;
    }
    
    QualityMetrics quality_metrics{};
    if (need_quality_metrics) {
        quality_metrics = evaluate_quality_metrics(candidate.puzzle, topo, cfg);
        if (has_quality_metrics_out) *quality_metrics_out = quality_metrics;
        if (has_quality_contract_out) {
            quality_contract_out->clue_range_ok = (candidate.clues >= cfg.min_clues && candidate.clues <= cfg.max_clues);
            quality_contract_out->symmetry_ok = quality_metrics.symmetry_ok;
            quality_contract_out->distribution_balance_ok = quality_metrics.distribution_balance_ok;
            quality_contract_out->givens_entropy_ok = quality_metrics.normalized_entropy >= quality_metrics.entropy_threshold;
        }

        if (quality_contract_enabled) {
            if (!quality_metrics.symmetry_ok) {
                reason = RejectReason::DistributionBias;
                return false;
            }
            if (distribution_filter_enabled) {
                if (!(quality_metrics.normalized_entropy >= quality_metrics.entropy_threshold) || 
                    !quality_metrics.distribution_balance_ok) {
                    reason = RejectReason::DistributionBias;
                    return false;
                }
            }
        }
    }
    
    const bool capture_logic_solution = replay_validation_enabled;
    const auto logic_t0 = std::chrono::steady_clock::now();
    const GenericLogicCertifyResult logic_result = logic.certify(candidate.puzzle, topo, budget_ptr, capture_logic_solution);
    if (collect_perf) {
        perf_out->logic_elapsed_ns += static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now() - logic_t0)
                .count());
    }
    if (logic_result.timed_out) {
        if (budget_ptr != nullptr && budget_ptr->aborted_by_pause) {
            reason = RejectReason::None;
            return false;
        }
        if (has_timed_out_ptr) {
            *timed_out = (budget_ptr == nullptr) ? true : (budget_ptr->aborted_by_time || budget_ptr->aborted_by_nodes);
        }
        reason = RejectReason::Logic;
        return false;
    }
    
    if (collect_perf) {
        perf_out->logic_steps = static_cast<uint64_t>(std::max(0, logic_result.steps));
        perf_out->strategy_naked_use = logic_result.strategy_stats[GenericLogicCertify::SlotNakedSingle].use_count;
        perf_out->strategy_naked_hit = logic_result.strategy_stats[GenericLogicCertify::SlotNakedSingle].hit_count;
        perf_out->strategy_hidden_use = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenSingle].use_count;
        perf_out->strategy_hidden_hit = logic_result.strategy_stats[GenericLogicCertify::SlotHiddenSingle].hit_count;
    }

    if (!evaluate_difficulty_contract_generic(logic_result, cfg.difficulty_level_required)) {
        reason = RejectReason::Strategy;
        return false;
    }
    
    const bool contract_ok = evaluate_required_strategy_contract_generic(logic_result, cfg.required_strategy, strategy_info);
    if (cfg.required_strategy != RequiredStrategy::None && !contract_ok) {
        reason = RejectReason::Strategy;
        return false;
    }
    if (cfg.strict_logical && !logic_result.solved && cfg.required_strategy != RequiredStrategy::Backtracking) {
        reason = RejectReason::Logic;
        return false;
    }
    
    bool uniqueness_ok = true;
    if (cfg.require_unique) {
        auto record_uniqueness_perf = [&](const SearchAbortControl& b, uint64_t elapsed_ns) {
            if (!collect_perf) return;
            ++perf_out->uniqueness_calls;
            perf_out->uniqueness_nodes += b.nodes;
            perf_out->uniqueness_elapsed_ns += elapsed_ns;
        };
        SearchAbortControl uniq_budget = budget;
        SearchAbortControl* uniq_budget_ptr = budget_enabled ? &uniq_budget : nullptr;
        
        const auto uniq_t0 = std::chrono::steady_clock::now();
        const int solutions = uniq.count_solutions_limit2(candidate.puzzle, topo, uniq_budget_ptr);
        const auto uniq_elapsed_ns = static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - uniq_t0).count());
        record_uniqueness_perf(uniq_budget, uniq_elapsed_ns);
        
        if (solutions < 0) {
            if (uniq_budget_ptr != nullptr && uniq_budget_ptr->aborted_by_pause) {
                reason = RejectReason::None;
                return false;
            }
            if (has_timed_out_ptr) *timed_out = true;
            reason = RejectReason::Logic;
            return false;
        }
        if (solutions != 1) {
            reason = RejectReason::Uniqueness;
            return false;
        }
        
        if (quality_contract_enabled && topo.n >= 25) {
            SearchAbortControl confirm_budget;
            if (cfg.uniqueness_confirm_budget_s > 0.0) {
                confirm_budget.time_enabled = true;
                confirm_budget.deadline = std::chrono::steady_clock::now() + 
                    std::chrono::duration_cast<std::chrono::steady_clock::duration>(std::chrono::duration<double>(cfg.uniqueness_confirm_budget_s));
            }
            if (cfg.uniqueness_confirm_budget_nodes > 0) {
                confirm_budget.node_enabled = true;
                confirm_budget.node_limit = cfg.uniqueness_confirm_budget_nodes;
            }
            confirm_budget.force_abort_ptr = force_abort_ptr;
            confirm_budget.cancel_ptr = external_cancel_ptr;
            confirm_budget.pause_ptr = external_pause_ptr;

            const auto confirm_t0 = std::chrono::steady_clock::now();
            const int confirm_solutions = uniq.count_solutions_limit(candidate.puzzle, topo, 3, &confirm_budget);
            const auto confirm_elapsed_ns = static_cast<uint64_t>(
                std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now() - confirm_t0).count());
            record_uniqueness_perf(confirm_budget, confirm_elapsed_ns);
            
            if (confirm_solutions < 0) {
                if (confirm_budget.aborted_by_pause) {
                    reason = RejectReason::None;
                    return false;
                }
                reason = RejectReason::UniquenessBudget;
                return false;
            }
            if (confirm_solutions != 1) {
                reason = RejectReason::Uniqueness;
                return false;
            }
        }
    }

    ReplayValidationResult replay{};
    if (replay_validation_enabled) {
        replay.solved = logic_result.solved;
        replay.ok = replay.solved && logic_result.solved_grid == candidate.solution;
        if (has_replay_out || !replay.ok) {
            replay.puzzle_hash = hash_u16_vector(candidate.puzzle);
            replay.expected_solution_hash = hash_u16_vector(candidate.solution);
            replay.replay_solution_hash = hash_u16_vector(logic_result.solved_grid);
            uint64_t trace_seed = 1469598103934665603ULL;
            trace_seed = fnv1a64_bytes(&logic_result.steps, sizeof(logic_result.steps), trace_seed);
            // Optymalizacja haszowania strategii (unikanie pÄ™tli po elementach gdy to moĹĽliwe)
            trace_seed = fnv1a64_bytes(logic_result.strategy_stats.data(), logic_result.strategy_stats.size() * sizeof(StrategyStats), trace_seed);
            replay.trace_hash = trace_seed;
        }
        if (has_replay_out) *replay_out = replay;
        if (!replay.ok) {
            reason = RejectReason::Replay;
            return false;
        }
    }
    if (has_quality_contract_out) {
        quality_contract_out->is_unique = uniqueness_ok;
        quality_contract_out->logic_replay_ok = replay.ok || !replay_validation_enabled;
    }
    if (has_quality_contract_out && !quality_contract_passed(*quality_contract_out, cfg)) {
        reason = RejectReason::DistributionBias;
        return false;
    }
    
    reason = RejectReason::None;
    return true;
}

struct DifficultySignals {
    uint64_t attempts = 0;
    uint64_t accepted = 0;
    uint64_t rejected = 0;
    uint64_t logic_passes = 0;
    uint64_t candidate_eliminations = 0;
    uint64_t branching_proxy = 0;
    uint64_t max_depth_proxy = 0;
    uint64_t uniqueness_nodes = 0;
    double uniqueness_cost_ms = 0.0;
    double elapsed_s = 0.0;
    std::string mode;
};

inline DifficultySignals collect_difficulty_signals(const GenerateRunResult& result, const GenerationProfile& profile) {
    DifficultySignals s{};
    s.attempts = result.attempts;
    s.accepted = result.accepted;
    s.rejected = result.rejected;
    s.logic_passes = result.analyzed_required_strategy;
    s.candidate_eliminations = result.required_strategy_hits;
    s.branching_proxy = result.reject_logic + result.reject_uniqueness + result.reject_strategy;
    s.uniqueness_nodes = result.uniqueness_nodes;
    s.uniqueness_cost_ms = result.uniqueness_elapsed_ms;
    s.elapsed_s = result.elapsed_s;
    s.mode = generation_mode_name(profile.mode);
    return s;
}

inline double clamp01(double v) { return std::clamp(v, 0.0, 1.0); }

inline std::string vip_grade_from_score(double score) {
    if (score >= 700.0) return "platinum";
    if (score >= 500.0) return "gold";
    if (score >= 300.0) return "silver";
    if (score > 0.0) return "bronze";
    return "none";
}

struct VipScoreBreakdown {
    double logic_depth_norm = 0.0;
    double hidden_norm = 0.0;
    double naked_norm = 0.0;
    double uniqueness_norm = 0.0;
    double branching_norm = 0.0;
    double level_norm = 0.0;
    double weighted = 0.0;
    double asym_multiplier = 1.0;
    double final_score = 0.0;
    std::string profile = "standard";

    std::string to_json() const {
        std::ostringstream out;
        out << "{\"profile\":\"" << profile << "\","
            << "\"logic_depth_norm\":" << format_fixed(logic_depth_norm, 6) << ","
            << "\"hidden_norm\":" << format_fixed(hidden_norm, 6) << ","
            << "\"naked_norm\":" << format_fixed(naked_norm, 6) << ","
            << "\"uniqueness_norm\":" << format_fixed(uniqueness_norm, 6) << ","
            << "\"branching_norm\":" << format_fixed(branching_norm, 6) << ","
            << "\"level_norm\":" << format_fixed(level_norm, 6) << ","
            << "\"weighted\":" << format_fixed(weighted, 6) << ","
            << "\"asym_multiplier\":" << format_fixed(asym_multiplier, 6) << ","
            << "\"final_score\":" << format_fixed(final_score, 6) << "}";
        return out.str();
    }
};

inline std::string geometry_key_for_grade_target(int box_rows, int box_cols) {
    return std::to_string(box_rows) + "x" + std::to_string(box_cols);
}

inline std::unordered_map<std::string, std::string> load_vip_grade_target_overrides(const std::string& path_raw) {
    std::unordered_map<std::string, std::string> out_map;
    if (path_raw.empty()) return out_map;
    std::ifstream in(path_raw);
    if (!in) return out_map;
    std::string line;
    while (std::getline(in, line)) {
        if (line.empty() || line[0] == '#') continue;
        std::replace(line.begin(), line.end(), ';', ',');
        std::istringstream iss(line);
        std::string n_s, br_s, bc_s, grade_s;
        if (std::getline(iss, n_s, ',') && std::getline(iss, br_s, ',') && 
            std::getline(iss, bc_s, ',') && std::getline(iss, grade_s, ',')) {
            try {
                out_map[geometry_key_for_grade_target(std::stoi(br_s), std::stoi(bc_s))] = normalize_vip_grade_target(grade_s);
            } catch (...) {}
        }
    }
    return out_map;
}

inline std::string resolve_vip_grade_target_for_geometry(const GenerateRunConfig& cfg) {
    const std::string default_grade = normalize_vip_grade_target(cfg.vip_grade_target);
    if (cfg.vip_min_grade_by_geometry_path.empty()) return default_grade;
    const auto overrides = load_vip_grade_target_overrides(cfg.vip_min_grade_by_geometry_path);
    const auto it = overrides.find(geometry_key_for_grade_target(cfg.box_rows, cfg.box_cols));
    return it != overrides.end() ? normalize_vip_grade_target(it->second) : default_grade;
}

inline VipScoreBreakdown compute_vip_score_breakdown(const GenerateRunResult& result, const GenerateRunConfig& cfg, const GenerationProfile& runtime_profile) {
    VipScoreBreakdown b{};
    b.profile = normalize_vip_score_profile(cfg.vip_score_profile);
    const int n = std::max(1, cfg.box_rows) * std::max(1, cfg.box_cols);
    const double attempts = static_cast<double>(std::max<uint64_t>(1, result.attempts));
    const double logic_steps_per_attempt = static_cast<double>(result.logic_steps_total) / attempts;
    const double hidden_rate = static_cast<double>(result.strategy_hidden_hit) / attempts;
    const double naked_rate = static_cast<double>(result.strategy_naked_hit) / attempts;
    const double uniqueness_nodes_per_attempt = static_cast<double>(result.uniqueness_nodes) / attempts;
    const double reject_branching_rate = static_cast<double>(result.reject_logic + result.reject_strategy + result.reject_uniqueness) / attempts;
    const double asymmetry_norm = clamp01((runtime_profile.asymmetry_ratio - 1.0) / 3.0);

    b.logic_depth_norm = clamp01(logic_steps_per_attempt / std::max(4.0, static_cast<double>(n) * 0.35));
    b.hidden_norm = clamp01(hidden_rate / 0.60);
    b.naked_norm = clamp01(naked_rate / 0.80);
    b.uniqueness_norm = clamp01(uniqueness_nodes_per_attempt / std::max(500.0, static_cast<double>(n * n) * 0.90));
    b.branching_norm = clamp01(reject_branching_rate / 0.85);
    b.level_norm = clamp01(static_cast<double>(std::clamp(cfg.difficulty_level_required, 1, 9) - 1) / 8.0);

    double w_logic = 0.30, w_hidden = 0.22, w_naked = 0.12, w_uniq = 0.20, w_branch = 0.10, w_level = 0.06;
    if (b.profile == "strict") {
        w_logic = 0.34; w_hidden = 0.24; w_naked = 0.08; w_uniq = 0.22; w_branch = 0.08; w_level = 0.04;
    } else if (b.profile == "ultra") {
        w_logic = 0.36; w_hidden = 0.25; w_naked = 0.06; w_uniq = 0.23; w_branch = 0.07; w_level = 0.03;
    }
    b.weighted = w_logic * b.logic_depth_norm + w_hidden * b.hidden_norm + w_naked * b.naked_norm +
                 w_uniq * b.uniqueness_norm + w_branch * b.branching_norm + w_level * b.level_norm;
    b.asym_multiplier = 1.0 + 0.15 * asymmetry_norm;
    if (b.profile == "ultra") b.asym_multiplier += 0.05 * asymmetry_norm;
    b.final_score = std::clamp(b.weighted * b.asym_multiplier * 1000.0, 0.0, 1000.0);
    return b;
}

inline double compute_vip_score(const GenerateRunResult& result, const GenerateRunConfig& cfg, const GenerationProfile& runtime_profile) {
    return compute_vip_score_breakdown(result, cfg, runtime_profile).final_score;
}

inline bool vip_contract_passed(double score, const std::string& target_grade) {
    return vip_grade_rank(vip_grade_from_score(score)) >= vip_grade_rank(target_grade);
}

inline uint64_t compute_premium_signature(const GenerateRunConfig& cfg, const GenerateRunResult& result, const std::string& cpu_backend_selected) {
    uint64_t h = 1469598103934665603ULL;
    const int n = std::max(1, cfg.box_rows) * std::max(1, cfg.box_cols);
    h = fnv1a64_bytes(&n, sizeof(n), h);
    h = fnv1a64_bytes(&cfg.box_rows, sizeof(cfg.box_rows), h);
    h = fnv1a64_bytes(&cfg.box_cols, sizeof(cfg.box_cols), h);
    h = fnv1a64_bytes(&cfg.difficulty_level_required, sizeof(cfg.difficulty_level_required), h);
    h = fnv1a64_bytes(&result.accepted, sizeof(result.accepted), h);
    h = fnv1a64_bytes(&result.attempts, sizeof(result.attempts), h);
    h = fnv1a64_bytes(&result.logic_steps_total, sizeof(result.logic_steps_total), h);
    h = fnv1a64_bytes(&result.uniqueness_nodes, sizeof(result.uniqueness_nodes), h);
    h = fnv1a64_bytes(&result.vip_score, sizeof(result.vip_score), h);
    h = fnv1a64_bytes(cpu_backend_selected.data(), cpu_backend_selected.size(), h);
    return h;
}

inline uint64_t compute_premium_signature_v2(const GenerateRunConfig& cfg, const GenerateRunResult& result, const std::string& cpu_backend_selected, const std::string& vip_grade_target_effective) {
    uint64_t h = compute_premium_signature(cfg, result, cpu_backend_selected);
    h = fnv1a64_bytes(result.vip_grade.data(), result.vip_grade.size(), h);
    h = fnv1a64_bytes(vip_grade_target_effective.data(), vip_grade_target_effective.size(), h);
    h = fnv1a64_bytes(result.vip_score_breakdown_json.data(), result.vip_score_breakdown_json.size(), h);
    h = fnv1a64_bytes(&result.kernel_time_ms, sizeof(result.kernel_time_ms), h);
    h = fnv1a64_bytes(&result.kernel_calls, sizeof(result.kernel_calls), h);
    return h;
}

inline void write_vip_trace_and_signature_if_requested(const GenerateRunConfig& cfg, const GenerateRunResult& result, const std::string& cpu_backend_selected) {
    if (!cfg.difficulty_trace_out.empty()) {
        std::error_code ec;
        std::filesystem::create_directories(std::filesystem::path(cfg.difficulty_trace_out).parent_path(), ec);
        std::ofstream out(cfg.difficulty_trace_out, std::ios::out | std::ios::trunc);
        if (out) {
            out << "difficulty_engine=" << normalize_difficulty_engine(cfg.difficulty_engine) << "\nvip_mode=" << (cfg.vip_mode ? "1" : "0")
                << "\ncpu_backend=" << cpu_backend_selected << "\nlogic_steps_total=" << result.logic_steps_total
                << "\nnaked_use=" << result.strategy_naked_use << " naked_hit=" << result.strategy_naked_hit
                << "\nhidden_use=" << result.strategy_hidden_use << " hidden_hit=" << result.strategy_hidden_hit
                << "\nvip_score=" << format_fixed(result.vip_score, 3) << "\nvip_grade=" << result.vip_grade
                << "\npremium_signature=" << result.premium_signature << "\npremium_signature_v2=" << result.premium_signature_v2 << "\n";
            if (normalize_vip_trace_level(cfg.vip_trace_level) == "full") {
                out << "vip_contract_fail_reason=" << result.vip_contract_fail_reason << "\nvip_score_breakdown_json=" << result.vip_score_breakdown_json
                    << "\nkernel_time_ms=" << format_fixed(result.kernel_time_ms, 6) << "\nkernel_calls=" << result.kernel_calls
                    << "\nbackend_efficiency_score=" << format_fixed(result.backend_efficiency_score, 6) << "\nasymmetry_efficiency_index=" << format_fixed(result.asymmetry_efficiency_index, 6) << "\n";
            }
        }
    }
    if (!cfg.vip_signature_out.empty()) {
        std::error_code ec;
        std::filesystem::create_directories(std::filesystem::path(cfg.vip_signature_out).parent_path(), ec);
        std::ofstream out(cfg.vip_signature_out, std::ios::out | std::ios::trunc);
        if (out) out << "premium_signature=" << result.premium_signature << "\npremium_signature_v2=" << result.premium_signature_v2
                     << "\nvip_grade=" << result.vip_grade << "\nvip_score=" << format_fixed(result.vip_score, 3) << "\ncpu_backend=" << cpu_backend_selected << "\n";
    }
}

inline void append_difficulty_signals_csv(const GenerateRunConfig& cfg, const GenerateRunResult& result, const DifficultySignals& signals, const std::string& csv_path = "plikiTMP/porownania/difficulty_signals.csv") {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(csv_path).parent_path(), ec);
    bool write_header = !std::filesystem::exists(csv_path);
    std::ofstream out(csv_path, std::ios::out | std::ios::app);
    if (out && write_header) {
        out << "ts,box_rows,box_cols,n,difficulty,required_strategy,mode,attempts,accepted,rejected,logic_passes,candidate_eliminations,branching_proxy,max_depth_proxy,reject_replay,reject_distribution_bias,reject_uniqueness_budget,uniqueness_nodes,uniqueness_cost_ms,elapsed_s,avg_clues\n";
    }
    if (out) {
        out << now_local_compact_string() << "," << cfg.box_rows << "," << cfg.box_cols << "," << (cfg.box_rows * cfg.box_cols) << ","
            << cfg.difficulty_level_required << "," << to_string(cfg.required_strategy) << "," << signals.mode << ","
            << signals.attempts << "," << signals.accepted << "," << signals.rejected << "," << signals.logic_passes << ","
            << signals.candidate_eliminations << "," << signals.branching_proxy << "," << signals.max_depth_proxy << ","
            << result.reject_replay << "," << result.reject_distribution_bias << "," << result.reject_uniqueness_budget << ","
            << signals.uniqueness_nodes << "," << format_fixed(signals.uniqueness_cost_ms, 6) << "," << format_fixed(signals.elapsed_s, 6) << ","
            << format_fixed(result.avg_clues, 6) << "\n";
    }
}

GenerateRunResult run_generic_sudoku(
    const GenerateRunConfig& cfg,
    ConsoleStatsMonitor* monitor,
    const std::atomic<bool>* external_cancel,
    const std::atomic<bool>* external_paused,
    std::function<void(uint64_t, uint64_t)> on_progress,
    std::function<void(const std::string&)> on_log) {
    
    GenerateRunResult result{};
    const auto topo_opt = GenericTopology::build(cfg.box_rows, cfg.box_cols);
    if (!topo_opt.has_value()) {
        std::cerr << "Unsupported geometry. Expected box_rows*box_cols in [4..64].\n";
        return result;
    }
    const GenericTopology topo = *topo_opt;
    const GenerationProfile runtime_profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
    const RuntimeCpuContext cpu_ctx = resolve_runtime_cpu_context(cfg);
    
    GenerateRunConfig runtime_cfg = cfg;
    runtime_cfg.asym_heuristics_mode = normalize_asym_heuristics_mode(runtime_cfg.asym_heuristics_mode);
    runtime_cfg.vip_score_profile = normalize_vip_score_profile(runtime_cfg.vip_score_profile);
    runtime_cfg.vip_trace_level = normalize_vip_trace_level(runtime_cfg.vip_trace_level);
    
    if (!runtime_profile.is_symmetric) {
        if (runtime_cfg.asym_heuristics_mode == "aggressive") {
            runtime_cfg.min_clues = std::max(0, runtime_cfg.min_clues - 1);
            runtime_cfg.max_clues = std::max(runtime_cfg.min_clues, runtime_cfg.max_clues - 1);
            runtime_cfg.uniqueness_confirm_budget_nodes = std::max<uint64_t>(100000, static_cast<uint64_t>(runtime_cfg.uniqueness_confirm_budget_nodes * 0.85));
        } else if (runtime_cfg.asym_heuristics_mode == "off") {
            runtime_cfg.enable_distribution_filter = false;
        }
    }
    
    if (runtime_cfg.adaptive_budget) {
        const double suggested = std::max(0.05, runtime_profile.suggested_budget_s);
        const int effective_budget_level = strategy_adjusted_level(runtime_cfg.difficulty_level_required, runtime_cfg.required_strategy);
        const bool unlimited_by_default = (effective_budget_level >= 3);
        if (!unlimited_by_default) {
            if (runtime_cfg.attempt_time_budget_s <= 0.0) runtime_cfg.attempt_time_budget_s = std::min(5.0, suggested);
            if (runtime_cfg.attempt_node_budget == 0) runtime_cfg.attempt_node_budget = static_cast<uint64_t>(std::clamp<double>(static_cast<double>(topo.nn) * 4000.0, 200000.0, 10000000.0));
        }
    }

    const long long seed = (cfg.seed == 0) ? random_seed_i64() : cfg.seed;
    const int thread_count = cfg.threads > 0 ? cfg.threads : std::max(1u, std::thread::hardware_concurrency());

    auto log_message = [&](const std::string& msg) {
        log_info("run_generic.userlog", msg);
        if (on_log) {
            on_log(msg);
        }
    };
    if (!difficulty_level_selectable_for_geometry(cfg.difficulty_level_required, cfg.box_rows, cfg.box_cols)) {
        const std::string msg =
            "Difficulty level not runtime-ready for geometry: level=" + std::to_string(cfg.difficulty_level_required) +
            " box_rows=" + std::to_string(cfg.box_rows) +
            " box_cols=" + std::to_string(cfg.box_cols);
        log_error("run_generic", msg);
        log_message(msg);
        std::cerr << msg << "\n";
        return result;
    }
    if (cfg.required_strategy != RequiredStrategy::None &&
        !required_strategy_selectable_for_geometry(cfg.required_strategy, cfg.box_rows, cfg.box_cols)) {
        const std::string msg =
            "Required strategy not selectable for geometry: strategy=" + to_string(cfg.required_strategy) +
            " box_rows=" + std::to_string(cfg.box_rows) +
            " box_cols=" + std::to_string(cfg.box_cols) +
            " reason=" + (required_strategy_runtime_ready(cfg.required_strategy)
                              ? std::string("math_not_supported")
                              : std::string("runtime_not_ready"));
        log_error("run_generic", msg);
        log_message(msg);
        std::cerr << msg << "\n";
        return result;
    }
    log_info(
        "run_generic",
        "start n=" + std::to_string(topo.n) +
            " target=" + std::to_string(cfg.target_puzzles) +
            " level=" + std::to_string(cfg.difficulty_level_required) +
            " required=" + to_string(cfg.required_strategy) +
            " difficulty_engine=" + normalize_difficulty_engine(cfg.difficulty_engine) +
            " vip_mode=" + std::string(cfg.vip_mode ? "1" : "0") +
            " profile_policy=" + normalize_profile_mode_policy(cfg.profile_mode_policy) +
            " full_for_n_ge=" + std::to_string(cfg.full_for_n_ge) +
            " asym_heuristics=" + runtime_cfg.asym_heuristics_mode +
            " adaptive_budget=" + std::string(runtime_cfg.adaptive_budget ? "1" : "0") +
            " cpu_backend=" + cpu_ctx.selected_backend +
            " cpu_reason=" + cpu_ctx.reason +
            " threads=" + std::to_string(thread_count) +
            " seed=" + std::to_string(seed));
    log_message(
        "Start: n=" + std::to_string(topo.n) +
        " level=" + std::to_string(cfg.difficulty_level_required) +
        " required=" + to_string(cfg.required_strategy) +
        " backend=" + cpu_ctx.selected_backend +
        " threads=" + std::to_string(thread_count) +
        " seed=" + std::to_string(seed));
    log_message(
        "Parametry runtime: min_clues=" + std::to_string(runtime_cfg.min_clues) +
        " max_clues=" + std::to_string(runtime_cfg.max_clues) +
        " attempt_time_budget_s=" + format_fixed(runtime_cfg.attempt_time_budget_s, 3) +
        " attempt_node_budget=" + std::to_string(runtime_cfg.attempt_node_budget) +
        " force_new_seed_per_attempt=" + std::string(runtime_cfg.force_new_seed_per_attempt ? "1" : "0") +
        " asym_heuristics=" + runtime_cfg.asym_heuristics_mode +
        " adaptive_budget=" + std::string(runtime_cfg.adaptive_budget ? "1" : "0"));
    
    std::error_code mkdir_ec;
    std::filesystem::create_directories(cfg.output_folder, mkdir_ec);
    if (mkdir_ec) {
        const std::string msg = "Cannot create output folder: " + cfg.output_folder + " error=" + mkdir_ec.message();
        log_error("run_generic", msg);
        log_message(msg);
        return result;
    }
    const std::filesystem::path out_path = std::filesystem::path(cfg.output_folder) / cfg.output_file;

    if (monitor != nullptr) {
        monitor->set_active_workers(thread_count);
        monitor->set_grid_info(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required);
        MonitorTotalsSnapshot initial_totals{};
        initial_totals.target = cfg.target_puzzles;
        initial_totals.active_workers = static_cast<uint64_t>(thread_count);
        monitor->set_totals_snapshot(initial_totals);
        monitor->set_background_status(
            "Generowanie: start mode=" + std::string(generation_mode_name(runtime_profile.mode)) +
            " class=" + (runtime_profile.is_symmetric ? std::string("sym") : std::string("asym")) +
            " backend=" + cpu_ctx.selected_backend);
    }

    PaddedAtomic<uint64_t> accepted{0}, attempts{0}, attempt_ticket{0}, rejected{0}, reject_prefilter{0};
    PaddedAtomic<uint64_t> reject_logic{0}, reject_uniqueness{0}, reject_strategy{0}, reject_replay{0};
    PaddedAtomic<uint64_t> reject_distribution_bias{0}, reject_uniqueness_budget{0}, timeout_global_count{0};
    PaddedAtomic<uint64_t> timeout_per_attempt_count{0}, uniqueness_calls_total{0}, uniqueness_nodes_total{0};
    PaddedAtomic<uint64_t> uniqueness_elapsed_ns_total{0}, logic_steps_total{0}, strategy_naked_use_total{0};
    PaddedAtomic<uint64_t> strategy_naked_hit_total{0}, strategy_hidden_use_total{0}, strategy_hidden_hit_total{0};
    PaddedAtomic<uint64_t> premium_signature_last{0}, written{0}, reseeds_total{0}, clue_sum{0};
    PaddedAtomic<uint64_t> analyzed_required_strategy{0}, required_strategy_hits{0}, written_required_strategy{0}, clue_sum_required_strategy{0};
    PaddedAtomic<bool> force_abort{false}, io_failed{false};
    PaddedAtomic<int> started_workers{0};
    PaddedAtomic<int> hard_stop_reason{0}; // 0=none, 1=max_total_time_s, 2=max_attempts_s
    
    auto telemetry_ring = std::make_unique<TelemetryMpscRing<4096>>();
    auto apply_telemetry_delta = [&](const TelemetryDelta& d) {
        if (d.attempts > 0) attempts.fetch_add(d.attempts, std::memory_order_relaxed);
        if (d.rejected > 0) rejected.fetch_add(d.rejected, std::memory_order_relaxed);
        if (d.reject_prefilter > 0) reject_prefilter.fetch_add(d.reject_prefilter, std::memory_order_relaxed);
        if (d.reject_logic > 0) reject_logic.fetch_add(d.reject_logic, std::memory_order_relaxed);
        if (d.reject_uniqueness > 0) reject_uniqueness.fetch_add(d.reject_uniqueness, std::memory_order_relaxed);
        if (d.reject_strategy > 0) reject_strategy.fetch_add(d.reject_strategy, std::memory_order_relaxed);
        if (d.reject_replay > 0) reject_replay.fetch_add(d.reject_replay, std::memory_order_relaxed);
        if (d.reject_distribution_bias > 0) reject_distribution_bias.fetch_add(d.reject_distribution_bias, std::memory_order_relaxed);
        if (d.reject_uniqueness_budget > 0) reject_uniqueness_budget.fetch_add(d.reject_uniqueness_budget, std::memory_order_relaxed);
        if (d.analyzed_required > 0) analyzed_required_strategy.fetch_add(d.analyzed_required, std::memory_order_relaxed);
        if (d.required_hits > 0) required_strategy_hits.fetch_add(d.required_hits, std::memory_order_relaxed);
        if (d.uniqueness_calls > 0) uniqueness_calls_total.fetch_add(d.uniqueness_calls, std::memory_order_relaxed);
        if (d.uniqueness_nodes > 0) uniqueness_nodes_total.fetch_add(d.uniqueness_nodes, std::memory_order_relaxed);
        if (d.uniqueness_elapsed_ns > 0) uniqueness_elapsed_ns_total.fetch_add(d.uniqueness_elapsed_ns, std::memory_order_relaxed);
        if (d.logic_steps > 0) logic_steps_total.fetch_add(d.logic_steps, std::memory_order_relaxed);
        if (d.naked_use > 0) strategy_naked_use_total.fetch_add(d.naked_use, std::memory_order_relaxed);
        if (d.naked_hit > 0) strategy_naked_hit_total.fetch_add(d.naked_hit, std::memory_order_relaxed);
        if (d.hidden_use > 0) strategy_hidden_use_total.fetch_add(d.hidden_use, std::memory_order_relaxed);
        if (d.hidden_hit > 0) strategy_hidden_hit_total.fetch_add(d.hidden_hit, std::memory_order_relaxed);
        if (d.reseeds > 0) reseeds_total.fetch_add(d.reseeds, std::memory_order_relaxed);
    };
    auto drain_telemetry_ring = [&]() {
        TelemetryDelta d{};
        while (telemetry_ring->try_pop(d)) {
            apply_telemetry_delta(d);
        }
    };
    const auto start = std::chrono::steady_clock::now();
    const bool has_max_total_deadline = (cfg.max_total_time_s > 0);
    const bool has_max_attempts_deadline = (cfg.max_attempts_s > 0);
    const bool has_any_hard_deadline = has_max_total_deadline || has_max_attempts_deadline;
    const auto hard_deadline_total = has_max_total_deadline
        ? (start + std::chrono::seconds(cfg.max_total_time_s))
        : std::chrono::steady_clock::time_point::max();
    const auto hard_deadline_attempts = has_max_attempts_deadline
        ? (start + std::chrono::seconds(cfg.max_attempts_s))
        : std::chrono::steady_clock::time_point::max();
    auto latch_hard_stop = [&](int reason, const char* source, int tid) -> int {
        int expected = 0;
        if (!hard_stop_reason.value.compare_exchange_strong(expected, reason, std::memory_order_relaxed)) {
            return hard_stop_reason.load(std::memory_order_relaxed);
        }
        if (reason == 1) {
            timeout_global_count.fetch_add(1, std::memory_order_relaxed);
        } else if (reason == 2) {
            timeout_per_attempt_count.fetch_add(1, std::memory_order_relaxed);
        }
        force_abort.store(true, std::memory_order_relaxed);
        const double elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - start).count();
        const uint64_t limit_s = (reason == 1) ? cfg.max_total_time_s : cfg.max_attempts_s;
        log_warn(
            "run_generic.hard_stop",
            std::string("reason=") + (reason == 1 ? "max_total_time_s" : "max_attempts_s") +
                " source=" + source +
                " tid=" + std::to_string(tid) +
                " elapsed_s=" + format_fixed(elapsed_s, 3) +
                " limit_s=" + std::to_string(limit_s));
        return reason;
    };
    auto check_hard_deadline = [&](const std::chrono::steady_clock::time_point& now_tp, const char* source, int tid) -> int {
        if (has_max_total_deadline && now_tp >= hard_deadline_total) {
            return latch_hard_stop(1, source, tid);
        }
        if (has_max_attempts_deadline && now_tp >= hard_deadline_attempts) {
            return latch_hard_stop(2, source, tid);
        }
        return hard_stop_reason.load(std::memory_order_relaxed);
    };
    auto push_monitor_totals = [&]() {
        if (monitor == nullptr) {
            return;
        }
        MonitorTotalsSnapshot snapshot{};
        snapshot.target = cfg.target_puzzles;
        snapshot.accepted = std::min<uint64_t>(accepted.load(std::memory_order_relaxed), cfg.target_puzzles);
        snapshot.written = written.load(std::memory_order_relaxed);
        snapshot.attempts = attempts.load(std::memory_order_relaxed);
        snapshot.analyzed_required_strategy = analyzed_required_strategy.load(std::memory_order_relaxed);
        snapshot.required_strategy_hits = required_strategy_hits.load(std::memory_order_relaxed);
        snapshot.written_required_strategy = written_required_strategy.load(std::memory_order_relaxed);
        snapshot.rejected = rejected.load(std::memory_order_relaxed);
        snapshot.active_workers = static_cast<uint64_t>(thread_count);
        snapshot.reseeds = reseeds_total.load(std::memory_order_relaxed);
        monitor->set_totals_snapshot(snapshot);
    };
    auto push_strategy_snapshot = [&]() {
        if (monitor == nullptr) {
            return;
        }
        StrategyRow row{};
        row.strategy = to_string(cfg.required_strategy);
        row.lvl = cfg.difficulty_level_required;
        row.max_attempts = cfg.max_attempts;
        row.analyzed = analyzed_required_strategy.load(std::memory_order_relaxed);
        row.required_strategy_hits = required_strategy_hits.load(std::memory_order_relaxed);
        const double elapsed_min =
            std::chrono::duration<double>(std::chrono::steady_clock::now() - start).count() / 60.0;
        row.analyzed_per_min = elapsed_min > 0.0 ? static_cast<double>(row.analyzed) / elapsed_min : 0.0;
        row.est_5min = static_cast<uint64_t>(row.analyzed_per_min * 5.0);
        row.written = written_required_strategy.load(std::memory_order_relaxed);
        row.avg_clues = row.written > 0
            ? static_cast<double>(clue_sum_required_strategy.load(std::memory_order_relaxed)) / static_cast<double>(row.written)
            : 0.0;
        monitor->update_strategy_row(row);
    };

    auto output_ring = std::make_unique<OutputLineMpscRing<256>>();
    std::ofstream batch_out(out_path, std::ios::out | std::ios::trunc);
    if (!batch_out) {
        const std::string msg = "Cannot open output file: " + out_path.string();
        log_error("run_generic", msg);
        log_message(msg);
        return result;
    }
    
    std::atomic<bool> writer_stop{false};
    std::thread writer_thread([&]() {
        OutputLineEvent ev{};
        while (!writer_stop.load(std::memory_order_relaxed) || !output_ring->empty()) {
            if (!output_ring->try_pop(ev)) {
                std::this_thread::yield();
                continue;
            }
            batch_out.write(ev.bytes.data(), static_cast<std::streamsize>(ev.len));
            batch_out.put('\n');
            if (!batch_out) {
                io_failed.store(true, std::memory_order_relaxed);
                force_abort.store(true, std::memory_order_relaxed);
                break;
            }
            written.fetch_add(1, std::memory_order_relaxed);

            if (cfg.write_individual_files) {
                std::ostringstream one_name;
                one_name << "sudoku_" << std::setw(6) << std::setfill('0') << ev.accepted_idx << ".txt";
                std::ofstream one_out(std::filesystem::path(cfg.output_folder) / one_name.str(), std::ios::out | std::ios::trunc);
                if (one_out) {
                    one_out.write(ev.bytes.data(), static_cast<std::streamsize>(ev.len));
                    one_out.put('\n');
                }
            }
        }
        batch_out.flush();
    });


    std::atomic<bool> timeout_watchdog_stop{false};
    std::thread timeout_watchdog;
    if (has_any_hard_deadline) {
        timeout_watchdog = std::thread([&]() {
            while (!timeout_watchdog_stop.load(std::memory_order_relaxed) &&
                   !force_abort.load(std::memory_order_relaxed)) {
                const int reason = check_hard_deadline(std::chrono::steady_clock::now(), "watchdog", -1);
                if (reason != 0) {
                    break;
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(5));
            }
        });
    }

    const GenericSolvedKernel solved(GenericSolvedKernel::backend_from_string(cpu_ctx.selected_backend));
    const GenericDigKernel dig;
    const GenericQuickPrefilter prefilter;
    const GenericLogicCertify logic;

    push_monitor_totals();
    push_strategy_snapshot();

    auto worker_task = [&](int tid) {
        uint64_t worker_seed_state = static_cast<uint64_t>(seed) ^ (0x9e3779b97f4a7c15ULL * (tid + 1));
        long long local_seed = bounded_positive_seed_i64(splitmix64(worker_seed_state));
        std::mt19937_64 rng(static_cast<uint64_t>(local_seed));
        GenericUniquenessCounter uniq;
        
        const bool reporter_thread = (tid == 0);
        const bool monitor_enabled = (monitor != nullptr);
        const bool has_external_cancel = (external_cancel != nullptr);
        const bool has_external_pause = (external_paused != nullptr);
        const bool reseed_enabled = cfg.reseed_interval_s > 0;
        const auto reseed_interval = std::chrono::seconds(cfg.reseed_interval_s);
        const bool has_global_time_limit = has_any_hard_deadline;
        
        auto last_reseed_time = std::chrono::steady_clock::now();
        auto last_monitor_push = std::chrono::steady_clock::now();
        auto last_worker_push = std::chrono::steady_clock::now();
        auto current_attempt_start = std::chrono::steady_clock::now();
        bool attempt_in_progress = false;
        uint64_t reseed_counter = 0;
        uint64_t worker_applied = 0;
        uint64_t worker_dead_ends = 0;
        uint64_t worker_attempts_finished = 0;
        uint64_t worker_uniqueness_nodes_sum = 0;
        uint64_t worker_uniqueness_elapsed_ns_sum = 0;
        double worker_attempt_elapsed_ms_sum = 0.0;
        double worker_stage_solved_ms_sum = 0.0;
        double worker_stage_dig_ms_sum = 0.0;
        double worker_stage_prefilter_ms_sum = 0.0;
        double worker_stage_logic_ms_sum = 0.0;
        double worker_stage_uniqueness_ms_sum = 0.0;
        bool paused_state = false;

        WorkerRow worker{};
        {
            std::ostringstream name;
            name << "worker_" << std::setw(2) << std::setfill('0') << tid;
            worker.worker = name.str();
        }
        worker.seed = local_seed;
        worker.status = "running";
        worker.last_reseed_steady_ns = static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(last_reseed_time.time_since_epoch()).count());
        worker.reseed_interval_s = cfg.reseed_interval_s;
        worker.attempt_time_budget_s = 0.0;
        worker.attempt_node_budget = 0;
        auto ns_to_ms = [](uint64_t ns) -> double {
            return static_cast<double>(ns) / 1'000'000.0;
        };
        auto refresh_worker_dynamic = [&](const std::chrono::steady_clock::time_point& now_tp) {
            const double elapsed_since_reseed_s = std::chrono::duration<double>(now_tp - last_reseed_time).count();
            worker.last_reseed_steady_ns = static_cast<uint64_t>(
                std::chrono::duration_cast<std::chrono::nanoseconds>(last_reseed_time.time_since_epoch()).count());
            if (reseed_enabled) {
                const double interval_s = static_cast<double>(cfg.reseed_interval_s);
                worker.reset_in_s = std::max(0.0, interval_s - elapsed_since_reseed_s);
                worker.reset_lag = std::max(0.0, elapsed_since_reseed_s - interval_s);
                worker.lag_max = std::max(worker.lag_max, worker.reset_lag);
            } else {
                worker.reset_in_s = 0.0;
                worker.reset_lag = 0.0;
                worker.lag_max = 0.0;
            }
            if (attempt_in_progress) {
                worker.attempt_time_budget_s = std::chrono::duration<double>(now_tp - current_attempt_start).count();
            } else {
                worker.attempt_time_budget_s = 0.0;
            }
            worker.attempt_node_budget = worker_uniqueness_nodes_sum;
        };
        auto maybe_publish_worker = [&](const std::chrono::steady_clock::time_point& now_tp, bool force) {
            refresh_worker_dynamic(now_tp);
            if (!monitor_enabled) {
                return;
            }
            if (force || (now_tp - last_worker_push) >= std::chrono::milliseconds(500)) {
                monitor->set_worker_row(static_cast<size_t>(tid), worker);
                last_worker_push = now_tp;
            }
        };
        maybe_publish_worker(std::chrono::steady_clock::now(), true);
        
        started_workers.fetch_add(1, std::memory_order_relaxed);
        while (started_workers.load(std::memory_order_relaxed) < thread_count) {
            if (force_abort.load(std::memory_order_relaxed) || (has_external_cancel && external_cancel->load(std::memory_order_relaxed))) {
                worker.status = "cancel_requested";
                if (monitor_enabled) {
                    monitor->set_worker_row(static_cast<size_t>(tid), worker);
                }
                return;
            }
            std::this_thread::yield();
        }

        GenericPuzzleCandidate candidate;
        candidate.puzzle.resize(static_cast<size_t>(topo.nn));
        candidate.solution.resize(static_cast<size_t>(topo.nn));
        
        TelemetryDelta local_delta{};
        uint64_t local_attempts_done = 0;
        
        while (!force_abort.load(std::memory_order_relaxed)) {
            if (has_external_cancel && external_cancel->load(std::memory_order_relaxed)) {
                force_abort.store(true, std::memory_order_relaxed);
                worker.status = "cancel_requested";
                break;
            }
            if (has_external_pause && external_paused->load(std::memory_order_relaxed)) {
                if (!paused_state) {
                    paused_state = true;
                    worker.status = "paused";
                    maybe_publish_worker(std::chrono::steady_clock::now(), true);
                }
                maybe_publish_worker(std::chrono::steady_clock::now(), false);
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                continue;
            } else if (paused_state) {
                paused_state = false;
                worker.status = "running";
                maybe_publish_worker(std::chrono::steady_clock::now(), true);
            }

            if (reseed_enabled || has_global_time_limit) {
                const auto now_tp = std::chrono::steady_clock::now();

                if (reseed_enabled && (now_tp - last_reseed_time) >= reseed_interval) {
                    const long long old_seed = local_seed;
                    worker_seed_state = splitmix64(worker_seed_state);
                    reseed_counter = worker_seed_state;
                    local_seed = bounded_positive_seed_i64(reseed_counter);
                    rng.seed(static_cast<uint64_t>(local_seed));
                    last_reseed_time = now_tp;
                    reseeds_total.fetch_add(1, std::memory_order_relaxed);
                    worker.resets += 1;
                    worker.seed = local_seed;
                    log_info(
                        "run_generic.reseed",
                        "tid=" + std::to_string(tid) +
                            " old_seed=" + std::to_string(old_seed) +
                            " new_seed=" + std::to_string(local_seed) +
                            " interval_s=" + std::to_string(cfg.reseed_interval_s) +
                            " reason=reseed_interval_s_elapsed");
                    maybe_publish_worker(now_tp, true);
                }

                if (has_global_time_limit) {
                    const int stop_reason = check_hard_deadline(now_tp, "worker_loop", tid);
                    if (stop_reason != 0) {
                        worker.status = (stop_reason == 1) ? "global_timeout" : "run_time_budget";
                        break;
                    }
                }
            }

            if (accepted.load(std::memory_order_relaxed) >= cfg.target_puzzles || io_failed.load(std::memory_order_relaxed)) {
                force_abort.store(true, std::memory_order_relaxed);
                worker.status = io_failed.load(std::memory_order_relaxed) ? "io_error" : "target_reached";
                break;
            }
            if (cfg.max_attempts > 0) {
                const uint64_t att = attempt_ticket.fetch_add(1, std::memory_order_relaxed) + 1ULL;
                if (att > cfg.max_attempts) {
                    force_abort.store(true, std::memory_order_relaxed);
                    worker.status = "max_attempts";
                    break;
                }
            }

            ++local_attempts_done;
            attempts.fetch_add(1, std::memory_order_relaxed);
            current_attempt_start = std::chrono::steady_clock::now();
            attempt_in_progress = true;
            maybe_publish_worker(current_attempt_start, false);
            const auto attempt_t0 = current_attempt_start;
            GenerateRunConfig attempt_cfg = runtime_cfg;
            if (cfg.force_new_seed_per_attempt) {
                worker_seed_state = splitmix64(worker_seed_state);
                local_seed = bounded_positive_seed_i64(worker_seed_state);
                rng.seed(static_cast<uint64_t>(local_seed));
            }
            attempt_cfg.seed = local_seed;
            worker.seed = local_seed;
            if (has_global_time_limit) {
                const int stop_reason = check_hard_deadline(current_attempt_start, "attempt_start", tid);
                if (stop_reason != 0) {
                    attempt_in_progress = false;
                    worker.status = (stop_reason == 1) ? "global_timeout" : "run_time_budget";
                    break;
                }
                double remaining_s = std::numeric_limits<double>::infinity();
                if (has_max_total_deadline) {
                    const double left_total = std::chrono::duration<double>(hard_deadline_total - current_attempt_start).count();
                    remaining_s = std::min(remaining_s, left_total);
                }
                if (has_max_attempts_deadline) {
                    const double left_hard_deadline = std::chrono::duration<double>(hard_deadline_attempts - current_attempt_start).count();
                    remaining_s = std::min(remaining_s, left_hard_deadline);
                }
                remaining_s = std::max(0.0, remaining_s);
                if (!(remaining_s > 0.0)) {
                    const int forced_reason = has_max_attempts_deadline ? 2 : 1;
                    const int latched = latch_hard_stop(forced_reason, "attempt_remaining", tid);
                    attempt_in_progress = false;
                    worker.status = (latched == 1) ? "global_timeout" : "run_time_budget";
                    break;
                }
                if (attempt_cfg.attempt_time_budget_s <= 0.0) {
                    attempt_cfg.attempt_time_budget_s = remaining_s;
                } else {
                    attempt_cfg.attempt_time_budget_s = std::min(attempt_cfg.attempt_time_budget_s, remaining_s);
                }
            }

            RejectReason reason = RejectReason::None;
            RequiredStrategyAttemptInfo strategy_info{};
            AttemptPerfStats perf_stats{};
            bool attempt_timed_out = false;
            
            bool ok = generate_one_generic(
                attempt_cfg, topo, rng, candidate, reason, strategy_info,
                solved, dig, prefilter, logic, uniq,
                &force_abort.value, &attempt_timed_out, external_cancel, external_paused,
                nullptr, nullptr, nullptr, &perf_stats);
            attempt_in_progress = false;
            const auto attempt_elapsed_ms = std::chrono::duration<double, std::milli>(
                std::chrono::steady_clock::now() - attempt_t0).count();
            ++worker_attempts_finished;
            worker_attempt_elapsed_ms_sum += attempt_elapsed_ms;
            worker.avg_attempt_ms = worker_attempt_elapsed_ms_sum / static_cast<double>(worker_attempts_finished);

            // Aktualizacja metryk
            if (strategy_info.required_strategy_use_confirmed) {
                analyzed_required_strategy.fetch_add(1, std::memory_order_relaxed);
            }
            if (strategy_info.required_strategy_hit_confirmed) {
                required_strategy_hits.fetch_add(1, std::memory_order_relaxed);
            }
            local_delta.uniqueness_calls += perf_stats.uniqueness_calls;
            local_delta.uniqueness_nodes += perf_stats.uniqueness_nodes;
            local_delta.uniqueness_elapsed_ns += perf_stats.uniqueness_elapsed_ns;
            local_delta.logic_steps += perf_stats.logic_steps;
            local_delta.naked_use += perf_stats.strategy_naked_use;
            local_delta.naked_hit += perf_stats.strategy_naked_hit;
            local_delta.hidden_use += perf_stats.strategy_hidden_use;
            local_delta.hidden_hit += perf_stats.strategy_hidden_hit;
            worker_uniqueness_nodes_sum += perf_stats.uniqueness_nodes;
            worker_uniqueness_elapsed_ns_sum += perf_stats.uniqueness_elapsed_ns;
            worker.backtrack_count = worker_uniqueness_nodes_sum;
            if (worker_uniqueness_nodes_sum > 0) {
                worker.avg_node_ms =
                    (static_cast<double>(worker_uniqueness_elapsed_ns_sum) / 1'000'000.0) /
                    static_cast<double>(worker_uniqueness_nodes_sum);
            }
            worker_stage_solved_ms_sum += ns_to_ms(perf_stats.solved_elapsed_ns);
            worker_stage_dig_ms_sum += ns_to_ms(perf_stats.dig_elapsed_ns);
            worker_stage_prefilter_ms_sum += ns_to_ms(perf_stats.prefilter_elapsed_ns);
            worker_stage_logic_ms_sum += ns_to_ms(perf_stats.logic_elapsed_ns);
            worker_stage_uniqueness_ms_sum += ns_to_ms(perf_stats.uniqueness_elapsed_ns);
            worker.stage_solved_ms = worker_stage_solved_ms_sum / static_cast<double>(worker_attempts_finished);
            worker.stage_dig_ms = worker_stage_dig_ms_sum / static_cast<double>(worker_attempts_finished);
            worker.stage_prefilter_ms = worker_stage_prefilter_ms_sum / static_cast<double>(worker_attempts_finished);
            worker.stage_logic_ms = worker_stage_logic_ms_sum / static_cast<double>(worker_attempts_finished);
            worker.stage_uniqueness_ms = worker_stage_uniqueness_ms_sum / static_cast<double>(worker_attempts_finished);

            if (ok) {
                const uint64_t acc_before = accepted.fetch_add(1, std::memory_order_relaxed);
                if (acc_before < cfg.target_puzzles) {
                    clue_sum.fetch_add(static_cast<uint64_t>(candidate.clues), std::memory_order_relaxed);
                    const std::string line = serialize_line_generic(local_seed, cfg, candidate, topo.nn);
                    worker.clues = candidate.clues;
                    worker.applied = ++worker_applied;
                    worker.status = "running";
                    
                    if (strategy_info.matched_required_strategy) {
                        written_required_strategy.fetch_add(1, std::memory_order_relaxed);
                        clue_sum_required_strategy.fetch_add(static_cast<uint64_t>(candidate.clues), std::memory_order_relaxed);
                    }
                    
                    while (!output_ring->try_push(acc_before + 1, line)) {
                        if (io_failed.load(std::memory_order_relaxed) || force_abort.load(std::memory_order_relaxed)) break;
                        std::this_thread::yield();
                    }
                    
                    if (on_progress) on_progress(acc_before + 1, cfg.target_puzzles);
                    
                    if (acc_before + 1 >= cfg.target_puzzles) {
                        force_abort.store(true, std::memory_order_relaxed);
                    }
                }
            } else {
                rejected.fetch_add(1, std::memory_order_relaxed);
                if (reason != RejectReason::None) {
                    ++worker_dead_ends;
                }
                switch (reason) {
                case RejectReason::Prefilter:
                    reject_prefilter.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::Logic:
                    reject_logic.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::Uniqueness:
                    reject_uniqueness.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::Strategy:
                    reject_strategy.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::Replay:
                    reject_replay.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::DistributionBias:
                    reject_distribution_bias.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::UniquenessBudget:
                    reject_uniqueness_budget.fetch_add(1, std::memory_order_relaxed);
                    break;
                case RejectReason::None: break;
                }
            }
            worker.dead_ends = worker_dead_ends;
            worker.success_rate_pct = local_attempts_done > 0
                ? (100.0 * static_cast<double>(worker_applied) / static_cast<double>(local_attempts_done))
                : 0.0;

            // Popychanie metryk co 256 iteracji (szybkie flush)
            if ((local_attempts_done & 255ULL) == 0ULL) {
                if (!telemetry_ring->try_push(local_delta)) {
                    apply_telemetry_delta(local_delta);
                }
                local_delta = TelemetryDelta{};
                if (reporter_thread) {
                    TelemetryDelta d{};
                    while (telemetry_ring->try_pop(d)) apply_telemetry_delta(d);
                }
            }
            if (monitor_enabled && reporter_thread) {
                const auto now_tp = std::chrono::steady_clock::now();
                if ((now_tp - last_monitor_push) >= std::chrono::milliseconds(500)) {
                    drain_telemetry_ring();
                    push_monitor_totals();
                    push_strategy_snapshot();
                    monitor->set_background_status(
                        "Generowanie: accepted=" + std::to_string(std::min<uint64_t>(accepted.load(std::memory_order_relaxed), cfg.target_puzzles)) +
                        "/" + std::to_string(cfg.target_puzzles) +
                        " attempts=" + std::to_string(attempts.load(std::memory_order_relaxed)) +
                        " rejected=" + std::to_string(rejected.load(std::memory_order_relaxed)));
                    last_monitor_push = now_tp;
                }
            }
            maybe_publish_worker(std::chrono::steady_clock::now(), false);
        }
        
        // Zrzut reszty metryk na koniec wÄ…tku
        if (!local_delta.empty()) {
            apply_telemetry_delta(local_delta);
        }
        worker.status = force_abort.load(std::memory_order_relaxed)
            ? (has_external_cancel && external_cancel->load(std::memory_order_relaxed) ? "cancel_requested" : "stopped")
            : "finished";
        if (monitor_enabled) {
            refresh_worker_dynamic(std::chrono::steady_clock::now());
            monitor->set_worker_row(static_cast<size_t>(tid), worker);
        }
    };

    PersistentThreadPool::instance().run(thread_count, worker_task);
    timeout_watchdog_stop.store(true, std::memory_order_relaxed);
    if (timeout_watchdog.joinable()) {
        timeout_watchdog.join();
    }
    
    drain_telemetry_ring();
    
    force_abort.store(true, std::memory_order_relaxed);
    writer_stop.store(true, std::memory_order_relaxed);
    if (writer_thread.joinable()) {
        writer_thread.join();
    }

    const auto end = std::chrono::steady_clock::now();
    const double elapsed_s = std::chrono::duration<double>(end - start).count();

    result.accepted = std::min(accepted.load(std::memory_order_relaxed), cfg.target_puzzles);
    result.written = written.load(std::memory_order_relaxed);
    result.attempts = attempts.load(std::memory_order_relaxed);
    result.attempts_total = result.attempts;
    result.analyzed_required_strategy = analyzed_required_strategy.load(std::memory_order_relaxed);
    result.required_strategy_hits = required_strategy_hits.load(std::memory_order_relaxed);
    result.written_required_strategy = written_required_strategy.load(std::memory_order_relaxed);
    result.rejected = rejected.load(std::memory_order_relaxed);
    result.reject_prefilter = reject_prefilter.load(std::memory_order_relaxed);
    result.reject_logic = reject_logic.load(std::memory_order_relaxed);
    result.reject_uniqueness = reject_uniqueness.load(std::memory_order_relaxed);
    result.reject_strategy = reject_strategy.load(std::memory_order_relaxed);
    result.reject_replay = reject_replay.load(std::memory_order_relaxed);
    result.reject_distribution_bias = reject_distribution_bias.load(std::memory_order_relaxed);
    result.reject_uniqueness_budget = reject_uniqueness_budget.load(std::memory_order_relaxed);
    result.timeout_global = timeout_global_count.load(std::memory_order_relaxed);
    result.timeout_per_attempt = timeout_per_attempt_count.load(std::memory_order_relaxed);
    result.uniqueness_calls = uniqueness_calls_total.load(std::memory_order_relaxed);
    result.uniqueness_nodes = uniqueness_nodes_total.load(std::memory_order_relaxed);
    result.uniqueness_elapsed_ms = static_cast<double>(uniqueness_elapsed_ns_total.load(std::memory_order_relaxed)) / 1'000'000.0;
    result.uniqueness_avg_ms = result.uniqueness_calls > 0 ? (result.uniqueness_elapsed_ms / static_cast<double>(result.uniqueness_calls)) : 0.0;
    result.logic_steps_total = logic_steps_total.load(std::memory_order_relaxed);
    result.strategy_naked_use = strategy_naked_use_total.load(std::memory_order_relaxed);
    result.strategy_naked_hit = strategy_naked_hit_total.load(std::memory_order_relaxed);
    result.strategy_hidden_use = strategy_hidden_use_total.load(std::memory_order_relaxed);
    result.strategy_hidden_hit = strategy_hidden_hit_total.load(std::memory_order_relaxed);
    result.cpu_backend_selected = cpu_ctx.selected_backend;
    result.elapsed_s = elapsed_s;
    result.accepted_per_sec = elapsed_s > 0.0 ? static_cast<double>(result.accepted) / elapsed_s : 0.0;
    result.kernel_time_ms = elapsed_s * 1000.0;
    result.kernel_calls = result.attempts;
    result.backend_efficiency_score = result.accepted_per_sec * (1.0 + 0.05 * static_cast<double>(topo.n));
    result.asymmetry_efficiency_index = result.accepted_per_sec * runtime_profile.asymmetry_ratio;
    result.histogram_levels[std::clamp(runtime_cfg.difficulty_level_required, 0, 9)] = result.accepted;
    result.histogram_strategies[strategy_to_hist_idx_shared(runtime_cfg.required_strategy)] = result.accepted;
    result.avg_clues = result.written > 0 ? static_cast<double>(clue_sum.load(std::memory_order_relaxed)) / static_cast<double>(result.written) : 0.0;
    
    const bool vip_enabled = runtime_cfg.vip_mode || normalize_difficulty_engine(runtime_cfg.difficulty_engine) == "vip";
    const std::string vip_grade_target_effective = resolve_vip_grade_target_for_geometry(runtime_cfg);
    
    if (vip_enabled) {
        const VipScoreBreakdown breakdown = compute_vip_score_breakdown(result, runtime_cfg, runtime_profile);
        result.vip_score = breakdown.final_score;
        result.vip_score_breakdown_json = breakdown.to_json();
        result.vip_grade = vip_grade_from_score(result.vip_score);
    } else {
        result.vip_score = 0.0;
        result.vip_grade = "none";
        result.vip_score_breakdown_json = "{}";
    }
    
    result.vip_contract_ok = !vip_enabled || vip_contract_passed(result.vip_score, vip_grade_target_effective);
    if (!result.vip_contract_ok) {
        result.vip_contract_fail_reason = "target=" + vip_grade_target_effective + " got=" + result.vip_grade + " score=" + format_fixed(result.vip_score, 3);
    } else {
        result.vip_contract_fail_reason = "ok";
    }
    
    result.premium_signature = premium_signature_last.load(std::memory_order_relaxed);
    if (result.premium_signature == 0) {
        result.premium_signature = compute_premium_signature(runtime_cfg, result, cpu_ctx.selected_backend);
    }
    result.premium_signature_v2 = compute_premium_signature_v2(runtime_cfg, result, cpu_ctx.selected_backend, vip_grade_target_effective);
    
    write_vip_trace_and_signature_if_requested(runtime_cfg, result, cpu_ctx.selected_backend);
    const DifficultySignals diff_signals = collect_difficulty_signals(result, runtime_profile);
    append_difficulty_signals_csv(runtime_cfg, result, diff_signals);
    log_message(
        "Koniec: accepted=" + std::to_string(result.accepted) +
        "/" + std::to_string(cfg.target_puzzles) +
        " written=" + std::to_string(result.written) +
        " attempts=" + std::to_string(result.attempts) +
        " elapsed_s=" + format_fixed(result.elapsed_s, 2));

    if (monitor != nullptr) {
        MonitorTotalsSnapshot snapshot{};
        snapshot.target = cfg.target_puzzles;
        snapshot.accepted = result.accepted;
        snapshot.written = result.written;
        snapshot.attempts = result.attempts;
        snapshot.analyzed_required_strategy = result.analyzed_required_strategy;
        snapshot.required_strategy_hits = result.required_strategy_hits;
        snapshot.written_required_strategy = result.written_required_strategy;
        snapshot.rejected = result.rejected;
        snapshot.active_workers = static_cast<uint64_t>(thread_count);
        snapshot.reseeds = reseeds_total.load(std::memory_order_relaxed);
        monitor->set_totals_snapshot(snapshot);
        monitor->set_background_status("Generowanie zakonczone: accepted=" + std::to_string(result.accepted) + "/" + std::to_string(cfg.target_puzzles) + ", elapsed_s=" + format_fixed(result.elapsed_s, 2));
        monitor->add_avg_clues_per_level(cfg.difficulty_level_required, result.avg_clues);
    }
    return result;
}

RequiredStrategy parse_required_strategy(const std::string& s) {
    std::string key;
    key.reserve(s.size());
    for (unsigned char ch : s) {
        if (std::isalnum(ch) != 0) {
            key.push_back(static_cast<char>(std::tolower(ch)));
        }
    }
    if (key.empty()) return RequiredStrategy::None;
    if (key == "none" || key == "brak") return RequiredStrategy::None;
    if (key == "naked" || key == "nakedsingle" || key == "single") return RequiredStrategy::NakedSingle;
    if (key == "hidden" || key == "hiddensingle") return RequiredStrategy::HiddenSingle;
    if (key == "pointing" || key == "pointingpair" || key == "pointingpairs" || key == "pointingtriple" || key == "pointingtriples") return RequiredStrategy::PointingPairs;
    if (key == "boxline" || key == "boxlinereduction" || key == "linebox") return RequiredStrategy::BoxLineReduction;
    if (key == "nakedpair" || key == "pair") return RequiredStrategy::NakedPair;
    if (key == "hiddenpair") return RequiredStrategy::HiddenPair;
    if (key == "nakedtriple" || key == "triple") return RequiredStrategy::NakedTriple;
    if (key == "hiddentriple") return RequiredStrategy::HiddenTriple;
    if (key == "nakedquad" || key == "quad") return RequiredStrategy::NakedQuad;
    if (key == "hiddenquad") return RequiredStrategy::HiddenQuad;
    if (key == "xwing" || key == "xwingfish") return RequiredStrategy::XWing;
    if (key == "ywing") return RequiredStrategy::YWing;
    if (key == "skyscraper") return RequiredStrategy::Skyscraper;
    if (key == "twostringkite" || key == "2stringkite" || key == "kite") return RequiredStrategy::TwoStringKite;
    if (key == "emptyrectangle" || key == "er") return RequiredStrategy::EmptyRectangle;
    if (key == "remotepairs" || key == "remote") return RequiredStrategy::RemotePairs;
    if (key == "swordfish") return RequiredStrategy::Swordfish;
    if (key == "finnedxwing" || key == "finnedxwingsashimi" || key == "sashimixwing") return RequiredStrategy::FinnedXWingSashimi;
    if (key == "simplecoloring" || key == "coloring") return RequiredStrategy::SimpleColoring;
    if (key == "bug1" || key == "bugplus1" || key == "bugplusone") return RequiredStrategy::BUGPlusOne;
    if (key == "uniquerectangle" || key == "ur") return RequiredStrategy::UniqueRectangle;
    if (key == "xyzzwing" || key == "xyzwing") return RequiredStrategy::XYZWing;
    if (key == "wwing") return RequiredStrategy::WWing;
    if (key == "jellyfish") return RequiredStrategy::Jellyfish;
    if (key == "xchain") return RequiredStrategy::XChain;
    if (key == "xychain") return RequiredStrategy::XYChain;
    if (key == "wxyzwing") return RequiredStrategy::WXYZWing;
    if (key == "finnedswordfish" || key == "finnedswordfishjellyfish" || key == "finnedjellyfish") return RequiredStrategy::FinnedSwordfishJellyfish;
    if (key == "alsxz") return RequiredStrategy::ALSXZ;
    if (key == "uniqueloop") return RequiredStrategy::UniqueLoop;
    if (key == "avoidablerectangle") return RequiredStrategy::AvoidableRectangle;
    if (key == "bivalueoddagon") return RequiredStrategy::BivalueOddagon;
    if (key == "uniquerectangleextended" || key == "urextended" || key == "urtype2" || key == "urtype3" || key == "urtype4" || key == "urtype5" || key == "urtype6") return RequiredStrategy::UniqueRectangleExtended;
    if (key == "hiddenuniquerectangle" || key == "hiddenur") return RequiredStrategy::HiddenUniqueRectangle;
    if (key == "bugtype2" || key == "bug2") return RequiredStrategy::BUGType2;
    if (key == "bugtype3" || key == "bug3") return RequiredStrategy::BUGType3;
    if (key == "bugtype4" || key == "bug4") return RequiredStrategy::BUGType4;
    if (key == "borescoper" || key == "qiu" || key == "borescoperqiudeadlypattern" || key == "deadlypattern") return RequiredStrategy::BorescoperQiuDeadlyPattern;
    if (key == "medusa" || key == "3dmedusa" || key == "medusa3d") return RequiredStrategy::Medusa3D;
    if (key == "aic") return RequiredStrategy::AIC;
    if (key == "groupedaic") return RequiredStrategy::GroupedAIC;
    if (key == "groupedxcycle" || key == "xcyclegrouped") return RequiredStrategy::GroupedXCycle;
    if (key == "continuousniceloop" || key == "niceloop") return RequiredStrategy::ContinuousNiceLoop;
    if (key == "alsxywing" || key == "alsxy") return RequiredStrategy::ALSXYWing;
    if (key == "alschain") return RequiredStrategy::ALSChain;
    if (key == "suedecoq" || key == "sdc") return RequiredStrategy::SueDeCoq;
    if (key == "deathblossom") return RequiredStrategy::DeathBlossom;
    if (key == "frankenfish") return RequiredStrategy::FrankenFish;
    if (key == "mutantfish") return RequiredStrategy::MutantFish;
    if (key == "krakenfish") return RequiredStrategy::KrakenFish;
    if (key == "alignedpairexclusion" || key == "ape") return RequiredStrategy::AlignedPairExclusion;
    if (key == "alignedtripleexclusion" || key == "ate") return RequiredStrategy::AlignedTripleExclusion;
    if (key == "alsaic") return RequiredStrategy::ALSAIC;
    if (key == "msls") return RequiredStrategy::MSLS;
    if (key == "exocet") return RequiredStrategy::Exocet;
    if (key == "seniorexocet") return RequiredStrategy::SeniorExocet;
    if (key == "skloop") return RequiredStrategy::SKLoop;
    if (key == "patternoverlaymethod" || key == "patternoverlay" || key == "pom") return RequiredStrategy::PatternOverlayMethod;
    if (key == "forcingchains" || key == "forcingchain") return RequiredStrategy::ForcingChains;
    if (key == "dynamicforcingchains" || key == "dynamicforcingchain" || key == "dfc") return RequiredStrategy::DynamicForcingChains;
    if (key == "squirmbag" || key == "starfish") return RequiredStrategy::Squirmbag;
    if (key == "backtracking" || key == "brutalny" || key == "bruteforce") return RequiredStrategy::Backtracking;
    return RequiredStrategy::None;
}

inline bool required_strategy_runtime_ready(RequiredStrategy strategy) {
    switch (strategy) {
    case RequiredStrategy::None:
    case RequiredStrategy::NakedSingle:
    case RequiredStrategy::HiddenSingle:
    case RequiredStrategy::PointingPairs:
    case RequiredStrategy::BoxLineReduction:
    case RequiredStrategy::NakedPair:
    case RequiredStrategy::HiddenPair:
    case RequiredStrategy::NakedTriple:
    case RequiredStrategy::HiddenTriple:
    case RequiredStrategy::NakedQuad:
    case RequiredStrategy::HiddenQuad:
    case RequiredStrategy::XWing:
    case RequiredStrategy::YWing:
    case RequiredStrategy::Skyscraper:
    case RequiredStrategy::TwoStringKite:
    case RequiredStrategy::EmptyRectangle:
    case RequiredStrategy::RemotePairs:
    case RequiredStrategy::Swordfish:
    case RequiredStrategy::FinnedXWingSashimi:
    case RequiredStrategy::SimpleColoring:
    case RequiredStrategy::BUGPlusOne:
    case RequiredStrategy::UniqueRectangle:
    case RequiredStrategy::XYZWing:
    case RequiredStrategy::WWing:
    case RequiredStrategy::Jellyfish:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
    case RequiredStrategy::WXYZWing:
    case RequiredStrategy::FinnedSwordfishJellyfish:
    case RequiredStrategy::ALSXZ:
    case RequiredStrategy::UniqueRectangleExtended:
    case RequiredStrategy::HiddenUniqueRectangle:
    case RequiredStrategy::BUGType2:
    case RequiredStrategy::BUGType3:
    case RequiredStrategy::BUGType4:
    case RequiredStrategy::BorescoperQiuDeadlyPattern:
    case RequiredStrategy::UniqueLoop:
    case RequiredStrategy::AvoidableRectangle:
    case RequiredStrategy::BivalueOddagon:
    case RequiredStrategy::Medusa3D:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::ALSXYWing:
    case RequiredStrategy::ALSChain:
    case RequiredStrategy::SueDeCoq:
    case RequiredStrategy::DeathBlossom:
    case RequiredStrategy::FrankenFish:
    case RequiredStrategy::MutantFish:
    case RequiredStrategy::KrakenFish:
    case RequiredStrategy::AlignedPairExclusion:
    case RequiredStrategy::AlignedTripleExclusion:
    case RequiredStrategy::ALSAIC:
    case RequiredStrategy::MSLS:
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
    case RequiredStrategy::Squirmbag:
    case RequiredStrategy::Backtracking:
        return true;
    default:
        return false;
    }
}

inline bool required_strategy_math_supported(RequiredStrategy strategy, int box_rows, int box_cols) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    if (n < 4 || n > 64) {
        return strategy == RequiredStrategy::None;
    }
    switch (strategy) {
    case RequiredStrategy::None:
    case RequiredStrategy::NakedSingle:
    case RequiredStrategy::HiddenSingle:
    case RequiredStrategy::NakedPair:
    case RequiredStrategy::HiddenPair:
    case RequiredStrategy::NakedTriple:
    case RequiredStrategy::HiddenTriple:
    case RequiredStrategy::NakedQuad:
    case RequiredStrategy::HiddenQuad:
    case RequiredStrategy::XWing:
    case RequiredStrategy::YWing:
    case RequiredStrategy::Skyscraper:
    case RequiredStrategy::TwoStringKite:
    case RequiredStrategy::RemotePairs:
    case RequiredStrategy::Swordfish:
    case RequiredStrategy::SimpleColoring:
    case RequiredStrategy::XYZWing:
    case RequiredStrategy::WWing:
    case RequiredStrategy::Jellyfish:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
    case RequiredStrategy::WXYZWing:
    case RequiredStrategy::ALSXZ:
    case RequiredStrategy::BUGType2:
    case RequiredStrategy::BUGType3:
    case RequiredStrategy::BUGType4:
    case RequiredStrategy::BivalueOddagon:
    case RequiredStrategy::Medusa3D:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::ALSXYWing:
    case RequiredStrategy::ALSChain:
    case RequiredStrategy::KrakenFish:
    case RequiredStrategy::MSLS:
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
    case RequiredStrategy::AlignedPairExclusion:
    case RequiredStrategy::AlignedTripleExclusion:
    case RequiredStrategy::ALSAIC:
    case RequiredStrategy::Squirmbag:
    case RequiredStrategy::Backtracking:
        return true;
    case RequiredStrategy::PointingPairs:
    case RequiredStrategy::BoxLineReduction:
    case RequiredStrategy::EmptyRectangle:
    case RequiredStrategy::FinnedXWingSashimi:
    case RequiredStrategy::FinnedSwordfishJellyfish:
    case RequiredStrategy::BUGPlusOne:
    case RequiredStrategy::UniqueRectangle:
    case RequiredStrategy::UniqueRectangleExtended:
    case RequiredStrategy::HiddenUniqueRectangle:
    case RequiredStrategy::BorescoperQiuDeadlyPattern:
    case RequiredStrategy::UniqueLoop:
    case RequiredStrategy::AvoidableRectangle:
    case RequiredStrategy::SueDeCoq:
    case RequiredStrategy::DeathBlossom:
    case RequiredStrategy::FrankenFish:
    case RequiredStrategy::MutantFish:
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
    case RequiredStrategy::SKLoop:
        return box_rows > 1 && box_cols > 1;
    default:
        return false;
    }
}

inline bool required_strategy_selectable_for_geometry(RequiredStrategy strategy, int box_rows, int box_cols) {
    return required_strategy_runtime_ready(strategy) && required_strategy_math_supported(strategy, box_rows, box_cols);
}

inline bool difficulty_level_runtime_ready(int level) {
    const int lvl = std::clamp(level, 1, 9);
    return lvl <= 8 || lvl == 9;
}

inline bool difficulty_level_selectable_for_geometry(int level, int box_rows, int box_cols) {
    const int n = std::max(1, box_rows) * std::max(1, box_cols);
    if (n < 4 || n > 64) {

        return false;
    }
    return difficulty_level_runtime_ready(level);
}

int strategy_adjusted_level(int level, RequiredStrategy strategy) {
    const int clamped = std::clamp(level, 1, 9);
    switch (strategy) {
    case RequiredStrategy::NakedSingle: return std::min(clamped, 2);
    case RequiredStrategy::HiddenSingle: return std::clamp(clamped, 2, 4);
    case RequiredStrategy::PointingPairs:
    case RequiredStrategy::BoxLineReduction:
        return std::max(clamped, 2);
    case RequiredStrategy::NakedPair:
    case RequiredStrategy::HiddenPair:
    case RequiredStrategy::NakedTriple:
    case RequiredStrategy::HiddenTriple:
        return std::max(clamped, 3);
    case RequiredStrategy::NakedQuad:
    case RequiredStrategy::HiddenQuad:
    case RequiredStrategy::XWing:
    case RequiredStrategy::YWing:
    case RequiredStrategy::Skyscraper:
    case RequiredStrategy::TwoStringKite:
    case RequiredStrategy::EmptyRectangle:
    case RequiredStrategy::RemotePairs:
        return std::max(clamped, 4);
    case RequiredStrategy::Swordfish:
    case RequiredStrategy::FinnedXWingSashimi:
    case RequiredStrategy::SimpleColoring:
    case RequiredStrategy::BUGPlusOne:
    case RequiredStrategy::UniqueRectangle:
    case RequiredStrategy::XYZWing:
    case RequiredStrategy::WWing:
        return std::max(clamped, 5);
    case RequiredStrategy::Jellyfish:
    case RequiredStrategy::XChain:
    case RequiredStrategy::XYChain:
    case RequiredStrategy::WXYZWing:
    case RequiredStrategy::FinnedSwordfishJellyfish:
    case RequiredStrategy::ALSXZ:
    case RequiredStrategy::UniqueRectangleExtended:
    case RequiredStrategy::HiddenUniqueRectangle:
    case RequiredStrategy::BUGType2:
    case RequiredStrategy::BUGType3:
    case RequiredStrategy::BUGType4:
    case RequiredStrategy::BorescoperQiuDeadlyPattern:
    case RequiredStrategy::UniqueLoop:
    case RequiredStrategy::AvoidableRectangle:
    case RequiredStrategy::BivalueOddagon:
        return std::max(clamped, 6);
    case RequiredStrategy::Medusa3D:
    case RequiredStrategy::AIC:
    case RequiredStrategy::GroupedAIC:
    case RequiredStrategy::GroupedXCycle:
    case RequiredStrategy::ContinuousNiceLoop:
    case RequiredStrategy::ALSXYWing:
    case RequiredStrategy::ALSChain:
    case RequiredStrategy::SueDeCoq:
    case RequiredStrategy::DeathBlossom:
    case RequiredStrategy::FrankenFish:
    case RequiredStrategy::MutantFish:
    case RequiredStrategy::KrakenFish:
    case RequiredStrategy::AlignedPairExclusion:
    case RequiredStrategy::AlignedTripleExclusion:
    case RequiredStrategy::ALSAIC:
    case RequiredStrategy::Squirmbag:
        return std::max(clamped, 7);
    case RequiredStrategy::MSLS:
    case RequiredStrategy::Exocet:
    case RequiredStrategy::SeniorExocet:
    case RequiredStrategy::SKLoop:
    case RequiredStrategy::PatternOverlayMethod:
    case RequiredStrategy::ForcingChains:
    case RequiredStrategy::DynamicForcingChains:
        return std::max(clamped, 8);
    case RequiredStrategy::Backtracking: return 9;
    case RequiredStrategy::None:
    default: return clamped;
    }
}

ClueRange clue_range_for_size_level(int n, int level) {
    const int lvl = std::clamp(level, 1, 9);
    if (n <= 0) return {};
    if (n == 6) {
        static constexpr int min_t[9] = {14, 10, 10, 8, 8, 7, 7, 7, 6};
        // Poziom 9: max_clues ma byc takie samo jak dla poziomu 1.
        static constexpr int max_t[9] = {18, 14, 14, 10, 10, 9, 9, 9, 18};
        return {min_t[lvl - 1], max_t[lvl - 1]};
    }
    if (n == 9) {
        static constexpr int min_t[9] = {36, 30, 30, 25, 25, 22, 22, 22, 17};
        static constexpr int max_t[9] = {45, 35, 35, 29, 29, 25, 25, 25, 45};
        return {min_t[lvl - 1], max_t[lvl - 1]};
    }
    if (n == 16) {
        static constexpr int min_t[9] = {135, 110, 110, 90, 90, 75, 75, 75, 64};
        static constexpr int max_t[9] = {160, 134, 134, 109, 109, 89, 89, 89, 160};
        return {min_t[lvl - 1], max_t[lvl - 1]};
    }

    static constexpr double min_ratio[9] = {0.44, 0.38, 0.35, 0.31, 0.28, 0.24, 0.22, 0.20, 0.16};
    static constexpr double max_ratio[9] = {0.62, 0.56, 0.52, 0.47, 0.43, 0.39, 0.36, 0.33, 0.62};
    const int nn = n * n;
    int min_c = static_cast<int>(std::floor(static_cast<double>(nn) * min_ratio[lvl - 1]));
    int max_c = static_cast<int>(std::ceil(static_cast<double>(nn) * max_ratio[lvl - 1]));
    const int hard_floor = std::min(nn, n);
    min_c = std::clamp(min_c, hard_floor, nn);
    max_c = std::clamp(max_c, min_c, nn);
    return {min_c, max_c};
}

ClueRange resolve_auto_clue_range(int box_rows, int box_cols, int level, RequiredStrategy strategy) {
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    const int n = safe_box_rows * safe_box_cols;
    const int nn = n * n;
    const int adjusted_level = strategy_adjusted_level(level, strategy);
    ClueRange out = clue_range_for_size_level(n, adjusted_level);
    const double aspect = static_cast<double>(std::max(safe_box_rows, safe_box_cols)) / static_cast<double>(std::min(safe_box_rows, safe_box_cols));
    const double clues_scale = std::clamp(1.0 + 0.05 * (aspect - 1.0), 1.0, 1.30);
    out.min_clues = std::clamp(static_cast<int>(std::llround(static_cast<double>(out.min_clues) * clues_scale)), 0, nn);
    out.max_clues = std::clamp(static_cast<int>(std::llround(static_cast<double>(out.max_clues) * clues_scale)), out.min_clues, nn);
    return out;
}

inline double suggest_time_budget_base_s(int n) {
    if (n <= 6) return 0.5;
    if (n == 9) return 2.0;
    if (n == 12) return 5.0;
    if (n == 16) return 10.0;
    if (n == 20) return 30.0;
    if (n == 25) return 60.0;
    if (n >= 30) return 120.0;
    return static_cast<double>(n * n) / 4.0;
}

double suggest_time_budget_s(int box_rows, int box_cols, int level) {
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    const int n = safe_box_rows * safe_box_cols;
    const int lvl = std::clamp(level, 1, 9);
    const double level_scale = 1.0 + 0.08 * static_cast<double>(lvl - 1);
    const double asymmetry_scale = std::clamp(1.0 + 0.30 * (asymmetry_ratio_for_geometry(safe_box_rows, safe_box_cols) - 1.0), 1.0, 3.0);
    double high_level_scale = 1.0;
    if (lvl >= 8) high_level_scale = 1.80;
    else if (lvl == 7) high_level_scale = 1.40;
    else if (lvl == 6) high_level_scale = 1.20;

    double large_grid_scale = 1.0;
    if (n >= 36) large_grid_scale = (lvl >= 8) ? 4.00 : 2.50;
    else if (n >= 30) large_grid_scale = (lvl >= 8) ? 2.60 : 1.90;
    else if (n >= 25) large_grid_scale = 1.35;
    else if (n >= 20) large_grid_scale = 1.15;

    const double suggested = suggest_time_budget_base_s(n) * level_scale * asymmetry_scale * high_level_scale * large_grid_scale;
    return std::clamp(suggested, 0.05, 14400.0);
}

inline int suggest_attempt_time_budget_seconds(int box_rows, int box_cols, int level) {
    const double suggested = suggest_time_budget_s(box_rows, box_cols, level);
    const double rounded = std::ceil(std::max(1.0, suggested));
    return static_cast<int>(std::clamp(rounded, 1.0, 86400.0));
}

inline int suggest_reseed_interval_s(int box_rows, int box_cols, int level) {
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    const int n = safe_box_rows * safe_box_cols;
    const int lvl = std::clamp(level, 1, 9);

    int reseed_s = 0;
    if (n >= 36) reseed_s = (lvl >= 8) ? 20 : 12;
    else if (n >= 30) reseed_s = (lvl >= 8) ? 14 : 10;
    else if (n >= 25) reseed_s = 8;
    else if (n >= 16) reseed_s = 5;
    else if (n >= 12) reseed_s = 3;

    const double asymmetry = asymmetry_ratio_for_geometry(safe_box_rows, safe_box_cols);
    if (reseed_s > 0 && asymmetry >= 2.5) {
        reseed_s += 2;
    }
    return reseed_s;
}

inline uint64_t suggest_attempt_node_budget(int box_rows, int box_cols, int level) {
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    const int n = safe_box_rows * safe_box_cols;
    const int nn = n * n;
    const int lvl = std::clamp(level, 1, 9);
    const double asymmetry = asymmetry_ratio_for_geometry(safe_box_rows, safe_box_cols);

    const double base_nodes = std::clamp(static_cast<double>(nn) * 4000.0, 200000.0, 25000000.0);
    const double level_scale = 1.0 + 0.22 * static_cast<double>(lvl - 1);
    const double asymmetry_scale = std::clamp(1.0 + 0.25 * (asymmetry - 1.0), 1.0, 3.0);

    double large_grid_scale = 1.0;
    if (n >= 36) large_grid_scale = (lvl >= 8) ? 4.00 : 2.50;
    else if (n >= 30) large_grid_scale = (lvl >= 8) ? 2.70 : 1.90;
    else if (n >= 25) large_grid_scale = 1.35;

    double suggested = base_nodes * level_scale * asymmetry_scale * large_grid_scale;
    if (n >= 36 && lvl >= 8) suggested = std::max(suggested, 100000000.0);
    else if (n >= 36) suggested = std::max(suggested, 45000000.0);
    else if (n >= 30) suggested = std::max(suggested, 25000000.0);
    else if (n >= 25) suggested = std::max(suggested, 12000000.0);

    suggested = std::clamp(suggested, 200000.0, 500000000.0);
    return static_cast<uint64_t>(std::llround(suggested));
}

inline GenerationProfile resolve_generation_profile(
    int box_rows,
    int box_cols,
    int level,
    RequiredStrategy strategy,
    const GenerateRunConfig* cfg_override) {
    GenerationProfile profile{};
    const int safe_box_rows = std::max(1, box_rows);
    const int safe_box_cols = std::max(1, box_cols);
    const int n = safe_box_rows * safe_box_cols;
    profile.is_symmetric = geometria::is_symmetric_geometry(safe_box_rows, safe_box_cols);
    profile.asymmetry_ratio = asymmetry_ratio_for_geometry(safe_box_rows, safe_box_cols);
    profile.clue_range = resolve_auto_clue_range(safe_box_rows, safe_box_cols, level, strategy);
    profile.suggested_budget_s = suggest_time_budget_s(safe_box_rows, safe_box_cols, level);

    const std::string policy = normalize_profile_mode_policy(cfg_override != nullptr ? cfg_override->profile_mode_policy : "adaptive");
    const int full_for_n_ge = std::max(4, cfg_override != nullptr ? cfg_override->full_for_n_ge : 25);

    if (policy == "full") {
        profile.mode = GenerationMode::Full;
        profile.reason = "policy=full";
    } else {
        if (n <= 12) { profile.mode = GenerationMode::Full; profile.reason = "adaptive:n<=12"; }
        else if (n < full_for_n_ge) { profile.mode = GenerationMode::Lite; profile.reason = "adaptive:n<full_for_n_ge"; }
        else { profile.mode = GenerationMode::Full; profile.reason = "adaptive:n>=full_for_n_ge"; }
    }
    if (strategy == RequiredStrategy::Backtracking && n <= 20) {
        profile.mode = GenerationMode::Full;
        profile.reason = "required_strategy=Backtracking";
    }
    return profile;
}

struct ParseArgsResult {
    GenerateRunConfig cfg;
    std::set<std::string> arg_used;
    bool benchmark_mode = false;
    bool list_geometries = false;
    bool validate_geometry = false;
    bool validate_geometry_catalog = false;
    bool run_geometry_gate = false;
    bool run_quality_benchmark = false;
    bool run_pre_difficulty_gate = false;
    bool run_asym_pair_benchmark = false;
    bool run_vip_benchmark = false;
    bool run_vip_gate = false;
    bool explain_profile = false;
    std::string geometry_gate_report = "plikiTMP/porownania/geometry_gate_report.txt";
    std::string quality_benchmark_report = "plikiTMP/porownania/quality_benchmark_pre_diff.txt";
    std::string pre_difficulty_gate_report = "plikiTMP/porownania/pre_difficulty_gate.txt";
    std::string asym_pair_benchmark_report = "plikiTMP/porownania/asym_pair_benchmark.txt";
    std::string vip_benchmark_report = "plikiTMP/porownania/vip_benchmark.txt";
    std::string vip_gate_report = "plikiTMP/porownania/vip_gate.txt";
    int quality_benchmark_max_cases = 0;
};

ParseArgsResult parse_args(int argc, char** argv) {
    GenerateRunConfig cfg;
    bool min_clues_set = false;
    bool max_clues_set = false;
    ParseArgsResult res;
    
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        res.arg_used.insert(arg);
        auto read_value = [&](auto& out) {
            if (i + 1 < argc) {
                std::istringstream iss(argv[++i]);
                iss >> out;
            }
        };
        if (arg == "--target" || arg == "--target_puzzles") read_value(cfg.target_puzzles);
        else if (arg == "--box-rows" || arg == "--box_rows") read_value(cfg.box_rows);
        else if (arg == "--box-cols" || arg == "--box_cols") read_value(cfg.box_cols);
        else if (arg == "--threads") read_value(cfg.threads);
        else if (arg == "--seed") read_value(cfg.seed);
        else if (arg == "--reseed-interval-s" || arg == "--reseed_interval_s") read_value(cfg.reseed_interval_s);
        else if (arg == "--force-new-seed-per-attempt" || arg == "--force_new_seed_per_attempt") cfg.force_new_seed_per_attempt = true;
        else if (arg == "--no-force-new-seed-per-attempt" || arg == "--no_force_new_seed_per_attempt") cfg.force_new_seed_per_attempt = false;
        else if (arg == "--pattern-forcing" || arg == "--pattern_forcing") cfg.pattern_forcing_enabled = true;
        else if (arg == "--no-pattern-forcing" || arg == "--no_pattern_forcing") cfg.pattern_forcing_enabled = false;
        else if (arg == "--pattern-forcing-tries" || arg == "--pattern_forcing_tries") read_value(cfg.pattern_forcing_tries);
        else if (arg == "--pattern-anchor-count" || arg == "--pattern_anchor_count") read_value(cfg.pattern_forcing_anchor_count);
        else if (arg == "--pattern-lock-anchors" || arg == "--pattern_lock_anchors") cfg.pattern_forcing_lock_anchors = true;
        else if (arg == "--no-pattern-lock-anchors" || arg == "--no_pattern_lock_anchors") cfg.pattern_forcing_lock_anchors = false;
        else if (arg == "--mcts-digger" || arg == "--mcts_digger") cfg.mcts_digger_enabled = true;
        else if (arg == "--no-mcts-digger" || arg == "--no_mcts_digger") cfg.mcts_digger_enabled = false;
        else if ((arg == "--mcts-profile" || arg == "--mcts_profile") && i + 1 < argc) cfg.mcts_tuning_profile = normalize_mcts_tuning_profile(argv[++i]);
        else if (arg == "--mcts-p7" || arg == "--mctsp7") { cfg.mcts_tuning_profile = "p7"; cfg.mcts_digger_enabled = true; }
        else if (arg == "--mcts-p8" || arg == "--mctsp8") { cfg.mcts_tuning_profile = "p8"; cfg.mcts_digger_enabled = true; }
        else if (arg == "--mcts-iterations" || arg == "--mcts_iterations") read_value(cfg.mcts_digger_iterations);
        else if (arg == "--mcts-ucb-c" || arg == "--mcts_ucb_c") read_value(cfg.mcts_ucb_c);
        else if (arg == "--mcts-fail-cap" || arg == "--mcts_fail_cap") read_value(cfg.mcts_fail_cap);
        else if (arg == "--mcts-basic-level" || arg == "--mcts_basic_level") read_value(cfg.mcts_basic_logic_level);
        else if (arg == "--attempt-time-budget-s" || arg == "--attempt_time_budget_s") read_value(cfg.attempt_time_budget_s);
        else if (arg == "--attempt-node-budget" || arg == "--attempt_node_budget_s") read_value(cfg.attempt_node_budget);
        else if (arg == "--quality-contract-off") cfg.enable_quality_contract = false;
        else if (arg == "--quality-contract-on") cfg.enable_quality_contract = true;
        else if (arg == "--replay-validate-off") cfg.enable_replay_validation = false;
        else if (arg == "--replay-validate-on") cfg.enable_replay_validation = true;
        else if (arg == "--distribution-filter-off") cfg.enable_distribution_filter = false;
        else if (arg == "--distribution-filter-on") cfg.enable_distribution_filter = true;
        else if (arg == "--uniqueness-confirm-budget-s" || arg == "--uniqueness_confirm_budget_s") read_value(cfg.uniqueness_confirm_budget_s);
        else if (arg == "--uniqueness-confirm-budget-nodes" || arg == "--uniqueness_confirm_budget_nodes") read_value(cfg.uniqueness_confirm_budget_nodes);
        else if ((arg == "--profile-mode-policy" || arg == "--profile_mode_policy") && i + 1 < argc) cfg.profile_mode_policy = normalize_profile_mode_policy(argv[++i]);
        else if (arg == "--full-for-n-ge" || arg == "--full_for_n_ge") read_value(cfg.full_for_n_ge);
        else if ((arg == "--cpu-backend" || arg == "--cpu_backend") && i + 1 < argc) cfg.cpu_backend_policy = normalize_cpu_backend_policy(argv[++i]);
        else if (arg == "--cpu-dispatch-report" || arg == "--cpu_dispatch_report") cfg.cpu_dispatch_report = true;
        else if ((arg == "--asym-heuristics" || arg == "--asym_heuristics") && i + 1 < argc) cfg.asym_heuristics_mode = normalize_asym_heuristics_mode(argv[++i]);
        else if (arg == "--adaptive-budget" || arg == "--adaptive_budget") cfg.adaptive_budget = true;
        else if (arg == "--adaptive-budget-off" || arg == "--adaptive_budget_off") cfg.adaptive_budget = false;
        else if (arg == "--vip-mode" || arg == "--vip_mode") cfg.vip_mode = true;
        else if (arg == "--vip-contract-strict" || arg == "--vip_contract_strict") cfg.vip_contract_strict = true;
        else if ((arg == "--difficulty-engine" || arg == "--difficulty_engine") && i + 1 < argc) cfg.difficulty_engine = normalize_difficulty_engine(argv[++i]);
        else if ((arg == "--vip-score-profile" || arg == "--vip_score_profile") && i + 1 < argc) cfg.vip_score_profile = normalize_vip_score_profile(argv[++i]);
        else if ((arg == "--vip-trace-level" || arg == "--vip_trace_level") && i + 1 < argc) cfg.vip_trace_level = normalize_vip_trace_level(argv[++i]);
        else if ((arg == "--vip-min-grade-by-geometry" || arg == "--vip_min_grade_by_geometry") && i + 1 < argc) cfg.vip_min_grade_by_geometry_path = argv[++i];
        else if ((arg == "--vip-grade-target" || arg == "--vip_grade_target") && i + 1 < argc) cfg.vip_grade_target = normalize_vip_grade_target(argv[++i]);
        else if ((arg == "--difficulty-trace-out" || arg == "--difficulty_trace_out") && i + 1 < argc) cfg.difficulty_trace_out = argv[++i];
        else if ((arg == "--vip-signature-out" || arg == "--vip_signature_out") && i + 1 < argc) cfg.vip_signature_out = argv[++i];
        else if (arg == "--perf-ab-suite" || arg == "--perf_ab_suite") cfg.perf_ab_suite = true;
        else if ((arg == "--perf-report-out" || arg == "--perf_report_out") && i + 1 < argc) cfg.perf_report_out = argv[++i];
        else if ((arg == "--perf-csv-out" || arg == "--perf_csv_out") && i + 1 < argc) cfg.perf_csv_out = argv[++i];
        else if ((arg == "--perf-baseline-csv" || arg == "--perf_baseline_csv") && i + 1 < argc) cfg.perf_baseline_csv = argv[++i];
        else if ((arg == "--stage-start" || arg == "--stage_start") && i + 1 < argc) { cfg.stage_start = true; cfg.stage_name = argv[++i]; }
        else if ((arg == "--stage-end" || arg == "--stage_end") && i + 1 < argc) { cfg.stage_end = true; cfg.stage_name = argv[++i]; }
        else if ((arg == "--stage-report-out" || arg == "--stage_report_out") && i + 1 < argc) cfg.stage_report_out = argv[++i];
        else if (arg == "--min-clues" || arg == "--min_clues") { read_value(cfg.min_clues); min_clues_set = cfg.min_clues > 0; }
        else if (arg == "--max-clues" || arg == "--max_clues") { read_value(cfg.max_clues); max_clues_set = cfg.max_clues > 0; }
        else if (arg == "--difficulty") read_value(cfg.difficulty_level_required);
        else if ((arg == "--required-strategy" || arg == "--required_strategy") && i + 1 < argc) cfg.required_strategy = parse_required_strategy(argv[++i]);
        else if (arg == "--no-unique") cfg.require_unique = false;
        else if (arg == "--no-strict-logical") cfg.strict_logical = false;
        else if (arg == "--symmetry-center") cfg.symmetry_center = true;
        else if ((arg == "--output-folder" || arg == "--output_folder") && i + 1 < argc) cfg.output_folder = argv[++i];
        else if ((arg == "--output-file" || arg == "--output_file") && i + 1 < argc) cfg.output_file = argv[++i];
        else if (arg == "--test-mode") { cfg.output_folder = "plikiTMP/testy"; cfg.output_file = "test_" + now_local_compact_string() + ".txt"; }
        else if (arg == "--max-attempts" || arg == "--max_attempts") read_value(cfg.max_attempts);
        else if (arg == "--max-total-time-s" || arg == "--max_total_time_s") read_value(cfg.max_total_time_s);
        else if (arg == "--no-pause") cfg.pause_on_exit_windows = false;
        else if (arg == "--single-file-only") cfg.write_individual_files = false;
        else if (arg == "--benchmark-40s") { cfg.benchmark_profiles_40s = true; cfg.benchmark_seconds_per_profile = 40; res.arg_used.insert("--benchmark-mode"); }
        else if (arg == "--benchmark-seconds") { read_value(cfg.benchmark_seconds_per_profile); res.arg_used.insert("--benchmark-mode"); }
        else if (arg == "--benchmark-output" && i + 1 < argc) { cfg.benchmark_output_file = argv[++i]; res.arg_used.insert("--benchmark-mode"); }
        else if (arg == "--quality-gate-25s") { cfg.benchmark_profiles_40s = false; cfg.benchmark_seconds_per_profile = 25; cfg.benchmark_output_file = "plikiTMP/porownania/quality_gate_25s.txt"; res.arg_used.insert("--benchmark-mode"); }
        else if (arg == "--list-geometries") res.list_geometries = true;
        else if (arg == "--validate-geometry") res.validate_geometry = true;
        else if (arg == "--validate-geometry-catalog") res.validate_geometry_catalog = true;
        else if (arg == "--run-geometry-gate") res.run_geometry_gate = true;
        else if (arg == "--run-quality-benchmark") res.run_quality_benchmark = true;
        else if (arg == "--run-pre-difficulty-gate") res.run_pre_difficulty_gate = true;
        else if (arg == "--run-asym-pair-benchmark") res.run_asym_pair_benchmark = true;
        else if (arg == "--run-vip-benchmark") res.run_vip_benchmark = true;
        else if (arg == "--run-vip-gate") res.run_vip_gate = true;
        else if (arg == "--explain-profile") res.explain_profile = true;
        else if ((arg == "--geometry-gate-report" || arg == "--geometry_gate_report") && i + 1 < argc) res.geometry_gate_report = argv[++i];
        else if ((arg == "--quality-benchmark-report" || arg == "--quality_benchmark_report") && i + 1 < argc) res.quality_benchmark_report = argv[++i];
        else if ((arg == "--pre-difficulty-gate-report" || arg == "--pre_difficulty_gate_report") && i + 1 < argc) res.pre_difficulty_gate_report = argv[++i];
        else if ((arg == "--asym-pair-benchmark-report" || arg == "--asym_pair_benchmark_report") && i + 1 < argc) res.asym_pair_benchmark_report = argv[++i];
        else if ((arg == "--vip-benchmark-report" || arg == "--vip_benchmark_report") && i + 1 < argc) res.vip_benchmark_report = argv[++i];
        else if ((arg == "--vip-gate-report" || arg == "--vip_gate_report") && i + 1 < argc) res.vip_gate_report = argv[++i];
        else if (arg == "--quality-benchmark-max-cases" || arg == "--quality_benchmark_max_cases") read_value(res.quality_benchmark_max_cases);
        else if (arg == "--run-regression-tests") {
            std::cout << "Running regression tests...\n";
            sudoku_testy::run_all_regression_tests("plikiTMP/testy/regression_report.txt");
            std::exit(0);
        }
    }
    
    cfg.box_rows = std::max(1, cfg.box_rows);
    cfg.box_cols = std::max(1, cfg.box_cols);
    cfg.difficulty_level_required = std::clamp(cfg.difficulty_level_required, 1, 9);
    cfg.full_for_n_ge = std::clamp(cfg.full_for_n_ge, 4, 64);
    cfg.profile_mode_policy = normalize_profile_mode_policy(cfg.profile_mode_policy);
    cfg.cpu_backend_policy = normalize_cpu_backend_policy(cfg.cpu_backend_policy);
    cfg.asym_heuristics_mode = normalize_asym_heuristics_mode(cfg.asym_heuristics_mode);
    cfg.difficulty_engine = normalize_difficulty_engine(cfg.difficulty_engine);
    cfg.vip_score_profile = normalize_vip_score_profile(cfg.vip_score_profile);
    cfg.vip_trace_level = normalize_vip_trace_level(cfg.vip_trace_level);
    cfg.vip_grade_target = normalize_vip_grade_target(cfg.vip_grade_target);
    cfg.mcts_tuning_profile = normalize_mcts_tuning_profile(cfg.mcts_tuning_profile);
    cfg.pattern_forcing_tries = std::clamp(cfg.pattern_forcing_tries, 1, 64);
    cfg.pattern_forcing_anchor_count = std::clamp(cfg.pattern_forcing_anchor_count, 0, 32);
    cfg.mcts_digger_iterations = std::clamp(cfg.mcts_digger_iterations, 0, 1000000);
    cfg.mcts_ucb_c = std::clamp(cfg.mcts_ucb_c, 0.1, 4.0);
    cfg.mcts_fail_cap = std::clamp(cfg.mcts_fail_cap, 16, 1000000);
    cfg.mcts_basic_logic_level = std::clamp(cfg.mcts_basic_logic_level, 1, 5);
    if ((cfg.mcts_tuning_profile == "p7" || cfg.mcts_tuning_profile == "p8") && !cfg.mcts_digger_enabled) {
        cfg.mcts_digger_enabled = true;
    }
    
    if (cfg.difficulty_level_required <= 1 && cfg.required_strategy == RequiredStrategy::None) {
        cfg.required_strategy = RequiredStrategy::NakedSingle;
    }
    
    const ClueRange auto_clues = resolve_auto_clue_range(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy);
    if (!min_clues_set) cfg.min_clues = auto_clues.min_clues;
    if (!max_clues_set) cfg.max_clues = auto_clues.max_clues;
    
    const int n = cfg.box_rows * cfg.box_cols;
    const int nn = n * n;
    cfg.min_clues = std::clamp(cfg.min_clues, 0, nn);
    cfg.max_clues = std::clamp(cfg.max_clues, cfg.min_clues, nn);
    
    res.benchmark_mode = (cfg.benchmark_profiles_40s || res.arg_used.count("--benchmark-mode") > 0);
    res.cfg = cfg;
    return res;
}

inline std::string supported_geometries_text() {
    std::ostringstream out;
    out << "Supported geometries (" << geometria::all_geometries().size() << "):\n";
    for (const auto& g : geometria::all_geometries()) {
        out << "  - " << g.n << "x" << g.n << " (" << g.box_rows << "x" << g.box_cols << ") [" << (g.is_symmetric ? "sym" : "asym") << "]\n";
    }
    return out.str();
}

inline bool print_geometry_validation(int box_rows, int box_cols, std::ostream& out) {
    const int n = box_rows * box_cols;
    const bool ok = geometria::is_supported_geometry(box_rows, box_cols);
    if (ok) {
        out << "Geometry OK: " << n << "x" << n << " (" << box_rows << "x" << box_cols << ") [" << geometria::geometry_class_name(geometria::classify_geometry(box_rows, box_cols)) << "]\n";
        return true;
    }
    out << "Geometry NOT supported: " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")\n";
    const auto variants = geometria::geometries_for_n(n);
    if (!variants.empty()) {
        out << "Supported variants for N=" << n << ":\n";
        for (const auto& g : variants) out << "  - (" << g.box_rows << "x" << g.box_cols << ")\n";
    } else {
        out << "No supported variants for N=" << n << ".\n";
    }
    return false;
}

inline bool print_geometry_catalog_validation(std::ostream& out) {
    std::string details;
    const bool ok = geometria::validate_geometry_catalog(&details);
    if (ok) {
        out << "Geometry catalog OK: " << geometria::all_geometries().size() << " entries\n";
        return true;
    }
    out << "Geometry catalog INVALID\n" << details;
    return false;
}

inline std::string explain_generation_profile_text(const GenerateRunConfig& cfg) {
    const GenerationProfile profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
    const RuntimeCpuContext cpu_ctx = resolve_runtime_cpu_context(cfg);
    const int n = std::max(1, cfg.box_rows) * std::max(1, cfg.box_cols);
    std::ostringstream out;
    out << "Generation profile for " << n << "x" << n << " (" << cfg.box_rows << "x" << cfg.box_cols << ")\n"
        << "  mode: " << generation_mode_name(profile.mode) << "\n"
        << "  class: " << (profile.is_symmetric ? "symmetric" : "asymmetric") << " (ratio=" << format_fixed(profile.asymmetry_ratio, 3) << ")\n"
        << "  suggested_clues: " << profile.clue_range.min_clues << "-" << profile.clue_range.max_clues << "\n"
        << "  suggested_attempt_budget_s: " << format_fixed(profile.suggested_budget_s, 2) << "\n"
        << "  profile_mode_policy: " << normalize_profile_mode_policy(cfg.profile_mode_policy) << "\n"
        << "  full_for_n_ge: " << cfg.full_for_n_ge << "\n"
        << "  cpu_backend_requested: " << normalize_cpu_backend_policy(cfg.cpu_backend_policy) << "\n"
        << "  cpu_backend_selected: " << cpu_ctx.selected_backend << " (avx2=" << (cpu_ctx.avx2_supported ? "1" : "0") << ", avx512=" << (cpu_ctx.avx512_supported ? "1" : "0") << ", reason=" << cpu_ctx.reason << ")\n"
        << "  difficulty_engine: " << normalize_difficulty_engine(cfg.difficulty_engine) << "\n"
        << "  vip_mode: " << (cfg.vip_mode ? "on" : "off") << "\n"
        << "  vip_score_profile: " << normalize_vip_score_profile(cfg.vip_score_profile) << "\n"
        << "  vip_trace_level: " << normalize_vip_trace_level(cfg.vip_trace_level) << "\n"
        << "  vip_grade_target: " << normalize_vip_grade_target(cfg.vip_grade_target) << "\n"
        << "  vip_grade_target_override_path: " << (cfg.vip_min_grade_by_geometry_path.empty() ? "(none)" : cfg.vip_min_grade_by_geometry_path) << "\n"
        << "  vip_contract_strict: " << (cfg.vip_contract_strict ? "on" : "off") << "\n"
        << "  asym_heuristics_mode: " << normalize_asym_heuristics_mode(cfg.asym_heuristics_mode) << "\n"
        << "  adaptive_budget: " << (cfg.adaptive_budget ? "on" : "off") << "\n"
        << "  perf_baseline_csv: " << (cfg.perf_baseline_csv.empty() ? "(none)" : cfg.perf_baseline_csv) << "\n"
        << "  quality_contract: " << (cfg.enable_quality_contract ? "on" : "off") << "\n"
        << "  replay_validation: " << (cfg.enable_replay_validation ? "on" : "off") << "\n"
        << "  distribution_filter: " << (cfg.enable_distribution_filter ? "on" : "off") << "\n"
        << "  uniqueness_confirm_budget_s: " << format_fixed(cfg.uniqueness_confirm_budget_s, 2) << "\n"
        << "  uniqueness_confirm_budget_nodes: " << cfg.uniqueness_confirm_budget_nodes << "\n"
        << "  pattern_forcing: " << (cfg.pattern_forcing_enabled ? "on" : "off") << "\n"
        << "  pattern_forcing_tries: " << cfg.pattern_forcing_tries << "\n"
        << "  pattern_anchor_count: " << cfg.pattern_forcing_anchor_count << "\n"
        << "  pattern_lock_anchors: " << (cfg.pattern_forcing_lock_anchors ? "on" : "off") << "\n"
        << "  mcts_digger: " << (cfg.mcts_digger_enabled ? "on" : "off") << "\n"
        << "  mcts_profile: " << normalize_mcts_tuning_profile(cfg.mcts_tuning_profile) << "\n"
        << "  mcts_iterations: " << cfg.mcts_digger_iterations << "\n"
        << "  mcts_ucb_c: " << format_fixed(cfg.mcts_ucb_c, 3) << "\n"
        << "  mcts_fail_cap: " << cfg.mcts_fail_cap << "\n"
        << "  mcts_basic_level: " << cfg.mcts_basic_logic_level << "\n"
        << "  reason: " << profile.reason << "\n";
    return out.str();
}

struct GeometryGateCaseRow { int n = 0; int box_rows = 0; int box_cols = 0; bool is_symmetric = false; bool recognized = false; bool topology_ok = false; std::string smoke_mode; std::string profile_reason; bool smoke_ok = false; bool timed_out = false; double elapsed_s = 0.0; std::string message; };
struct GeometryGateSummary { std::vector<GeometryGateCaseRow> rows; int contract_failed = 0; int smoke_failed = 0; int timeout_count = 0; };
inline std::string geometry_gate_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline GeometryGateCaseRow run_geometry_gate_case(const geometria::GeometrySpec& g, const GenerateRunConfig* base_cfg = nullptr) {
    GeometryGateCaseRow row{};
    row.n = g.n; row.box_rows = g.box_rows; row.box_cols = g.box_cols; row.is_symmetric = g.is_symmetric;
    row.recognized = geometria::czy_obslugiwana(g.n, g.box_rows, g.box_cols);
    if (!row.recognized) { row.message = "not_recognized"; return row; }

    const auto topo_opt = GenericTopology::build(g.box_rows, g.box_cols);
    row.topology_ok = topo_opt.has_value();
    if (!row.topology_ok) { row.message = "topology_build_failed"; return row; }
    
    const GenericTopology topo = *topo_opt;
    GenerateRunConfig profile_cfg{};
    profile_cfg.box_rows = g.box_rows; profile_cfg.box_cols = g.box_cols;
    if (base_cfg != nullptr) { profile_cfg.profile_mode_policy = base_cfg->profile_mode_policy; profile_cfg.full_for_n_ge = base_cfg->full_for_n_ge; }
    
    const GenerationProfile profile = resolve_generation_profile(g.box_rows, g.box_cols, 1, RequiredStrategy::NakedSingle, &profile_cfg);
    row.smoke_mode = generation_mode_name(profile.mode);
    row.profile_reason = profile.reason;

    const auto t0 = std::chrono::steady_clock::now();

    if (profile.mode == GenerationMode::Full) {
        GenerateRunConfig cfg{};
        cfg.box_rows = g.box_rows; cfg.box_cols = g.box_cols; cfg.target_puzzles = 1; cfg.threads = 1;
        cfg.seed = static_cast<long long>(g.n * 100000 + g.box_rows * 100 + g.box_cols);
        cfg.required_strategy = RequiredStrategy::None; cfg.difficulty_level_required = 1;
        cfg.pause_on_exit_windows = false; cfg.write_individual_files = false;
        cfg.output_folder = "plikiTMP/testy/geometry_gate"; cfg.output_file = "gate_" + std::to_string(g.n) + "_" + std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ".txt";
        cfg.max_total_time_s = 20; cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;
        cfg.profile_mode_policy = profile_cfg.profile_mode_policy; cfg.full_for_n_ge = profile_cfg.full_for_n_ge;
        GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
        row.elapsed_s = result.elapsed_s;
        row.timed_out = (result.elapsed_s + 0.05 >= 20.0) && result.accepted == 0;
        row.smoke_ok = result.accepted > 0 || result.written > 0;
        row.message = row.smoke_ok ? "ok accepted=" + std::to_string(result.accepted) : (row.timed_out ? "timeout_20s" : "accepted=0 attempts=" + std::to_string(result.attempts));
        return row;
    }

    if (profile.mode == GenerationMode::Lite) {
        GenerateRunConfig cfg{};
        cfg.box_rows = g.box_rows; cfg.box_cols = g.box_cols; cfg.target_puzzles = 1; cfg.threads = 1;
        cfg.seed = static_cast<long long>(g.n * 100000 + g.box_rows * 100 + g.box_cols);
        cfg.required_strategy = RequiredStrategy::None; cfg.difficulty_level_required = 1;
        cfg.require_unique = false; cfg.strict_logical = false; cfg.pause_on_exit_windows = false; cfg.write_individual_files = false;
        cfg.output_folder = "plikiTMP/testy/geometry_gate"; cfg.output_file = "gate_lite_" + std::to_string(g.n) + "_" + std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ".txt";
        cfg.max_total_time_s = 20; cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;
        cfg.profile_mode_policy = profile_cfg.profile_mode_policy; cfg.full_for_n_ge = profile_cfg.full_for_n_ge;
        GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
        row.elapsed_s = result.elapsed_s;
        row.timed_out = (result.elapsed_s + 0.05 >= 20.0) && result.accepted == 0;
        row.smoke_ok = result.accepted > 0 || (result.attempts > 0 && result.rejected > 0);
        row.message = row.smoke_ok ? "ok attempts=" + std::to_string(result.attempts) : (row.timed_out ? "timeout_20s" : "no_activity attempts=" + std::to_string(result.attempts));
        return row;
    }

    GenericSolvedKernel solved;
    std::mt19937_64 rng(static_cast<uint64_t>(g.n * 100000 + g.box_rows * 100 + g.box_cols));
    std::vector<uint16_t> solution;
    SearchAbortControl budget;
    budget.time_enabled = true;
    budget.deadline = std::chrono::steady_clock::now() + std::chrono::duration_cast<std::chrono::steady_clock::duration>(std::chrono::duration<double>(2.0));
    budget.node_enabled = true; budget.node_limit = 500000ULL;
    const bool solved_ok = solved.generate(topo, rng, solution, &budget);
    row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    row.timed_out = budget.aborted_by_time;
    row.smoke_ok = solved_ok || budget.aborted_by_time || budget.aborted_by_nodes;
    row.message = row.smoke_ok ? (solved_ok ? "ok solved_kernel" : "ok budget_guard") : "core_smoke_failed";
    return row;
}

inline GeometryGateSummary run_geometry_gate_20s_suite(const GenerateRunConfig* base_cfg = nullptr) {
    GeometryGateSummary summary{};
    const auto& geometries = geometria::all_geometries();
    summary.rows.reserve(geometries.size());
    for (const auto& g : geometries) {
        GeometryGateCaseRow row = run_geometry_gate_case(g, base_cfg);
        if (!row.recognized || !row.topology_ok) ++summary.contract_failed;
        if (!row.smoke_ok) ++summary.smoke_failed;
        if (row.timed_out) ++summary.timeout_count;
        summary.rows.push_back(std::move(row));
    }
    return summary;
}

inline void write_geometry_gate_reports(const GeometryGateSummary& summary, const std::string& report_txt) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(geometry_gate_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== Geometry Gate (20s per case) ===\ntotal=" << summary.rows.size() << " contract_failed=" << summary.contract_failed << " smoke_failed=" << summary.smoke_failed << " timeout_count=" << summary.timeout_count << "\n\n";
        for (const auto& r : summary.rows) {
            txt << r.n << "x" << r.n << " (" << r.box_rows << "x" << r.box_cols << ") class=" << (r.is_symmetric ? "sym" : "asym") << " recognized=" << (r.recognized ? "1" : "0") << " topology=" << (r.topology_ok ? "1" : "0") << " mode=" << r.smoke_mode << " reason=" << r.profile_reason << " smoke=" << (r.smoke_ok ? "1" : "0") << " timeout=" << (r.timed_out ? "1" : "0") << " elapsed_s=" << format_fixed(r.elapsed_s, 3) << " msg=" << r.message << "\n";
        }
    }

    std::ofstream csv(geometry_gate_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        csv << "n,box_rows,box_cols,is_symmetric,recognized,topology_ok,smoke_mode,profile_reason,smoke_ok,timed_out,elapsed_s,message\n";
        for (const auto& r : summary.rows) {
            std::string msg = r.message; std::string reason = r.profile_reason;
            std::replace(msg.begin(), msg.end(), ',', ';'); std::replace(reason.begin(), reason.end(), ',', ';');
            csv << r.n << "," << r.box_rows << "," << r.box_cols << "," << (r.is_symmetric ? 1 : 0) << "," << (r.recognized ? 1 : 0) << "," << (r.topology_ok ? 1 : 0) << "," << r.smoke_mode << "," << reason << "," << (r.smoke_ok ? 1 : 0) << "," << (r.timed_out ? 1 : 0) << "," << format_fixed(r.elapsed_s, 6) << "," << msg << "\n";
        }
    }
}

inline int run_geometry_gate_cli(const std::string& report_txt, const GenerateRunConfig* base_cfg = nullptr) {
    const GeometryGateSummary summary = run_geometry_gate_20s_suite(base_cfg);
    write_geometry_gate_reports(summary, report_txt);
    std::cout << "Geometry gate: total=" << summary.rows.size() << " contract_failed=" << summary.contract_failed << " smoke_failed=" << summary.smoke_failed << " timeout_count=" << summary.timeout_count << "\nReports: " << report_txt << " | " << geometry_gate_csv_path_for(report_txt) << "\n";
    if (summary.contract_failed > 0) return 1;
    if (summary.timeout_count > 0) return 3;
    if (summary.smoke_failed > 0) return 2;
    return 0;
}

struct QualityBenchmarkCaseRow { int n = 0; int box_rows = 0; int box_cols = 0; bool is_symmetric = false; std::string mode; uint64_t attempts = 0; uint64_t accepted = 0; uint64_t rejected = 0; uint64_t reject_replay = 0; uint64_t reject_distribution_bias = 0; uint64_t reject_uniqueness_budget = 0; double elapsed_s = 0.0; double quality_pass_rate_pct = 0.0; };
struct QualityBenchmarkSummary { std::vector<QualityBenchmarkCaseRow> rows; int pair_checked = 0; int pair_violations = 0; };
inline std::string quality_benchmark_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline QualityBenchmarkSummary run_quality_benchmark_suite_20s(int max_cases = 0, const GenerateRunConfig* base_cfg = nullptr) {
    QualityBenchmarkSummary summary{};
    std::vector<geometria::GeometrySpec> selected;
    std::map<int, std::vector<geometria::GeometrySpec>> by_n;
    for (const auto& g : geometria::all_geometries()) { if (g.n >= 16) by_n[g.n].push_back(g); }
    for (auto& kv : by_n) {
        auto& geos = kv.second;
        auto sym_it = std::find_if(geos.begin(), geos.end(), [](const geometria::GeometrySpec& g) { return g.box_rows == g.box_cols; });
        if (sym_it != geos.end()) selected.push_back(*sym_it);
        for (const auto& g : geos) {
            if (g.box_rows < g.box_cols && geometria::is_supported_geometry(g.box_cols, g.box_rows)) {
                selected.push_back(g); selected.push_back({g.n, g.box_cols, g.box_rows, false, ""}); break;
            }
        }
    }
    std::sort(selected.begin(), selected.end(), [](const auto& a, const auto& b) { if (a.n != b.n) return a.n < b.n; if (a.box_rows != b.box_rows) return a.box_rows < b.box_rows; return a.box_cols < b.box_cols; });
    selected.erase(std::unique(selected.begin(), selected.end(), [](const auto& a, const auto& b) { return a.n == b.n && a.box_rows == b.box_rows && a.box_cols == b.box_cols; }), selected.end());

    int executed = 0;
    for (const auto& g : selected) {
        if (max_cases > 0 && executed >= max_cases) break;
        GenerateRunConfig cfg{};
        cfg.box_rows = g.box_rows; cfg.box_cols = g.box_cols; cfg.target_puzzles = 1; cfg.threads = 1;
        cfg.seed = static_cast<long long>(g.n * 100000 + g.box_rows * 100 + g.box_cols + 77);
        cfg.required_strategy = RequiredStrategy::None; cfg.difficulty_level_required = 1;
        cfg.require_unique = true; cfg.strict_logical = true; cfg.enable_quality_contract = true; cfg.enable_replay_validation = true; cfg.enable_distribution_filter = true;
        cfg.pause_on_exit_windows = false; cfg.write_individual_files = false; cfg.output_folder = "plikiTMP/testy/quality_benchmark"; cfg.output_file = "qb_" + std::to_string(g.n) + "_" + std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ".txt";
        cfg.max_total_time_s = 20;
        if (base_cfg != nullptr) { cfg.profile_mode_policy = base_cfg->profile_mode_policy; cfg.full_for_n_ge = base_cfg->full_for_n_ge; }
        const GenerationProfile profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
        cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;
        const GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);

        QualityBenchmarkCaseRow row{};
        row.n = g.n; row.box_rows = g.box_rows; row.box_cols = g.box_cols; row.is_symmetric = (g.box_rows == g.box_cols);
        row.mode = generation_mode_name(profile.mode); row.attempts = result.attempts; row.accepted = result.accepted; row.rejected = result.rejected;
        row.reject_replay = result.reject_replay; row.reject_distribution_bias = result.reject_distribution_bias; row.reject_uniqueness_budget = result.reject_uniqueness_budget;
        row.elapsed_s = result.elapsed_s; row.quality_pass_rate_pct = row.attempts > 0 ? (100.0 * static_cast<double>(row.accepted) / static_cast<double>(row.attempts)) : 0.0;
        summary.rows.push_back(std::move(row));
        ++executed;
    }

    std::map<std::tuple<int, int, int>, std::array<const QualityBenchmarkCaseRow*, 2>> pairs;
    for (const auto& row : summary.rows) {
        if (row.box_rows == row.box_cols) continue;
        const int a = std::min(row.box_rows, row.box_cols); const int b = std::max(row.box_rows, row.box_cols);
        auto& slot = pairs[std::make_tuple(row.n, a, b)];
        if (row.box_rows <= row.box_cols) slot[0] = &row; else slot[1] = &row;
    }
    for (const auto& kv : pairs) {
        const auto* p0 = kv.second[0]; const auto* p1 = kv.second[1];
        if (p0 == nullptr || p1 == nullptr) continue;
        ++summary.pair_checked;
        if (std::abs(p0->quality_pass_rate_pct - p1->quality_pass_rate_pct) > 35.0) ++summary.pair_violations;
    }
    return summary;
}

inline void write_quality_benchmark_reports(const QualityBenchmarkSummary& summary, const std::string& report_txt) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(quality_benchmark_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== Quality Benchmark (pre-difficulty, 20s/case) ===\nrows=" << summary.rows.size() << " pair_checked=" << summary.pair_checked << " pair_violations=" << summary.pair_violations << "\n\n";
        for (const auto& r : summary.rows) txt << r.n << "x" << r.n << " (" << r.box_rows << "x" << r.box_cols << ") class=" << (r.is_symmetric ? "sym" : "asym") << " mode=" << r.mode << " accepted=" << r.accepted << " attempts=" << r.attempts << " rejected=" << r.rejected << " reject_replay=" << r.reject_replay << " reject_dist=" << r.reject_distribution_bias << " reject_uniq_budget=" << r.reject_uniqueness_budget << " quality_pass_rate=" << format_fixed(r.quality_pass_rate_pct, 2) << "% elapsed_s=" << format_fixed(r.elapsed_s, 3) << "\n";
    }

    std::ofstream csv(quality_benchmark_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        csv << "n,box_rows,box_cols,is_symmetric,mode,attempts,accepted,rejected,reject_replay,reject_distribution_bias,reject_uniqueness_budget,quality_pass_rate_pct,elapsed_s\n";
        for (const auto& r : summary.rows) csv << r.n << "," << r.box_rows << "," << r.box_cols << "," << (r.is_symmetric ? 1 : 0) << "," << r.mode << "," << r.attempts << "," << r.accepted << "," << r.rejected << "," << r.reject_replay << "," << r.reject_distribution_bias << "," << r.reject_uniqueness_budget << "," << format_fixed(r.quality_pass_rate_pct, 6) << "," << format_fixed(r.elapsed_s, 6) << "\n";
    }
}

inline int run_quality_benchmark_cli(const std::string& report_txt, int max_cases = 0, const GenerateRunConfig* base_cfg = nullptr) {
    const QualityBenchmarkSummary summary = run_quality_benchmark_suite_20s(max_cases, base_cfg);
    write_quality_benchmark_reports(summary, report_txt);
    std::cout << "Quality benchmark: rows=" << summary.rows.size() << " pair_checked=" << summary.pair_checked << " pair_violations=" << summary.pair_violations << "\nReports: " << report_txt << " | " << quality_benchmark_csv_path_for(report_txt) << "\n";
    return summary.pair_violations > 0 ? 4 : 0;
}

struct AsymPairBenchmarkRow { int n = 0; int a = 0; int b = 0; uint64_t attempts_ab = 0; uint64_t attempts_ba = 0; uint64_t accepted_ab = 0; uint64_t accepted_ba = 0; double elapsed_ab = 0.0; double elapsed_ba = 0.0; double throughput_ab = 0.0; double throughput_ba = 0.0; double throughput_delta_pct = 0.0; double pass_rate_ab = 0.0; double pass_rate_ba = 0.0; double pass_rate_delta = 0.0; bool violation = false; };
struct AsymPairBenchmarkSummary { std::vector<AsymPairBenchmarkRow> rows; int pairs_checked = 0; int violations = 0; double avg_throughput_delta_pct = 0.0; };
inline std::string asym_pair_benchmark_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline AsymPairBenchmarkSummary run_asym_pair_benchmark_suite(int max_cases = 0, const GenerateRunConfig* base_cfg = nullptr) {
    AsymPairBenchmarkSummary summary{};
    std::set<std::tuple<int, int, int>> pairs;
    for (const auto& g : geometria::all_geometries()) {
        if (g.box_rows == g.box_cols) continue;
        const int a = std::min(g.box_rows, g.box_cols); const int b = std::max(g.box_rows, g.box_cols);
        if (geometria::is_supported_geometry(a, b) && geometria::is_supported_geometry(b, a)) pairs.insert(std::make_tuple(g.n, a, b));
    }

    int executed = 0; double delta_sum = 0.0;
    for (const auto& pair : pairs) {
        if (max_cases > 0 && executed >= max_cases) break;
        const int n = std::get<0>(pair); const int a = std::get<1>(pair); const int b = std::get<2>(pair);

        auto run_case = [&](int br, int bc, uint64_t seed_bias) -> GenerateRunResult {
            GenerateRunConfig cfg{};
            cfg.box_rows = br; cfg.box_cols = bc; cfg.target_puzzles = 1; cfg.threads = 1;
            cfg.seed = static_cast<long long>(n * 100000 + br * 100 + bc + seed_bias);
            cfg.required_strategy = RequiredStrategy::None; cfg.difficulty_level_required = 1;
            cfg.require_unique = true; cfg.strict_logical = true; cfg.enable_quality_contract = true; cfg.enable_replay_validation = true; cfg.enable_distribution_filter = true;
            cfg.pause_on_exit_windows = false; cfg.write_individual_files = false; cfg.output_folder = "plikiTMP/testy/asym_pair_benchmark"; cfg.output_file = "asym_" + std::to_string(n) + "_" + std::to_string(br) + "x" + std::to_string(bc) + ".txt";
            cfg.max_total_time_s = 20;
            if (base_cfg != nullptr) { cfg.profile_mode_policy = base_cfg->profile_mode_policy; cfg.full_for_n_ge = base_cfg->full_for_n_ge; cfg.cpu_backend_policy = base_cfg->cpu_backend_policy; cfg.asym_heuristics_mode = base_cfg->asym_heuristics_mode; cfg.adaptive_budget = base_cfg->adaptive_budget; }
            const GenerationProfile profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
            cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;

            return run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
        };

        const GenerateRunResult ab = run_case(a, b, 401);
        const GenerateRunResult ba = run_case(b, a, 402);

        AsymPairBenchmarkRow row{};
        row.n = n; row.a = a; row.b = b; row.attempts_ab = ab.attempts; row.attempts_ba = ba.attempts; row.accepted_ab = ab.accepted; row.accepted_ba = ba.accepted;
        row.elapsed_ab = ab.elapsed_s; row.elapsed_ba = ba.elapsed_s; row.throughput_ab = ab.accepted_per_sec; row.throughput_ba = ba.accepted_per_sec;
        const double base_tp = std::max(0.001, std::max(row.throughput_ab, row.throughput_ba));
        row.throughput_delta_pct = std::abs(row.throughput_ab - row.throughput_ba) * 100.0 / base_tp;
        row.pass_rate_ab = row.attempts_ab > 0 ? (100.0 * static_cast<double>(row.accepted_ab) / static_cast<double>(row.attempts_ab)) : 0.0;
        row.pass_rate_ba = row.attempts_ba > 0 ? (100.0 * static_cast<double>(row.accepted_ba) / static_cast<double>(row.attempts_ba)) : 0.0;
        row.pass_rate_delta = std::abs(row.pass_rate_ab - row.pass_rate_ba);
        row.violation = (row.throughput_delta_pct > 50.0) || (row.pass_rate_delta > 35.0);
        if (row.violation) ++summary.violations;
        delta_sum += row.throughput_delta_pct;
        summary.rows.push_back(std::move(row));
        ++summary.pairs_checked; ++executed;
    }
    summary.avg_throughput_delta_pct = summary.rows.empty() ? 0.0 : (delta_sum / static_cast<double>(summary.rows.size()));
    return summary;
}

inline void write_asym_pair_benchmark_reports(const AsymPairBenchmarkSummary& summary, const std::string& report_txt) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(asym_pair_benchmark_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== Asym Pair Benchmark ===\npairs_checked=" << summary.pairs_checked << " violations=" << summary.violations << " avg_throughput_delta_pct=" << format_fixed(summary.avg_throughput_delta_pct, 3) << "\n\n";
        for (const auto& r : summary.rows) txt << r.n << "x" << r.n << " (" << r.a << "x" << r.b << " vs " << r.b << "x" << r.a << ") tp_ab=" << format_fixed(r.throughput_ab, 6) << " tp_ba=" << format_fixed(r.throughput_ba, 6) << " tp_delta_pct=" << format_fixed(r.throughput_delta_pct, 3) << " pass_ab=" << format_fixed(r.pass_rate_ab, 3) << " pass_ba=" << format_fixed(r.pass_rate_ba, 3) << " pass_delta=" << format_fixed(r.pass_rate_delta, 3) << " violation=" << (r.violation ? "1" : "0") << "\n";
    }

    std::ofstream csv(asym_pair_benchmark_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        csv << "n,a,b,attempts_ab,attempts_ba,accepted_ab,accepted_ba,elapsed_ab,elapsed_ba,throughput_ab,throughput_ba,throughput_delta_pct,pass_rate_ab,pass_rate_ba,pass_rate_delta,violation\n";
        for (const auto& r : summary.rows) csv << r.n << "," << r.a << "," << r.b << "," << r.attempts_ab << "," << r.attempts_ba << "," << r.accepted_ab << "," << r.accepted_ba << "," << format_fixed(r.elapsed_ab, 6) << "," << format_fixed(r.elapsed_ba, 6) << "," << format_fixed(r.throughput_ab, 6) << "," << format_fixed(r.throughput_ba, 6) << "," << format_fixed(r.throughput_delta_pct, 6) << "," << format_fixed(r.pass_rate_ab, 6) << "," << format_fixed(r.pass_rate_ba, 6) << "," << format_fixed(r.pass_rate_delta, 6) << "," << (r.violation ? 1 : 0) << "\n";
    }
}

inline int run_asym_pair_benchmark_cli(const std::string& report_txt, int max_cases = 0, const GenerateRunConfig* base_cfg = nullptr) {
    const AsymPairBenchmarkSummary summary = run_asym_pair_benchmark_suite(max_cases, base_cfg);
    write_asym_pair_benchmark_reports(summary, report_txt);
    std::cout << "Asym pair benchmark: pairs_checked=" << summary.pairs_checked << " violations=" << summary.violations << " avg_throughput_delta_pct=" << format_fixed(summary.avg_throughput_delta_pct, 3) << "\nReports: " << report_txt << " | " << asym_pair_benchmark_csv_path_for(report_txt) << "\n";
    return summary.violations > 0 ? 8 : 0;
}

struct PreDifficultyGateSummary { GeometryGateSummary geometry; QualityBenchmarkSummary quality; int throughput_pair_violations = 0; double uniqueness_budget_pct = 0.0; bool passed = false; std::string message; };
inline int count_quality_throughput_pair_violations(const QualityBenchmarkSummary& summary, double max_delta_pct = 50.0) {
    std::map<std::tuple<int, int, int>, std::array<const QualityBenchmarkCaseRow*, 2>> pairs;
    for (const auto& row : summary.rows) {
        if (row.box_rows == row.box_cols) continue;
        const int a = std::min(row.box_rows, row.box_cols); const int b = std::max(row.box_rows, row.box_cols);
        auto& slot = pairs[std::make_tuple(row.n, a, b)];
        if (row.box_rows <= row.box_cols) slot[0] = &row; else slot[1] = &row;
    }
    int violations = 0;
    for (const auto& kv : pairs) {
        const auto* p0 = kv.second[0]; const auto* p1 = kv.second[1];
        if (p0 == nullptr || p1 == nullptr) continue;
        const double t0 = p0->elapsed_s > 0.0 ? (static_cast<double>(p0->accepted) / p0->elapsed_s) : 0.0;
        const double t1 = p1->elapsed_s > 0.0 ? (static_cast<double>(p1->accepted) / p1->elapsed_s) : 0.0;
        const double base = std::max(0.001, std::max(t0, t1));
        if (std::abs(t0 - t1) * 100.0 / base > max_delta_pct) ++violations;
    }
    return violations;
}

inline PreDifficultyGateSummary run_pre_difficulty_gate_suite(const GenerateRunConfig& cfg, int quality_max_cases = 0) {
    PreDifficultyGateSummary summary{};
    summary.geometry = run_geometry_gate_20s_suite(&cfg);
    summary.quality = run_quality_benchmark_suite_20s(quality_max_cases, &cfg);
    summary.throughput_pair_violations = count_quality_throughput_pair_violations(summary.quality, 50.0);
    uint64_t attempts_total = 0; uint64_t reject_uniqueness_budget_total = 0;
    for (const auto& row : summary.quality.rows) { attempts_total += row.attempts; reject_uniqueness_budget_total += row.reject_uniqueness_budget; }
    summary.uniqueness_budget_pct = attempts_total > 0 ? (100.0 * static_cast<double>(reject_uniqueness_budget_total) / static_cast<double>(attempts_total)) : 0.0;

    const bool gate_ok_geometry = summary.geometry.contract_failed == 0 && summary.geometry.smoke_failed == 0 && summary.geometry.timeout_count == 0;
    const bool gate_ok_quality_pairs = summary.quality.pair_violations == 0;
    const bool gate_ok_throughput_pairs = summary.throughput_pair_violations == 0;
    const bool gate_ok_uniqueness_budget = summary.uniqueness_budget_pct <= 20.0;

    summary.passed = gate_ok_geometry && gate_ok_quality_pairs && gate_ok_throughput_pairs && gate_ok_uniqueness_budget;
    std::ostringstream msg;
    msg << "geometry_ok=" << (gate_ok_geometry ? "1" : "0") << " quality_pair_ok=" << (gate_ok_quality_pairs ? "1" : "0") << " throughput_pair_ok=" << (gate_ok_throughput_pairs ? "1" : "0") << " uniq_budget_ok=" << (gate_ok_uniqueness_budget ? "1" : "0") << " uniq_budget_pct=" << format_fixed(summary.uniqueness_budget_pct, 2);
    summary.message = msg.str();
    return summary;
}

inline std::string pre_difficulty_gate_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline void write_pre_difficulty_gate_report(const std::string& report_txt, const GenerateRunConfig& cfg, const PreDifficultyGateSummary& summary) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(pre_difficulty_gate_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== Pre-Difficulty Gate ===\nstatus=" << (summary.passed ? "PASS" : "FAIL") << "\npolicy=" << normalize_profile_mode_policy(cfg.profile_mode_policy) << " full_for_n_ge=" << cfg.full_for_n_ge << "\nmessage=" << summary.message << "\n\ngeometry_total=" << summary.geometry.rows.size() << " contract_failed=" << summary.geometry.contract_failed << " smoke_failed=" << summary.geometry.smoke_failed << " timeout_count=" << summary.geometry.timeout_count << "\nquality_rows=" << summary.quality.rows.size() << " quality_pair_violations=" << summary.quality.pair_violations << " throughput_pair_violations=" << summary.throughput_pair_violations << " uniqueness_budget_pct=" << format_fixed(summary.uniqueness_budget_pct, 2) << "\n";
    }

    std::ofstream csv(pre_difficulty_gate_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        std::string msg = summary.message; std::replace(msg.begin(), msg.end(), ',', ';');
        csv << "status,profile_mode_policy,full_for_n_ge,geometry_contract_failed,geometry_smoke_failed,geometry_timeout_count,quality_pair_violations,throughput_pair_violations,uniqueness_budget_pct,message\n" << (summary.passed ? "PASS" : "FAIL") << "," << normalize_profile_mode_policy(cfg.profile_mode_policy) << "," << cfg.full_for_n_ge << "," << summary.geometry.contract_failed << "," << summary.geometry.smoke_failed << "," << summary.geometry.timeout_count << "," << summary.quality.pair_violations << "," << summary.throughput_pair_violations << "," << format_fixed(summary.uniqueness_budget_pct, 6) << "," << msg << "\n";
    }
}

inline int run_pre_difficulty_gate_cli(const std::string& report_txt, const GenerateRunConfig& cfg, int quality_max_cases = 0) {
    const PreDifficultyGateSummary summary = run_pre_difficulty_gate_suite(cfg, quality_max_cases);
    write_pre_difficulty_gate_report(report_txt, cfg, summary);
    std::cout << "Pre-difficulty gate: status=" << (summary.passed ? "PASS" : "FAIL") << " | " << summary.message << "\nReports: " << report_txt << " | " << pre_difficulty_gate_csv_path_for(report_txt) << "\n";
    return summary.passed ? 0 : 5;
}

struct VipBenchmarkCaseRow { int n = 0; int box_rows = 0; int box_cols = 0; std::string cpu_backend; uint64_t attempts = 0; uint64_t accepted = 0; double elapsed_s = 0.0; double vip_score = 0.0; std::string vip_grade; bool vip_contract_ok = true; uint64_t premium_signature = 0; };
struct VipBenchmarkSummary { std::vector<VipBenchmarkCaseRow> rows; int grade_target_failures = 0; double avg_vip_score = 0.0; };
inline std::string vip_benchmark_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline VipBenchmarkSummary run_vip_benchmark_suite(const GenerateRunConfig& base_cfg, int max_cases = 0) {
    VipBenchmarkSummary summary{};
    int executed = 0; double score_sum = 0.0;
    for (const auto& g : geometria::all_geometries()) {
        if (max_cases > 0 && executed >= max_cases) break;
        GenerateRunConfig cfg = base_cfg;
        cfg.box_rows = g.box_rows; cfg.box_cols = g.box_cols; cfg.target_puzzles = 1; cfg.threads = std::max(1, base_cfg.threads);
        cfg.seed = static_cast<long long>(g.n * 100000 + g.box_rows * 100 + g.box_cols + 313);
        cfg.required_strategy = RequiredStrategy::None; cfg.difficulty_level_required = 1;
        cfg.require_unique = true; cfg.strict_logical = true; cfg.enable_quality_contract = true; cfg.enable_replay_validation = true; cfg.enable_distribution_filter = true;
        cfg.pause_on_exit_windows = false; cfg.write_individual_files = false; cfg.output_folder = "plikiTMP/testy/vip_benchmark"; cfg.output_file = "vip_" + std::to_string(g.n) + "_" + std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ".txt";
        cfg.max_total_time_s = std::max<uint64_t>(10, base_cfg.max_total_time_s > 0 ? base_cfg.max_total_time_s : 20);
        cfg.vip_mode = true; cfg.difficulty_engine = "vip"; cfg.cpu_dispatch_report = false;
        const GenerationProfile profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
        cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;

        const GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);

        VipBenchmarkCaseRow row{};
        row.n = g.n; row.box_rows = g.box_rows; row.box_cols = g.box_cols; row.cpu_backend = result.cpu_backend_selected;
        row.attempts = result.attempts; row.accepted = result.accepted; row.elapsed_s = result.elapsed_s;
        row.vip_score = result.vip_score; row.vip_grade = result.vip_grade; row.vip_contract_ok = result.vip_contract_ok; row.premium_signature = result.premium_signature;
        if (!row.vip_contract_ok) ++summary.grade_target_failures;
        score_sum += row.vip_score;
        summary.rows.push_back(std::move(row));
        ++executed;
    }
    summary.avg_vip_score = summary.rows.empty() ? 0.0 : (score_sum / static_cast<double>(summary.rows.size()));
    return summary;
}

inline void write_vip_benchmark_reports(const VipBenchmarkSummary& summary, const std::string& report_txt) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(vip_benchmark_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== VIP Benchmark ===\nrows=" << summary.rows.size() << " grade_target_failures=" << summary.grade_target_failures << " avg_vip_score=" << format_fixed(summary.avg_vip_score, 3) << "\n\n";
        for (const auto& r : summary.rows) txt << r.n << "x" << r.n << " (" << r.box_rows << "x" << r.box_cols << ") backend=" << r.cpu_backend << " accepted=" << r.accepted << " attempts=" << r.attempts << " elapsed_s=" << format_fixed(r.elapsed_s, 3) << " vip_score=" << format_fixed(r.vip_score, 3) << " vip_grade=" << r.vip_grade << " vip_contract_ok=" << (r.vip_contract_ok ? "1" : "0") << " signature=" << r.premium_signature << "\n";
    }

    std::ofstream csv(vip_benchmark_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        csv << "n,box_rows,box_cols,cpu_backend,attempts,accepted,elapsed_s,vip_score,vip_grade,vip_contract_ok,premium_signature\n";
        for (const auto& r : summary.rows) csv << r.n << "," << r.box_rows << "," << r.box_cols << "," << r.cpu_backend << "," << r.attempts << "," << r.accepted << "," << format_fixed(r.elapsed_s, 6) << "," << format_fixed(r.vip_score, 6) << "," << r.vip_grade << "," << (r.vip_contract_ok ? 1 : 0) << "," << r.premium_signature << "\n";
    }
}

inline int run_vip_benchmark_cli(const std::string& report_txt, const GenerateRunConfig& base_cfg, int max_cases = 0) {
    const VipBenchmarkSummary summary = run_vip_benchmark_suite(base_cfg, max_cases);
    write_vip_benchmark_reports(summary, report_txt);
    std::cout << "VIP benchmark: rows=" << summary.rows.size() << " grade_target_failures=" << summary.grade_target_failures << " avg_vip_score=" << format_fixed(summary.avg_vip_score, 3) << "\nReports: " << report_txt << " | " << vip_benchmark_csv_path_for(report_txt) << "\n";
    return summary.grade_target_failures > 0 ? 6 : 0;
}

struct VipGateSummary { VipBenchmarkSummary benchmark; bool passed = false; std::string message; };
inline std::string vip_gate_csv_path_for(const std::string& report_txt) { std::filesystem::path p(report_txt); if (!p.has_extension()) p += ".txt"; std::filesystem::path csv = p; csv.replace_extension(".csv"); return csv.string(); }

inline VipGateSummary run_vip_gate_suite(const GenerateRunConfig& base_cfg, int max_cases = 0) {
    VipGateSummary out{};
    out.benchmark = run_vip_benchmark_suite(base_cfg, max_cases);
    const bool avg_score_ok = out.benchmark.avg_vip_score >= 300.0;
    const bool grade_ok = out.benchmark.grade_target_failures == 0;
    out.passed = avg_score_ok && grade_ok;
    std::ostringstream oss;
    oss << "avg_score_ok=" << (avg_score_ok ? "1" : "0") << " grade_ok=" << (grade_ok ? "1" : "0") << " avg_vip_score=" << format_fixed(out.benchmark.avg_vip_score, 3) << " grade_target_failures=" << out.benchmark.grade_target_failures;
    out.message = oss.str();
    return out;
}

inline void write_vip_gate_report(const VipGateSummary& summary, const std::string& report_txt) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_txt).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(vip_gate_csv_path_for(report_txt)).parent_path(), ec);

    std::ofstream txt(report_txt, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== VIP Gate ===\nstatus=" << (summary.passed ? "PASS" : "FAIL") << "\nmessage=" << summary.message << "\nrows=" << summary.benchmark.rows.size() << " avg_vip_score=" << format_fixed(summary.benchmark.avg_vip_score, 3) << " grade_target_failures=" << summary.benchmark.grade_target_failures << "\n";
    }

    std::ofstream csv(vip_gate_csv_path_for(report_txt), std::ios::out | std::ios::trunc);
    if (csv) {
        std::string msg = summary.message; std::replace(msg.begin(), msg.end(), ',', ';');
        csv << "status,avg_vip_score,grade_target_failures,message\n" << (summary.passed ? "PASS" : "FAIL") << "," << format_fixed(summary.benchmark.avg_vip_score, 6) << "," << summary.benchmark.grade_target_failures << "," << msg << "\n";
    }
}

inline int run_vip_gate_cli(const std::string& report_txt, const GenerateRunConfig& base_cfg, int max_cases = 0) {
    const VipGateSummary summary = run_vip_gate_suite(base_cfg, max_cases);
    write_vip_gate_report(summary, report_txt);
    std::cout << "VIP gate: status=" << (summary.passed ? "PASS" : "FAIL") << " | " << summary.message << "\nReports: " << report_txt << " | " << vip_gate_csv_path_for(report_txt) << "\n";
    return summary.passed ? 0 : 7;
}

struct PerfAbCaseRow { int n = 0; int box_rows = 0; int box_cols = 0; std::string backend; uint64_t accepted = 0; uint64_t attempts = 0; double elapsed_s = 0.0; double throughput = 0.0; double baseline_throughput = 0.0; double delta_pct = 0.0; };
struct PerfAbSummary { std::vector<PerfAbCaseRow> rows; double avg_throughput = 0.0; double avg_delta_pct = 0.0; };

inline std::unordered_map<std::string, double> load_perf_ab_baseline_csv(const std::string& path) {
    std::unordered_map<std::string, double> out;
    if (path.empty()) return out;
    std::ifstream in(path);
    if (!in) return out;
    std::string line;
    if (!std::getline(in, line)) return out;
    while (std::getline(in, line)) {
        if (line.empty()) continue;
        std::vector<std::string> fields;
        std::istringstream iss(line);
        std::string token;
        while (std::getline(iss, token, ',')) fields.push_back(token);
        if (fields.size() < 8) continue;
        const std::string key = fields[1] + "x" + fields[2];
        try { out[key] = std::stod(fields[7]); } catch (...) {}
    }
    return out;
}

inline PerfAbSummary run_perf_ab_suite(const GenerateRunConfig& base_cfg) {
    PerfAbSummary out{};
    std::vector<geometria::GeometrySpec> selected;
    for (const auto& g : geometria::all_geometries()) {
        if (g.n < 9 || g.n > 30) continue;
        if (g.n == 9 || g.n == 12 || g.n == 16 || g.n == 20 || g.n == 24 || g.n == 30) selected.push_back(g);
    }
    std::sort(selected.begin(), selected.end(), [](const auto& a, const auto& b) { if (a.n != b.n) return a.n < b.n; if (a.box_rows != b.box_rows) return a.box_rows < b.box_rows; return a.box_cols < b.box_cols; });
    if (selected.size() > 12) selected.resize(12);

    const auto baseline_map = load_perf_ab_baseline_csv(base_cfg.perf_baseline_csv);
    double throughput_sum = 0.0; double delta_sum = 0.0; int delta_count = 0;
    for (const auto& g : selected) {
        GenerateRunConfig cfg = base_cfg;
        cfg.box_rows = g.box_rows; cfg.box_cols = g.box_cols;
        cfg.target_puzzles = std::max<uint64_t>(3, std::min<uint64_t>(10, base_cfg.target_puzzles));
        cfg.max_total_time_s = std::max<uint64_t>(6, (base_cfg.max_total_time_s > 0 ? base_cfg.max_total_time_s : 8));
        cfg.max_attempts_s = 0; cfg.seed = static_cast<long long>(g.n * 100000 + g.box_rows * 100 + g.box_cols + 991);
        cfg.pause_on_exit_windows = false; cfg.write_individual_files = false;
        cfg.output_folder = "plikiTMP/testy/perf_ab"; cfg.output_file = "perf_" + std::to_string(g.n) + "_" + std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ".txt";
        const GenerationProfile profile = resolve_generation_profile(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy, &cfg);
        cfg.min_clues = profile.clue_range.min_clues; cfg.max_clues = profile.clue_range.max_clues;

        const GenerateRunResult result = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
        PerfAbCaseRow row{};
        row.n = g.n; row.box_rows = g.box_rows; row.box_cols = g.box_cols; row.backend = result.cpu_backend_selected;
        row.accepted = result.accepted; row.attempts = result.attempts; row.elapsed_s = result.elapsed_s; row.throughput = result.accepted_per_sec;
        const std::string key = std::to_string(row.box_rows) + "x" + std::to_string(row.box_cols);
        const auto it = baseline_map.find(key);
        if (it != baseline_map.end()) {
            row.baseline_throughput = it->second;
            row.delta_pct = ((row.throughput - row.baseline_throughput) / std::max(0.000001, row.baseline_throughput)) * 100.0;
            delta_sum += row.delta_pct; ++delta_count;
        }
        throughput_sum += row.throughput; out.rows.push_back(row);
    }
    out.avg_throughput = out.rows.empty() ? 0.0 : throughput_sum / static_cast<double>(out.rows.size());
    out.avg_delta_pct = delta_count > 0 ? (delta_sum / static_cast<double>(delta_count)) : 0.0;
    return out;
}

inline void write_perf_ab_reports(const PerfAbSummary& summary, const std::string& txt_path, const std::string& csv_path) {
    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(txt_path).parent_path(), ec);
    std::filesystem::create_directories(std::filesystem::path(csv_path).parent_path(), ec);

    std::ofstream txt(txt_path, std::ios::out | std::ios::trunc);
    if (txt) {
        txt << "=== PERF A/B SUITE ===\nrows=" << summary.rows.size() << " avg_throughput=" << format_fixed(summary.avg_throughput, 4) << " avg_delta_pct=" << format_fixed(summary.avg_delta_pct, 3) << "\n\n";
        for (const auto& row : summary.rows) {
            txt << row.n << "x" << row.n << " (" << row.box_rows << "x" << row.box_cols << ") backend=" << row.backend << " accepted=" << row.accepted << " attempts=" << row.attempts << " elapsed_s=" << format_fixed(row.elapsed_s, 6) << " throughput=" << format_fixed(row.throughput, 6);
            if (row.baseline_throughput > 0.0) txt << " baseline=" << format_fixed(row.baseline_throughput, 6) << " delta_pct=" << format_fixed(row.delta_pct, 3);
            txt << "\n";
        }
    }

    std::ofstream csv(csv_path, std::ios::out | std::ios::trunc);
    if (csv) {
        csv << "n,box_rows,box_cols,backend,accepted,attempts,elapsed_s,throughput,baseline_throughput,delta_pct\n";
        for (const auto& row : summary.rows) csv << row.n << "," << row.box_rows << "," << row.box_cols << "," << row.backend << "," << row.accepted << "," << row.attempts << "," << format_fixed(row.elapsed_s, 6) << "," << format_fixed(row.throughput, 6) << "," << format_fixed(row.baseline_throughput, 6) << "," << format_fixed(row.delta_pct, 6) << "\n";
    }
}

inline int run_perf_ab_suite_cli(const GenerateRunConfig& cfg) {
    const auto baseline_debug = load_perf_ab_baseline_csv(cfg.perf_baseline_csv);
    const PerfAbSummary summary = run_perf_ab_suite(cfg);
    write_perf_ab_reports(summary, cfg.perf_report_out, cfg.perf_csv_out);
    std::cout << "Perf A/B suite: rows=" << summary.rows.size() << " avg_throughput=" << format_fixed(summary.avg_throughput, 4) << " avg_delta_pct=" << format_fixed(summary.avg_delta_pct, 3) << "\n";
    if (!cfg.perf_baseline_csv.empty()) std::cout << "Perf baseline entries: " << baseline_debug.size() << "\n";
    std::cout << "Reports: " << cfg.perf_report_out << " | " << cfg.perf_csv_out << "\n";
    return 0;
}

inline std::vector<std::string> stage_trackable_roots() { return {"main.cpp", "Sources"}; }

inline bool stage_is_source_file(const std::filesystem::path& p) {
    const std::string ext = p.extension().string();
    return ext == ".h" || ext == ".hpp" || ext == ".cpp" || ext == ".cc" || ext == ".cxx" || ext == ".c";
}

inline std::vector<std::filesystem::path> collect_stage_files_current() {
    std::vector<std::filesystem::path> files;
    const std::filesystem::path cwd = std::filesystem::weakly_canonical(std::filesystem::current_path());
    auto to_rel = [&](const std::filesystem::path& p) -> std::filesystem::path {
        std::error_code ec; const auto abs = std::filesystem::weakly_canonical(p, ec);
        if (!ec) { const auto rel = abs.lexically_relative(cwd); return !rel.empty() ? rel : abs.lexically_normal(); }
        return p.lexically_normal();
    };
    for (const auto& root : stage_trackable_roots()) {
        const std::filesystem::path rp(root);
        if (!std::filesystem::exists(rp)) continue;
        if (std::filesystem::is_regular_file(rp)) {
            const auto rel = to_rel(rp);
            if (stage_is_source_file(rel)) files.push_back(rel);
            continue;
        }
        for (const auto& entry : std::filesystem::recursive_directory_iterator(rp)) {
            if (!entry.is_regular_file()) continue;
            const auto rel = to_rel(entry.path());
            if (stage_is_source_file(rel)) files.push_back(rel);
        }
    }
    std::sort(files.begin(), files.end());
    files.erase(std::unique(files.begin(), files.end()), files.end());
    return files;
}

inline std::vector<std::string> read_text_lines(const std::filesystem::path& p) {
    std::vector<std::string> out; std::ifstream in(p); std::string line;
    while (std::getline(in, line)) out.push_back(line);
    return out;
}

inline uint64_t lcs_length(const std::vector<std::string>& a, const std::vector<std::string>& b) {
    if (a.empty() || b.empty()) return 0;
    std::vector<uint32_t> prev(b.size() + 1, 0); std::vector<uint32_t> curr(b.size() + 1, 0);
    for (size_t i = 1; i <= a.size(); ++i) {
        for (size_t j = 1; j <= b.size(); ++j) {
            if (a[i - 1] == b[j - 1]) curr[j] = prev[j - 1] + 1U;
            else curr[j] = std::max(prev[j], curr[j - 1]);
        }
        std::swap(prev, curr); std::fill(curr.begin(), curr.end(), 0U);
    }
    return static_cast<uint64_t>(prev[b.size()]);
}

inline std::pair<uint64_t, uint64_t> diff_added_removed_lines(const std::filesystem::path& before_file, const std::filesystem::path& after_file) {
    const bool has_before = std::filesystem::exists(before_file); const bool has_after = std::filesystem::exists(after_file);
    if (!has_before && !has_after) return {0ULL, 0ULL};
    if (!has_before && has_after) return {static_cast<uint64_t>(read_text_lines(after_file).size()), 0ULL};
    if (has_before && !has_after) return {0ULL, static_cast<uint64_t>(read_text_lines(before_file).size())};
    const auto a = read_text_lines(before_file); const auto b = read_text_lines(after_file);
    if (a == b) return {0ULL, 0ULL};
    return {static_cast<uint64_t>(b.size()), static_cast<uint64_t>(a.size())};
}

inline std::filesystem::path stage_snapshot_root(const std::string& stage_name) {
    return std::filesystem::path("plikiTMP") / "stage_snapshots" / stage_name;
}

inline int run_stage_start_cli(const GenerateRunConfig& base_cfg) {
    if (base_cfg.stage_name.empty()) { std::cerr << "stage-start requires --stage-start <name>\n"; return 2; }
    std::error_code ec; const auto root = stage_snapshot_root(base_cfg.stage_name); const auto before_dir = root / "before";
    std::filesystem::remove_all(root, ec); std::filesystem::create_directories(before_dir, ec);
    if (ec) { std::cerr << "stage-start: cannot create snapshot dir: " << root.string() << " err=" << ec.message() << "\n"; return 2; }
    const auto files = collect_stage_files_current();
    for (const auto& rel : files) {
        const auto dst = before_dir / rel; std::filesystem::create_directories(dst.parent_path(), ec);
        std::filesystem::copy_file(rel, dst, std::filesystem::copy_options::overwrite_existing, ec);
        if (ec) { std::cerr << "stage-start: copy failed: " << rel.string() << " err=" << ec.message() << "\n"; return 2; }
    }

    GenerateRunConfig perf_cfg = base_cfg; perf_cfg.perf_baseline_csv.clear();
    perf_cfg.perf_report_out = (root / "perf_before.txt").string(); perf_cfg.perf_csv_out = (root / "perf_before.csv").string();
    const PerfAbSummary perf_before = run_perf_ab_suite(perf_cfg);
    write_perf_ab_reports(perf_before, perf_cfg.perf_report_out, perf_cfg.perf_csv_out);

    std::ofstream out(base_cfg.stage_report_out, std::ios::out | std::ios::trunc);
    if (out) { out << "stage=" << base_cfg.stage_name << "\nstatus=STARTED\nsnapshot_root=" << root.string() << "\ntracked_files=" << files.size() << "\nperf_before_csv=" << perf_cfg.perf_csv_out << "\nperf_before_txt=" << perf_cfg.perf_report_out << "\n"; }
    std::cout << "Stage start: " << base_cfg.stage_name << "\nTracked files: " << files.size() << "\nPerf BEFORE: " << perf_cfg.perf_report_out << " | " << perf_cfg.perf_csv_out << "\n";
    return 0;
}

inline int run_stage_end_cli(const GenerateRunConfig& base_cfg) {
    if (base_cfg.stage_name.empty()) { std::cerr << "stage-end requires --stage-end <name>\n"; return 3; }
    const auto root = stage_snapshot_root(base_cfg.stage_name); const auto before_dir = root / "before";
    if (!std::filesystem::exists(before_dir)) { std::cerr << "stage-end: snapshot not found: " << before_dir.string() << "\n"; return 3; }
    std::error_code ec; const auto current_dir = root / "current"; std::filesystem::remove_all(current_dir, ec); std::filesystem::create_directories(current_dir, ec);
    if (ec) { std::cerr << "stage-end: cannot create current snapshot: " << current_dir.string() << " err=" << ec.message() << "\n"; return 3; }
    const auto current_files = collect_stage_files_current();
    for (const auto& rel : current_files) {
        const auto dst = current_dir / rel; std::filesystem::create_directories(dst.parent_path(), ec);
        std::filesystem::copy_file(rel, dst, std::filesystem::copy_options::overwrite_existing, ec);
        if (ec) { std::cerr << "stage-end: copy current failed: " << rel.string() << " err=" << ec.message() << "\n"; return 3; }
    }
    const auto numstat_path = root / "numstat.txt";
    const std::string cmd = "git diff --no-index --numstat \"" + before_dir.string() + "\" \"" + current_dir.string() + "\" > \"" + numstat_path.string() + "\" 2> NUL";
    (void)std::system(cmd.c_str());
    uint64_t lines_added = 0; uint64_t lines_removed = 0;
    std::ifstream numstat(numstat_path); std::string line;
    while (std::getline(numstat, line)) {
        if (line.empty()) continue; std::istringstream iss(line); std::string add_s, rem_s, path_s;
        if (!std::getline(iss, add_s, '\t') || !std::getline(iss, rem_s, '\t')) continue; std::getline(iss, path_s);
        if (add_s == "-" || rem_s == "-") continue;
        try { lines_added += static_cast<uint64_t>(std::stoull(add_s)); lines_removed += static_cast<uint64_t>(std::stoull(rem_s)); } catch (...) {}
    }

    GenerateRunConfig perf_cfg = base_cfg; perf_cfg.perf_baseline_csv = (root / "perf_before.csv").string();
    perf_cfg.perf_report_out = (root / "perf_after.txt").string(); perf_cfg.perf_csv_out = (root / "perf_after.csv").string();
    const PerfAbSummary perf_after = run_perf_ab_suite(perf_cfg);
    write_perf_ab_reports(perf_after, perf_cfg.perf_report_out, perf_cfg.perf_csv_out);

    std::ofstream out(base_cfg.stage_report_out, std::ios::out | std::ios::trunc);
    if (out) { out << "stage=" << base_cfg.stage_name << "\nstatus=COMPLETED\nlines_added=" << lines_added << "\nlines_removed=" << lines_removed << "\nperf_after_avg_throughput=" << format_fixed(perf_after.avg_throughput, 6) << "\nperf_after_avg_delta_pct=" << format_fixed(perf_after.avg_delta_pct, 6) << "\nperf_after_csv=" << perf_cfg.perf_csv_out << "\nperf_after_txt=" << perf_cfg.perf_report_out << "\n"; }
    std::cout << "Stage end: " << base_cfg.stage_name << " lines_added=" << lines_added << " lines_removed=" << lines_removed << " avg_delta_pct=" << format_fixed(perf_after.avg_delta_pct, 3) << "\nPerf AFTER: " << perf_cfg.perf_report_out << " | " << perf_cfg.perf_csv_out << "\nStage report: " << base_cfg.stage_report_out << "\n";
    return 0;
}

BenchmarkReportData build_sample_benchmark_data(const GenerateRunConfig& cfg, const GenerateRunResult& result) {
    BenchmarkReportData data;
    data.probe_per_level = std::to_string(cfg.target_puzzles);
    data.benchmark_mode = "initial_generic_stage";
    data.runtime_info = detect_runtime_info();
    data.threads_info = std::to_string(cfg.threads <= 0 ? std::max(1u, std::thread::hardware_concurrency()) : static_cast<unsigned>(cfg.threads));
#ifdef _WIN32
    data.os_info = detect_os_info();
#else
    data.os_info = "UnknownOS";
#endif
    data.cpu_model = detect_cpu_model(); data.ram_info = detect_ram_info();

    BenchmarkTableARow a;
    a.lvl = cfg.difficulty_level_required; a.solved_ok = static_cast<int>(result.accepted); a.analyzed = static_cast<int>(result.attempts);
    a.required_use = result.analyzed_required_strategy; a.required_hit = result.required_strategy_hits; a.reject_strategy = result.reject_strategy;
    a.avg_solved_gen_ms = result.accepted > 0 ? (result.elapsed_s * 1000.0) / static_cast<double>(result.accepted) : 0.0;
    a.avg_dig_ms = 0.0; a.avg_analyze_ms = 0.0; a.backtracks = 0; a.timeouts = 0; a.success_rate = result.attempts > 0 ? (100.0 * static_cast<double>(result.accepted) / static_cast<double>(result.attempts)) : 0.0;
    data.table_a.push_back(a);

    BenchmarkTableA2Row a2; a2.lvl = cfg.difficulty_level_required; a2.analyzed = static_cast<int>(result.attempts); data.table_a2.push_back(a2);

    BenchmarkTableA3Row a3; a3.strategy = to_string(cfg.required_strategy); a3.lvl = cfg.difficulty_level_required; a3.max_attempts = cfg.max_attempts; a3.analyzed = result.analyzed_required_strategy; a3.required_strategy_hits = result.required_strategy_hits;
    a3.analyzed_per_s = result.elapsed_s > 0.0 ? static_cast<double>(a3.analyzed) / result.elapsed_s : 0.0; a3.est_5min = static_cast<uint64_t>(a3.analyzed_per_s * 300.0); a3.written = result.written_required_strategy;
    data.table_a3.push_back(a3);

    BenchmarkTableBRow bg; const int n = std::max(1, cfg.box_rows) * std::max(1, cfg.box_cols); bg.size = std::to_string(n) + "x" + std::to_string(n);
    for (int lvl = 1; lvl <= 8; ++lvl) { const ClueRange cr = clue_range_for_size_level(n, lvl); bg.levels[static_cast<size_t>(lvl - 1)] = std::to_string(cr.min_clues) + "-" + std::to_string(cr.max_clues); }
    data.table_b.push_back(bg);

    BenchmarkTableCRow c; c.size = std::to_string(n) + "x" + std::to_string(n); c.lvl = cfg.difficulty_level_required; c.est_analyze_s = 0.0; c.budget_s = cfg.attempt_time_budget_s > 0.0 ? cfg.attempt_time_budget_s : 0.0; c.peak_ram_mb = 0.0; c.decision = "RUN";
    data.table_c.push_back(c);

    data.rules = { "Pomijanie testow gdy est_analyze_s > budget_s dla danego rozmiaru.", "Dla N>12 mozna pomijac poziomy 7-9 przy przekroczeniu budzetu.", "Wymuszona unikalnosc tylko przez array DLX limit=2.", "Kontrakt required_strategy: use=analyzed_required_strategy, hit=required_strategy_hits, reject_strategy gdy !(use&&hit)." };
    data.total_execution_s = static_cast<uint64_t>(std::llround(result.elapsed_s));
    data.table_microprofiling.clear();
    return data;
}

RequiredStrategy default_required_strategy_for_level(int lvl) {
    if (lvl == 1) return RequiredStrategy::NakedSingle;
    if (lvl == 2) return RequiredStrategy::PointingPairs;
    if (lvl == 3) return RequiredStrategy::NakedPair;
    if (lvl == 4) return RequiredStrategy::XWing;
    if (lvl == 5) return RequiredStrategy::Swordfish;
    if (lvl == 6) return RequiredStrategy::Jellyfish;
    if (lvl == 7) return RequiredStrategy::Medusa3D;
    if (lvl == 8) return RequiredStrategy::MSLS;
    return RequiredStrategy::None;
}

BenchmarkReportData run_benchmark_profiles_40s(const GenerateRunConfig& base_cfg);

} // namespace sudoku_hpc







==============================================================================
PLIK: Sources\geometry.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <cstdlib>
#include <limits>
#include <set>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

namespace sudoku_geometrie {

struct GeometriaInfo {
    int N;
    int box_rows;
    int box_cols;
    const char* desc;
};

static constexpr int MIN_N = 4;
static constexpr int MAX_N = 64;
static std::vector<GeometriaInfo> g_wszystkie_geometrie;
static std::vector<std::string> g_opisy_geometrii;
static bool g_geometrie_zainicjalizowane = false;

inline void zainicjalizuj_geometrie() {
    if (g_geometrie_zainicjalizowane) return;

    int total = 0;
    for (int n = MIN_N; n <= MAX_N; ++n) {
        for (int box_rows = 1; box_rows <= n; ++box_rows) {
            if (n % box_rows != 0) continue;
            ++total;
        }
    }
    g_wszystkie_geometrie.clear();
    g_opisy_geometrii.clear();
    g_wszystkie_geometrie.reserve(static_cast<size_t>(total));
    g_opisy_geometrii.reserve(static_cast<size_t>(total));

    for (int n = MIN_N; n <= MAX_N; ++n) {
        for (int box_rows = 1; box_rows <= n; ++box_rows) {
            if (n % box_rows != 0) continue;
            const int box_cols = n / box_rows;
            g_opisy_geometrii.push_back(
                std::to_string(n) + "x" + std::to_string(n) + " (" +
                std::to_string(box_rows) + "x" + std::to_string(box_cols) + ")");
            GeometriaInfo info{};
            info.N = n;
            info.box_rows = box_rows;
            info.box_cols = box_cols;
            info.desc = g_opisy_geometrii.back().c_str();
            g_wszystkie_geometrie.push_back(info);
        }
    }
    g_geometrie_zainicjalizowane = true;
}

inline int liczba_geometrii() {
    zainicjalizuj_geometrie();
    return static_cast<int>(g_wszystkie_geometrie.size());
}

inline const GeometriaInfo* get_wszystkie_geometrie_ptr() {
    zainicjalizuj_geometrie();
    return g_wszystkie_geometrie.empty() ? nullptr : g_wszystkie_geometrie.data();
}

inline const GeometriaInfo& get_geometria(int index) {
    zainicjalizuj_geometrie();
    return g_wszystkie_geometrie[static_cast<size_t>(index)];
}

inline const GeometriaInfo* znajdz_geometrie(int N, int box_rows, int box_cols) {
    zainicjalizuj_geometrie();
    for (const auto& g : g_wszystkie_geometrie) {
        if (g.N == N && g.box_rows == box_rows && g.box_cols == box_cols) return &g;
    }
    return nullptr;
}

inline std::vector<const GeometriaInfo*> znajdz_geometrie_dla_N(int N) {
    zainicjalizuj_geometrie();
    std::vector<const GeometriaInfo*> wynik;
    for (const auto& g : g_wszystkie_geometrie) {
        if (g.N == N) wynik.push_back(&g);
    }
    return wynik;
}

inline bool czy_obslugiwana(int N, int box_rows, int box_cols) {
    return znajdz_geometrie(N, box_rows, box_cols) != nullptr;
}

inline const GeometriaInfo* domyslna_geometria(int N) {
    auto geometrie = znajdz_geometrie_dla_N(N);
    if (geometrie.empty()) return nullptr;
    const GeometriaInfo* najlepsza = geometrie[0];
    int min_roznica = std::abs(najlepsza->box_rows - najlepsza->box_cols);
    for (const auto* g : geometrie) {
        int roznica = std::abs(g->box_rows - g->box_cols);
        if (roznica < min_roznica) {
            min_roznica = roznica;
            najlepsza = g;
        }
    }
    return najlepsza;
}

inline std::vector<int> wszystkie_rozmiary() {
    zainicjalizuj_geometrie();
    std::vector<int> wynik;
    wynik.reserve(static_cast<size_t>(MAX_N - MIN_N + 1));
    int ostatni_N = std::numeric_limits<int>::min();
    for (const auto& g : g_wszystkie_geometrie) {
        const int N = g.N;
        if (N != ostatni_N) {
            wynik.push_back(N);
            ostatni_N = N;
        }
    }
    return wynik;
}

inline std::string format_geometria(const GeometriaInfo& g) {
    return std::to_string(g.N) + "x" + std::to_string(g.N) + " (" +
           std::to_string(g.box_rows) + "x" + std::to_string(g.box_cols) + ")";
}

inline void wypisz_wszystkie_geometrie() {
    zainicjalizuj_geometrie();
}

}  // namespace sudoku_geometrie

namespace sudoku_hpc::geometria {

using sudoku_geometrie::GeometriaInfo;

inline int liczba_geometrii() {
    return sudoku_geometrie::liczba_geometrii();
}

struct GeometrySpec {
    int n = 0;
    int box_rows = 0;
    int box_cols = 0;
    bool is_symmetric = false;
    std::string label;
};

enum class GeometryClass {
    Symmetric,
    Asymmetric
};

inline void zainicjalizuj_geometrie() {
    sudoku_geometrie::zainicjalizuj_geometrie();
}

inline bool czy_obslugiwana(int n, int box_rows, int box_cols) {
    return sudoku_geometrie::czy_obslugiwana(n, box_rows, box_cols);
}

inline bool czy_obslugiwana(int box_rows, int box_cols) {
    if (box_rows <= 0 || box_cols <= 0) {
        return false;
    }
    return czy_obslugiwana(box_rows * box_cols, box_rows, box_cols);
}

inline const GeometriaInfo* znajdz_geometrie(int n, int box_rows, int box_cols) {
    return sudoku_geometrie::znajdz_geometrie(n, box_rows, box_cols);
}

inline const std::vector<GeometrySpec>& all_geometries() {
    zainicjalizuj_geometrie();
    static const std::vector<GeometrySpec> cache = [] {
        std::vector<GeometrySpec> out;
        const int count = sudoku_geometrie::liczba_geometrii();
        out.reserve(static_cast<size_t>(count));
        for (int i = 0; i < count; ++i) {
            const auto& g = sudoku_geometrie::get_geometria(i);
            out.push_back(
                {g.N,
                 g.box_rows,
                 g.box_cols,
                 g.box_rows == g.box_cols,
                 g.desc == nullptr ? "" : std::string(g.desc)});
        }
        std::sort(out.begin(), out.end(), [](const GeometrySpec& a, const GeometrySpec& b) {
            if (a.n != b.n) {
                return a.n < b.n;
            }
            if (a.box_rows != b.box_rows) {
                return a.box_rows < b.box_rows;
            }
            return a.box_cols < b.box_cols;
        });
        return out;
    }();
    return cache;
}

inline bool is_symmetric_geometry(int box_rows, int box_cols) {
    return box_rows > 0 && box_cols > 0 && box_rows == box_cols;
}

inline GeometryClass classify_geometry(int box_rows, int box_cols) {
    return is_symmetric_geometry(box_rows, box_cols) ? GeometryClass::Symmetric : GeometryClass::Asymmetric;
}

inline const char* geometry_class_name(GeometryClass c) {
    return c == GeometryClass::Symmetric ? "symmetric" : "asymmetric";
}

inline bool is_supported_geometry(int box_rows, int box_cols) {
    if (box_rows <= 0 || box_cols <= 0) {
        return false;
    }
    return czy_obslugiwana(box_rows * box_cols, box_rows, box_cols);
}

inline std::vector<GeometrySpec> geometries_for_n(int n) {
    std::vector<GeometrySpec> out;
    for (const auto& g : all_geometries()) {
        if (g.n == n) {
            out.push_back(g);
        }
    }
    std::sort(out.begin(), out.end(), [](const GeometrySpec& a, const GeometrySpec& b) {
        if (a.box_rows != b.box_rows) {
            return a.box_rows < b.box_rows;
        }
        return a.box_cols < b.box_cols;
    });
    return out;
}

inline bool validate_geometry_catalog(std::string* details_out = nullptr) {
    const auto& catalog = all_geometries();
    std::set<std::tuple<int, int, int>> seen;
    std::ostringstream details;
    bool ok = true;
    for (const auto& g : catalog) {
        if (g.n != g.box_rows * g.box_cols) {
            ok = false;
            details << "invalid_product " << g.n << " (" << g.box_rows << "x" << g.box_cols << ")\n";
        }
        const auto key = std::make_tuple(g.n, g.box_rows, g.box_cols);
        if (!seen.insert(key).second) {
            ok = false;
            details << "duplicate " << g.n << " (" << g.box_rows << "x" << g.box_cols << ")\n";
        }
        if (!czy_obslugiwana(g.n, g.box_rows, g.box_cols)) {
            ok = false;
            details << "not_recognized " << g.n << " (" << g.box_rows << "x" << g.box_cols << ")\n";
        }
    }
    if (details_out != nullptr) {
        *details_out = details.str();
    }
    return ok;
}

} // namespace sudoku_hpc::geometria



==============================================================================
PLIK: Sources\gui.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>
#ifdef _WIN32
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#endif

namespace sudoku_hpc {
#ifdef _WIN32
enum : int {
    IDC_PROGRESS_BAR = 1001,
    IDC_PROGRESS_TEXT,
    IDC_MONITOR_BOX,
    IDC_LOG_BOX,
    IDC_BTN_START,
    IDC_BTN_CANCEL,
    IDC_BTN_PAUSE
};

constexpr UINT WM_APP_PROGRESS = WM_APP + 101;
constexpr UINT WM_APP_LOG = WM_APP + 102;
constexpr UINT WM_APP_DONE = WM_APP + 103;
constexpr UINT WM_APP_INLINE_CLOSE = WM_APP + 104;
constexpr UINT WM_APP_FORM_NAV = WM_APP + 105;
constexpr UINT_PTR IDT_MONITOR_REFRESH = 1;
constexpr UINT_PTR IDSC_INLINE_EDITOR = 1;
constexpr int IDC_INLINE_EDIT = 4500;
constexpr int IDC_FORM_PANEL = 4501;

enum class FormFieldType {
    Int,
    Text,
    Combo,
    Checkbox,
    ActionButton
};

enum FormFieldKey {
    F_BOX_ROWS = 1,
    F_BOX_COLS,
    F_TARGET_PUZZLES,
    F_MIN_CLUES,
    F_MAX_CLUES,
    F_DIFFICULTY,
    F_CLUES_PRESET,
    F_THREADS,
    F_SEED,
    F_RESEED_INTERVAL,
    F_FORCE_NEW_SEED,
    F_ATTEMPT_TIME_BUDGET,
    F_ATTEMPT_NODE_BUDGET,
    F_MAX_ATTEMPTS,
    F_MAX_TOTAL_TIME,  // Globalny limit czasu na całe uruchomienie
    F_REQUIRED_STRATEGY,
    F_OUTPUT_FOLDER,
    F_OUTPUT_FILE,
    F_SYMMETRY_CENTER,
    F_REQUIRE_UNIQUE,
    F_SHOW_MONITOR
};

struct FormField {
    int key = 0;
    FormFieldType type = FormFieldType::Text;
    std::wstring label;
    std::wstring text;
    std::vector<std::wstring> options;
    std::vector<int> option_payload;
    int option_index = 0;
    bool checked = false;
    bool enabled = true;
    bool has_browse = false;
    RECT label_rect{};
    RECT value_rect{};
    RECT browse_rect{};
};

struct FormLayoutItem {
    bool is_section = false;
    std::wstring section_title;
    int field_key = 0;
    RECT section_rect{};
};

struct GuiAppState {
    HWND hwnd = nullptr;
    HWND h_form_panel = nullptr;
    HWND h_inline_editor = nullptr;
    HWND h_progress = nullptr;
    HWND h_progress_text = nullptr;
    HWND h_monitor = nullptr;
    HWND h_log = nullptr;
    HWND h_start = nullptr;
    HWND h_cancel = nullptr;
    HWND h_pause = nullptr;
    HFONT h_mono_font = nullptr;
    int inline_field_key = 0;
    int focused_field_key = 0;
    int hover_field_key = 0;
    bool inline_is_combo = false;
    bool form_read_only = false;
    bool inline_close_posted = false;
    bool mouse_tracking = false;
    int form_scroll_y = 0;
    int form_content_height = 0;
    int form_view_height = 0;
    std::vector<FormField> form_fields;
    std::vector<FormLayoutItem> form_layout;

    std::jthread run_thread;
    std::atomic<bool> running{false};
    std::atomic<bool> cancel_requested{false};
    std::atomic<bool> paused{false};
    uint64_t target = 0;

    std::mutex monitor_mu;
    std::shared_ptr<ConsoleStatsMonitor> gui_monitor;
};

int form_first_focusable_key(const GuiAppState* state);
void form_set_focused_field(GuiAppState* state, int field_key, bool ensure_visible);

#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstringop-overread"
#endif

std::wstring utf8_to_wide(const std::string& s) {
    if (s.empty()) {
        return L"";
    }
    const int len = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, nullptr, 0);
    if (len <= 0) {
        return L"";
    }
    std::wstring out;
    out.resize(static_cast<size_t>(len));
    MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, out.data(), len);
    out.resize(static_cast<size_t>(len - 1));
    return out;
}

std::string wide_to_utf8(const std::wstring& ws) {
    if (ws.empty()) {
        return "";
    }
    const int len = WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, nullptr, 0, nullptr, nullptr);
    if (len <= 0) {
        return "";
    }
    std::string out;
    out.resize(static_cast<size_t>(len));
    WideCharToMultiByte(CP_UTF8, 0, ws.c_str(), -1, out.data(), len, nullptr, nullptr);
    out.resize(static_cast<size_t>(len - 1));
    return out;
}

#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif

std::wstring get_text(HWND h) {
    const int len = GetWindowTextLengthW(h);
    std::wstring text(static_cast<size_t>(len) + 1, L'\0');
    GetWindowTextW(h, text.data(), len + 1);
    text.resize(static_cast<size_t>(len));
    return text;
}

void set_text(HWND h, const std::wstring& value) {
    SetWindowTextW(h, value.c_str());
}

int parse_int_text_or_default(const std::wstring& text, int fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return std::stoi(text);
    } catch (...) {
        return fallback;
    }
}

uint64_t parse_u64_text_or_default(const std::wstring& text, uint64_t fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return static_cast<uint64_t>(std::stoull(text));
    } catch (...) {
        return fallback;
    }
}

long long parse_i64_text_or_default(const std::wstring& text, long long fallback) {
    if (text.empty()) {
        return fallback;
    }
    try {
        return static_cast<long long>(std::stoll(text));
    } catch (...) {
        return fallback;
    }
}

FormField* find_form_field(GuiAppState* state, int key) {
    if (state == nullptr) {
        return nullptr;
    }
    for (auto& field : state->form_fields) {
        if (field.key == key) {
            return &field;
        }
    }
    return nullptr;
}

const FormField* find_form_field(const GuiAppState* state, int key) {
    if (state == nullptr) {
        return nullptr;
    }
    for (const auto& field : state->form_fields) {
        if (field.key == key) {
            return &field;
        }
    }
    return nullptr;
}

std::wstring form_field_text(const GuiAppState* state, int key, const std::wstring& fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr || field->text.empty()) {
        return fallback;
    }
    return field->text;
}

int form_field_int(const GuiAppState* state, int key, int fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_int_text_or_default(field->text, fallback);
}

uint64_t form_field_u64(const GuiAppState* state, int key, uint64_t fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_u64_text_or_default(field->text, fallback);
}

long long form_field_i64(const GuiAppState* state, int key, long long fallback) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return parse_i64_text_or_default(field->text, fallback);
}

int form_field_combo_index(const GuiAppState* state, int key, int fallback = 0) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return field->option_index;
}

bool form_field_checked(const GuiAppState* state, int key, bool fallback = false) {
    const FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return fallback;
    }
    return field->checked;
}

void set_form_field_text(GuiAppState* state, int key, const std::wstring& value) {
    FormField* field = find_form_field(state, key);
    if (field != nullptr) {
        field->text = value;
    }
}

void set_form_field_combo_index(GuiAppState* state, int key, int index) {
    FormField* field = find_form_field(state, key);
    if (field == nullptr) {
        return;
    }
    if (field->options.empty()) {
        field->option_index = 0;
        return;
    }
    field->option_index = std::clamp(index, 0, static_cast<int>(field->options.size()) - 1);
}

void set_form_field_checked(GuiAppState* state, int key, bool checked) {
    FormField* field = find_form_field(state, key);
    if (field != nullptr) {
        field->checked = checked;
    }
}

struct RequiredStrategyUiEntry {
    RequiredStrategy strategy = RequiredStrategy::None;
    const wchar_t* label = L"";
};

struct DifficultyUiEntry {
    int level = 1;
    const wchar_t* label = L"";
};

inline const std::vector<DifficultyUiEntry>& difficulty_ui_catalog() {
    static const std::vector<DifficultyUiEntry> entries = {
        {1, L"1 - Naked/Hidden Single"},
        {2, L"2 - Pointing / Box-Line"},
        {3, L"3 - Pairs/Triples"},
        {4, L"4 - Wings/Fishes basic"},
        {5, L"5 - Swordfish/FinnedXW/Coloring"},
        {6, L"6 - Jellyfish/Chains/ALS"},
        {7, L"7 - Medusa/AIC/Sue de Coq"},
        {8, L"8 - MSLS/Exocet/Forcing Chains"},
        {9, L"9 - Backtracking/Brutalny (max_clues=L1)"},
    };
    return entries;
}

inline int difficulty_level_from_form(const GuiAppState* state) {
    const FormField* field = find_form_field(state, F_DIFFICULTY);
    if (field == nullptr) {
        return 1;
    }
    const int sel = std::clamp(field->option_index, 0, std::max(0, static_cast<int>(field->options.size()) - 1));
    if (!field->option_payload.empty() && sel >= 0 && sel < static_cast<int>(field->option_payload.size())) {
        return std::clamp(field->option_payload[static_cast<size_t>(sel)], 1, 9);
    }
    return std::clamp(sel + 1, 1, 9);
}

inline void refresh_difficulty_options(GuiAppState* state, bool keep_selection = true) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, F_DIFFICULTY);
    if (field == nullptr || field->type != FormFieldType::Combo) {
        return;
    }
    const int prev = keep_selection ? difficulty_level_from_form(state) : 1;
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));

    field->options.clear();
    field->option_payload.clear();
    for (const auto& entry : difficulty_ui_catalog()) {
        if (!difficulty_level_selectable_for_geometry(entry.level, box_rows, box_cols)) {
            continue;
        }
        field->options.push_back(entry.label);
        field->option_payload.push_back(entry.level);
    }
    if (field->options.empty()) {
        field->options.push_back(L"1 - Naked/Hidden Single");
        field->option_payload.push_back(1);
    }
    int next_index = 0;
    for (int i = 0; i < static_cast<int>(field->option_payload.size()); ++i) {
        if (field->option_payload[static_cast<size_t>(i)] == prev) {
            next_index = i;
            break;
        }
    }
    field->option_index = std::clamp(next_index, 0, static_cast<int>(field->options.size()) - 1);
}

inline const std::vector<RequiredStrategyUiEntry>& required_strategy_ui_catalog() {
    static const std::vector<RequiredStrategyUiEntry> entries = {
        {RequiredStrategy::None, L"(brak)"},
        {RequiredStrategy::NakedSingle, L"Naked Single"},
        {RequiredStrategy::HiddenSingle, L"Hidden Single"},
        {RequiredStrategy::PointingPairs, L"Pointing Pairs/Triples"},
        {RequiredStrategy::BoxLineReduction, L"Box/Line Reduction"},
        {RequiredStrategy::NakedPair, L"Naked Pair"},
        {RequiredStrategy::HiddenPair, L"Hidden Pair"},
        {RequiredStrategy::NakedTriple, L"Naked Triple"},
        {RequiredStrategy::HiddenTriple, L"Hidden Triple"},
        {RequiredStrategy::NakedQuad, L"Naked Quad"},
        {RequiredStrategy::HiddenQuad, L"Hidden Quad"},
        {RequiredStrategy::XWing, L"X-Wing"},
        {RequiredStrategy::YWing, L"Y-Wing"},
        {RequiredStrategy::Skyscraper, L"Skyscraper"},
        {RequiredStrategy::TwoStringKite, L"2-String Kite"},
        {RequiredStrategy::EmptyRectangle, L"Empty Rectangle"},
        {RequiredStrategy::RemotePairs, L"Remote Pairs"},
        {RequiredStrategy::Swordfish, L"Swordfish"},
        {RequiredStrategy::FinnedXWingSashimi, L"Finned X-Wing/Sashimi"},
        {RequiredStrategy::SimpleColoring, L"Simple Coloring"},
        {RequiredStrategy::BUGPlusOne, L"BUG+1"},
        {RequiredStrategy::UniqueRectangle, L"Unique Rectangle"},
        {RequiredStrategy::XYZWing, L"XYZ-Wing"},
        {RequiredStrategy::WWing, L"W-Wing"},
        {RequiredStrategy::Jellyfish, L"Jellyfish"},
        {RequiredStrategy::XChain, L"X-Chain"},
        {RequiredStrategy::XYChain, L"XY-Chain"},
        {RequiredStrategy::WXYZWing, L"WXYZ-Wing"},
        {RequiredStrategy::FinnedSwordfishJellyfish, L"Finned Swordfish/Jellyfish"},
        {RequiredStrategy::ALSXZ, L"ALS-XZ"},
        {RequiredStrategy::UniqueLoop, L"Unique Loop"},
        {RequiredStrategy::AvoidableRectangle, L"Avoidable Rectangle"},
        {RequiredStrategy::BivalueOddagon, L"Bivalue Oddagon"},
        {RequiredStrategy::UniqueRectangleExtended, L"UR Extended (Type 2-6)"},
        {RequiredStrategy::HiddenUniqueRectangle, L"Hidden UR"},
        {RequiredStrategy::BUGType2, L"BUG Type 2"},
        {RequiredStrategy::BUGType3, L"BUG Type 3"},
        {RequiredStrategy::BUGType4, L"BUG Type 4"},
        {RequiredStrategy::BorescoperQiuDeadlyPattern, L"Borescoper/Qiu Deadly"},
        {RequiredStrategy::Medusa3D, L"3D Medusa"},
        {RequiredStrategy::AIC, L"AIC"},
        {RequiredStrategy::GroupedAIC, L"Grouped AIC"},
        {RequiredStrategy::GroupedXCycle, L"Grouped X-Cycle"},
        {RequiredStrategy::ContinuousNiceLoop, L"Continuous Nice Loop"},
        {RequiredStrategy::ALSXYWing, L"ALS-XY-Wing"},
        {RequiredStrategy::ALSChain, L"ALS-Chain"},
        {RequiredStrategy::AlignedPairExclusion, L"Aligned Pair Exclusion"},
        {RequiredStrategy::AlignedTripleExclusion, L"Aligned Triple Exclusion"},
        {RequiredStrategy::ALSAIC, L"ALS-AIC"},
        {RequiredStrategy::SueDeCoq, L"Sue de Coq"},
        {RequiredStrategy::DeathBlossom, L"Death Blossom"},
        {RequiredStrategy::FrankenFish, L"Franken Fish"},
        {RequiredStrategy::MutantFish, L"Mutant Fish"},
        {RequiredStrategy::KrakenFish, L"Kraken Fish"},
        {RequiredStrategy::Squirmbag, L"Squirmbag / Starfish"},
        {RequiredStrategy::MSLS, L"MSLS"},
        {RequiredStrategy::Exocet, L"Exocet"},
        {RequiredStrategy::SeniorExocet, L"Senior Exocet"},
        {RequiredStrategy::SKLoop, L"SK Loop"},
        {RequiredStrategy::PatternOverlayMethod, L"Pattern Overlay Method"},
        {RequiredStrategy::ForcingChains, L"Forcing Chains"},
        {RequiredStrategy::DynamicForcingChains, L"Dynamic Forcing Chains"},
        {RequiredStrategy::Backtracking, L"Backtracking"},
    };
    return entries;
}

inline RequiredStrategy required_strategy_from_form(const GuiAppState* state) {
    const FormField* field = find_form_field(state, F_REQUIRED_STRATEGY);
    if (field == nullptr) {
        return RequiredStrategy::None;
    }
    const int sel = std::clamp(field->option_index, 0, std::max(0, static_cast<int>(field->options.size()) - 1));
    if (!field->option_payload.empty() && sel >= 0 && sel < static_cast<int>(field->option_payload.size())) {
        return static_cast<RequiredStrategy>(field->option_payload[static_cast<size_t>(sel)]);
    }
    return RequiredStrategy::None;
}

inline void refresh_required_strategy_options(GuiAppState* state, bool keep_selection = true) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, F_REQUIRED_STRATEGY);
    if (field == nullptr || field->type != FormFieldType::Combo) {
        return;
    }
    const RequiredStrategy prev = keep_selection ? required_strategy_from_form(state) : RequiredStrategy::None;
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));

    field->options.clear();
    field->option_payload.clear();
    for (const auto& entry : required_strategy_ui_catalog()) {
        if (entry.strategy != RequiredStrategy::None &&
            !required_strategy_selectable_for_geometry(entry.strategy, box_rows, box_cols)) {
            continue;
        }
        field->options.push_back(entry.label);
        field->option_payload.push_back(static_cast<int>(entry.strategy));
    }
    if (field->options.empty()) {
        field->options.push_back(L"(brak)");
        field->option_payload.push_back(static_cast<int>(RequiredStrategy::None));
    }

    int next_index = 0;
    if (keep_selection) {
        for (int i = 0; i < static_cast<int>(field->option_payload.size()); ++i) {
            if (field->option_payload[static_cast<size_t>(i)] == static_cast<int>(prev)) {
                next_index = i;
                break;
            }
        }
    }
    field->option_index = std::clamp(next_index, 0, static_cast<int>(field->options.size()) - 1);
}

void init_form_model(GuiAppState* state) {
    state->form_fields.clear();
    state->form_layout.clear();
    auto add_field = [&](FormField field) {
        state->form_fields.push_back(std::move(field));
    };
    auto add_layout_field = [&](int key) {
        FormLayoutItem it;
        it.field_key = key;
        state->form_layout.push_back(it);
    };
    auto add_section = [&](const wchar_t* title) {
        FormLayoutItem it;
        it.is_section = true;
        it.section_title = title;
        state->form_layout.push_back(std::move(it));
    };
    auto make_field = [](int key, FormFieldType type, const wchar_t* label, const wchar_t* text) {
        FormField f;
        f.key = key;
        f.type = type;
        f.label = label;
        f.text = text;
        return f;
    };

    add_field(make_field(F_BOX_ROWS, FormFieldType::Int, L"box_rows:", L"3"));
    add_field(make_field(F_BOX_COLS, FormFieldType::Int, L"box_cols:", L"3"));
    add_field(make_field(F_TARGET_PUZZLES, FormFieldType::Int, L"target_puzzles:", L"100"));
    add_field(make_field(F_MIN_CLUES, FormFieldType::Int, L"min_clues (0=auto, można nadpisać):", L"0"));
    add_field(make_field(F_MAX_CLUES, FormFieldType::Int, L"max_clues (0=auto, można nadpisać):", L"0"));

    FormField difficulty;
    difficulty.key = F_DIFFICULTY;
    difficulty.type = FormFieldType::Combo;
    difficulty.label = L"difficulty_level_required:";
    difficulty.options.clear();
    difficulty.option_payload.clear();
    difficulty.option_index = 0;
    add_field(std::move(difficulty));

    FormField preset;
    preset.key = F_CLUES_PRESET;
    preset.type = FormFieldType::ActionButton;
    preset.label = L"clues_preset:";
    preset.text = L"Auto (wg difficulty + rozmiaru)";
    add_field(std::move(preset));

    add_field(make_field(F_THREADS, FormFieldType::Int, L"threads (0=auto):", L"0"));
    add_field(make_field(F_SEED, FormFieldType::Int, L"seed (0=random):", L"0"));
    add_field(make_field(F_RESEED_INTERVAL, FormFieldType::Int, L"reseed_interval_s (0=off, full worker reset):", L"0"));
    FormField force_seed;
    force_seed.key = F_FORCE_NEW_SEED;
    force_seed.type = FormFieldType::Checkbox;
    force_seed.label = L"Force new seed per attempt";
    force_seed.checked = true;
    add_field(std::move(force_seed));
    add_field(make_field(F_ATTEMPT_TIME_BUDGET, FormFieldType::Int, L"attempt_time_budget_s (0=brak limitu):", L"0"));
    add_field(make_field(F_ATTEMPT_NODE_BUDGET, FormFieldType::Int, L"attempt_node_budget (0=brak limitu):", L"0"));
    add_field(make_field(F_MAX_ATTEMPTS, FormFieldType::Int, L"max_attempts (0=bez limitu):", L"0"));
    add_field(make_field(F_MAX_TOTAL_TIME, FormFieldType::Int, L"max_total_time_s (0=bez limitu, CAŁE URUCHOMIENIE):", L"0"));

    FormField strategy;
    strategy.key = F_REQUIRED_STRATEGY;
    strategy.type = FormFieldType::Combo;
    strategy.label = L"required_strategy (opcjonalnie):";
    strategy.options.clear();
    strategy.option_payload.clear();
    strategy.option_index = 0;
    add_field(std::move(strategy));

    FormField out_folder;
    out_folder.key = F_OUTPUT_FOLDER;
    out_folder.type = FormFieldType::Text;
    out_folder.label = L"output_folder:";
    out_folder.text = L"generated_sudoku_files";
    out_folder.has_browse = true;
    add_field(std::move(out_folder));

    FormField out_file;
    out_file.key = F_OUTPUT_FILE;
    out_file.type = FormFieldType::Text;
    out_file.label = L"output_file:";
    out_file.text = L"generated_sudoku.txt";
    out_file.has_browse = true;
    add_field(std::move(out_file));

    FormField symmetry;
    symmetry.key = F_SYMMETRY_CENTER;
    symmetry.type = FormFieldType::Checkbox;
    symmetry.label = L"symmetry_center";
    symmetry.checked = false;
    add_field(std::move(symmetry));

    FormField unique;
    unique.key = F_REQUIRE_UNIQUE;
    unique.type = FormFieldType::Checkbox;
    unique.label = L"require_unique (wymuszone)";
    unique.checked = true;
    unique.enabled = false;
    add_field(std::move(unique));

    FormField show_monitor;
    show_monitor.key = F_SHOW_MONITOR;
    show_monitor.type = FormFieldType::Checkbox;
    show_monitor.label = L"live monitor (GUI+console)";
    show_monitor.checked = true;
    add_field(std::move(show_monitor));

    add_section(L"Podstawowe parametry");
    add_layout_field(F_BOX_ROWS);
    add_layout_field(F_BOX_COLS);
    add_layout_field(F_TARGET_PUZZLES);
    add_layout_field(F_MIN_CLUES);
    add_layout_field(F_MAX_CLUES);
    add_layout_field(F_DIFFICULTY);
    add_layout_field(F_CLUES_PRESET);

    add_section(L"Ustawienia zaawansowane / silnika");
    add_layout_field(F_THREADS);
    add_layout_field(F_SEED);
    add_layout_field(F_RESEED_INTERVAL);
    add_layout_field(F_FORCE_NEW_SEED);
    add_layout_field(F_ATTEMPT_TIME_BUDGET);
    add_layout_field(F_ATTEMPT_NODE_BUDGET);
    add_layout_field(F_MAX_ATTEMPTS);
    add_layout_field(F_MAX_TOTAL_TIME);  // Globalny limit czasu
    add_layout_field(F_REQUIRED_STRATEGY);

    add_section(L"Zapis i eksport");
    add_layout_field(F_OUTPUT_FOLDER);
    add_layout_field(F_OUTPUT_FILE);
    add_layout_field(F_SYMMETRY_CENTER);
    add_layout_field(F_SHOW_MONITOR);

    refresh_difficulty_options(state, false);
    refresh_required_strategy_options(state, false);
}

void append_log(GuiAppState* state, const std::wstring& line) {
    if (state == nullptr || state->h_log == nullptr) {
        return;
    }
    const int len = GetWindowTextLengthW(state->h_log);
    SendMessageW(state->h_log, EM_SETSEL, len, len);
    std::wstring text = line + L"\r\n";
    SendMessageW(state->h_log, EM_REPLACESEL, FALSE, reinterpret_cast<LPARAM>(text.c_str()));
}

void set_monitor_text(GuiAppState* state, const std::wstring& text) {
    if (state == nullptr || state->h_monitor == nullptr) {
        return;
    }
    set_text(state->h_monitor, text);
}

void post_log(HWND hwnd, const std::wstring& line) {
    auto* payload = new std::wstring(line);
    PostMessageW(hwnd, WM_APP_LOG, 0, reinterpret_cast<LPARAM>(payload));
}

bool browse_for_folder(HWND owner, std::wstring& out_path) {
    BROWSEINFOW bi{};
    wchar_t display_name[MAX_PATH]{};
    bi.hwndOwner = owner;
    bi.pszDisplayName = display_name;
    bi.lpszTitle = L"Wybierz folder wyjsciowy";
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
    PIDLIST_ABSOLUTE pidl = SHBrowseForFolderW(&bi);
    if (pidl == nullptr) {
        return false;
    }
    wchar_t path[MAX_PATH]{};
    const BOOL ok = SHGetPathFromIDListW(pidl, path);
    CoTaskMemFree(pidl);
    if (!ok) {
        return false;
    }
    out_path = path;
    return true;
}

bool browse_for_save_file(HWND owner, std::wstring& out_path) {
    wchar_t file_buffer[MAX_PATH] = L"generated_sudoku.txt";
    OPENFILENAMEW ofn{};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = owner;
    ofn.lpstrFile = file_buffer;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFilter = L"Text Files\0*.txt\0All Files\0*.*\0";
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = L"txt";
    if (!GetSaveFileNameW(&ofn)) {
        return false;
    }
    out_path = file_buffer;
    return true;
}

void apply_clues_preset(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    const int box_rows = std::max(1, form_field_int(state, F_BOX_ROWS, 3));
    const int box_cols = std::max(1, form_field_int(state, F_BOX_COLS, 3));
    const int lvl = difficulty_level_from_form(state);
    const RequiredStrategy required = required_strategy_from_form(state);
    const int effective_budget_level = strategy_adjusted_level(lvl, required);
    const bool unlimited_by_default = (effective_budget_level >= 3);
    const ClueRange range = resolve_auto_clue_range(box_rows, box_cols, lvl, required);
    const int min_clues = range.min_clues;
    const int max_clues = range.max_clues;
    const int suggested_reseed_s = suggest_reseed_interval_s(box_rows, box_cols, effective_budget_level);
    const int suggested_attempt_time_s = suggest_attempt_time_budget_seconds(box_rows, box_cols, effective_budget_level);
    const uint64_t suggested_attempt_nodes = suggest_attempt_node_budget(box_rows, box_cols, effective_budget_level);

    set_form_field_text(state, F_MIN_CLUES, std::to_wstring(min_clues));
    set_form_field_text(state, F_MAX_CLUES, std::to_wstring(max_clues));
    set_form_field_text(state, F_RESEED_INTERVAL, std::to_wstring(suggested_reseed_s));
    set_form_field_text(state, F_ATTEMPT_TIME_BUDGET, unlimited_by_default ? L"0" : std::to_wstring(suggested_attempt_time_s));
    set_form_field_text(state, F_ATTEMPT_NODE_BUDGET, unlimited_by_default ? L"0" : std::to_wstring(suggested_attempt_nodes));
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
    append_log(
        state,
        L"Preset: clues=" + std::to_wstring(min_clues) + L"-" + std::to_wstring(max_clues) +
            L", reseed=" + std::to_wstring(suggested_reseed_s) + L"s, attempt_time=" +
            (unlimited_by_default ? std::wstring(L"0(unlimited)") : std::to_wstring(suggested_attempt_time_s) + L"s") +
            L", attempt_nodes=" +
            (unlimited_by_default ? std::wstring(L"0(unlimited)") : std::to_wstring(suggested_attempt_nodes)) + L", budget_lvl=" +
            std::to_wstring(effective_budget_level));
}

void set_running_state(GuiAppState* state, bool running) {
    state->running.store(running, std::memory_order_relaxed);
    state->form_read_only = running;
    EnableWindow(state->h_start, running ? FALSE : TRUE);
    EnableWindow(state->h_cancel, running ? TRUE : FALSE);
    EnableWindow(state->h_pause, running ? TRUE : FALSE);
    if (state->h_form_panel != nullptr) {
        form_set_focused_field(state, form_first_focusable_key(state), false);
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool is_live_monitor_enabled(const GuiAppState* state) {
    if (state == nullptr) {
        return true;
    }
    return form_field_checked(state, F_SHOW_MONITOR, true);
}

bool read_config_from_form(GuiAppState* state, GenerateRunConfig& cfg, std::map<std::string, std::string>& dict) {
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    cfg.box_rows = form_field_int(state, F_BOX_ROWS, 3);
    cfg.box_cols = form_field_int(state, F_BOX_COLS, 3);
    cfg.target_puzzles = form_field_u64(state, F_TARGET_PUZZLES, 100);
    cfg.difficulty_level_required = difficulty_level_from_form(state);
    cfg.required_strategy = required_strategy_from_form(state);
    const int min_clues_input = form_field_int(state, F_MIN_CLUES, 0);
    const int max_clues_input = form_field_int(state, F_MAX_CLUES, 0);
    const ClueRange auto_clues = resolve_auto_clue_range(
        cfg.box_rows,
        cfg.box_cols,
        cfg.difficulty_level_required,
        cfg.required_strategy);
    cfg.min_clues = (min_clues_input > 0) ? min_clues_input : auto_clues.min_clues;
    cfg.max_clues = (max_clues_input > 0) ? max_clues_input : auto_clues.max_clues;
    cfg.threads = form_field_int(state, F_THREADS, 0);
    cfg.seed = form_field_i64(state, F_SEED, 0);
    cfg.reseed_interval_s = form_field_int(state, F_RESEED_INTERVAL, 0);
    cfg.force_new_seed_per_attempt = form_field_checked(state, F_FORCE_NEW_SEED, true);
    cfg.attempt_time_budget_s = static_cast<double>(form_field_u64(state, F_ATTEMPT_TIME_BUDGET, 0));
    cfg.attempt_node_budget = form_field_u64(state, F_ATTEMPT_NODE_BUDGET, 0);
    cfg.max_attempts = form_field_u64(state, F_MAX_ATTEMPTS, 0);
    cfg.max_total_time_s = form_field_u64(state, F_MAX_TOTAL_TIME, 0);  // Globalny limit czasu
    cfg.symmetry_center = form_field_checked(state, F_SYMMETRY_CENTER, false);
    cfg.require_unique = true;
    cfg.write_individual_files = true;
    cfg.output_folder = wide_to_utf8(form_field_text(state, F_OUTPUT_FOLDER, L"generated_sudoku_files"));
    cfg.output_file = wide_to_utf8(form_field_text(state, F_OUTPUT_FILE, L"generated_sudoku.txt"));
    cfg.pause_on_exit_windows = false;

    if (cfg.box_rows <= 0 || cfg.box_cols <= 0) {
        MessageBoxW(state->hwnd, L"box_rows i box_cols musza byc > 0", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "box_rows/box_cols must be > 0");
        return false;
    }
    if (!difficulty_level_selectable_for_geometry(cfg.difficulty_level_required, cfg.box_rows, cfg.box_cols)) {
        MessageBoxW(
            state->hwnd,
            L"Wybrany poziom trudnosci nie jest jeszcze dostepny runtime dla tej geometrii.",
            L"Walidacja",
            MB_ICONWARNING);
        log_warn("gui.validation", "difficulty level not selectable for geometry");
        return false;
    }
    if (!required_strategy_selectable_for_geometry(cfg.required_strategy, cfg.box_rows, cfg.box_cols)) {
        MessageBoxW(
            state->hwnd,
            L"required_strategy nie jest dostepna dla tej geometrii.",
            L"Walidacja",
            MB_ICONWARNING);
        log_warn("gui.validation", "required_strategy not selectable for geometry");
        return false;
    }
    if (cfg.max_clues < cfg.min_clues) {
        MessageBoxW(state->hwnd, L"max_clues musi byc >= min_clues", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "max_clues must be >= min_clues");
        return false;
    }
    if (cfg.target_puzzles == 0) {
        MessageBoxW(state->hwnd, L"target_puzzles musi byc > 0", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "target_puzzles must be > 0");
        return false;
    }
    const int n = cfg.box_rows * cfg.box_cols;
    const int nn = n * n;
    cfg.min_clues = std::clamp(cfg.min_clues, 0, nn);
    cfg.max_clues = std::clamp(cfg.max_clues, cfg.min_clues, nn);
    if (cfg.output_folder.empty() || cfg.output_file.empty()) {
        MessageBoxW(state->hwnd, L"output_folder i output_file nie moga byc puste", L"Walidacja", MB_ICONWARNING);
        log_warn("gui.validation", "output_folder/output_file cannot be empty");
        return false;
    }

    dict["box_rows"] = std::to_string(cfg.box_rows);
    dict["box_cols"] = std::to_string(cfg.box_cols);
    dict["target_puzzles"] = std::to_string(cfg.target_puzzles);
    dict["min_clues"] = std::to_string(cfg.min_clues);
    dict["max_clues"] = std::to_string(cfg.max_clues);
    dict["difficulty_level_required"] = std::to_string(cfg.difficulty_level_required);
    dict["required_strategy"] = to_string(cfg.required_strategy);
    dict["threads"] = std::to_string(cfg.threads);
    dict["seed"] = std::to_string(cfg.seed);
    dict["reseed_interval_s"] = std::to_string(cfg.reseed_interval_s);
    dict["force_new_seed_per_attempt"] = cfg.force_new_seed_per_attempt ? "true" : "false";
    dict["attempt_time_budget_s"] = std::to_string(static_cast<int>(cfg.attempt_time_budget_s));
    dict["attempt_node_budget_s"] = std::to_string(cfg.attempt_node_budget);
    dict["max_attempts"] = std::to_string(cfg.max_attempts);
    dict["max_total_time_s"] = std::to_string(cfg.max_total_time_s);  // Globalny limit czasu
    dict["symmetry_center"] = cfg.symmetry_center ? "true" : "false";
    dict["require_unique"] = "true";
    dict["output_folder"] = cfg.output_folder;
    dict["output_file"] = cfg.output_file;
    return true;
}

void toggle_pause(GuiAppState* state);
void start_generation(GuiAppState* state);
void cancel_generation(GuiAppState* state);

void start_generation(GuiAppState* state) {
    if (state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.start_generation", "ignored start while already running");
        return;
    }
    GenerateRunConfig cfg;
    std::map<std::string, std::string> dict;
    if (!read_config_from_form(state, cfg, dict)) {
        log_warn("gui.start_generation", "read_config_from_form failed");
        return;
    }

    std::cout << "start_generation() form values:\n";
    for (const auto& [k, v] : dict) {
        std::cout << "  " << k << " = " << v << "\n";
    }
    
    // Show suggestions for profile and currently configured attempt budgets.
    const double suggested_time = suggest_time_budget_s(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required);
    const ClueRange suggested_clues = resolve_auto_clue_range(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy);
    
    std::wcout << L"\n[SUGESTIA] Dla rozmiaru " << (cfg.box_rows * cfg.box_cols) << L"x" << (cfg.box_rows * cfg.box_cols) << L":\n";
    std::wcout << L"  attempt_time_budget_s: sugerowane=" << static_cast<int>(std::ceil(suggested_time))
               << L"s, ustawione=" << static_cast<int>(cfg.attempt_time_budget_s) << L"s\n";
    std::wcout << L"  min_clues: sugerowane=" << suggested_clues.min_clues << L", ustawione=" << cfg.min_clues << L"\n";
    std::wcout << L"  max_clues: sugerowane=" << suggested_clues.max_clues << L", ustawione=" << cfg.max_clues << L"\n\n";
    
    append_log(state, L"Start generation...");
    log_info(
        "gui.start_generation",
        "start target=" + std::to_string(cfg.target_puzzles) +
            " level=" + std::to_string(cfg.difficulty_level_required) +
            " required=" + to_string(cfg.required_strategy) +
            " threads=" + std::to_string(cfg.threads) +
            " suggested_time_budget=" + std::to_string(suggested_time) +
            " suggested_clues=" + std::to_string(suggested_clues.min_clues) + "-" + std::to_string(suggested_clues.max_clues));
    for (const auto& [k, v] : dict) {
        append_log(state, utf8_to_wide(k + "=" + v));
    }

    state->target = cfg.target_puzzles;
    SendMessageW(state->h_progress, PBM_SETRANGE32, 0, static_cast<LPARAM>(std::min<uint64_t>(cfg.target_puzzles, 0x7fffffffULL)));
    SendMessageW(state->h_progress, PBM_SETPOS, 0, 0);
    set_text(state->h_progress_text, L"Wygenerowano 0/" + std::to_wstring(cfg.target_puzzles));
    state->cancel_requested.store(false, std::memory_order_relaxed);
    state->paused.store(false, std::memory_order_relaxed);
    SetWindowTextW(state->h_pause, L"Pauza");
    set_running_state(state, true);
    SetTimer(state->hwnd, IDT_MONITOR_REFRESH, 500, nullptr);
    set_monitor_text(state, L"Monitor start...");
    const bool live_monitor_on = is_live_monitor_enabled(state);
    EnableWindow(state->h_monitor, live_monitor_on ? TRUE : FALSE);
    if (!live_monitor_on) {
        set_monitor_text(state, L"Live monitor: OFF");
    }

    state->run_thread = std::jthread([state, cfg, live_monitor_on]() {
        auto monitor = std::make_shared<ConsoleStatsMonitor>();
        monitor->start_ui_thread(5000);
        {
            std::lock_guard<std::mutex> lock(state->monitor_mu);
            state->gui_monitor = monitor;
        }
        GenerateRunResult result = run_generic_sudoku(
            cfg,
            monitor.get(),
            &state->cancel_requested,
            &state->paused,
            [hwnd = state->hwnd](uint64_t accepted, uint64_t target) {
                PostMessageW(hwnd, WM_APP_PROGRESS, static_cast<WPARAM>(accepted), static_cast<LPARAM>(target));
            },
            [hwnd = state->hwnd](const std::string& msg) {
                post_log(hwnd, utf8_to_wide(msg));
            });
        log_info(
            "gui.run_thread",
            "run done accepted=" + std::to_string(result.accepted) +
                " written=" + std::to_string(result.written) +
                " attempts=" + std::to_string(result.attempts));
        monitor->stop_ui_thread();
        {
            std::lock_guard<std::mutex> lock(state->monitor_mu);
            state->gui_monitor.reset();
        }
        auto* payload = new GenerateRunResult(result);
        PostMessageW(state->hwnd, WM_APP_DONE, reinterpret_cast<WPARAM>(payload), 0);
    });
}

void publish_cli_status(GuiAppState* state, const std::string& status) {
    if (state == nullptr) {
        return;
    }
    std::shared_ptr<ConsoleStatsMonitor> monitor;
    {
        std::lock_guard<std::mutex> lock(state->monitor_mu);
        monitor = state->gui_monitor;
    }
    if (monitor != nullptr) {
        monitor->set_background_status(status);
    }
}

void cancel_generation(GuiAppState* state) {
    if (!state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.cancel_generation", "cancel ignored - not running");
        return;
    }
    state->cancel_requested.store(true, std::memory_order_relaxed);
    state->paused.store(false, std::memory_order_relaxed);
    SetWindowTextW(state->h_pause, L"Pauza");
    publish_cli_status(state, "Generowanie: cancel requested");
    log_info("gui.cancel_generation", "cancel requested - waiting for workers to finish");
    append_log(state, L"Anulowanie... czekam na zakonczenie workerow.");
}

void toggle_pause(GuiAppState* state) {
    if (!state->running.load(std::memory_order_relaxed)) {
        log_warn("gui.toggle_pause", "pause ignored - not running");
        return;
    }
    const bool new_paused = !state->paused.load(std::memory_order_relaxed);
    state->paused.store(new_paused, std::memory_order_relaxed);
    if (new_paused) {
        append_log(state, L"Pauza - generowanie wstrzymane");
        SetWindowTextW(state->h_pause, L"Wznow");
        publish_cli_status(state, "Generowanie: paused");
        log_info("gui.toggle_pause", "PAUSED - all workers will sleep");
    } else {
        append_log(state, L"Wznowienie - kontynuacja generowania");
        SetWindowTextW(state->h_pause, L"Pauza");
        publish_cli_status(state, "Generowanie: resumed");
        log_info("gui.toggle_pause", "RESUMED - workers continue processing");
    }
}

// 
void sync_live_monitor_visual_state(GuiAppState* state) {
    if (state == nullptr || state->h_monitor == nullptr) {
        return;
    }
    const bool on = is_live_monitor_enabled(state);
    EnableWindow(state->h_monitor, on ? TRUE : FALSE);
    if (!on) {
        set_monitor_text(state, L"Live monitor: OFF");
    } else if (!state->running.load(std::memory_order_relaxed)) {
        append_log(state, L"Live monitor: ON");
    }
}

void form_update_scrollbar(GuiAppState* state) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    RECT rc{};
    GetClientRect(state->h_form_panel, &rc);
    const int view_h = std::max(1, static_cast<int>(rc.bottom - rc.top));
    state->form_view_height = view_h;
    const int max_scroll = std::max(0, state->form_content_height - view_h);
    state->form_scroll_y = std::clamp(state->form_scroll_y, 0, max_scroll);
    SCROLLINFO si{};
    si.cbSize = sizeof(si);
    si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
    si.nMin = 0;
    si.nMax = std::max(0, state->form_content_height - 1);
    si.nPage = static_cast<UINT>(view_h);
    si.nPos = state->form_scroll_y;
    SetScrollInfo(state->h_form_panel, SB_VERT, &si, TRUE);
}

void form_layout_fields(GuiAppState* state) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    RECT client{};
    GetClientRect(state->h_form_panel, &client);
    const int client_w = std::max(1, static_cast<int>(client.right - client.left));
    const int margin = 14;
    const int row_h = 26;
    const int row_gap = 8;
    const int section_h = 28;
    const int label_w = std::clamp(client_w / 2 - 20, 210, 430);
    const int value_x = margin + label_w + 10;
    const int browse_w = 28;
    const int value_w = std::max(160, client_w - value_x - margin);

    for (auto& field : state->form_fields) {
        field.label_rect = RECT{};
        field.value_rect = RECT{};
        field.browse_rect = RECT{};
    }

    int y = margin;
    FormLayoutItem* current_section = nullptr;
    for (auto& item : state->form_layout) {
        if (item.is_section) {
            item.section_rect = RECT{margin - 4, y + 10, client_w - margin + 4, y + 34};
            current_section = &item;
            y += section_h;
            continue;
        }
        FormField* field = find_form_field(state, item.field_key);
        if (field == nullptr) {
            continue;
        }
        if (item.field_key == F_SYMMETRY_CENTER) {
            FormField* req_unique = find_form_field(state, F_REQUIRE_UNIQUE);
            const int half_w = std::max(220, (client_w - margin * 2 - 24) / 2);
            field->value_rect = RECT{margin + 2, y, margin + 2 + half_w, y + row_h};
            if (req_unique != nullptr) {
                req_unique->value_rect = RECT{margin + 14 + half_w, y, margin + 14 + half_w + half_w, y + row_h};
            }
            if (current_section != nullptr) {
                current_section->section_rect.bottom =
                    std::max(current_section->section_rect.bottom, static_cast<LONG>(y + row_h + 12));
            }
            y += row_h + row_gap;
            continue;
        }

        field->label_rect = RECT{margin, y, margin + label_w, y + row_h};
        if (field->type == FormFieldType::Checkbox) {
            field->value_rect = RECT{margin + 2, y, margin + 2 + value_w, y + row_h};
        } else if (field->has_browse) {
            field->value_rect = RECT{value_x, y, value_x + value_w - (browse_w + 4), y + row_h};
            field->browse_rect = RECT{value_x + value_w - browse_w, y, value_x + value_w, y + row_h};
        } else {
            field->value_rect = RECT{value_x, y, value_x + value_w, y + row_h};
        }
        if (current_section != nullptr) {
            current_section->section_rect.bottom =
                std::max(current_section->section_rect.bottom, static_cast<LONG>(y + row_h + 12));
        }
        y += row_h + row_gap;
    }
    for (auto& item : state->form_layout) {
        if (item.is_section) {
            item.section_rect.bottom = std::max(item.section_rect.bottom, item.section_rect.top + 48);
        }
    }

    state->form_content_height = y + margin;
    form_update_scrollbar(state);
}

bool form_affects_clues_preset(int field_key);
void update_suggestions_for_grid_size(GuiAppState* state);

void form_destroy_inline_editor(GuiAppState* state, bool commit) {
    if (state == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, state->inline_field_key);
    int committed_field_key = 0;
    if (commit && field != nullptr) {
        if (state->inline_is_combo) {
            const int sel = static_cast<int>(SendMessageW(state->h_inline_editor, CB_GETCURSEL, 0, 0));
            if (sel >= 0 && sel < static_cast<int>(field->options.size())) {
                field->option_index = sel;
                committed_field_key = field->key;
            }
        } else {
            field->text = get_text(state->h_inline_editor);
            committed_field_key = field->key;
        }
    }
    DestroyWindow(state->h_inline_editor);
    state->h_inline_editor = nullptr;
    state->inline_field_key = 0;
    state->inline_is_combo = false;
    state->inline_close_posted = false;
    if (commit && !state->form_read_only && form_affects_clues_preset(committed_field_key)) {
        apply_clues_preset(state);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

void form_request_inline_close(GuiAppState* state, bool commit) {
    if (state == nullptr || state->h_form_panel == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    if (state->inline_close_posted) {
        return;
    }
    state->inline_close_posted = true;
    PostMessageW(state->h_form_panel, WM_APP_INLINE_CLOSE, commit ? 1 : 0, 0);
}

LRESULT CALLBACK form_inline_editor_subclass_proc(
    HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, UINT_PTR /*id*/, DWORD_PTR ref_data) {
    auto* state = reinterpret_cast<GuiAppState*>(ref_data);
    if (state != nullptr && msg == WM_KEYDOWN) {
        if (wParam == VK_TAB) {
            const bool back = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            form_request_inline_close(state, true);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, back ? static_cast<WPARAM>(0) : static_cast<WPARAM>(1), 0);
            return 0;
        }
        if (wParam == VK_ESCAPE) {
            form_request_inline_close(state, false);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, 0, 1);
            return 0;
        }
        if (!state->inline_is_combo && wParam == VK_RETURN) {
            form_request_inline_close(state, true);
            PostMessageW(state->h_form_panel, WM_APP_FORM_NAV, 0, 1);
            return 0;
        }
    }
    if (msg == WM_NCDESTROY) {
        RemoveWindowSubclass(hwnd, form_inline_editor_subclass_proc, IDSC_INLINE_EDITOR);
    }
    return DefSubclassProc(hwnd, msg, wParam, lParam);
}

void form_attach_inline_subclass(GuiAppState* state) {
    if (state == nullptr || state->h_inline_editor == nullptr) {
        return;
    }
    SetWindowSubclass(state->h_inline_editor, form_inline_editor_subclass_proc, IDSC_INLINE_EDITOR, reinterpret_cast<DWORD_PTR>(state));
}

RECT form_view_rect(const RECT& content_rect, int scroll_y) {
    RECT rc = content_rect;
    rc.top -= scroll_y;
    rc.bottom -= scroll_y;
    return rc;
}

void form_begin_inline_edit(GuiAppState* state, FormField* field) {
    if (state == nullptr || field == nullptr || state->h_form_panel == nullptr || state->form_read_only || !field->enabled) {
        return;
    }
    form_destroy_inline_editor(state, true);

    RECT rc = form_view_rect(field->value_rect, state->form_scroll_y);
    const DWORD style = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL |
                        ((field->type == FormFieldType::Int) ? ES_NUMBER : 0);
    state->h_inline_editor = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        field->text.c_str(),
        style,
        rc.left,
        rc.top,
        std::max(60, static_cast<int>(rc.right - rc.left)),
        std::max(22, static_cast<int>(rc.bottom - rc.top)),
        state->h_form_panel,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_INLINE_EDIT)),
        GetModuleHandleW(nullptr),
        nullptr);
    if (state->h_inline_editor != nullptr) {
        form_attach_inline_subclass(state);
        HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        SendMessageW(state->h_inline_editor, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        SendMessageW(state->h_inline_editor, EM_SETSEL, 0, -1);
        SetFocus(state->h_inline_editor);
        state->inline_field_key = field->key;
        state->inline_is_combo = false;
        state->inline_close_posted = false;
    }
}

void form_begin_inline_combo(GuiAppState* state, FormField* field) {
    if (state == nullptr || field == nullptr || state->h_form_panel == nullptr || state->form_read_only || !field->enabled) {
        return;
    }
    form_destroy_inline_editor(state, true);

    RECT rc = form_view_rect(field->value_rect, state->form_scroll_y);
    state->h_inline_editor = CreateWindowExW(
        0,
        L"COMBOBOX",
        nullptr,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | CBS_DROPDOWNLIST | WS_VSCROLL,
        rc.left,
        rc.top,
        std::max(120, static_cast<int>(rc.right - rc.left)),
        260,
        state->h_form_panel,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_INLINE_EDIT)),
        GetModuleHandleW(nullptr),
        nullptr);
    if (state->h_inline_editor != nullptr) {
        form_attach_inline_subclass(state);
        HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        SendMessageW(state->h_inline_editor, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        for (const auto& opt : field->options) {
            SendMessageW(state->h_inline_editor, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(opt.c_str()));
        }
        SendMessageW(state->h_inline_editor, CB_SETCURSEL, field->option_index, 0);
        SetFocus(state->h_inline_editor);
        SendMessageW(state->h_inline_editor, CB_SHOWDROPDOWN, TRUE, 0);
        state->inline_field_key = field->key;
        state->inline_is_combo = true;
        state->inline_close_posted = false;
    }
}

void form_set_scroll(GuiAppState* state, int new_scroll) {
    if (state == nullptr || state->h_form_panel == nullptr) {
        return;
    }
    const int max_scroll = std::max(0, state->form_content_height - state->form_view_height);
    new_scroll = std::clamp(new_scroll, 0, max_scroll);
    if (new_scroll == state->form_scroll_y) {
        return;
    }
    form_destroy_inline_editor(state, true);
    state->form_scroll_y = new_scroll;
    SCROLLINFO si{};
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = state->form_scroll_y;
    SetScrollInfo(state->h_form_panel, SB_VERT, &si, TRUE);
    InvalidateRect(state->h_form_panel, nullptr, TRUE);
}

bool form_field_is_focusable(const GuiAppState* state, const FormField* field) {
    if (state == nullptr || field == nullptr) {
        return false;
    }
    if (field->key == F_REQUIRE_UNIQUE) {
        return false;
    }
    if (state->form_read_only) {
        return field->key == F_SHOW_MONITOR;
    }
    return field->enabled;
}

int form_first_focusable_key(const GuiAppState* state) {
    if (state == nullptr) {
        return 0;
    }
    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }
        const FormField* field = find_form_field(state, item.field_key);
        if (form_field_is_focusable(state, field)) {
            return item.field_key;
        }
    }
    return 0;
}

int form_next_focusable_key(const GuiAppState* state, int current_key, int direction) {
    if (state == nullptr) {
        return 0;
    }
    std::vector<int> keys;
    keys.reserve(state->form_layout.size());
    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }
        const FormField* field = find_form_field(state, item.field_key);
        if (form_field_is_focusable(state, field)) {
            keys.push_back(item.field_key);
        }
    }
    if (keys.empty()) {
        return 0;
    }
    int idx = -1;
    for (int i = 0; i < static_cast<int>(keys.size()); ++i) {
        if (keys[static_cast<size_t>(i)] == current_key) {
            idx = i;
            break;
        }
    }
    if (idx < 0) {
        return direction < 0 ? keys.back() : keys.front();
    }
    idx = (idx + (direction < 0 ? -1 : 1) + static_cast<int>(keys.size())) % static_cast<int>(keys.size());
    return keys[static_cast<size_t>(idx)];
}

void form_ensure_field_visible(GuiAppState* state, int field_key) {
    if (state == nullptr || state->h_form_panel == nullptr || field_key == 0) {
        return;
    }
    const FormField* field = find_form_field(state, field_key);
    if (field == nullptr) {
        return;
    }
    RECT rc = field->value_rect;
    if (rc.bottom <= rc.top) {
        return;
    }
    const int top = static_cast<int>(rc.top);
    const int bottom = static_cast<int>(rc.bottom);
    const int view_top = state->form_scroll_y;
    const int view_bottom = state->form_scroll_y + std::max(1, state->form_view_height);
    if (top < view_top + 8) {
        form_set_scroll(state, std::max(0, top - 8));
    } else if (bottom > view_bottom - 8) {
        form_set_scroll(state, bottom - std::max(1, state->form_view_height) + 8);
    }
}

void form_set_focused_field(GuiAppState* state, int field_key, bool ensure_visible) {
    if (state == nullptr) {
        return;
    }
    if (field_key != 0) {
        const FormField* field = find_form_field(state, field_key);
        if (!form_field_is_focusable(state, field)) {
            field_key = 0;
        }
    }
    if (field_key == 0) {
        field_key = form_first_focusable_key(state);
    }
    if (state->focused_field_key == field_key) {
        if (ensure_visible) {
            form_ensure_field_visible(state, field_key);
        }
        return;
    }
    state->focused_field_key = field_key;
    if (ensure_visible) {
        form_ensure_field_visible(state, field_key);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

void form_navigate_focus(GuiAppState* state, int direction) {
    if (state == nullptr) {
        return;
    }
    const int next_key = form_next_focusable_key(state, state->focused_field_key, direction);
    form_set_focused_field(state, next_key, true);
}

int form_hit_test_field_key(const GuiAppState* state, POINT pt_client, bool* hit_browse) {
    if (state == nullptr) {
        return 0;
    }
    POINT pt = pt_client;
    pt.y += state->form_scroll_y;
    if (hit_browse != nullptr) {
        *hit_browse = false;
    }

    const FormField* sym = find_form_field(state, F_SYMMETRY_CENTER);
    const FormField* req = find_form_field(state, F_REQUIRE_UNIQUE);
    if (sym != nullptr && PtInRect(&sym->value_rect, pt)) {
        return F_SYMMETRY_CENTER;
    }
    if (req != nullptr && PtInRect(&req->value_rect, pt)) {
        return F_REQUIRE_UNIQUE;
    }

    for (const auto& field : state->form_fields) {
        if (field.key == F_REQUIRE_UNIQUE || field.key == F_SYMMETRY_CENTER) {
            continue;
        }
        if (PtInRect(&field.value_rect, pt) || PtInRect(&field.label_rect, pt)) {
            return field.key;
        }
        if (field.has_browse && PtInRect(&field.browse_rect, pt)) {
            if (hit_browse != nullptr) {
                *hit_browse = true;
            }
            return field.key;
        }
    }
    return 0;
}

void form_set_hover_field(GuiAppState* state, int field_key) {
    if (state == nullptr) {
        return;
    }
    if (state->hover_field_key == field_key) {
        return;
    }
    state->hover_field_key = field_key;
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool form_affects_clues_preset(int field_key) {
    return field_key == F_CLUES_PRESET ||
           field_key == F_BOX_ROWS ||
           field_key == F_BOX_COLS ||
           field_key == F_DIFFICULTY ||
           field_key == F_REQUIRED_STRATEGY;
}

// Update clues suggestions based on grid size/level/strategy.
void update_suggestions_for_grid_size(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    refresh_difficulty_options(state, true);
    refresh_required_strategy_options(state, true);
    const int box_rows = form_field_int(state, F_BOX_ROWS, 3);
    const int box_cols = form_field_int(state, F_BOX_COLS, 3);
    const int difficulty = difficulty_level_from_form(state);
    const RequiredStrategy required = required_strategy_from_form(state);
    const ClueRange suggested_clues = resolve_auto_clue_range(box_rows, box_cols, difficulty, required);
    
    // Update min/max clues fields (only if user hasn't modified them)
    const int current_min = form_field_int(state, F_MIN_CLUES, 0);
    const int current_max = form_field_int(state, F_MAX_CLUES, 0);
    if (current_min == 0) {
        set_form_field_text(state, F_MIN_CLUES, std::to_wstring(suggested_clues.min_clues));
    }
    if (current_max == 0) {
        set_form_field_text(state, F_MAX_CLUES, std::to_wstring(suggested_clues.max_clues));
    }
    
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
}

bool form_step_combo_value(GuiAppState* state, int field_key, int delta) {
    if (state == nullptr || delta == 0) {
        return false;
    }
    FormField* field = find_form_field(state, field_key);
    if (field == nullptr || field->type != FormFieldType::Combo || field->options.empty()) {
        return false;
    }
    const int count = static_cast<int>(field->options.size());
    int idx = field->option_index;
    idx = (idx + delta + count) % count;
    if (idx == field->option_index) {
        return false;
    }
    field->option_index = idx;
    if (!state->form_read_only && form_affects_clues_preset(field_key)) {
        apply_clues_preset(state);
    }
    if (state->h_form_panel != nullptr) {
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
    }
    return true;
}

void form_activate_focused_field(GuiAppState* state) {
    if (state == nullptr) {
        return;
    }
    FormField* field = find_form_field(state, state->focused_field_key);
    if (field == nullptr || !form_field_is_focusable(state, field)) {
        return;
    }
    switch (field->type) {
    case FormFieldType::Int:
    case FormFieldType::Text:
        form_begin_inline_edit(state, field);
        break;
    case FormFieldType::Combo:
        form_begin_inline_combo(state, field);
        break;
    case FormFieldType::Checkbox:
        if (field->enabled) {
            field->checked = !field->checked;
            if (field->key == F_SHOW_MONITOR) {
                sync_live_monitor_visual_state(state);
            }
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        break;
    case FormFieldType::ActionButton:
        if (!state->form_read_only) {
            apply_clues_preset(state);
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        break;
    default:
        break;
    }
}

void form_draw_checkbox(HDC hdc, const RECT& row_rc, const std::wstring& text, bool checked, bool enabled) {
    RECT box = row_rc;
    box.left += 2;
    box.top += 4;
    box.right = box.left + 16;
    box.bottom = box.top + 16;
    UINT state = DFCS_BUTTONCHECK;
    if (checked) {
        state |= DFCS_CHECKED;
    }
    if (!enabled) {
        state |= DFCS_INACTIVE;
    }
    DrawFrameControl(hdc, &box, DFC_BUTTON, state);

    RECT text_rc = row_rc;
    text_rc.left = box.right + 8;
    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, enabled ? RGB(20, 20, 20) : RGB(130, 130, 130));
    DrawTextW(hdc, text.c_str(), -1, &text_rc, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
}

void form_draw_outline(HDC hdc, const RECT& rc, COLORREF color) {
    HPEN pen = CreatePen(PS_SOLID, 1, color);
    HGDIOBJ old_pen = SelectObject(hdc, pen);
    HGDIOBJ old_brush = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    SelectObject(hdc, old_brush);
    SelectObject(hdc, old_pen);
    DeleteObject(pen);
}

void form_handle_click(GuiAppState* state, POINT pt_client) {
    if (state == nullptr) {
        return;
    }
    bool hit_browse = false;
    const int hit_key = form_hit_test_field_key(state, pt_client, &hit_browse);
    form_destroy_inline_editor(state, true);
    if (hit_key == 0) {
        form_set_focused_field(state, 0, false);
        return;
    }
    form_set_focused_field(state, hit_key, true);

    FormField* field = find_form_field(state, hit_key);
    if (field == nullptr) {
        return;
    }
    if (hit_key == F_REQUIRE_UNIQUE) {
        return;
    }
    if (state->form_read_only && hit_key != F_SHOW_MONITOR) {
        return;
    }
    if (hit_browse && field->has_browse) {
        if (state->form_read_only) {
            return;
        }
        std::wstring path;
        if (field->key == F_OUTPUT_FOLDER) {
            if (browse_for_folder(state->hwnd, path)) {
                field->text = path;
                InvalidateRect(state->h_form_panel, nullptr, TRUE);
            }
        } else if (field->key == F_OUTPUT_FILE) {
            if (browse_for_save_file(state->hwnd, path)) {
                std::filesystem::path p(path);
                field->text = p.filename().wstring();
                set_form_field_text(state, F_OUTPUT_FOLDER, p.parent_path().wstring());
                InvalidateRect(state->h_form_panel, nullptr, TRUE);
            }
        }
        return;
    }

    POINT pt = pt_client;
    pt.y += state->form_scroll_y;
    const bool clicked_value = PtInRect(&field->value_rect, pt);
    if (!clicked_value && field->type != FormFieldType::Checkbox) {
        return;
    }

    switch (field->type) {
    case FormFieldType::Int:
    case FormFieldType::Text:
        form_begin_inline_edit(state, field);
        return;
    case FormFieldType::Combo:
        form_begin_inline_combo(state, field);
        return;
    case FormFieldType::Checkbox:
        if (field->enabled) {
            field->checked = !field->checked;
            if (field->key == F_SHOW_MONITOR) {
                sync_live_monitor_visual_state(state);
            }
            InvalidateRect(state->h_form_panel, nullptr, TRUE);
        }
        return;
    case FormFieldType::ActionButton:
        apply_clues_preset(state);
        InvalidateRect(state->h_form_panel, nullptr, TRUE);
        return;
    default:
        return;
    }
}

void form_paint(HWND hwnd, GuiAppState* state) {
    PAINTSTRUCT ps{};
    HDC hdc = BeginPaint(hwnd, &ps);
    RECT client{};
    GetClientRect(hwnd, &client);
    const int width = std::max(1, static_cast<int>(client.right - client.left));
    const int height = std::max(1, static_cast<int>(client.bottom - client.top));

    HDC mem = CreateCompatibleDC(hdc);
    HBITMAP bmp = CreateCompatibleBitmap(hdc, width, height);
    HGDIOBJ old_bmp = SelectObject(mem, bmp);

    HBRUSH bg = CreateSolidBrush(RGB(242, 246, 250));
    FillRect(mem, &client, bg);
    DeleteObject(bg);

    HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
    HGDIOBJ old_font = SelectObject(mem, font);

    const int scroll_y = state->form_scroll_y;

    for (const auto& item : state->form_layout) {
        if (!item.is_section) {
            continue;
        }
        RECT sec = form_view_rect(item.section_rect, scroll_y);
        if (sec.bottom < 0 || sec.top > height) {
            continue;
        }
        FrameRect(mem, &sec, reinterpret_cast<HBRUSH>(GetStockObject(GRAY_BRUSH)));
        RECT title_bg{sec.left + 10, sec.top - 9, sec.left + 320, sec.top + 10};
        HBRUSH bg_br = CreateSolidBrush(RGB(242, 246, 250));
        FillRect(mem, &title_bg, bg_br);
        DeleteObject(bg_br);
        RECT title_txt = title_bg;
        title_txt.left += 4;
        SetBkMode(mem, TRANSPARENT);
        SetTextColor(mem, RGB(25, 36, 48));
        DrawTextW(mem, item.section_title.c_str(), -1, &title_txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
    }

    for (const auto& item : state->form_layout) {
        if (item.is_section) {
            continue;
        }

        FormField* field = find_form_field(state, item.field_key);
        if (field == nullptr || item.field_key == F_REQUIRE_UNIQUE) {
            continue;
        }
        RECT label_rc = form_view_rect(field->label_rect, scroll_y);
        RECT value_rc = form_view_rect(field->value_rect, scroll_y);
        RECT browse_rc = form_view_rect(field->browse_rect, scroll_y);
        const bool is_hover = (state->hover_field_key == field->key);
        const bool is_focus = (state->focused_field_key == field->key);
        if (value_rc.bottom < 0 || value_rc.top > height) {
            continue;
        }

        if (item.field_key == F_SYMMETRY_CENTER) {
            FormField* req_unique = find_form_field(state, F_REQUIRE_UNIQUE);
            form_draw_checkbox(mem, value_rc, field->label, field->checked, !state->form_read_only && field->enabled);
            if (req_unique != nullptr) {
                RECT req_rc = form_view_rect(req_unique->value_rect, scroll_y);
                form_draw_checkbox(mem, req_rc, req_unique->label, req_unique->checked, false);
            }
            if (is_focus || is_hover) {
                form_draw_outline(mem, value_rc, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
            }
            continue;
        }

        if (field->type == FormFieldType::Checkbox) {
            form_draw_checkbox(mem, value_rc, field->label, field->checked, !state->form_read_only && field->enabled);
            if (is_focus || is_hover) {
                form_draw_outline(mem, value_rc, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
            }
            continue;
        }

        SetBkMode(mem, TRANSPARENT);
        SetTextColor(mem, RGB(26, 26, 26));
        DrawTextW(mem, field->label.c_str(), -1, &label_rc, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

        RECT frame = value_rc;
        if (field->type == FormFieldType::ActionButton) {
            HBRUSH btn_br = CreateSolidBrush(
                state->form_read_only ? RGB(214, 220, 226) : (is_hover ? RGB(196, 216, 236) : RGB(206, 223, 238)));
            FillRect(mem, &frame, btn_br);
            DeleteObject(btn_br);
            DrawEdge(mem, &frame, EDGE_RAISED, BF_RECT);
            RECT txt = frame;
            txt.left += 8;
            SetTextColor(mem, RGB(20, 34, 50));
            DrawTextW(mem, field->text.c_str(), -1, &txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
        } else {
            COLORREF field_bg = field->enabled ? (is_hover ? RGB(248, 252, 255) : RGB(255, 255, 255)) : RGB(236, 236, 236);
            HBRUSH white_br = CreateSolidBrush(field_bg);
            FillRect(mem, &frame, white_br);
            DeleteObject(white_br);
            form_draw_outline(mem, frame, RGB(140, 140, 140));
            RECT txt = frame;
            txt.left += 6;
            txt.right -= 6;
            std::wstring display;
            if (field->type == FormFieldType::Combo) {
                if (!field->options.empty() && field->option_index >= 0 && field->option_index < static_cast<int>(field->options.size())) {
                    display = field->options[static_cast<size_t>(field->option_index)];
                }
            } else {
                display = field->text;
            }
            SetTextColor(mem, field->enabled ? RGB(22, 22, 22) : RGB(130, 130, 130));
            DrawTextW(mem, display.c_str(), -1, &txt, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
            if (field->type == FormFieldType::Combo) {
                RECT arrow = frame;
                arrow.left = arrow.right - 20;
                DrawFrameControl(mem, &arrow, DFC_SCROLL, DFCS_SCROLLCOMBOBOX);
            }
        }
        if (is_focus || is_hover) {
            form_draw_outline(mem, frame, is_focus ? RGB(52, 109, 194) : RGB(129, 165, 214));
        }

        if (field->has_browse) {
            const bool browse_hover = is_hover;
            HBRUSH b = CreateSolidBrush(state->form_read_only ? RGB(214, 220, 226) : (browse_hover ? RGB(216, 226, 236) : RGB(226, 232, 238)));
            FillRect(mem, &browse_rc, b);
            DeleteObject(b);
            DrawEdge(mem, &browse_rc, EDGE_RAISED, BF_RECT);
            RECT dots = browse_rc;
            DrawTextW(mem, L"...", -1, &dots, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
        }
    }

    BitBlt(hdc, 0, 0, width, height, mem, 0, 0, SRCCOPY);
    SelectObject(mem, old_font);
    SelectObject(mem, old_bmp);
    DeleteObject(bmp);
    DeleteDC(mem);
    EndPaint(hwnd, &ps);
}

LRESULT CALLBACK form_panel_wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    auto* state = reinterpret_cast<GuiAppState*>(GetWindowLongPtrW(hwnd, GWLP_USERDATA));
    switch (msg) {
    case WM_CREATE: {
        auto* cs = reinterpret_cast<CREATESTRUCTW*>(lParam);
        auto* s = reinterpret_cast<GuiAppState*>(cs->lpCreateParams);
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(s));
        return 0;
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_GETDLGCODE:
        return static_cast<LRESULT>(DLGC_WANTTAB | DLGC_WANTARROWS | DLGC_WANTCHARS);
    case WM_SETFOCUS:
        if (state != nullptr) {
            if (!form_field_is_focusable(state, find_form_field(state, state->focused_field_key))) {
                form_set_focused_field(state, form_first_focusable_key(state), false);
            } else {
                InvalidateRect(hwnd, nullptr, TRUE);
            }
        }
        return 0;
    case WM_KILLFOCUS:
        if (state != nullptr) {
            InvalidateRect(hwnd, nullptr, TRUE);
        }
        return 0;
    case WM_SIZE:
        if (state != nullptr) {
            form_layout_fields(state);
            if (!form_field_is_focusable(state, find_form_field(state, state->focused_field_key))) {
                form_set_focused_field(state, form_first_focusable_key(state), false);
            }
            InvalidateRect(hwnd, nullptr, TRUE);
        }
        return 0;
    case WM_VSCROLL:
        if (state != nullptr) {
            SCROLLINFO si{};
            si.cbSize = sizeof(si);
            si.fMask = SIF_ALL;
            GetScrollInfo(hwnd, SB_VERT, &si);
            int pos = state->form_scroll_y;
            switch (LOWORD(wParam)) {
            case SB_TOP:
                pos = 0;
                break;
            case SB_BOTTOM:
                pos = si.nMax;
                break;
            case SB_LINEUP:
                pos -= 26;
                break;
            case SB_LINEDOWN:
                pos += 26;
                break;
            case SB_PAGEUP:
                pos -= static_cast<int>(si.nPage);
                break;
            case SB_PAGEDOWN:
                pos += static_cast<int>(si.nPage);
                break;
            case SB_THUMBTRACK:
            case SB_THUMBPOSITION:
                pos = si.nTrackPos;
                break;
            default:
                break;
            }
            form_set_scroll(state, pos);
        }
        return 0;
    case WM_MOUSEWHEEL:
        if (state != nullptr) {
            const int delta = GET_WHEEL_DELTA_WPARAM(wParam);
            const int lines = delta / WHEEL_DELTA;
            form_set_scroll(state, state->form_scroll_y - lines * 48);
        }
        return 0;
    case WM_MOUSEMOVE:
        if (state != nullptr) {
            if (!state->mouse_tracking) {
                TRACKMOUSEEVENT tme{};
                tme.cbSize = sizeof(tme);
                tme.dwFlags = TME_LEAVE;
                tme.hwndTrack = hwnd;
                TrackMouseEvent(&tme);
                state->mouse_tracking = true;
            }
            POINT pt{GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
            form_set_hover_field(state, form_hit_test_field_key(state, pt, nullptr));
        }
        return 0;
    case WM_MOUSELEAVE:
        if (state != nullptr) {
            state->mouse_tracking = false;
            form_set_hover_field(state, 0);
        }
        return 0;
    case WM_LBUTTONDOWN:
        if (state != nullptr) {
            POINT pt{GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
            form_handle_click(state, pt);
            if (state->h_inline_editor == nullptr) {
                SetFocus(hwnd);
            }
        }
        return 0;
    case WM_KEYDOWN:
        if (state != nullptr) {
            if (wParam == VK_TAB) {
                const bool back = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                form_navigate_focus(state, back ? -1 : 1);
                return 0;
            }
            if (wParam == VK_UP || wParam == VK_DOWN) {
                const int delta = (wParam == VK_UP) ? -1 : 1;
                if (form_step_combo_value(state, state->focused_field_key, delta)) {
                    return 0;
                }
                form_set_scroll(state, state->form_scroll_y + (delta < 0 ? -26 : 26));
                return 0;
            }
            if (wParam == VK_RETURN || wParam == VK_SPACE) {
                form_activate_focused_field(state);
                return 0;
            }
        }
        break;
    case WM_APP_INLINE_CLOSE:
        if (state != nullptr) {
            const bool commit = (wParam != 0);
            form_destroy_inline_editor(state, commit);
        }
        return 0;
    case WM_APP_FORM_NAV:
        if (state != nullptr) {
            if (lParam != 0) {
                SetFocus(hwnd);
                return 0;
            }
            form_navigate_focus(state, (wParam == 0) ? -1 : 1);
            SetFocus(hwnd);
        }
        return 0;
    case WM_COMMAND:
        if (state != nullptr && LOWORD(wParam) == IDC_INLINE_EDIT) {
            const int code = HIWORD(wParam);
            if (!state->inline_is_combo && code == EN_KILLFOCUS) {
                form_request_inline_close(state, true);
                return 0;
            }
            if (state->inline_is_combo) {
                if (code == CBN_SELENDOK) {
                    form_request_inline_close(state, true);
                    return 0;
                }
                if (code == CBN_SELENDCANCEL) {
                    form_request_inline_close(state, false);
                    return 0;
                }
                if (code == CBN_KILLFOCUS && !state->inline_close_posted) {
                    const LRESULT dropped = SendMessageW(state->h_inline_editor, CB_GETDROPPEDSTATE, 0, 0);
                    if (dropped != 0) {
                        return 0;
                    }
                    form_request_inline_close(state, true);
                    return 0;
                }
            }
        }
        break;
    case WM_PAINT:
        if (state != nullptr) {
            form_paint(hwnd, state);
            return 0;
        }
        break;
    default:
        break;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

void layout_gui_controls(GuiAppState* s) {
    if (s == nullptr) {
        return;
    }
    RECT client{};
    GetClientRect(s->hwnd, &client);
    const int margin = 12;
    const int gap = 8;
    const int client_w = std::max(1, static_cast<int>(client.right - client.left));
    const int client_h = std::max(1, static_cast<int>(client.bottom - client.top));
    const int content_w = std::max(1, client_w - margin * 2);

    const int btn_h = 30;
    const int btn_w = 100;
    const int btn_y = std::max(margin, client_h - margin - btn_h);
    const int btn_total = btn_w * 3 + 20 * 2;
    const int btn_x0 = std::max(margin, client_w / 2 - btn_total / 2);
    SetWindowPos(s->h_start, nullptr, btn_x0, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);
    SetWindowPos(s->h_cancel, nullptr, btn_x0 + btn_w + 20, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);
    SetWindowPos(s->h_pause, nullptr, btn_x0 + btn_w * 2 + 40, btn_y, btn_w, btn_h, SWP_NOZORDER | SWP_NOACTIVATE);

    const int body_bottom = std::max(margin, btn_y - gap);
    int y = margin;
    int remain = body_bottom - y;
    const int progress_pack_h = 54;
    const int fixed_spacing = gap * 3;
    const int usable = std::max(40, remain - progress_pack_h - fixed_spacing);
    int form_h = std::max(40, (usable * 58) / 100);
    int monitor_h = std::max(0, (usable * 24) / 100);
    int log_h = std::max(0, usable - form_h - monitor_h);
    if (log_h < 36) {
        const int need = 36 - log_h;
        const int take_from_form = std::min(need, std::max(0, form_h - 60));
        form_h -= take_from_form;
        log_h += take_from_form;
    }
    if (log_h < 36) {
        const int need = 36 - log_h;
        const int take_from_monitor = std::min(need, std::max(0, monitor_h - 40));
        monitor_h -= take_from_monitor;
        log_h += take_from_monitor;
    }
    if (form_h < 40) {
        const int need = 40 - form_h;
        const int take = std::min(need, std::max(0, monitor_h - 20));
        monitor_h -= take;
        form_h += take;
    }
    log_h = std::max(0, usable - form_h - monitor_h);

    SetWindowPos(s->h_form_panel, nullptr, margin, y, content_w, form_h, SWP_NOZORDER | SWP_NOACTIVATE);
    y += form_h + gap;
    SetWindowPos(s->h_progress_text, nullptr, margin + 4, y, 380, 22, SWP_NOZORDER | SWP_NOACTIVATE);
    y += 24;
    SetWindowPos(s->h_progress, nullptr, margin, y, content_w, 20, SWP_NOZORDER | SWP_NOACTIVATE);
    y += 20 + gap;
    SetWindowPos(s->h_monitor, nullptr, margin, y, content_w, monitor_h, SWP_NOZORDER | SWP_NOACTIVATE);
    ShowWindow(s->h_monitor, monitor_h > 0 ? SW_SHOW : SW_HIDE);
    y += monitor_h + gap;
    const int final_log_h = std::max(0, body_bottom - y);
    SetWindowPos(s->h_log, nullptr, margin, y, content_w, final_log_h, SWP_NOZORDER | SWP_NOACTIVATE);
    ShowWindow(s->h_log, final_log_h > 0 ? SW_SHOW : SW_HIDE);

    form_layout_fields(s);
}

void create_gui_controls(GuiAppState* s) {
    HFONT font = static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
    init_form_model(s);

    s->h_form_panel = CreateWindowExW(
        0,
        L"SudokuHpcFormPanelClass",
        nullptr,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0,
        0,
        100,
        100,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_FORM_PANEL)),
        GetModuleHandleW(nullptr),
        s);

    s->h_progress_text = CreateWindowExW(
        0,
        L"STATIC",
        L"Wygenerowano 0/0",
        WS_CHILD | WS_VISIBLE,
        0,
        0,
        260,
        22,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_PROGRESS_TEXT)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_progress = CreateWindowExW(
        0,
        PROGRESS_CLASSW,
        nullptr,
        WS_CHILD | WS_VISIBLE,
        0,
        0,
        260,
        20,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_PROGRESS_BAR)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_monitor = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        L"",
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        0,
        0,
        260,
        120,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_MONITOR_BOX)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_log = CreateWindowExW(
        WS_EX_CLIENTEDGE,
        L"EDIT",
        L"",
        WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY,
        0,
        0,
        260,
        90,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_LOG_BOX)),
        GetModuleHandleW(nullptr),
        nullptr);

    s->h_start = CreateWindowExW(
        0,
        L"BUTTON",
        L"Start",
        WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_START)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_cancel = CreateWindowExW(
        0,
        L"BUTTON",
        L"Anuluj",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_CANCEL)),
        GetModuleHandleW(nullptr),
        nullptr);
    s->h_pause = CreateWindowExW(
        0,
        L"BUTTON",
        L"Pauza",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        0,
        0,
        100,
        30,
        s->hwnd,
        reinterpret_cast<HMENU>(static_cast<INT_PTR>(IDC_BTN_PAUSE)),
        GetModuleHandleW(nullptr),
        nullptr);

    const HWND controls[] = {s->h_progress_text, s->h_progress, s->h_monitor, s->h_log, s->h_start, s->h_cancel, s->h_pause};
    for (HWND h : controls) {
        if (h != nullptr) {
            SendMessageW(h, WM_SETFONT, reinterpret_cast<WPARAM>(font), TRUE);
        }
    }

    HFONT mono_font = CreateFontW(
        -14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
        FF_DONTCARE, L"Consolas");
    if (mono_font != nullptr) {
        s->h_mono_font = mono_font;
        SendMessageW(s->h_monitor, WM_SETFONT, reinterpret_cast<WPARAM>(mono_font), TRUE);
    }

    SendMessageW(s->h_progress, PBM_SETRANGE32, 0, 100);
    SendMessageW(s->h_progress, PBM_SETPOS, 0, 0);
    EnableWindow(s->h_cancel, FALSE);
    layout_gui_controls(s);
    form_set_focused_field(s, form_first_focusable_key(s), false);
    sync_live_monitor_visual_state(s);
    apply_clues_preset(s);
}

LRESULT CALLBACK gui_wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    auto* state = reinterpret_cast<GuiAppState*>(GetWindowLongPtrW(hwnd, GWLP_USERDATA));
    switch (msg) {
    case WM_CREATE: {
        auto* s = new GuiAppState();
        s->hwnd = hwnd;
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(s));
        create_gui_controls(s);
        append_log(s, L"GUI gotowe.");
        return 0;
    }
    case WM_COMMAND:
        if (state == nullptr) {
            break;
        }
        if (LOWORD(wParam) == IDC_BTN_START) {
            start_generation(state);
            return 0;
        }
        if (LOWORD(wParam) == IDC_BTN_CANCEL) {
            cancel_generation(state);
            return 0;
        }
        if (LOWORD(wParam) == IDC_BTN_PAUSE) {
            toggle_pause(state);
            return 0;
        }
        break;
    case WM_APP_PROGRESS:
        if (state == nullptr) {
            return 0;
        }
        SendMessageW(state->h_progress, PBM_SETRANGE32, 0, static_cast<LPARAM>(std::min<uint64_t>(static_cast<uint64_t>(lParam), 0x7fffffffULL)));
        SendMessageW(state->h_progress, PBM_SETPOS, static_cast<WPARAM>(std::min<uint64_t>(static_cast<uint64_t>(wParam), 0x7fffffffULL)), 0);
        set_text(state->h_progress_text, L"Wygenerowano " + std::to_wstring(static_cast<uint64_t>(wParam)) + L"/" + std::to_wstring(static_cast<uint64_t>(lParam)));
        if (is_live_monitor_enabled(state)) {
            std::shared_ptr<ConsoleStatsMonitor> monitor;
            {
                std::lock_guard<std::mutex> lock(state->monitor_mu);
                monitor = state->gui_monitor;
            }
            if (monitor != nullptr) {
                set_monitor_text(state, utf8_to_wide(monitor->snapshot_text()));
            }
        }
        return 0;
    case WM_APP_LOG:
        if (state == nullptr) {
            return 0;
        } else {
            std::unique_ptr<std::wstring> payload(reinterpret_cast<std::wstring*>(lParam));
            if (payload) {
                append_log(state, *payload);
            }
        }
        return 0;
    case WM_APP_DONE:
        if (state == nullptr) {
            return 0;
        }
        KillTimer(hwnd, IDT_MONITOR_REFRESH);
        {
            std::unique_ptr<GenerateRunResult> result(reinterpret_cast<GenerateRunResult*>(wParam));
            set_running_state(state, false);
            if (result) {
                append_log(state, L"Zakonczono: accepted=" + std::to_wstring(result->accepted) + L", attempts=" + std::to_wstring(result->attempts));
                set_text(state->h_progress_text, L"Wygenerowano " + std::to_wstring(result->written) + L"/" + std::to_wstring(state->target));
                SendMessageW(state->h_progress, PBM_SETPOS, static_cast<WPARAM>(std::min<uint64_t>(result->written, 0x7fffffffULL)), 0);
            }
        }
        if (state->run_thread.joinable()) {
            state->run_thread.join();
        }
        return 0;
    case WM_TIMER:
        if (state != nullptr && wParam == IDT_MONITOR_REFRESH) {
            if (is_live_monitor_enabled(state)) {
                std::shared_ptr<ConsoleStatsMonitor> monitor;
                {
                    std::lock_guard<std::mutex> lock(state->monitor_mu);
                    monitor = state->gui_monitor;
                }
                if (monitor != nullptr) {
                    set_monitor_text(state, utf8_to_wide(monitor->snapshot_text()));
                }
            }
            return 0;
        }
        break;
    case WM_SIZE:
        if (state != nullptr) {
            layout_gui_controls(state);
        }
        return 0;
    case WM_CLOSE:
        if (state != nullptr && state->running.load(std::memory_order_relaxed)) {
            if (MessageBoxW(hwnd, L"Generowanie trwa. Zamknac i anulowac?", L"Potwierdzenie", MB_ICONQUESTION | MB_YESNO) == IDYES) {
                cancel_generation(state);
                DestroyWindow(hwnd);
            }
            return 0;
        }
        DestroyWindow(hwnd);
        return 0;
    case WM_DESTROY:
        if (state != nullptr) {
            KillTimer(hwnd, IDT_MONITOR_REFRESH);
            state->cancel_requested.store(true, std::memory_order_relaxed);
            if (state->run_thread.joinable()) {
                state->run_thread.request_stop();
                state->run_thread.join();
            }
            if (state->h_mono_font != nullptr) {
                DeleteObject(state->h_mono_font);
                state->h_mono_font = nullptr;
            }
            delete state;
            SetWindowLongPtrW(hwnd, GWLP_USERDATA, 0);
        }
        PostQuitMessage(0);
        return 0;
    default:
        break;
    }
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

int run_gui_winapi(HINSTANCE hinst) {
    CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

    INITCOMMONCONTROLSEX icc{};
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_PROGRESS_CLASS | ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icc);

    const wchar_t* panel_cls = L"SudokuHpcFormPanelClass";
    WNDCLASSW wc_panel{};
    wc_panel.lpfnWndProc = form_panel_wnd_proc;
    wc_panel.hInstance = hinst;
    wc_panel.lpszClassName = panel_cls;
    wc_panel.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc_panel.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
    RegisterClassW(&wc_panel);

    const wchar_t* cls = L"SudokuHpcGuiWndClass";
    WNDCLASSW wc{};
    wc.lpfnWndProc = gui_wnd_proc;
    wc.hInstance = hinst;
    wc.lpszClassName = cls;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
    RegisterClassW(&wc);

    RECT work{};
    SystemParametersInfoW(SPI_GETWORKAREA, 0, &work, 0);
    const int work_w = std::max(640, static_cast<int>(work.right - work.left));
    const int work_h = std::max(480, static_cast<int>(work.bottom - work.top));
    const int wnd_w = std::min(1040, std::max(760, work_w - 32));
    const int wnd_h = std::min(860, std::max(560, work_h - 32));
    const int wnd_x = work.left + std::max(0, (work_w - wnd_w) / 2);
    const int wnd_y = work.top + std::max(0, (work_h - wnd_h) / 2);

    HWND hwnd = CreateWindowExW(
        0,
        cls,
        L"Sudoku HPC Generator - GUI",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        wnd_x,
        wnd_y,
        wnd_w,
        wnd_h,
        nullptr,
        nullptr,
        hinst,
        nullptr);
    if (hwnd == nullptr) {
        return 1;
    }
    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    MSG msg{};
    while (GetMessageW(&msg, nullptr, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    CoUninitialize();
    return static_cast<int>(msg.wParam);
}

void ensure_console_attached() {
    if (GetConsoleWindow() != nullptr) {
        return;
    }
    if (!AllocConsole()) {
        return;
    }
    std::freopen("CONIN$", "r", stdin);
    std::freopen("CONOUT$", "w", stdout);
    std::freopen("CONOUT$", "w", stderr);
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
    std::ios::sync_with_stdio(true);
}

bool is_parent_explorer() {
    const DWORD self_pid = GetCurrentProcessId();
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD parent_pid = 0;
    PROCESSENTRY32W pe{};
    pe.dwSize = sizeof(pe);
    if (Process32FirstW(snapshot, &pe)) {
        do {
            if (pe.th32ProcessID == self_pid) {
                parent_pid = pe.th32ParentProcessID;
                break;
            }
        } while (Process32NextW(snapshot, &pe));
    }

    std::wstring parent_name;
    if (parent_pid != 0) {
        pe.dwSize = sizeof(pe);
        if (Process32FirstW(snapshot, &pe)) {
            do {
                if (pe.th32ProcessID == parent_pid) {
                    parent_name = pe.szExeFile;
                    break;
                }
            } while (Process32NextW(snapshot, &pe));
        }
    }
    CloseHandle(snapshot);

    if (parent_name.empty()) {
        return false;
    }
    std::transform(parent_name.begin(), parent_name.end(), parent_name.begin(), [](wchar_t ch) {
        return static_cast<wchar_t>(std::towlower(ch));
    });
    return parent_name == L"explorer.exe";
}
#endif

bool has_arg(int argc, char** argv, const char* key) {
    for (int i = 1; i < argc; ++i) {
        if (std::string_view(argv[i]) == key) {
            return true;
        }
    }
    return false;
}

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\kernels.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>
#include <bit>

#if defined(__x86_64__) || defined(__i386__)
#include <immintrin.h>
#endif

namespace sudoku_hpc {

#if defined(__GNUC__) || defined(__clang__)
#define SUDOKU_HOT_INLINE inline __attribute__((always_inline))
#define SUDOKU_LIKELY(x) (__builtin_expect(!!(x), 1))
#define SUDOKU_UNLIKELY(x) (__builtin_expect(!!(x), 0))
#else
#define SUDOKU_HOT_INLINE inline
#define SUDOKU_LIKELY(x) (x)
#define SUDOKU_UNLIKELY(x) (x)
#endif

#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
#define SUDOKU_TARGET_AVX2 __attribute__((target("avx2")))
#define SUDOKU_TARGET_AVX512BW __attribute__((target("avx512f,avx512bw")))
#define SUDOKU_TARGET_AVX512VPOPCNT __attribute__((target("avx512f,avx512bw,avx512vpopcntdq")))
#define SUDOKU_TARGET_BMI2 __attribute__((target("bmi,bmi2")))
#else
#define SUDOKU_TARGET_AVX2
#define SUDOKU_TARGET_AVX512BW
#define SUDOKU_TARGET_AVX512VPOPCNT
#define SUDOKU_TARGET_BMI2
#endif

enum class RejectReason {
    None,
    Prefilter,
    Logic,
    Uniqueness,
    Strategy,
    Replay,
    DistributionBias,
    UniquenessBudget
};

struct RequiredStrategyAttemptInfo {
    bool analyzed_required_strategy = false;
    bool required_strategy_use_confirmed = false;
    bool required_strategy_hit_confirmed = false;
    bool matched_required_strategy = false;
};

struct SearchAbortControl {
    bool time_enabled = false;
    bool node_enabled = false;
    std::chrono::steady_clock::time_point deadline{};
    uint64_t node_limit = 0;
    uint64_t nodes = 0;
    bool aborted_by_time = false;
    bool aborted_by_nodes = false;
    bool aborted_by_force = false;
    bool aborted_by_pause = false;
    const std::atomic<bool>* force_abort_ptr = nullptr;
    const std::atomic<bool>* cancel_ptr = nullptr;
    const std::atomic<bool>* pause_ptr = nullptr;

    SUDOKU_HOT_INLINE bool step() {
        const uint64_t n = ++nodes;
        if (SUDOKU_UNLIKELY(node_enabled && n > node_limit)) {
            aborted_by_nodes = true;
            return false;
        }
        if ((n & 511ULL) != 0ULL) {
            return true;
        }
        if (SUDOKU_LIKELY(cancel_ptr == nullptr && pause_ptr == nullptr && force_abort_ptr == nullptr && !time_enabled)) {
            return true;
        }
        if (cancel_ptr != nullptr && cancel_ptr->load(std::memory_order_relaxed)) {
            aborted_by_force = true;
            return false;
        }
        if (pause_ptr != nullptr && pause_ptr->load(std::memory_order_relaxed)) {
            aborted_by_pause = true;
            return false;
        }
        if (force_abort_ptr != nullptr && force_abort_ptr->load(std::memory_order_relaxed)) {
            aborted_by_force = true;
            return false;
        }
        if (time_enabled && std::chrono::steady_clock::now() >= deadline) {
            aborted_by_time = true;
            return false;
        }
        return true;
    }

    bool aborted() const {
        return aborted_by_time || aborted_by_nodes || aborted_by_force || aborted_by_pause;
    }
};

#if defined(__x86_64__) || defined(__i386__)
SUDOKU_TARGET_BMI2 static int shuffled_digits_from_mask_bmi2(uint64_t mask, std::mt19937_64& rng, int* out_digits) {
    const int count = static_cast<int>(std::popcount(mask));
    if (count == 0) {
        return 0;
    }
    if (count <= 2) {
        const uint64_t dense = _pext_u64(mask, mask);
        const uint64_t a = _pdep_u64(1ULL & dense, mask);
        out_digits[0] = static_cast<int>(_tzcnt_u64(a)) + 1;
        if (count == 2) {
            const uint64_t b = _pdep_u64((2ULL & dense), mask);
            out_digits[1] = static_cast<int>(_tzcnt_u64(b)) + 1;
            if ((rng() & 1ULL) != 0ULL) {
                std::swap(out_digits[0], out_digits[1]);
            }
        }
        return count;
    }
    if (count > 8) {
        int out_count = 0;
        while (mask != 0ULL) {
            const uint64_t bit = _blsi_u64(mask);
            out_digits[out_count++] = static_cast<int>(_tzcnt_u64(bit)) + 1;
            mask = _blsr_u64(mask);
        }
        for (int i = out_count - 1; i > 0; --i) {
            const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
            std::swap(out_digits[i], out_digits[j]);
        }
        return out_count;
    }
    int ranks[16];
    for (int i = 0; i < count; ++i) {
        ranks[i] = i;
    }
    for (int i = count - 1; i > 0; --i) {
        const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
        std::swap(ranks[i], ranks[j]);
    }
    const uint64_t dense = _pext_u64(mask, mask); // contiguous candidate domain bits [0..count)
    for (int i = 0; i < count; ++i) {
        const uint64_t compact_pick = (1ULL << ranks[i]) & dense;
        const uint64_t lifted = _pdep_u64(compact_pick, mask);
        out_digits[i] = static_cast<int>(_tzcnt_u64(lifted)) + 1;
    }
    return count;
}
#endif

static int shuffled_digits_from_mask(uint64_t mask, std::mt19937_64& rng, int* out_digits) {
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
    if (__builtin_cpu_supports("bmi2")) {
        return shuffled_digits_from_mask_bmi2(mask, rng, out_digits);
    }
#endif
    int count = 0;
    while (mask != 0ULL) {
        const int bit = std::countr_zero(mask);
        out_digits[count++] = bit + 1;
        mask &= (mask - 1ULL);
    }
    if (count <= 2) {
        if (count == 2 && (rng() & 1ULL) != 0ULL) {
            std::swap(out_digits[0], out_digits[1]);
        }
        return count;
    }
    for (int i = count - 1; i > 0; --i) {
        const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
        std::swap(out_digits[i], out_digits[j]);
    }
    return count;
}

struct GenericSolvedKernel {
    enum class Backend : uint8_t {
        Scalar = 0,
        Avx2 = 1,
        Avx512 = 2
    };

    explicit GenericSolvedKernel(Backend backend = Backend::Scalar) : backend_(backend) {}

    static Backend backend_from_string(const std::string& backend) {
        if (backend == "avx2") {
            return Backend::Avx2;
        }
        if (backend == "avx512") {
            return Backend::Avx512;
        }
        return Backend::Scalar;
    }

    struct CandidateCache {
        int prepared_nn = 0;
        std::vector<uint64_t> candidates;
        std::vector<uint8_t> candidate_popcnt;
        std::vector<uint64_t> singleton_words;
        std::vector<int> undo_idx;
        std::vector<uint64_t> undo_old;
        std::vector<uint8_t> undo_old_count;

        void ensure(const GenericTopology& topo) {
            if (prepared_nn != topo.nn) {
                candidates.resize(static_cast<size_t>(topo.nn));
                candidate_popcnt.resize(static_cast<size_t>(topo.nn));
                singleton_words.resize((static_cast<size_t>(topo.nn) + 63ULL) >> 6U);
                const size_t per_depth_hint = static_cast<size_t>(std::max(8, std::min(3 * topo.n, 64)));
                const size_t reserve_hint = static_cast<size_t>(topo.nn) * per_depth_hint;
                if (undo_idx.capacity() < reserve_hint) {
                    undo_idx.reserve(reserve_hint);
                    undo_old.reserve(reserve_hint);
                    undo_old_count.reserve(reserve_hint);
                }
                prepared_nn = topo.nn;
            }
            undo_idx.clear();
            undo_old.clear();
            undo_old_count.clear();
        }
    };

    static CandidateCache& candidate_cache_for(const GenericTopology& topo) {
        static thread_local CandidateCache cache;
        cache.ensure(topo);
        return cache;
    }

    static SUDOKU_HOT_INLINE void cache_set_candidate(
        CandidateCache& cache,
        int idx,
        uint64_t mask,
        uint8_t count) {
        const size_t uidx = static_cast<size_t>(idx);
        cache.candidates[uidx] = mask;
        cache.candidate_popcnt[uidx] = count;
        const size_t w = uidx >> 6U;
        const uint64_t bit = 1ULL << (uidx & 63ULL);
        uint64_t& word = cache.singleton_words[w];
        if (count == 1U) {
            word |= bit;
        } else {
            word &= ~bit;
        }
    }

    static int cell_pressure(const GenericBoard& board, int idx) {
        const uint32_t rcb = board.topo->cell_rcb_packed[static_cast<size_t>(idx)];
        const int r = GenericBoard::packed_row(rcb);
        const int c = GenericBoard::packed_col(rcb);
        const int b = GenericBoard::packed_box(rcb);
        const uint64_t used =
            board.row_used[static_cast<size_t>(r)] |
            board.col_used[static_cast<size_t>(c)] |
            board.box_used[static_cast<size_t>(b)];
        return static_cast<int>(std::popcount(used));
    }

    struct MvrState {
        int best_bucket = 65;
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        int best_pressure = -1;
        bool found_empty = false;
    };

    static bool consider_empty_cell_mrv_precount(
        int idx,
        uint64_t candidate_mask,
        int candidate_cnt,
        int used_pressure,
        MvrState& state) {
        if (candidate_cnt == 0) {
            return false;
        }
        state.found_empty = true;
        if (candidate_cnt < state.best_bucket) {
            state.best_bucket = candidate_cnt;
            state.best_idx = idx;
            state.best_mask = candidate_mask;
            state.best_pressure = (candidate_cnt == 1) ? 64 : used_pressure;
        } else if (candidate_cnt == state.best_bucket && candidate_cnt > 1) {
            if (used_pressure > state.best_pressure) {
                state.best_idx = idx;
                state.best_mask = candidate_mask;
                state.best_pressure = used_pressure;
            }
        }
        return true;
    }

    static bool consider_empty_cell_mrv_fast(
        int idx,
        uint64_t candidate_mask,
        uint64_t used_mask,
        MvrState& state) {
        const int cnt = static_cast<int>(std::popcount(candidate_mask));
        const int pressure = static_cast<int>(std::popcount(used_mask));
        return consider_empty_cell_mrv_precount(idx, candidate_mask, cnt, pressure, state);
    }

    static bool finalize_mrv_pick(
        int& best_idx,
        uint64_t& best_mask,
        const MvrState& state) {
        if (!state.found_empty) {
            best_idx = -1;
            best_mask = 0ULL;
            return true;
        }
        best_idx = state.best_idx;
        best_mask = state.best_mask;
        return true;
    }

    static void popcount4x64_scalar(const uint64_t* in_masks, int* out_counts) {
        out_counts[0] = static_cast<int>(std::popcount(in_masks[0]));
        out_counts[1] = static_cast<int>(std::popcount(in_masks[1]));
        out_counts[2] = static_cast<int>(std::popcount(in_masks[2]));
        out_counts[3] = static_cast<int>(std::popcount(in_masks[3]));
    }

#if defined(__x86_64__) || defined(__i386__)
    SUDOKU_TARGET_AVX2 static void popcount4x64_avx2(const uint64_t* in_masks, int* out_counts) {
        const __m256i x = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(in_masks));
        const __m256i low_nibble_mask = _mm256_set1_epi8(0x0F);
        const __m256i lut = _mm256_setr_epi8(
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);

        const __m256i lo = _mm256_and_si256(x, low_nibble_mask);
        const __m256i hi = _mm256_and_si256(_mm256_srli_epi16(x, 4), low_nibble_mask);
        const __m256i pc = _mm256_add_epi8(_mm256_shuffle_epi8(lut, lo), _mm256_shuffle_epi8(lut, hi));
        const __m256i sad = _mm256_sad_epu8(pc, _mm256_setzero_si256());
        alignas(32) uint64_t sums[4];
        _mm256_store_si256(reinterpret_cast<__m256i*>(sums), sad);
        out_counts[0] = static_cast<int>(sums[0]);
        out_counts[1] = static_cast<int>(sums[1]);
        out_counts[2] = static_cast<int>(sums[2]);
        out_counts[3] = static_cast<int>(sums[3]);
    }

    SUDOKU_TARGET_AVX512VPOPCNT static void popcount8x64_avx512vpopcnt(const uint64_t* in_masks, int* out_counts) {
        const __m512i x = _mm512_loadu_si512(reinterpret_cast<const void*>(in_masks));
        const __m512i c = _mm512_popcnt_epi64(x);
        alignas(64) uint64_t lanes[8];
        _mm512_store_si512(reinterpret_cast<__m512i*>(lanes), c);
        for (int i = 0; i < 8; ++i) {
            out_counts[i] = static_cast<int>(lanes[i]);
        }
    }
#endif

    static bool select_best_cell_bucketed_scalar(
        const GenericBoard& board,
        int& best_idx,
        uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        for (int idx = 0; idx < topo->nn; ++idx) {
            if (board.values[static_cast<size_t>(idx)] != 0) {
                continue;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int b = GenericBoard::packed_box(rcb);
            const uint64_t used = row_used[static_cast<size_t>(r)] |
                                  col_used[static_cast<size_t>(c)] |
                                  box_used[static_cast<size_t>(b)];
            const uint64_t candidate_mask = (~used) & full_mask;
            const int cnt = static_cast<int>(std::popcount(candidate_mask));
            const int pressure = static_cast<int>(std::popcount(used));
            if (!consider_empty_cell_mrv_precount(idx, candidate_mask, cnt, pressure, state)) {
                return false;
            }
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

#if defined(__x86_64__) || defined(__i386__)
    SUDOKU_TARGET_AVX2 static bool select_best_cell_bucketed_avx2(
        const GenericBoard& board,
        int& best_idx,
        uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        constexpr int kLanes = 16;  // 16x uint16_t in 256-bit register.
        const int nn = topo->nn;
        const auto* values_ptr = board.values.data();
        const __m256i zero = _mm256_setzero_si256();
        int batch_idx[4];
        uint64_t batch_cand[4];
        uint64_t batch_used[4];
        int batch_size = 0;
        auto flush_batch = [&](int count) -> bool {
            if (count <= 0) {
                return true;
            }
            int cand_cnt[4]{};
            int used_cnt[4]{};
            if (count == 4) {
                popcount4x64_avx2(batch_cand, cand_cnt);
                popcount4x64_avx2(batch_used, used_cnt);
            } else {
                for (int i = 0; i < count; ++i) {
                    cand_cnt[i] = static_cast<int>(std::popcount(batch_cand[i]));
                    used_cnt[i] = static_cast<int>(std::popcount(batch_used[i]));
                }
            }
            for (int i = 0; i < count; ++i) {
                if (!consider_empty_cell_mrv_precount(batch_idx[i], batch_cand[i], cand_cnt[i], used_cnt[i], state)) {
                    return false;
                }
            }
            return true;
        };

        int idx = 0;
        for (; idx + kLanes <= nn; idx += kLanes) {
            const __m256i v = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(values_ptr + idx));
            const __m256i eq_zero = _mm256_cmpeq_epi16(v, zero);
            const uint32_t bytes_mask = static_cast<uint32_t>(_mm256_movemask_epi8(eq_zero));
            uint32_t pair_mask = bytes_mask & (bytes_mask >> 1U) & 0x55555555U;
            while (pair_mask != 0U) {
                const uint32_t bit = static_cast<uint32_t>(std::countr_zero(pair_mask));
                const int lane = static_cast<int>(bit >> 1U);
                const int cell_idx = idx + lane;
                const uint32_t rcb = packed_ptr[static_cast<size_t>(cell_idx)];
                const int r = GenericBoard::packed_row(rcb);
                const int c = GenericBoard::packed_col(rcb);
                const int b = GenericBoard::packed_box(rcb);
                const uint64_t used = row_used[static_cast<size_t>(r)] |
                                      col_used[static_cast<size_t>(c)] |
                                      box_used[static_cast<size_t>(b)];
                batch_idx[batch_size] = cell_idx;
                batch_used[batch_size] = used;
                batch_cand[batch_size] = (~used) & full_mask;
                ++batch_size;
                if (batch_size == 4) {
                    if (!flush_batch(batch_size)) {
                        return false;
                    }
                    batch_size = 0;
                }
                pair_mask &= (pair_mask - 1U);
            }
        }
        for (; idx < nn; ++idx) {
            if (values_ptr[idx] != 0) {
                continue;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int b = GenericBoard::packed_box(rcb);
            const uint64_t used = row_used[static_cast<size_t>(r)] |
                                  col_used[static_cast<size_t>(c)] |
                                  box_used[static_cast<size_t>(b)];
            batch_idx[batch_size] = idx;
            batch_used[batch_size] = used;
            batch_cand[batch_size] = (~used) & full_mask;
            ++batch_size;
            if (batch_size == 4) {
                if (!flush_batch(batch_size)) {
                    return false;
                }
                batch_size = 0;
            }
        }
        if (!flush_batch(batch_size)) {
            return false;
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

    SUDOKU_TARGET_AVX512BW static bool select_best_cell_bucketed_avx512(
        const GenericBoard& board,
        int& best_idx,
        uint64_t& best_mask) {
        MvrState state{};
        const auto* topo = board.topo;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const uint64_t full_mask = board.full_mask;

        constexpr int kLanes = 32;  // 32x uint16_t in 512-bit register.
        const int nn = topo->nn;
        const auto* values_ptr = board.values.data();
        const __m512i zero = _mm512_setzero_si512();
        static const bool kHasVpopcntDq =
#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
            __builtin_cpu_supports("avx512vpopcntdq");
#else
            false;
#endif

        int batch_idx[8];
        uint64_t batch_cand[8];
        uint64_t batch_used[8];
        int batch_size = 0;
        auto flush_batch = [&](int count) -> bool {
            if (count <= 0) {
                return true;
            }
            int cand_cnt[8]{};
            int used_cnt[8]{};
            if (count == 8 && kHasVpopcntDq) {
                popcount8x64_avx512vpopcnt(batch_cand, cand_cnt);
                popcount8x64_avx512vpopcnt(batch_used, used_cnt);
            } else {
                for (int i = 0; i < count; ++i) {
                    cand_cnt[i] = static_cast<int>(std::popcount(batch_cand[i]));
                    used_cnt[i] = static_cast<int>(std::popcount(batch_used[i]));
                }
            }
            for (int i = 0; i < count; ++i) {
                if (!consider_empty_cell_mrv_precount(batch_idx[i], batch_cand[i], cand_cnt[i], used_cnt[i], state)) {
                    return false;
                }
            }
            return true;
        };

        int idx = 0;
        for (; idx + kLanes <= nn; idx += kLanes) {
            const __m512i v = _mm512_loadu_si512(reinterpret_cast<const void*>(values_ptr + idx));
            uint32_t empty_mask = static_cast<uint32_t>(_mm512_cmpeq_epi16_mask(v, zero));
            while (empty_mask != 0U) {
                const uint32_t lane = static_cast<uint32_t>(std::countr_zero(empty_mask));
                const int cell_idx = idx + static_cast<int>(lane);
                const uint32_t rcb = packed_ptr[static_cast<size_t>(cell_idx)];
                const int r = GenericBoard::packed_row(rcb);
                const int c = GenericBoard::packed_col(rcb);
                const int b = GenericBoard::packed_box(rcb);
                const uint64_t used = row_used[static_cast<size_t>(r)] |
                                      col_used[static_cast<size_t>(c)] |
                                      box_used[static_cast<size_t>(b)];
                batch_idx[batch_size] = cell_idx;
                batch_used[batch_size] = used;
                batch_cand[batch_size] = (~used) & full_mask;
                ++batch_size;
                if (batch_size == 8) {
                    if (!flush_batch(batch_size)) {
                        return false;
                    }
                    batch_size = 0;
                }
                empty_mask &= (empty_mask - 1U);
            }
        }
        for (; idx < nn; ++idx) {
            if (values_ptr[idx] != 0) {
                continue;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int b = GenericBoard::packed_box(rcb);
            const uint64_t used = row_used[static_cast<size_t>(r)] |
                                  col_used[static_cast<size_t>(c)] |
                                  box_used[static_cast<size_t>(b)];
            batch_idx[batch_size] = idx;
            batch_used[batch_size] = used;
            batch_cand[batch_size] = (~used) & full_mask;
            ++batch_size;
            if (batch_size == 8) {
                if (!flush_batch(batch_size)) {
                    return false;
                }
                batch_size = 0;
            }
        }
        if (!flush_batch(batch_size)) {
            return false;
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }
#endif

    // MRV with bucketed candidate counts and pressure tie-break for asymmetric topologies.
    static bool select_best_cell_bucketed(
        const GenericBoard& board,
        int& best_idx,
        uint64_t& best_mask,
        Backend backend = Backend::Scalar) {
        switch (backend) {
        case Backend::Avx512:
#if defined(__x86_64__) || defined(__i386__)
            return select_best_cell_bucketed_avx512(board, best_idx, best_mask);
#else
            return select_best_cell_bucketed_scalar(board, best_idx, best_mask);
#endif
        case Backend::Avx2:
#if defined(__x86_64__) || defined(__i386__)
            return select_best_cell_bucketed_avx2(board, best_idx, best_mask);
#else
            return select_best_cell_bucketed_scalar(board, best_idx, best_mask);
#endif
        case Backend::Scalar:
        default:
            return select_best_cell_bucketed_scalar(board, best_idx, best_mask);
        }
    }

    static bool init_candidate_cache(const GenericBoard& board, CandidateCache& cache) {
        const auto* topo = board.topo;
        const int nn = topo->nn;
        const auto* packed_ptr = topo->cell_rcb_packed.data();
        const auto* row_used = board.row_used.data();
        const auto* col_used = board.col_used.data();
        const auto* box_used = board.box_used.data();
        const auto* values_ptr = board.values.data();
        const uint64_t full_mask = board.full_mask;
        std::fill(cache.singleton_words.begin(), cache.singleton_words.end(), 0ULL);
        for (int idx = 0; idx < nn; ++idx) {
            if (values_ptr[static_cast<size_t>(idx)] != 0) {
                cache_set_candidate(cache, idx, 0ULL, 0U);
                continue;
            }
            const uint32_t rcb = packed_ptr[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(rcb);
            const int c = GenericBoard::packed_col(rcb);
            const int b = GenericBoard::packed_box(rcb);
            const uint64_t used = row_used[static_cast<size_t>(r)] |
                                  col_used[static_cast<size_t>(c)] |
                                  box_used[static_cast<size_t>(b)];
            const uint64_t mask = (~used) & full_mask;
            if (mask == 0ULL) {
                return false;
            }
            const uint8_t cnt = static_cast<uint8_t>(std::popcount(mask));
            cache_set_candidate(cache, idx, mask, cnt);
        }
        cache.undo_idx.clear();
        cache.undo_old.clear();
        cache.undo_old_count.clear();
        return true;
    }

    static bool select_best_cell_cached(
        const GenericBoard& board,
        const CandidateCache& cache,
        int& best_idx,
        uint64_t& best_mask) {
        MvrState state{};
        const int nn = board.topo->nn;
        const int n = board.topo->n;
        const uint64_t* const cand_ptr = cache.candidates.data();
        const uint8_t* const cnt_ptr = cache.candidate_popcnt.data();
        const uint64_t* const singles_ptr = cache.singleton_words.data();
        const int single_words = static_cast<int>(cache.singleton_words.size());
        for (int wi = 0; wi < single_words; ++wi) {
            uint64_t sw = singles_ptr[static_cast<size_t>(wi)];
            while (sw != 0ULL) {
                const int bit = static_cast<int>(std::countr_zero(sw));
                const int idx = (wi << 6) + bit;
                if (idx >= nn) {
                    break;
                }
                const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
                if (candidate_mask != 0ULL) {
                    best_idx = idx;
                    best_mask = candidate_mask;
                    return true;
                }
                sw &= (sw - 1ULL);
            }
        }
        for (int idx = 0; idx < nn; ++idx) {
            const int cnt = static_cast<int>(cnt_ptr[static_cast<size_t>(idx)]);
            if (cnt == 0) {
                continue;
            }
            if (cnt == 1) {
                const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
                best_idx = idx;
                best_mask = candidate_mask;
                return true;
            }
            const uint64_t candidate_mask = cand_ptr[static_cast<size_t>(idx)];
            const int pressure = n - cnt;
            if (!consider_empty_cell_mrv_precount(idx, candidate_mask, cnt, pressure, state)) {
                return false;
            }
        }
        return finalize_mrv_pick(best_idx, best_mask, state);
    }

    static bool try_place_with_cache(
        GenericBoard& board,
        CandidateCache& cache,
        int idx,
        int digit,
        size_t& out_marker) {
        const auto* topo = board.topo;
        const uint64_t placed_bit = 1ULL << (digit - 1);

        out_marker = cache.undo_idx.size();
        const size_t idx_u = static_cast<size_t>(idx);
        cache.undo_idx.push_back(idx);
        cache.undo_old.push_back(cache.candidates[idx_u]);
        cache.undo_old_count.push_back(cache.candidate_popcnt[idx_u]);
        cache_set_candidate(cache, idx, 0ULL, 0U);

        board.place(idx, digit);
        const int off0 = topo->peer_offsets[static_cast<size_t>(idx)];
        const int off1 = topo->peer_offsets[static_cast<size_t>(idx + 1)];
        for (int p = off0; p < off1; ++p) {
            const int peer_idx = topo->peers_flat[static_cast<size_t>(p)];
            const size_t peer_u = static_cast<size_t>(peer_idx);
            const uint64_t old_mask = cache.candidates[peer_u];
            if (old_mask == 0ULL) {
                continue;
            }
            const uint64_t new_mask = old_mask & ~placed_bit;
            if (new_mask == old_mask) {
                continue;
            }
            cache.undo_idx.push_back(peer_idx);
            cache.undo_old.push_back(old_mask);
            cache.undo_old_count.push_back(cache.candidate_popcnt[peer_u]);
            if (new_mask == 0ULL) {
                cache_set_candidate(cache, peer_idx, 0ULL, 0U);
                return false;
            }
            const uint8_t new_cnt = static_cast<uint8_t>(std::popcount(new_mask));
            cache_set_candidate(cache, peer_idx, new_mask, new_cnt);
        }
        return true;
    }

    static void rollback_place_with_cache(
        GenericBoard& board,
        CandidateCache& cache,
        int idx,
        int digit,
        size_t marker) {
        while (cache.undo_idx.size() > marker) {
            const int changed_idx = cache.undo_idx.back();
            const uint64_t old_mask = cache.undo_old.back();
            const uint8_t old_count = cache.undo_old_count.back();
            cache.undo_idx.pop_back();
            cache.undo_old.pop_back();
            cache.undo_old_count.pop_back();
            cache_set_candidate(cache, changed_idx, old_mask, old_count);
        }
        board.unplace(idx, digit);
    }

    bool fill_cached(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget, CandidateCache& cache) const {
        const bool has_budget = (budget != nullptr);
        if (has_budget && !budget->step()) {
            return false;
        }
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        if (!select_best_cell_cached(board, cache, best_idx, best_mask)) {
            return false;
        }
        if (best_idx == -1) {
            return true;
        }

        int digits[64];
        const int digit_count = shuffled_digits_from_mask(best_mask, rng, digits);
        if (digit_count == 1) {
            size_t marker = 0;
            const int d = digits[0];
            const bool ok = try_place_with_cache(board, cache, best_idx, d, marker);
            if (ok && fill_cached(board, rng, budget, cache)) {
                return true;
            }
            rollback_place_with_cache(board, cache, best_idx, d, marker);
            return false;
        }
        for (int i = 0; i < digit_count; ++i) {
            const int d = digits[i];
            size_t marker = 0;
            const bool ok = try_place_with_cache(board, cache, best_idx, d, marker);
            if (ok && fill_cached(board, rng, budget, cache)) {
                return true;
            }
            rollback_place_with_cache(board, cache, best_idx, d, marker);
            if (has_budget && budget->aborted()) {
                return false;
            }
        }
        return false;
    }

    bool fill_recompute(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget) const {
        const bool has_budget = (budget != nullptr);
        if (has_budget && !budget->step()) {
            return false;
        }
        int best_idx = -1;
        uint64_t best_mask = 0ULL;
        if (!select_best_cell_bucketed(board, best_idx, best_mask, backend_)) {
            return false;
        }
        if (best_idx == -1) {
            return true;
        }

        int digits[64];
        const int digit_count = shuffled_digits_from_mask(best_mask, rng, digits);
        if (digit_count == 1) {
            const int d = digits[0];
            board.place(best_idx, d);
            if (fill_recompute(board, rng, budget)) {
                return true;
            }
            board.unplace(best_idx, d);
            return false;
        }
        for (int i = 0; i < digit_count; ++i) {
            const int d = digits[i];
            board.place(best_idx, d);
            if (fill_recompute(board, rng, budget)) {
                return true;
            }
            board.unplace(best_idx, d);
            if (has_budget && budget->aborted()) {
                return false;
            }
        }
        return false;
    }

    bool fill(GenericBoard& board, std::mt19937_64& rng, SearchAbortControl* budget) const {
        // Candidate-cache MRV is most beneficial for larger boards where repeated
        // candidate recomputation dominates. For smaller geometries, recompute path
        // with AVX dispatch is typically faster.
        static constexpr int kCacheMrvMinN = 25;
        if (board.topo->n < kCacheMrvMinN) {
            return fill_recompute(board, rng, budget);
        }
        CandidateCache& cache = candidate_cache_for(*board.topo);
        if (!init_candidate_cache(board, cache)) {
            return false;
        }
        return fill_cached(board, rng, budget, cache);
    }

    bool generate(
        const GenericTopology& topo,
        std::mt19937_64& rng,
        std::vector<uint16_t>& out_solution,
        SearchAbortControl* budget = nullptr) const {
        static thread_local GenericBoard board;
        board.reset(topo);
        if (!fill(board, rng, budget)) {
            return false;
        }
        if (out_solution.size() != static_cast<size_t>(topo.nn)) {
            out_solution.resize(static_cast<size_t>(topo.nn));
        }
        std::copy_n(board.values.data(), static_cast<size_t>(topo.nn), out_solution.data());
        return true;
    }

private:
    Backend backend_ = Backend::Scalar;
};

struct GenericDigResult {
    std::vector<uint16_t> puzzle;
    int clues = 0;
};

struct GenericDigKernel {
    void dig_into(
        const std::vector<uint16_t>& solved,
        const GenericTopology& topo,
        const GenerateRunConfig& cfg,
        std::mt19937_64& rng,
        std::vector<uint16_t>& out_puzzle,
        int& out_clues,
        const uint8_t* protected_cells = nullptr) const {
        out_puzzle.resize(solved.size());
        std::copy(solved.begin(), solved.end(), out_puzzle.begin());
        int min_clues = std::clamp(cfg.min_clues, 0, topo.nn);
        int max_clues = std::clamp(cfg.max_clues, min_clues, topo.nn);
        std::uniform_int_distribution<int> pick_target(min_clues, max_clues);
        const int target_clues = pick_target(rng);

        GenericThreadScratch& scratch = generic_tls_for(topo);
        std::vector<int>& order = scratch.order;
        for (int i = 0; i < topo.nn; ++i) {
            order[static_cast<size_t>(i)] = i;
        }
        for (int i = topo.nn - 1; i > 0; --i) {
            const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
            std::swap(order[static_cast<size_t>(i)], order[static_cast<size_t>(j)]);
        }

        int clues = topo.nn;
        for (int i = 0; i < topo.nn; ++i) {
            const int idx = order[static_cast<size_t>(i)];
            if (clues <= target_clues) {
                break;
            }
            if (protected_cells != nullptr && protected_cells[static_cast<size_t>(idx)] != 0) {
                continue;
            }
            if (out_puzzle[static_cast<size_t>(idx)] == 0) {
                continue;
            }
            int sym_idx = -1;
            if (cfg.symmetry_center) {
                sym_idx = topo.cell_center_sym[static_cast<size_t>(idx)];
            }
            if (sym_idx >= 0 && sym_idx != idx && out_puzzle[static_cast<size_t>(sym_idx)] != 0) {
                if (protected_cells != nullptr &&
                    protected_cells[static_cast<size_t>(sym_idx)] != 0) {
                    continue;
                }
                if (clues - 2 < target_clues) {
                    continue;
                }
                out_puzzle[static_cast<size_t>(idx)] = 0;
                out_puzzle[static_cast<size_t>(sym_idx)] = 0;
                clues -= 2;
            } else {
                if (clues - 1 < target_clues) {
                    continue;
                }
                out_puzzle[static_cast<size_t>(idx)] = 0;
                --clues;
            }
        }
        out_clues = clues;
    }

    GenericDigResult dig(const std::vector<uint16_t>& solved, const GenericTopology& topo, const GenerateRunConfig& cfg, std::mt19937_64& rng) const {
        GenericDigResult result;
        dig_into(solved, topo, cfg, rng, result.puzzle, result.clues);
        return result;
    }
};

struct GenericQuickPrefilter {
    bool check(const std::vector<uint16_t>& puzzle, const GenericTopology& topo, int min_clues, int max_clues) const {
        if (static_cast<int>(puzzle.size()) != topo.nn) {
            return false;
        }
        int clues = 0;
        const auto& rcb = topo.cell_rcb_packed;
        GenericThreadScratch& scratch = generic_tls_for(topo);
        std::fill(scratch.row_tmp.begin(), scratch.row_tmp.end(), 0ULL);
        std::fill(scratch.col_tmp.begin(), scratch.col_tmp.end(), 0ULL);
        std::fill(scratch.box_tmp.begin(), scratch.box_tmp.end(), 0ULL);
        uint64_t* const row_used = scratch.row_tmp.data();
        uint64_t* const col_used = scratch.col_tmp.data();
        uint64_t* const box_used = scratch.box_tmp.data();
        const uint32_t* const packed = rcb.data();
        for (int idx = 0; idx < topo.nn; ++idx) {
            const int d = static_cast<int>(puzzle[static_cast<size_t>(idx)]);
            if (d == 0) {
                const int remaining = topo.nn - idx - 1;
                if (clues + remaining < min_clues) {
                    return false;
                }
                continue;
            }
            if (d < 1 || d > topo.n) {
                return false;
            }
            ++clues;
            if (clues > max_clues) {
                return false;
            }
            const uint32_t p = packed[static_cast<size_t>(idx)];
            const int r = GenericBoard::packed_row(p);
            const int c = GenericBoard::packed_col(p);
            const int b = GenericBoard::packed_box(p);
            const uint64_t bit = (1ULL << (d - 1));
            if ((row_used[static_cast<size_t>(r)] & bit) ||
                (col_used[static_cast<size_t>(c)] & bit) ||
                (box_used[static_cast<size_t>(b)] & bit)) {
                return false;
            }
            row_used[static_cast<size_t>(r)] |= bit;
            col_used[static_cast<size_t>(c)] |= bit;
            box_used[static_cast<size_t>(b)] |= bit;
        }
        return clues >= min_clues;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\logic\p1_p5\level1_module.h
==============================================================================

﻿#pragma once

#include "../../sudoku_logic_engine.h"

namespace sudoku_hpc::logic_p1_p5::level1 {

inline GenericLogicCertifyResult certify(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    SearchAbortControl* budget = nullptr,
    bool capture_solution_grid = false) {
    GenericLogicCertify core;
    return core.certify_up_to_level(puzzle, topo, 1, budget, capture_solution_grid);
}

}  // namespace sudoku_hpc::logic_p1_p5::level1




==============================================================================
PLIK: Sources\logic\p1_p5\level2_module.h
==============================================================================

﻿#pragma once

#include "../../sudoku_logic_engine.h"

namespace sudoku_hpc::logic_p1_p5::level2 {

inline GenericLogicCertifyResult certify(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    SearchAbortControl* budget = nullptr,
    bool capture_solution_grid = false) {
    GenericLogicCertify core;
    return core.certify_up_to_level(puzzle, topo, 2, budget, capture_solution_grid);
}

}  // namespace sudoku_hpc::logic_p1_p5::level2




==============================================================================
PLIK: Sources\logic\p1_p5\level3_module.h
==============================================================================

﻿#pragma once

#include "../../sudoku_logic_engine.h"

namespace sudoku_hpc::logic_p1_p5::level3 {

inline GenericLogicCertifyResult certify(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    SearchAbortControl* budget = nullptr,
    bool capture_solution_grid = false) {
    GenericLogicCertify core;
    return core.certify_up_to_level(puzzle, topo, 3, budget, capture_solution_grid);
}

}  // namespace sudoku_hpc::logic_p1_p5::level3




==============================================================================
PLIK: Sources\logic\p1_p5\level4_module.h
==============================================================================

﻿#pragma once

#include "../../sudoku_logic_engine.h"

namespace sudoku_hpc::logic_p1_p5::level4 {

inline GenericLogicCertifyResult certify(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    SearchAbortControl* budget = nullptr,
    bool capture_solution_grid = false) {
    GenericLogicCertify core;
    return core.certify_up_to_level(puzzle, topo, 4, budget, capture_solution_grid);
}

}  // namespace sudoku_hpc::logic_p1_p5::level4




==============================================================================
PLIK: Sources\logic\p1_p5\level5_module.h
==============================================================================

﻿#pragma once

#include "../../sudoku_logic_engine.h"

namespace sudoku_hpc::logic_p1_p5::level5 {

inline GenericLogicCertifyResult certify(
    const std::vector<uint16_t>& puzzle,
    const GenericTopology& topo,
    SearchAbortControl* budget = nullptr,
    bool capture_solution_grid = false) {
    GenericLogicCertify core;
    return core.certify_up_to_level(puzzle, topo, 5, budget, capture_solution_grid);
}

}  // namespace sudoku_hpc::logic_p1_p5::level5




==============================================================================
PLIK: Sources\logic\p6\bug_variants_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_bug_type2(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int nn = st.topo->nn;
        int tri[64]{};
        int tc = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 3) {
                if (tc < 64) tri[tc++] = idx;
            }
        }
        bool progress = false;
        for (int i = 0; i < tc; ++i) {
            const int a = tri[i];
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            for (int j = i + 1; j < tc; ++j) {
                const int b = tri[j];
                if (!is_peer(st, a, b)) continue;
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                const uint64_t shared = ma & mb;
                if (popcnt(shared) != 2) continue;
                const ApplyResult ea = st.keep_only(a, shared);
                if (ea == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ea; }
                const ApplyResult eb = st.keep_only(b, shared);
                if (eb == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return eb; }
                progress = progress || (ea == ApplyResult::Progress) || (eb == ApplyResult::Progress);
            }
        }
        if (progress) {
            ++s.hit_count;
            r.used_bug_type2 = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_bug_type3(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int n = st.topo->n;
        const int nn = st.topo->nn;
        int tri[64]{};
        int tc = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 3 && tc < 64) tri[tc++] = idx;
        }
        if (tc == 0) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        for (int ti = 0; ti < tc; ++ti) {
            const int idx = tri[ti];
            const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
            const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
            const int bb = st.topo->cell_box[static_cast<size_t>(idx)];
            const uint64_t m = st.cands[static_cast<size_t>(idx)];
            for (uint64_t w = m; w != 0ULL; w &= (w - 1ULL)) {
                const uint64_t bit = lsb(w);
                int row_cnt = 0;
                int col_cnt = 0;
                int box_cnt = 0;
                for (int c = 0; c < n; ++c) {
                    const int t = rr * n + c;
                    if (st.board->values[static_cast<size_t>(t)] == 0 &&
                        (st.cands[static_cast<size_t>(t)] & bit) != 0ULL) ++row_cnt;
                }
                for (int r0 = 0; r0 < n; ++r0) {
                    const int t = r0 * n + cc;
                    if (st.board->values[static_cast<size_t>(t)] == 0 &&
                        (st.cands[static_cast<size_t>(t)] & bit) != 0ULL) ++col_cnt;
                }
                for (int t = 0; t < nn; ++t) {
                    if (st.topo->cell_box[static_cast<size_t>(t)] != bb) continue;
                    if (st.board->values[static_cast<size_t>(t)] == 0 &&
                        (st.cands[static_cast<size_t>(t)] & bit) != 0ULL) ++box_cnt;
                }
                if ((row_cnt & 1) == 1 && (col_cnt & 1) == 1 && (box_cnt & 1) == 1) {
                    const int d = bit_to_index(bit) + 1;
                    if (!st.place(idx, d)) {
                        s.elapsed_ns += now_ns() - t0;
                        return ApplyResult::Contradiction;
                    }
                    ++s.hit_count;
                    ++s.placements;
                    ++r.steps;
                    r.used_bug_type3 = true;
                    s.elapsed_ns += now_ns() - t0;
                    return ApplyResult::Progress;
                }
            }
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_bug_type4(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int nn = st.topo->nn;
        int tri[64]{};
        int tc = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 3 && tc < 64) tri[tc++] = idx;
        }
        bool progress = false;
        for (int i = 0; i < tc; ++i) {
            const int a = tri[i];
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            for (int j = i + 1; j < tc; ++j) {
                const int b = tri[j];
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                const uint64_t common = ma & mb;
                if (popcnt(common) != 1) continue;
                for (int t = 0; t < nn; ++t) {
                    if (t == a || t == b) continue;
                    if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                    if (!is_peer(st, t, a) || !is_peer(st, t, b)) continue;
                    const ApplyResult er = st.eliminate(t, common);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }
        if (progress) {
            ++s.hit_count;
            r.used_bug_type4 = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p6\deadly_patterns_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_borescoper_qiu_deadly_pattern(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        StrategyStats tmp{};

        ApplyResult ar = apply_ur_extended(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_borescoper_qiu_deadly_pattern = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_hidden_ur(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_borescoper_qiu_deadly_pattern = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_bug_type2(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_borescoper_qiu_deadly_pattern = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_bug_type3(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_borescoper_qiu_deadly_pattern = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_bug_type4(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_borescoper_qiu_deadly_pattern = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        // Extra deadly proxy: if one cell sees all four UR corners, purge pair from that cell.
        const int n = st.topo->n;
        for (int r1 = 0; r1 < n; ++r1) {
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                for (int c1 = 0; c1 < n; ++c1) {
                    for (int c2 = c1 + 1; c2 < n; ++c2) {
                        const int a = r1 * n + c1;
                        const int b = r1 * n + c2;
                        const int c = r2 * n + c1;
                        const int d = r2 * n + c2;
                        if (st.board->values[static_cast<size_t>(a)] != 0 ||
                            st.board->values[static_cast<size_t>(b)] != 0 ||
                            st.board->values[static_cast<size_t>(c)] != 0 ||
                            st.board->values[static_cast<size_t>(d)] != 0) continue;
                        const uint64_t pair = st.cands[static_cast<size_t>(a)] &
                                              st.cands[static_cast<size_t>(b)] &
                                              st.cands[static_cast<size_t>(c)] &
                                              st.cands[static_cast<size_t>(d)];
                        if (popcnt(pair) != 2) continue;
                        for (int t = 0; t < st.topo->nn; ++t) {
                            if (t == a || t == b || t == c || t == d) continue;
                            if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                            if (!is_peer(st, t, a) || !is_peer(st, t, b) || !is_peer(st, t, c) || !is_peer(st, t, d)) continue;
                            const ApplyResult er = st.eliminate(t, pair);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            if (er == ApplyResult::Progress) {
                                ++s.hit_count;
                                r.used_borescoper_qiu_deadly_pattern = true;
                                s.elapsed_ns += now_ns() - t0;
                                return ApplyResult::Progress;
                            }
                        }
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p6\exact_pattern_scratchpad.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>

namespace sudoku_hpc {

struct ALS {
    uint64_t cell_mask[64]{};
    uint64_t digit_mask = 0ULL;
    uint8_t size = 0;
    uint8_t degree = 0;
    uint16_t house = 0;
};

struct alignas(64) ExactPatternScratchpad {
    static constexpr int MAX_N = 64;
    static constexpr int MAX_NN = MAX_N * MAX_N;
    static constexpr int MAX_HOUSES = MAX_N * 3;
    static constexpr int MAX_STRONG_LINKS_PER_DIGIT = MAX_HOUSES;
    static constexpr int MAX_EDGES = MAX_HOUSES;
    static constexpr int MAX_ADJ = MAX_NN * 128;
    static constexpr int MAX_BFS = MAX_NN * 4;
    static constexpr int MAX_CHAIN = MAX_NN * 8;
    static constexpr int MAX_LINK_EDGES = MAX_NN * 48;

    int bfs_queue[MAX_BFS]{};
    int bfs_depth[MAX_BFS]{};
    int bfs_parent[MAX_BFS]{};
    int visited[MAX_NN]{};

    int cell_to_node[MAX_NN]{};
    int node_to_cell[MAX_NN]{};
    int node_degree[MAX_NN]{};
    int adj_offsets[MAX_NN + 1]{};
    int adj_cursor[MAX_NN]{};
    int adj_flat[MAX_ADJ]{};
    int edge_u[MAX_EDGES]{};
    int edge_v[MAX_EDGES]{};
    int edge_count = 0;
    int node_count = 0;

    int chain_cell[MAX_CHAIN]{};
    uint64_t chain_enter_bit[MAX_CHAIN]{};
    int chain_parent[MAX_CHAIN]{};
    uint8_t chain_depth[MAX_CHAIN]{};
    int chain_count = 0;

    uint64_t fish_row_masks[MAX_N]{};
    uint64_t fish_col_masks[MAX_N]{};
    int active_rows[MAX_N]{};
    int active_cols[MAX_N]{};
    int wing_cells[MAX_NN]{};
    int wing_count = 0;

    ALS als_list[MAX_NN]{};
    int als_count = 0;
    int als_cells[MAX_NN]{};
    int als_cell_count = 0;
    int strong_count[MAX_N + 1]{};
    int strong_a[MAX_N + 1][MAX_STRONG_LINKS_PER_DIGIT]{};
    int strong_b[MAX_N + 1][MAX_STRONG_LINKS_PER_DIGIT]{};

    int dyn_cell_to_node[MAX_NN]{};
    int dyn_node_to_cell[MAX_NN]{};
    int dyn_node_count = 0;
    int dyn_digit_cells[MAX_NN]{};
    int dyn_digit_cell_count = 0;

    int dyn_strong_edge_u[MAX_HOUSES * 2]{};
    int dyn_strong_edge_v[MAX_HOUSES * 2]{};
    int dyn_strong_edge_count = 0;
    int dyn_weak_edge_u[MAX_LINK_EDGES]{};
    int dyn_weak_edge_v[MAX_LINK_EDGES]{};
    int dyn_weak_edge_count = 0;

    int dyn_strong_degree[MAX_NN]{};
    int dyn_weak_degree[MAX_NN]{};
    int dyn_strong_offsets[MAX_NN + 1]{};
    int dyn_weak_offsets[MAX_NN + 1]{};
    int dyn_strong_cursor[MAX_NN]{};
    int dyn_weak_cursor[MAX_NN]{};
    int dyn_strong_adj[MAX_ADJ]{};
    int dyn_weak_adj[MAX_ADJ]{};

    int dyn_state_depth[MAX_NN * 2]{};
    int dyn_state_parent[MAX_NN * 2]{};
    int dyn_state_queue[MAX_NN * 2]{};
    int dyn_prop_queue[MAX_NN]{};
    uint64_t dyn_cands_backup[MAX_NN]{};
    uint16_t dyn_values_backup[MAX_NN]{};
    int dyn_empty_backup = 0;

    void reset_node_maps(int nn) {
        std::fill_n(cell_to_node, nn, -1);
        node_count = 0;
        edge_count = 0;
    }

    void reset_graph(int node_n) {
        std::fill_n(node_degree, node_n, 0);
        std::fill_n(adj_offsets, node_n + 1, 0);
        std::fill_n(adj_cursor, node_n, 0);
    }

    void reset_dynamic_graph(int nn) {
        std::fill_n(dyn_cell_to_node, nn, -1);
        dyn_node_count = 0;
        dyn_digit_cell_count = 0;
        dyn_strong_edge_count = 0;
        dyn_weak_edge_count = 0;
    }

    void reset_dynamic_adjacency(int node_n) {
        std::fill_n(dyn_strong_degree, node_n, 0);
        std::fill_n(dyn_weak_degree, node_n, 0);
        std::fill_n(dyn_strong_offsets, node_n + 1, 0);
        std::fill_n(dyn_weak_offsets, node_n + 1, 0);
        std::fill_n(dyn_strong_cursor, node_n, 0);
        std::fill_n(dyn_weak_cursor, node_n, 0);
    }
};

inline ExactPatternScratchpad& exact_pattern_scratchpad() {
    thread_local ExactPatternScratchpad scratch;
    return scratch;
}

}  // namespace sudoku_hpc



==============================================================================
PLIK: Sources\logic\p6\ur_extended_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_ur_extended(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        const int n = st.topo->n;
        bool progress = false;
        for (int r1 = 0; r1 < n; ++r1) {
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                for (int c1 = 0; c1 < n; ++c1) {
                    for (int c2 = c1 + 1; c2 < n; ++c2) {
                        const int a = r1 * n + c1;
                        const int b = r1 * n + c2;
                        const int c = r2 * n + c1;
                        const int d = r2 * n + c2;
                        if (st.board->values[static_cast<size_t>(a)] != 0 ||
                            st.board->values[static_cast<size_t>(b)] != 0 ||
                            st.board->values[static_cast<size_t>(c)] != 0 ||
                            st.board->values[static_cast<size_t>(d)] != 0) {
                            continue;
                        }
                        const std::array<int, 4> cells = {a, b, c, d};
                        const std::array<uint64_t, 4> masks = {
                            st.cands[static_cast<size_t>(a)],
                            st.cands[static_cast<size_t>(b)],
                            st.cands[static_cast<size_t>(c)],
                            st.cands[static_cast<size_t>(d)]
                        };

                        const uint64_t pair = masks[0] & masks[1] & masks[2] & masks[3];
                        if (popcnt(pair) != 2) continue;
                        bool all_superset = true;
                        for (int i = 0; i < 4; ++i) {
                            if ((masks[static_cast<size_t>(i)] & pair) != pair) {
                                all_superset = false;
                                break;
                            }
                        }
                        if (!all_superset) continue;

                        int extra_count = 0;
                        int extra_idx[4]{-1, -1, -1, -1};
                        uint64_t extra_union = 0ULL;
                        for (int i = 0; i < 4; ++i) {
                            const uint64_t extra = masks[static_cast<size_t>(i)] & ~pair;
                            if (extra == 0ULL) continue;
                            extra_idx[extra_count++] = i;
                            extra_union |= extra;
                        }
                        if (extra_count == 0) continue;

                        // UR Type 2-6 proxy: one or more extra cells form a deadly rectangle barrier.
                        // Remove non-pair extras from the rectangle when they are weakly supported.
                        for (int ei = 0; ei < extra_count; ++ei) {
                            const int ci = extra_idx[ei];
                            const uint64_t rm = masks[static_cast<size_t>(ci)] & ~pair;
                            if (rm == 0ULL) continue;
                            const ApplyResult er = st.eliminate(cells[static_cast<size_t>(ci)], rm);
                            if (er == ApplyResult::Contradiction) {
                                s.elapsed_ns += now_ns() - t0;
                                return er;
                            }
                            progress = progress || (er == ApplyResult::Progress);
                        }

                        // Extended UR guard: if extra digit appears in >=2 rectangle cells, remove it
                        // from cells seeing all these occurrences.
                        for (uint64_t wx = extra_union; wx != 0ULL; wx &= (wx - 1ULL)) {
                            const uint64_t x = lsb(wx);
                            int holders[4]{-1, -1, -1, -1};
                            int hc = 0;
                            for (int i = 0; i < 4; ++i) {
                                if ((masks[static_cast<size_t>(i)] & x) != 0ULL) {
                                    holders[hc++] = cells[static_cast<size_t>(i)];
                                }
                            }
                            if (hc < 2) continue;
                            for (int t = 0; t < st.topo->nn; ++t) {
                                if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                                bool sees_all = true;
                                for (int i = 0; i < hc; ++i) {
                                    if (!is_peer(st, t, holders[i])) {
                                        sees_all = false;
                                        break;
                                    }
                                }
                                if (!sees_all) continue;
                                bool is_rect = false;
                                for (int i = 0; i < 4; ++i) {
                                    if (cells[static_cast<size_t>(i)] == t) {
                                        is_rect = true;
                                        break;
                                    }
                                }
                                if (is_rect) continue;
                                const ApplyResult er = st.eliminate(t, x);
                                if (er == ApplyResult::Contradiction) {
                                    s.elapsed_ns += now_ns() - t0;
                                    return er;
                                }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }
        }
        if (progress) {
            ++s.hit_count;
            r.used_ur_extended = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_hidden_ur(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int n = st.topo->n;
        bool progress = false;

        for (int d1 = 1; d1 <= n; ++d1) {
            const uint64_t b1 = (1ULL << (d1 - 1));
            for (int d2 = d1 + 1; d2 <= n; ++d2) {
                const uint64_t b2 = (1ULL << (d2 - 1));
                const uint64_t pair = b1 | b2;
                for (int r1 = 0; r1 < n; ++r1) {
                    for (int r2 = r1 + 1; r2 < n; ++r2) {
                        for (int c1 = 0; c1 < n; ++c1) {
                            for (int c2 = c1 + 1; c2 < n; ++c2) {
                                const int a = r1 * n + c1;
                                const int b = r1 * n + c2;
                                const int c = r2 * n + c1;
                                const int d = r2 * n + c2;
                                if (st.board->values[static_cast<size_t>(a)] != 0 ||
                                    st.board->values[static_cast<size_t>(b)] != 0 ||
                                    st.board->values[static_cast<size_t>(c)] != 0 ||
                                    st.board->values[static_cast<size_t>(d)] != 0) {
                                    continue;
                                }
                                const std::array<int, 4> cells = {a, b, c, d};
                                bool all_have_one = true;
                                for (int i = 0; i < 4; ++i) {
                                    const uint64_t m = st.cands[static_cast<size_t>(cells[static_cast<size_t>(i)])];
                                    if ((m & pair) == 0ULL) {
                                        all_have_one = false;
                                        break;
                                    }
                                }
                                if (!all_have_one) continue;

                                int row_hits_d1 = 0;
                                int row_hits_d2 = 0;
                                for (int cc = 0; cc < n; ++cc) {
                                    const int i1 = r1 * n + cc;
                                    const int i2 = r2 * n + cc;
                                    if (st.board->values[static_cast<size_t>(i1)] == 0 &&
                                        (st.cands[static_cast<size_t>(i1)] & b1) != 0ULL) ++row_hits_d1;
                                    if (st.board->values[static_cast<size_t>(i2)] == 0 &&
                                        (st.cands[static_cast<size_t>(i2)] & b1) != 0ULL) ++row_hits_d1;
                                    if (st.board->values[static_cast<size_t>(i1)] == 0 &&
                                        (st.cands[static_cast<size_t>(i1)] & b2) != 0ULL) ++row_hits_d2;
                                    if (st.board->values[static_cast<size_t>(i2)] == 0 &&
                                        (st.cands[static_cast<size_t>(i2)] & b2) != 0ULL) ++row_hits_d2;
                                }
                                if (row_hits_d1 < 4 || row_hits_d2 < 4) continue;

                                for (int i = 0; i < 4; ++i) {
                                    const int idx = cells[static_cast<size_t>(i)];
                                    const uint64_t m = st.cands[static_cast<size_t>(idx)];
                                    if ((m & pair) == pair && (m & ~pair) != 0ULL) {
                                        const ApplyResult er = st.eliminate(idx, m & ~pair);
                                        if (er == ApplyResult::Contradiction) {
                                            s.elapsed_ns += now_ns() - t0;
                                            return er;
                                        }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_hidden_ur = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p7\aligned_exclusion_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_aligned_pair_exclusion(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int nn = st.topo->nn;
        bool progress = false;

        for (int a = 0; a < nn; ++a) {
            if (st.board->values[static_cast<size_t>(a)] != 0) continue;
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            if (ma == 0ULL) continue;
            for (int b = a + 1; b < nn; ++b) {
                if (st.board->values[static_cast<size_t>(b)] != 0) continue;
                if (!is_peer(st, a, b)) continue;
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                if (mb == 0ULL) continue;

                uint64_t bad_a = 0ULL;
                uint64_t bad_b = 0ULL;
                for (uint64_t wa = ma; wa != 0ULL; wa &= (wa - 1ULL)) {
                    const uint64_t ba = lsb(wa);
                    const int da = bit_to_index(ba) + 1;
                    bool valid_for_a = false;
                    for (uint64_t wb = mb; wb != 0ULL; wb &= (wb - 1ULL)) {
                        const uint64_t bb = lsb(wb);
                        const int db = bit_to_index(bb) + 1;
                        if (da == db) continue;
                        if (!st.board->can_place(a, da) || !st.board->can_place(b, db)) continue;
                        valid_for_a = true;
                        break;
                    }
                    if (!valid_for_a) bad_a |= ba;
                }

                for (uint64_t wb = mb; wb != 0ULL; wb &= (wb - 1ULL)) {
                    const uint64_t bb = lsb(wb);
                    const int db = bit_to_index(bb) + 1;
                    bool valid_for_b = false;
                    for (uint64_t wa = ma; wa != 0ULL; wa &= (wa - 1ULL)) {
                        const uint64_t ba = lsb(wa);
                        const int da = bit_to_index(ba) + 1;
                        if (da == db) continue;
                        if (!st.board->can_place(a, da) || !st.board->can_place(b, db)) continue;
                        valid_for_b = true;
                        break;
                    }
                    if (!valid_for_b) bad_b |= bb;
                }

                if (bad_a != 0ULL) {
                    const ApplyResult er = st.eliminate(a, bad_a);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
                if (bad_b != 0ULL) {
                    const ApplyResult er = st.eliminate(b, bad_b);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_aligned_pair_exclusion = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_aligned_triple_exclusion(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int nn = st.topo->nn;
        bool progress = false;

        for (int a = 0; a < nn; ++a) {
            if (st.board->values[static_cast<size_t>(a)] != 0) continue;
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            if (ma == 0ULL || popcnt(ma) > 8) continue;
            for (int b = a + 1; b < nn; ++b) {
                if (st.board->values[static_cast<size_t>(b)] != 0) continue;
                if (!is_peer(st, a, b)) continue;
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                if (mb == 0ULL || popcnt(mb) > 8) continue;
                for (int c = b + 1; c < nn; ++c) {
                    if (st.board->values[static_cast<size_t>(c)] != 0) continue;
                    if (!is_peer(st, a, c) || !is_peer(st, b, c)) continue;
                    const uint64_t mc = st.cands[static_cast<size_t>(c)];
                    if (mc == 0ULL || popcnt(mc) > 8) continue;

                    uint64_t bad_a = 0ULL;
                    for (uint64_t wa = ma; wa != 0ULL; wa &= (wa - 1ULL)) {
                        const uint64_t ba = lsb(wa);
                        const int da = bit_to_index(ba) + 1;
                        bool valid = false;
                        for (uint64_t wb = mb; wb != 0ULL && !valid; wb &= (wb - 1ULL)) {
                            const uint64_t bb = lsb(wb);
                            const int db = bit_to_index(bb) + 1;
                            if (db == da) continue;
                            for (uint64_t wc = mc; wc != 0ULL; wc &= (wc - 1ULL)) {
                                const uint64_t bc = lsb(wc);
                                const int dc = bit_to_index(bc) + 1;
                                if (dc == da || dc == db) continue;
                                if (!st.board->can_place(a, da) || !st.board->can_place(b, db) || !st.board->can_place(c, dc)) continue;
                                valid = true;
                                break;
                            }
                        }
                        if (!valid) bad_a |= ba;
                    }

                    if (bad_a != 0ULL) {
                        const ApplyResult er = st.eliminate(a, bad_a);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_aligned_triple_exclusion = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p7\als_aic_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_als_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        auto& sp = exact_pattern_scratchpad();
        const int nn = st.topo->nn;
        bool progress = false;

        const int als_cnt = build_als_list(st, 2, 4);
        if (als_cnt < 2) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        // ALS-AIC proxy: join two ALS nodes by a grouped strong/weak chain on restricted common.
        for (int i = 0; i < als_cnt; ++i) {
            const ALS& a = sp.als_list[i];
            for (int j = i + 1; j < als_cnt; ++j) {
                const ALS& b = sp.als_list[j];
                const uint64_t common = a.digit_mask & b.digit_mask;
                if (popcnt(common) < 2) continue;

                const uint64_t x = lsb(common);
                const uint64_t zmask = common & ~x;
                if (zmask == 0ULL) continue;
                const int xd = bit_to_index(x) + 1;

                if (!build_grouped_link_graph_for_digit(st, xd, sp)) continue;
                if (sp.dyn_strong_edge_count == 0 && sp.dyn_weak_edge_count == 0) continue;

                for (uint64_t wz = zmask; wz != 0ULL; wz &= (wz - 1ULL)) {
                    const uint64_t z = lsb(wz);
                    for (int t = 0; t < nn; ++t) {
                        if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                        if ((st.cands[static_cast<size_t>(t)] & z) == 0ULL) continue;
                        if (als_cell_in(a, t) || als_cell_in(b, t)) continue;

                        bool sees_a = false;
                        bool sees_b = false;
                        for (int cell = 0; cell < nn && !(sees_a && sees_b); ++cell) {
                            if (!sees_a && als_cell_in(a, cell) && is_peer(st, t, cell)) sees_a = true;
                            if (!sees_b && als_cell_in(b, cell) && is_peer(st, t, cell)) sees_b = true;
                        }
                        if (!sees_a || !sees_b) continue;
                        const ApplyResult er = st.eliminate(t, z);
                        if (er == ApplyResult::Contradiction) {
                            s.elapsed_ns += now_ns() - t0;
                            return er;
                        }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_als_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p8\exocet_exact_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_exocet_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        const int n = st.topo->n;
        bool progress = false;
        for (int b = 0; b < n; ++b) {
            int box_cells[64]{};
            int bc = 0;
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.topo->cell_box[static_cast<size_t>(idx)] != b) continue;
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if (popcnt(st.cands[static_cast<size_t>(idx)]) != 2) continue;
                if (bc < 64) box_cells[bc++] = idx;
            }
            for (int i = 0; i < bc; ++i) {
                const int base1 = box_cells[i];
                const int r1 = st.topo->cell_row[static_cast<size_t>(base1)];
                const int c1 = st.topo->cell_col[static_cast<size_t>(base1)];
                const uint64_t m1 = st.cands[static_cast<size_t>(base1)];
                for (int j = i + 1; j < bc; ++j) {
                    const int base2 = box_cells[j];
                    const int r2 = st.topo->cell_row[static_cast<size_t>(base2)];
                    const int c2 = st.topo->cell_col[static_cast<size_t>(base2)];
                    if (r1 == r2 || c1 == c2) continue;
                    if (is_peer(st, base1, base2)) continue;
                    const uint64_t m2 = st.cands[static_cast<size_t>(base2)];
                    if (m1 != m2) continue;

                    // Cross targets: (r1,c2) and (r2,c1)
                    const int t1 = r1 * n + c2;
                    const int t2 = r2 * n + c1;
                    if (st.board->values[static_cast<size_t>(t1)] != 0 ||
                        st.board->values[static_cast<size_t>(t2)] != 0) {
                        continue;
                    }
                    const uint64_t common = m1 & m2;
                    if (popcnt(common) != 2) continue;

                    for (int rr = 0; rr < n; ++rr) {
                        const int idx1 = rr * n + c2;
                        if (idx1 != t1 && idx1 != base1 && idx1 != base2) {
                            const ApplyResult er = st.eliminate(idx1, common);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                        const int idx2 = rr * n + c1;
                        if (idx2 != t2 && idx2 != base1 && idx2 != base2) {
                            const ApplyResult er = st.eliminate(idx2, common);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_exocet = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }




==============================================================================
PLIK: Sources\logic\p8\forcing_chains_dynamic_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_dynamic_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.board->empty_cells > (st.topo->nn - st.topo->n)) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        auto& sp = exact_pattern_scratchpad();
        const int nn = st.topo->nn;
        const int n = st.topo->n;

        // 1) Exact-style contradiction probing on constrained pivots.
        int pivots[32]{};
        int pc = 0;
        for (int idx = 0; idx < nn && pc < 32; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const int c = popcnt(st.cands[static_cast<size_t>(idx)]);
            if (c >= 2 && c <= std::min(5, n)) pivots[pc++] = idx;
        }

        for (int pi = 0; pi < pc; ++pi) {
            const int pivot = pivots[pi];
            for (int i = 0; i < nn; ++i) {
                sp.dyn_cands_backup[i] = st.cands[static_cast<size_t>(i)];
                sp.dyn_values_backup[i] = st.board->values[static_cast<size_t>(i)];
            }
            sp.dyn_empty_backup = st.board->empty_cells;

            uint64_t contradiction_bits = 0ULL;
            const uint64_t pm = st.cands[static_cast<size_t>(pivot)];
            for (uint64_t w = pm; w != 0ULL; w &= (w - 1ULL)) {
                const uint64_t bit = lsb(w);
                const int d = bit_to_index(bit) + 1;

                for (int i = 0; i < nn; ++i) {
                    st.cands[static_cast<size_t>(i)] = sp.dyn_cands_backup[i];
                    st.board->values[static_cast<size_t>(i)] = sp.dyn_values_backup[i];
                }
                st.board->empty_cells = sp.dyn_empty_backup;

                bool contradiction = false;
                if (!st.place(pivot, d)) {
                    contradiction = true;
                } else {
                    int iters = 0;
                    bool changed = true;
                    while (changed && iters < 160) {
                        changed = false;
                        ++iters;
                        for (int idx = 0; idx < nn; ++idx) {
                            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                            const uint64_t m = st.cands[static_cast<size_t>(idx)];
                            if (m == 0ULL) {
                                contradiction = true;
                                break;
                            }
                            const int sd = single_digit(m);
                            if (sd == 0) continue;
                            if (!st.place(idx, sd)) {
                                contradiction = true;
                                break;
                            }
                            changed = true;
                        }
                        if (contradiction) break;
                    }
                }
                if (contradiction) contradiction_bits |= bit;
            }

            for (int i = 0; i < nn; ++i) {
                st.cands[static_cast<size_t>(i)] = sp.dyn_cands_backup[i];
                st.board->values[static_cast<size_t>(i)] = sp.dyn_values_backup[i];
            }
            st.board->empty_cells = sp.dyn_empty_backup;

            if (contradiction_bits != 0ULL) {
                const ApplyResult er = st.eliminate(pivot, contradiction_bits);
                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                if (er == ApplyResult::Progress) {
                    ++s.hit_count;
                    r.used_dynamic_forcing_chains = true;
                    s.elapsed_ns += now_ns() - t0;
                    return ApplyResult::Progress;
                }
            }
        }

        // 2) Deep grouped strong/weak chain elimination with explicit depth cap.
        bool used_dynamic = false;
        const int depth_cap = std::clamp(20 + (st.board->empty_cells / std::max(1, st.topo->n)), 24, 48);
        const ApplyResult ar = apply_dynamic_chain_elimination(st, 6, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_dynamic_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }



==============================================================================
PLIK: Sources\logic\p8\level8_pattern_scratchpad.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <cstdint>

#include "../p6/exact_pattern_scratchpad.h"

namespace sudoku_hpc {

// Compatibility frame for Pattern Overlay style DFS/BFS exploration.
struct PomFrame {
    int cell_idx = -1;
    uint64_t pending_mask = 0ULL;
    uint64_t tried_mask = 0ULL;
};

// Level 8 dedicated scratch wrapper.
// Reuses the production ExactPatternScratchpad to avoid duplicate buffers.
struct alignas(64) Level8Scratchpad {
    ExactPatternScratchpad exact{};
    std::array<PomFrame, ExactPatternScratchpad::MAX_N> pom_stack{};
    int pom_depth = 0;

    void reset_pom() {
        pom_depth = 0;
        for (auto& f : pom_stack) {
            f.cell_idx = -1;
            f.pending_mask = 0ULL;
            f.tried_mask = 0ULL;
        }
    }
};

inline Level8Scratchpad& level8_pattern_scratchpad() {
    thread_local Level8Scratchpad scratch{};
    return scratch;
}

} // namespace sudoku_hpc




==============================================================================
PLIK: Sources\logic\p8\pom_exact_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_pom_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        auto& l8 = level8_pattern_scratchpad();
        auto& sp = l8.exact;
        const int nn = st.topo->nn;

        int pivot = -1;
        int best_pc = 10;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const int pc = popcnt(st.cands[static_cast<size_t>(idx)]);
            if (pc >= 2 && pc <= 4 && pc < best_pc) {
                best_pc = pc;
                pivot = idx;
                if (best_pc == 2) break;
            }
        }
        if (pivot < 0) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        l8.reset_pom();
        l8.pom_stack[0].cell_idx = pivot;
        l8.pom_stack[0].pending_mask = st.cands[static_cast<size_t>(pivot)];
        l8.pom_depth = 1;

        for (int i = 0; i < nn; ++i) {
            sp.dyn_cands_backup[i] = st.cands[static_cast<size_t>(i)];
            sp.dyn_values_backup[i] = st.board->values[static_cast<size_t>(i)];
        }
        sp.dyn_empty_backup = st.board->empty_cells;

        uint64_t inter_cands[ExactPatternScratchpad::MAX_NN]{};
        for (int i = 0; i < nn; ++i) inter_cands[i] = ~0ULL;
        uint64_t contradiction_mask = 0ULL;
        int valid_hyp = 0;

        const uint64_t pm = st.cands[static_cast<size_t>(pivot)];
        for (uint64_t w = pm; w != 0ULL; w &= (w - 1ULL)) {
            const uint64_t bit = lsb(w);
            const int d = bit_to_index(bit) + 1;

            for (int i = 0; i < nn; ++i) {
                st.cands[static_cast<size_t>(i)] = sp.dyn_cands_backup[i];
                st.board->values[static_cast<size_t>(i)] = sp.dyn_values_backup[i];
            }
            st.board->empty_cells = sp.dyn_empty_backup;

            bool contradiction = false;
            if (!st.place(pivot, d)) {
                contradiction = true;
            } else {
                int steps = 0;
                bool changed = true;
                while (changed && steps < 128) {
                    changed = false;
                    ++steps;
                    for (int idx = 0; idx < nn; ++idx) {
                        if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                        const uint64_t m = st.cands[static_cast<size_t>(idx)];
                        if (m == 0ULL) {
                            contradiction = true;
                            break;
                        }
                        const int sd = single_digit(m);
                        if (sd == 0) continue;
                        if (!st.place(idx, sd)) {
                            contradiction = true;
                            break;
                        }
                        changed = true;
                    }
                    if (contradiction) break;
                }
            }

            if (contradiction) {
                contradiction_mask |= bit;
                continue;
            }

            ++valid_hyp;
            for (int i = 0; i < nn; ++i) {
                uint64_t cur = st.cands[static_cast<size_t>(i)];
                if (st.board->values[static_cast<size_t>(i)] != 0) {
                    cur = (1ULL << (st.board->values[static_cast<size_t>(i)] - 1));
                }
                inter_cands[i] &= cur;
            }
        }

        for (int i = 0; i < nn; ++i) {
            st.cands[static_cast<size_t>(i)] = sp.dyn_cands_backup[i];
            st.board->values[static_cast<size_t>(i)] = sp.dyn_values_backup[i];
        }
        st.board->empty_cells = sp.dyn_empty_backup;

        if (contradiction_mask != 0ULL) {
            const ApplyResult er = st.eliminate(pivot, contradiction_mask);
            if (er == ApplyResult::Contradiction) {
                s.elapsed_ns += now_ns() - t0;
                return er;
            }
            if (er == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_pattern_overlay_method = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }

        if (valid_hyp >= 2) {
            bool progress = false;
            for (int idx = 0; idx < nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                const uint64_t base = st.cands[static_cast<size_t>(idx)];
                const uint64_t keep = inter_cands[idx] & base;
                if (keep == 0ULL) continue;
                const uint64_t rm = base & ~keep;
                if (rm == 0ULL) continue;
                const ApplyResult er = st.eliminate(idx, rm);
                if (er == ApplyResult::Contradiction) {
                    s.elapsed_ns += now_ns() - t0;
                    return er;
                }
                progress = progress || (er == ApplyResult::Progress);
            }
            if (progress) {
                ++s.hit_count;
                r.used_pattern_overlay_method = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }




==============================================================================
PLIK: Sources\logic\p8\sk_loop_exact_module.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static ApplyResult apply_sk_loop_exact(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;

        // Compact exact-like SK loop probe on 2x2 cyclic pivots with shared bi-value core.
        for (int r1 = 0; r1 < n; ++r1) {
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                for (int c1 = 0; c1 < n; ++c1) {
                    for (int c2 = c1 + 1; c2 < n; ++c2) {
                        const int a = r1 * n + c1;
                        const int b = r1 * n + c2;
                        const int c = r2 * n + c1;
                        const int d = r2 * n + c2;
                        if (st.board->values[static_cast<size_t>(a)] != 0 ||
                            st.board->values[static_cast<size_t>(b)] != 0 ||
                            st.board->values[static_cast<size_t>(c)] != 0 ||
                            st.board->values[static_cast<size_t>(d)] != 0) continue;

                        const uint64_t ma = st.cands[static_cast<size_t>(a)];
                        const uint64_t mb = st.cands[static_cast<size_t>(b)];
                        const uint64_t mc = st.cands[static_cast<size_t>(c)];
                        const uint64_t md = st.cands[static_cast<size_t>(d)];
                        const uint64_t core = ma & mb & mc & md;
                        if (popcnt(core) != 2) continue;

                        const uint64_t exa = ma & ~core;
                        const uint64_t exb = mb & ~core;
                        const uint64_t exc = mc & ~core;
                        const uint64_t exd = md & ~core;
                        const uint64_t extra_union = exa | exb | exc | exd;
                        if (extra_union == 0ULL) continue;

                        for (uint64_t wx = extra_union; wx != 0ULL; wx &= (wx - 1ULL)) {
                            const uint64_t x = lsb(wx);
                            int holders[4]{};
                            int hc = 0;
                            if ((exa & x) != 0ULL) holders[hc++] = a;
                            if ((exb & x) != 0ULL) holders[hc++] = b;
                            if ((exc & x) != 0ULL) holders[hc++] = c;
                            if ((exd & x) != 0ULL) holders[hc++] = d;
                            if (hc < 2) continue;
                            for (int t = 0; t < st.topo->nn; ++t) {
                                if (t == a || t == b || t == c || t == d) continue;
                                if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                                bool sees_all = true;
                                for (int i = 0; i < hc; ++i) {
                                    if (!is_peer(st, t, holders[i])) {
                                        sees_all = false;
                                        break;
                                    }
                                }
                                if (!sees_all) continue;
                                const ApplyResult er = st.eliminate(t, x);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_sk_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }




==============================================================================
PLIK: Sources\logic\shared\als_builder.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static void als_clear_cell_mask(ALS& als, int words) {
        for (int w = 0; w < words; ++w) als.cell_mask[w] = 0ULL;
    }

    static bool als_cell_in(const ALS& als, int idx) {
        const int w = (idx >> 6);
        const int b = (idx & 63);
        return (als.cell_mask[w] & (1ULL << b)) != 0ULL;
    }

    static void als_add_cell(ALS& als, int idx) {
        const int w = (idx >> 6);
        const int b = (idx & 63);
        als.cell_mask[w] |= (1ULL << b);
    }

    static void als_push_record(
        ExactPatternScratchpad& sp,
        int words,
        int house,
        const int* cells,
        int cell_count,
        uint64_t digit_mask) {
        if (sp.als_count >= ExactPatternScratchpad::MAX_NN) return;
        ALS& rec = sp.als_list[sp.als_count++];
        als_clear_cell_mask(rec, words);
        for (int i = 0; i < cell_count; ++i) {
            als_add_cell(rec, cells[i]);
        }
        rec.digit_mask = digit_mask;
        rec.size = static_cast<uint8_t>(cell_count);
        rec.degree = static_cast<uint8_t>(std::popcount(digit_mask) - cell_count);
        rec.house = static_cast<uint16_t>(std::max(0, house));
    }

    static int build_als_list(CandidateState& st, int min_size = 2, int max_size = 4) {
        auto& sp = exact_pattern_scratchpad();
        sp.als_count = 0;
        const int nn = st.topo->nn;
        const int n = st.topo->n;
        const int words = (nn + 63) >> 6;
        const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
        const int lo = std::clamp(min_size, 2, 6);
        const int hi = std::clamp(max_size, lo, 6);

        int house_cells[64]{};
        uint64_t house_masks[64]{};

        for (int h = 0; h < house_count; ++h) {
            const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
            const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
            int hc = 0;
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                const uint64_t m = st.cands[static_cast<size_t>(idx)];
                const int pc = popcnt(m);
                if (pc < 2 || pc > n) continue;
                house_cells[hc] = idx;
                house_masks[hc] = m;
                ++hc;
                if (hc >= 64) break;
            }
            if (hc < lo) continue;

            for (int a = 0; a < hc; ++a) {
                if (lo <= 1 && hi >= 1) {
                    const uint64_t dm = house_masks[a];
                    if (std::popcount(dm) == 2) {
                        const int cells[1] = {house_cells[a]};
                        als_push_record(sp, words, h, cells, 1, dm);
                    }
                }
                for (int b = a + 1; b < hc; ++b) {
                    const uint64_t dm2 = house_masks[a] | house_masks[b];
                    if (lo <= 2 && hi >= 2 && std::popcount(dm2) == 3) {
                        const int cells2[2] = {house_cells[a], house_cells[b]};
                        als_push_record(sp, words, h, cells2, 2, dm2);
                    }
                    if (hi < 3) continue;
                    for (int c = b + 1; c < hc; ++c) {
                        const uint64_t dm3 = dm2 | house_masks[c];
                        if (lo <= 3 && hi >= 3 && std::popcount(dm3) == 4) {
                            const int cells3[3] = {house_cells[a], house_cells[b], house_cells[c]};
                            als_push_record(sp, words, h, cells3, 3, dm3);
                        }
                        if (hi < 4) continue;
                        for (int d = c + 1; d < hc; ++d) {
                            const uint64_t dm4 = dm3 | house_masks[d];
                            if (lo <= 4 && hi >= 4 && std::popcount(dm4) == 5) {
                                const int cells4[4] = {house_cells[a], house_cells[b], house_cells[c], house_cells[d]};
                                als_push_record(sp, words, h, cells4, 4, dm4);
                            }
                        }
                    }
                }
            }
        }

        return sp.als_count;
    }




==============================================================================
PLIK: Sources\logic\shared\link_graph.h
==============================================================================

// Author copyright Marcin Matysek (Rewertyn)
#pragma once

    static bool link_graph_has_strong_edge(const ExactPatternScratchpad& sp, int u, int v) {
        for (int i = 0; i < sp.dyn_strong_edge_count; ++i) {
            const int a = sp.dyn_strong_edge_u[i];
            const int b = sp.dyn_strong_edge_v[i];
            if ((a == u && b == v) || (a == v && b == u)) return true;
        }
        return false;
    }

    static void link_graph_add_strong_edge(ExactPatternScratchpad& sp, int u, int v) {
        if (u == v) return;
        if (link_graph_has_strong_edge(sp, u, v)) return;
        if (sp.dyn_strong_edge_count >= (ExactPatternScratchpad::MAX_HOUSES * 2)) return;
        sp.dyn_strong_edge_u[sp.dyn_strong_edge_count] = u;
        sp.dyn_strong_edge_v[sp.dyn_strong_edge_count] = v;
        ++sp.dyn_strong_edge_count;
    }

    static void link_graph_add_weak_edge(ExactPatternScratchpad& sp, int u, int v) {
        if (u == v) return;
        if (link_graph_has_strong_edge(sp, u, v)) return;
        if (sp.dyn_weak_edge_count >= ExactPatternScratchpad::MAX_LINK_EDGES) return;
        sp.dyn_weak_edge_u[sp.dyn_weak_edge_count] = u;
        sp.dyn_weak_edge_v[sp.dyn_weak_edge_count] = v;
        ++sp.dyn_weak_edge_count;
    }

    static bool build_grouped_link_graph_for_digit(CandidateState& st, int digit, ExactPatternScratchpad& sp) {
        const int nn = st.topo->nn;
        const uint64_t bit = (1ULL << (digit - 1));
        sp.reset_dynamic_graph(nn);

        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
            if (sp.dyn_node_count >= nn) break;
            sp.dyn_cell_to_node[idx] = sp.dyn_node_count;
            sp.dyn_node_to_cell[sp.dyn_node_count] = idx;
            sp.dyn_digit_cells[sp.dyn_digit_cell_count++] = idx;
            ++sp.dyn_node_count;
        }
        if (sp.dyn_node_count < 2) return false;

        const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
        for (int h = 0; h < house_count; ++h) {
            const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
            const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
            int a = -1;
            int b = -1;
            int cnt = 0;
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                if (cnt == 0) a = idx;
                else if (cnt == 1) b = idx;
                ++cnt;
                if (cnt > 2) break;
            }
            if (cnt != 2) continue;
            const int na = sp.dyn_cell_to_node[a];
            const int nb = sp.dyn_cell_to_node[b];
            if (na < 0 || nb < 0) continue;
            link_graph_add_strong_edge(sp, na, nb);
        }

        for (int ni = 0; ni < sp.dyn_node_count; ++ni) {
            const int cell = sp.dyn_node_to_cell[ni];
            const int p0 = st.topo->peer_offsets[static_cast<size_t>(cell)];
            const int p1 = st.topo->peer_offsets[static_cast<size_t>(cell + 1)];
            for (int p = p0; p < p1; ++p) {
                const int peer = st.topo->peers_flat[static_cast<size_t>(p)];
                if (peer <= cell) continue;
                const int nj = sp.dyn_cell_to_node[peer];
                if (nj < 0) continue;
                link_graph_add_weak_edge(sp, ni, nj);
            }
        }
        if (sp.dyn_strong_edge_count == 0 && sp.dyn_weak_edge_count == 0) return false;

        sp.reset_dynamic_adjacency(sp.dyn_node_count);
        for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
            const int u = sp.dyn_strong_edge_u[e];
            const int v = sp.dyn_strong_edge_v[e];
            ++sp.dyn_strong_degree[u];
            ++sp.dyn_strong_degree[v];
            ++sp.dyn_weak_degree[u];
            ++sp.dyn_weak_degree[v];
        }
        for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
            const int u = sp.dyn_weak_edge_u[e];
            const int v = sp.dyn_weak_edge_v[e];
            ++sp.dyn_weak_degree[u];
            ++sp.dyn_weak_degree[v];
        }

        int strong_total = 0;
        int weak_total = 0;
        for (int i = 0; i < sp.dyn_node_count; ++i) {
            sp.dyn_strong_offsets[i] = strong_total;
            sp.dyn_weak_offsets[i] = weak_total;
            strong_total += sp.dyn_strong_degree[i];
            weak_total += sp.dyn_weak_degree[i];
        }
        sp.dyn_strong_offsets[sp.dyn_node_count] = strong_total;
        sp.dyn_weak_offsets[sp.dyn_node_count] = weak_total;
        if (strong_total > ExactPatternScratchpad::MAX_ADJ || weak_total > ExactPatternScratchpad::MAX_ADJ) {
            return false;
        }

        for (int i = 0; i < sp.dyn_node_count; ++i) {
            sp.dyn_strong_cursor[i] = sp.dyn_strong_offsets[i];
            sp.dyn_weak_cursor[i] = sp.dyn_weak_offsets[i];
        }
        for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
            const int u = sp.dyn_strong_edge_u[e];
            const int v = sp.dyn_strong_edge_v[e];
            sp.dyn_strong_adj[sp.dyn_strong_cursor[u]++] = v;
            sp.dyn_strong_adj[sp.dyn_strong_cursor[v]++] = u;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
        }
        for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
            const int u = sp.dyn_weak_edge_u[e];
            const int v = sp.dyn_weak_edge_v[e];
            sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
        }
        return true;
    }




==============================================================================
PLIK: Sources\logic_engine_part01.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <bit>
#include <chrono>
#include <cstdint>
#include <deque>
#include <optional>
#include <string>
#include <vector>

#include "geometry.h"

namespace sudoku_hpc {

enum class RuntimeStrategyId : uint8_t {
    NakedSingle = 0,
    HiddenSingle = 1,
    PointingPairs = 2,
    BoxLineReduction = 3,
    NakedPair = 4,
    HiddenPair = 5,
    NakedTriple = 6,
    HiddenTriple = 7,
    NakedQuad = 8,
    HiddenQuad = 9,
    XWing = 10,
    YWing = 11,
    Skyscraper = 12,
    TwoStringKite = 13,
    EmptyRectangle = 14,
    RemotePairs = 15,
    Swordfish = 16,
    FinnedXWingSashimi = 17,
    SimpleColoring = 18,
    BUGPlusOne = 19,
    UniqueRectangle = 20,
    XYZWing = 21,
    WWing = 22,
    Jellyfish = 23,
    XChain = 24,
    XYChain = 25,
    WXYZWing = 26,
    FinnedSwordfishJellyfish = 27,
    ALSXZ = 28,
    UniqueLoop = 29,
    AvoidableRectangle = 30,
    BivalueOddagon = 31,
    Medusa3D = 32,
    AIC = 33,
    GroupedAIC = 34,
    GroupedXCycle = 35,
    ContinuousNiceLoop = 36,
    ALSXYWing = 37,
    ALSChain = 38,
    SueDeCoq = 39,
    DeathBlossom = 40,
    FrankenFish = 41,
    MutantFish = 42,
    KrakenFish = 43,
    MSLS = 44,
    Exocet = 45,
    SeniorExocet = 46,
    SKLoop = 47,
    PatternOverlayMethod = 48,
    ForcingChains = 49,
    Squirmbag = 50,
    URExtended = 51,
    HiddenUR = 52,
    BUGType2 = 53,
    BUGType3 = 54,
    BUGType4 = 55,
    BorescoperQiuDeadlyPattern = 56,
    AlignedPairExclusion = 57,
    AlignedTripleExclusion = 58,
    ALSAIC = 59,
    DynamicForcingChains = 60
};

struct RuntimeStrategyMeta {
    RuntimeStrategyId id{};
    const char* name = "";
    int level = 1;
    bool runtime_ready = false;
};

inline const std::vector<RuntimeStrategyMeta>& runtime_strategy_registry() {
    static const std::vector<RuntimeStrategyMeta> registry = {
        {RuntimeStrategyId::NakedSingle, "NakedSingle", 1, true},
        {RuntimeStrategyId::HiddenSingle, "HiddenSingle", 1, true},
        {RuntimeStrategyId::PointingPairs, "PointingPairs", 2, true},
        {RuntimeStrategyId::BoxLineReduction, "BoxLineReduction", 2, true},
        {RuntimeStrategyId::NakedPair, "NakedPair", 3, true},
        {RuntimeStrategyId::HiddenPair, "HiddenPair", 3, true},
        {RuntimeStrategyId::NakedTriple, "NakedTriple", 3, true},
        {RuntimeStrategyId::HiddenTriple, "HiddenTriple", 3, true},
        {RuntimeStrategyId::NakedQuad, "NakedQuad", 4, true},
        {RuntimeStrategyId::HiddenQuad, "HiddenQuad", 4, true},
        {RuntimeStrategyId::XWing, "XWing", 4, true},
        {RuntimeStrategyId::YWing, "YWing", 4, true},
        {RuntimeStrategyId::Skyscraper, "Skyscraper", 4, true},
        {RuntimeStrategyId::TwoStringKite, "TwoStringKite", 4, true},
        {RuntimeStrategyId::EmptyRectangle, "EmptyRectangle", 4, true},
        {RuntimeStrategyId::RemotePairs, "RemotePairs", 4, true},
        {RuntimeStrategyId::Swordfish, "Swordfish", 5, true},
        {RuntimeStrategyId::FinnedXWingSashimi, "FinnedXWingSashimi", 5, true},
        {RuntimeStrategyId::SimpleColoring, "SimpleColoring", 5, true},
        {RuntimeStrategyId::BUGPlusOne, "BUGPlusOne", 5, true},
        {RuntimeStrategyId::UniqueRectangle, "UniqueRectangle", 5, true},
        {RuntimeStrategyId::XYZWing, "XYZWing", 5, true},
        {RuntimeStrategyId::WWing, "WWing", 5, true},
        {RuntimeStrategyId::Jellyfish, "Jellyfish", 6, true},
        {RuntimeStrategyId::XChain, "XChain", 6, true},
        {RuntimeStrategyId::XYChain, "XYChain", 6, true},
        {RuntimeStrategyId::WXYZWing, "WXYZWing", 6, true},
        {RuntimeStrategyId::FinnedSwordfishJellyfish, "FinnedSwordfishJellyfish", 6, true},
        {RuntimeStrategyId::ALSXZ, "ALSXZ", 6, true},
        {RuntimeStrategyId::UniqueLoop, "UniqueLoop", 6, true},
        {RuntimeStrategyId::AvoidableRectangle, "AvoidableRectangle", 6, true},
        {RuntimeStrategyId::BivalueOddagon, "BivalueOddagon", 6, true},
        {RuntimeStrategyId::Medusa3D, "Medusa3D", 7, true},
        {RuntimeStrategyId::AIC, "AIC", 7, true},
        {RuntimeStrategyId::GroupedAIC, "GroupedAIC", 7, true},
        {RuntimeStrategyId::GroupedXCycle, "GroupedXCycle", 7, true},
        {RuntimeStrategyId::ContinuousNiceLoop, "ContinuousNiceLoop", 7, true},
        {RuntimeStrategyId::ALSXYWing, "ALSXYWing", 7, true},
        {RuntimeStrategyId::ALSChain, "ALSChain", 7, true},
        {RuntimeStrategyId::SueDeCoq, "SueDeCoq", 7, true},
        {RuntimeStrategyId::DeathBlossom, "DeathBlossom", 7, true},
        {RuntimeStrategyId::FrankenFish, "FrankenFish", 7, true},
        {RuntimeStrategyId::MutantFish, "MutantFish", 7, true},
        {RuntimeStrategyId::KrakenFish, "KrakenFish", 7, true},
        {RuntimeStrategyId::MSLS, "MSLS", 8, true},
        {RuntimeStrategyId::Exocet, "Exocet", 8, true},
        {RuntimeStrategyId::SeniorExocet, "SeniorExocet", 8, true},
        {RuntimeStrategyId::SKLoop, "SKLoop", 8, true},
        {RuntimeStrategyId::PatternOverlayMethod, "PatternOverlayMethod", 8, true},
        {RuntimeStrategyId::ForcingChains, "ForcingChains", 8, true},
        {RuntimeStrategyId::Squirmbag, "Squirmbag", 7, true},
        {RuntimeStrategyId::URExtended, "URExtended", 6, true},
        {RuntimeStrategyId::HiddenUR, "HiddenUR", 6, true},
        {RuntimeStrategyId::BUGType2, "BUGType2", 6, true},
        {RuntimeStrategyId::BUGType3, "BUGType3", 6, true},
        {RuntimeStrategyId::BUGType4, "BUGType4", 6, true},
        {RuntimeStrategyId::BorescoperQiuDeadlyPattern, "BorescoperQiuDeadlyPattern", 6, true},
        {RuntimeStrategyId::AlignedPairExclusion, "AlignedPairExclusion", 7, true},
        {RuntimeStrategyId::AlignedTripleExclusion, "AlignedTripleExclusion", 7, true},
        {RuntimeStrategyId::ALSAIC, "ALSAIC", 7, true},
        {RuntimeStrategyId::DynamicForcingChains, "DynamicForcingChains", 8, true},
    };
    return registry;
}

struct StrategyStats {
    uint64_t use_count = 0;
    uint64_t hit_count = 0;
    uint64_t placements = 0;
    uint64_t elapsed_ns = 0;
};

struct GenericLogicCertifyResult {
    bool solved = false;
    bool timed_out = false;
    bool used_naked_single = false;
    bool used_hidden_single = false;
    bool used_pointing_pairs = false;
    bool used_box_line = false;
    bool used_naked_pair = false;
    bool used_hidden_pair = false;
    bool used_naked_triple = false;
    bool used_hidden_triple = false;
    bool used_naked_quad = false;
    bool used_hidden_quad = false;
    bool used_x_wing = false;
    bool used_y_wing = false;
    bool used_skyscraper = false;
    bool used_two_string_kite = false;
    bool used_empty_rectangle = false;
    bool used_remote_pairs = false;
    bool used_swordfish = false;
    bool used_finned_x_wing_sashimi = false;
    bool used_simple_coloring = false;
    bool used_bug_plus_one = false;
    bool used_unique_rectangle = false;
    bool used_xyz_wing = false;
    bool used_w_wing = false;
    bool used_jellyfish = false;
    bool used_x_chain = false;
    bool used_xy_chain = false;
    bool used_wxyz_wing = false;
    bool used_finned_swordfish_jellyfish = false;
    bool used_als_xz = false;
    bool used_unique_loop = false;
    bool used_avoidable_rectangle = false;
    bool used_bivalue_oddagon = false;
    bool used_medusa_3d = false;
    bool used_aic = false;
    bool used_grouped_aic = false;
    bool used_grouped_x_cycle = false;
    bool used_continuous_nice_loop = false;
    bool used_als_xy_wing = false;
    bool used_als_chain = false;
    bool used_sue_de_coq = false;
    bool used_death_blossom = false;
    bool used_franken_fish = false;
    bool used_mutant_fish = false;
    bool used_kraken_fish = false;
    bool used_msls = false;
    bool used_exocet = false;
    bool used_senior_exocet = false;
    bool used_sk_loop = false;
    bool used_pattern_overlay_method = false;
    bool used_forcing_chains = false;
    bool used_squirmbag = false;
    bool used_ur_extended = false;
    bool used_hidden_ur = false;
    bool used_bug_type2 = false;
    bool used_bug_type3 = false;
    bool used_bug_type4 = false;
    bool used_borescoper_qiu_deadly_pattern = false;
    bool used_aligned_pair_exclusion = false;
    bool used_aligned_triple_exclusion = false;
    bool used_als_aic = false;
    bool used_dynamic_forcing_chains = false;
    bool naked_single_scanned = false;
    bool hidden_single_scanned = false;
    int steps = 0;
    std::vector<uint16_t> solved_grid;
    std::array<StrategyStats, 61> strategy_stats{};
};

struct GenericLogicCertify {
    enum class ApplyResult : uint8_t { NoProgress = 0, Progress = 1, Contradiction = 2 };
    enum StrategySlot : size_t {
        SlotNakedSingle = 0,
        SlotHiddenSingle = 1,
        SlotPointingPairs = 2,
        SlotBoxLineReduction = 3,
        SlotNakedPair = 4,
        SlotHiddenPair = 5,
        SlotNakedTriple = 6,
        SlotHiddenTriple = 7,
        SlotNakedQuad = 8,
        SlotHiddenQuad = 9,
        SlotXWing = 10,
        SlotYWing = 11,
        SlotSkyscraper = 12,
        SlotTwoStringKite = 13,
        SlotEmptyRectangle = 14,
        SlotRemotePairs = 15,
        SlotSwordfish = 16,
        SlotFinnedXWingSashimi = 17,
        SlotSimpleColoring = 18,
        SlotBUGPlusOne = 19,
        SlotUniqueRectangle = 20,
        SlotXYZWing = 21,
        SlotWWing = 22,
        SlotJellyfish = 23,
        SlotXChain = 24,
        SlotXYChain = 25,
        SlotWXYZWing = 26,
        SlotFinnedSwordfishJellyfish = 27,
        SlotALSXZ = 28,
        SlotUniqueLoop = 29,
        SlotAvoidableRectangle = 30,
        SlotBivalueOddagon = 31,
        SlotMedusa3D = 32,
        SlotAIC = 33,
        SlotGroupedAIC = 34,
        SlotGroupedXCycle = 35,
        SlotContinuousNiceLoop = 36,
        SlotALSXYWing = 37,
        SlotALSChain = 38,
        SlotSueDeCoq = 39,
        SlotDeathBlossom = 40,
        SlotFrankenFish = 41,
        SlotMutantFish = 42,
        SlotKrakenFish = 43,
        SlotMSLS = 44,
        SlotExocet = 45,
        SlotSeniorExocet = 46,
        SlotSKLoop = 47,
        SlotPatternOverlayMethod = 48,
        SlotForcingChains = 49,
        SlotSquirmbag = 50,
        SlotURExtended = 51,
        SlotHiddenUR = 52,
        SlotBUGType2 = 53,
        SlotBUGType3 = 54,
        SlotBUGType4 = 55,
        SlotBorescoperQiuDeadlyPattern = 56,
        SlotAlignedPairExclusion = 57,
        SlotAlignedTripleExclusion = 58,
        SlotALSAIC = 59,
        SlotDynamicForcingChains = 60
    };

private:
    static uint64_t now_ns() {
        return static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
    }

    struct CandidateState {
        GenericBoard* board = nullptr;
        const GenericTopology* topo = nullptr;
        std::vector<uint64_t> cands;

        bool init(GenericBoard& b, const GenericTopology& t) {
            board = &b;
            topo = &t;
            cands.assign(static_cast<size_t>(t.nn), 0ULL);
            for (int idx = 0; idx < t.nn; ++idx) {
                if (b.values[static_cast<size_t>(idx)] != 0) continue;
                const uint64_t m = b.candidate_mask_for_idx(idx);
                if (m == 0ULL) return false;
                cands[static_cast<size_t>(idx)] = m;
            }
            return true;
        }

        bool place(int idx, int d) {
            if (board->values[static_cast<size_t>(idx)] != 0) {
                return board->values[static_cast<size_t>(idx)] == static_cast<uint16_t>(d);
            }
            const uint64_t bit = (1ULL << (d - 1));
            if ((cands[static_cast<size_t>(idx)] & bit) == 0ULL) return false;
            if (!board->can_place(idx, d)) return false;
            board->place(idx, d);
            cands[static_cast<size_t>(idx)] = 0ULL;
            const int p0 = topo->peer_offsets[static_cast<size_t>(idx)];
            const int p1 = topo->peer_offsets[static_cast<size_t>(idx + 1)];
            for (int p = p0; p < p1; ++p) {
                const int peer = topo->peers_flat[static_cast<size_t>(p)];
                if (board->values[static_cast<size_t>(peer)] != 0) continue;
                uint64_t& pm = cands[static_cast<size_t>(peer)];
                if ((pm & bit) == 0ULL) continue;
                pm &= ~bit;
                if (pm == 0ULL) return false;
            }
            return true;
        }

        ApplyResult eliminate(int idx, uint64_t rm) {
            if (rm == 0ULL || board->values[static_cast<size_t>(idx)] != 0) return ApplyResult::NoProgress;
            uint64_t& m = cands[static_cast<size_t>(idx)];
            if ((m & rm) == 0ULL) return ApplyResult::NoProgress;
            m &= ~rm;
            if (m == 0ULL) return ApplyResult::Contradiction;
            return ApplyResult::Progress;
        }

        ApplyResult keep_only(int idx, uint64_t allowed) {
            if (board->values[static_cast<size_t>(idx)] != 0) return ApplyResult::NoProgress;
            uint64_t& m = cands[static_cast<size_t>(idx)];
            const uint64_t nm = m & allowed;
            if (nm == m) return ApplyResult::NoProgress;
            if (nm == 0ULL) return ApplyResult::Contradiction;
            m = nm;
            return ApplyResult::Progress;
        }
    };

    static int popcnt(uint64_t x) { return std::popcount(x); }
    static int single_digit(uint64_t m) {
        if (m == 0ULL || (m & (m - 1ULL)) != 0ULL) return 0;
        return static_cast<int>(std::countr_zero(m)) + 1;
    }
    static bool is_peer(const CandidateState& st, int a, int b) {
        if (a == b) return false;
        const auto& topo = *st.topo;
        return topo.cell_row[static_cast<size_t>(a)] == topo.cell_row[static_cast<size_t>(b)] ||
               topo.cell_col[static_cast<size_t>(a)] == topo.cell_col[static_cast<size_t>(b)] ||
               topo.cell_box[static_cast<size_t>(a)] == topo.cell_box[static_cast<size_t>(b)];
    }
    static uint64_t lsb(uint64_t x) { return x & (~x + 1ULL); }
    static int bit_to_index(uint64_t bit) { return static_cast<int>(std::countr_zero(bit)); }
    static bool decode_two_bits(uint64_t m, uint64_t& a, uint64_t& b) {
        if (popcnt(m) != 2) return false;
        a = lsb(m);
        b = m ^ a;
        return true;
    }

    static ApplyResult apply_naked_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const uint64_t m = st.cands[static_cast<size_t>(idx)];
            if (m == 0ULL) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
            const int d = single_digit(m);
            if (d == 0) continue;
            if (!st.place(idx, d)) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
            ++s.hit_count; ++s.placements; ++r.steps; r.used_naked_single = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_hidden_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h], p1 = st.topo->house_offsets[h + 1];
            for (int d = 1; d <= n; ++d) {
                const uint64_t bit = (1ULL << (d - 1));
                int pos = -1, cnt = 0;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                    pos = idx; ++cnt; if (cnt > 1) break;
                }
                if (cnt != 1) continue;
                if (!st.place(pos, d)) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
                ++s.hit_count; ++s.placements; ++r.steps; r.used_hidden_single = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_house_subset(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r, int subset, bool hidden) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;
        std::vector<uint64_t> pos;
        if (hidden) {
            pos.assign(static_cast<size_t>(n), 0ULL);
        }

        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h], p1 = st.topo->house_offsets[h + 1];
            if (!hidden) {
                std::vector<int> cells;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    const int bits = popcnt(st.cands[static_cast<size_t>(idx)]);
                    if (bits >= 2 && bits <= subset) cells.push_back(idx);
                }
                const int m = static_cast<int>(cells.size());
                if (m < subset) continue;
                auto apply_naked_union = [&](int a, int b, int c, int d) -> ApplyResult {
                    uint64_t um = st.cands[static_cast<size_t>(cells[static_cast<size_t>(a)])] |
                                  st.cands[static_cast<size_t>(cells[static_cast<size_t>(b)])];
                    if (c >= 0) um |= st.cands[static_cast<size_t>(cells[static_cast<size_t>(c)])];
                    if (d >= 0) um |= st.cands[static_cast<size_t>(cells[static_cast<size_t>(d)])];
                    if (popcnt(um) != subset) return ApplyResult::NoProgress;
                    for (int p = p0; p < p1; ++p) {
                        const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                        if (idx == cells[static_cast<size_t>(a)] || idx == cells[static_cast<size_t>(b)] ||
                            (c >= 0 && idx == cells[static_cast<size_t>(c)]) ||
                            (d >= 0 && idx == cells[static_cast<size_t>(d)])) {
                            continue;
                        }
                        const ApplyResult er = st.eliminate(idx, um);
                        if (er == ApplyResult::Contradiction) return er;
                        progress = progress || (er == ApplyResult::Progress);
                    }
                    return ApplyResult::NoProgress;
                };

                for (int i = 0; i < m; ++i) {
                    for (int j = i + 1; j < m; ++j) {
                        if (subset == 2) {
                            const ApplyResult rr = apply_naked_union(i, j, -1, -1);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                            continue;
                        }
                        for (int k = j + 1; k < m; ++k) {
                            if (subset == 3) {
                                const ApplyResult rr = apply_naked_union(i, j, k, -1);
                                if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                                continue;
                            }
                            for (int l = k + 1; l < m; ++l) {
                                const ApplyResult rr = apply_naked_union(i, j, k, l);
                                if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                            }
                        }
                    }
                }
            } else {
                std::fill(pos.begin(), pos.end(), 0ULL);
                for (int d = 1; d <= n; ++d) {
                    const uint64_t bit = (1ULL << (d - 1));
                    uint64_t bits = 0ULL;
                    for (int p = p0; p < p1; ++p) {
                        const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                        if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                        if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) bits |= (1ULL << (p - p0));
                    }
                    pos[static_cast<size_t>(d - 1)] = bits;
                }
                std::vector<int> active_digits;
                active_digits.reserve(static_cast<size_t>(n));
                for (int d = 1; d <= n; ++d) {
                    const int cnt = popcnt(pos[static_cast<size_t>(d - 1)]);
                    if (cnt >= 1 && cnt <= subset) {
                        active_digits.push_back(d);
                    }
                }
                if (static_cast<int>(active_digits.size()) < subset) {
                    continue;
                }
                auto apply_hidden_union = [&](int d1, int d2, int d3, int d4) -> ApplyResult {
                    uint64_t up = pos[static_cast<size_t>(d1 - 1)] | pos[static_cast<size_t>(d2 - 1)];
                    uint64_t allowed = (1ULL << (d1 - 1)) | (1ULL << (d2 - 1));
                    if (d3 > 0) {
                        up |= pos[static_cast<size_t>(d3 - 1)];
                        allowed |= (1ULL << (d3 - 1));
                    }
                    if (d4 > 0) {
                        up |= pos[static_cast<size_t>(d4 - 1)];
                        allowed |= (1ULL << (d4 - 1));
                    }
                    if (popcnt(up) != subset) return ApplyResult::NoProgress;
                    for (uint64_t w = up; w != 0ULL; w &= (w - 1ULL)) {
                        const int b = static_cast<int>(std::countr_zero(w));
                        const int idx = st.topo->houses_flat[static_cast<size_t>(p0 + b)];
                        const ApplyResult rr = st.keep_only(idx, allowed);
                        if (rr == ApplyResult::Contradiction) return rr;
                        progress = progress || (rr == ApplyResult::Progress);
                    }
                    return ApplyResult::NoProgress;
                };
                const int ad = static_cast<int>(active_digits.size());
                for (int i = 0; i < ad; ++i) {
                    const int d1 = active_digits[static_cast<size_t>(i)];
                    for (int j = i + 1; j < ad; ++j) {
                        const int d2 = active_digits[static_cast<size_t>(j)];
                        if (subset == 2) {
                            const ApplyResult rr = apply_hidden_union(d1, d2, -1, -1);
                            if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                            continue;
                        }
                        for (int k = j + 1; k < ad; ++k) {
                            const int d3 = active_digits[static_cast<size_t>(k)];
                            if (subset == 3) {
                                const ApplyResult rr = apply_hidden_union(d1, d2, d3, -1);
                                if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                                continue;
                            }
                            for (int l = k + 1; l < ad; ++l) {
                                const int d4 = active_digits[static_cast<size_t>(l)];
                                const ApplyResult rr = apply_hidden_union(d1, d2, d3, d4);
                                if (rr == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return rr; }
                            }
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            if (!hidden && subset == 2) r.used_naked_pair = true;
            if (!hidden && subset == 3) r.used_naked_triple = true;
            if (!hidden && subset == 4) r.used_naked_quad = true;
            if (hidden && subset == 2) r.used_hidden_pair = true;
            if (hidden && subset == 3) r.used_hidden_triple = true;
            if (hidden && subset == 4) r.used_hidden_quad = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_pointing_and_boxline(CandidateState& st, StrategyStats& sp, StrategyStats& sb, GenericLogicCertifyResult& r) {
        const uint64_t t0p = now_ns();
        ++sp.use_count;
        const int n = st.topo->n;
        bool p_progress = false;
        for (int brg = 0; brg < st.topo->box_rows_count; ++brg) {
            for (int bcg = 0; bcg < st.topo->box_cols_count; ++bcg) {
                const int r0 = brg * st.topo->box_rows;
                const int c0 = bcg * st.topo->box_cols;
                for (int d = 1; d <= n; ++d) {
                    const uint64_t bit = (1ULL << (d - 1));
                    int fr = -1, fc = -1, cnt = 0;
                    bool sr = true, sc = true;
                    for (int dr = 0; dr < st.topo->box_rows; ++dr) for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                        const int rr = r0 + dr, cc = c0 + dc, idx = rr * n + cc;
                        if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                        if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                        if (cnt == 0) { fr = rr; fc = cc; } else { sr = sr && (rr == fr); sc = sc && (cc == fc); }
                        ++cnt;
                    }
                    if (cnt < 2) continue;
                    if (sr) for (int c = 0; c < n; ++c) {
                        if (c >= c0 && c < c0 + st.topo->box_cols) continue;
                        const ApplyResult er = st.eliminate(fr * n + c, bit);
                        if (er == ApplyResult::Contradiction) { sp.elapsed_ns += now_ns() - t0p; return er; }
                        p_progress = p_progress || (er == ApplyResult::Progress);
                    }
                    if (sc) for (int rr = 0; rr < n; ++rr) {
                        if (rr >= r0 && rr < r0 + st.topo->box_rows) continue;
                        const ApplyResult er = st.eliminate(rr * n + fc, bit);
                        if (er == ApplyResult::Contradiction) { sp.elapsed_ns += now_ns() - t0p; return er; }
                        p_progress = p_progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
        sp.elapsed_ns += now_ns() - t0p;
        if (p_progress) { ++sp.hit_count; r.used_pointing_pairs = true; return ApplyResult::Progress; }

        const uint64_t t0b = now_ns();
        ++sb.use_count;
        bool b_progress = false;
        for (int r0 = 0; r0 < n; ++r0) for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int first_box = -1, cnt = 0; bool same_box = true;
            for (int c = 0; c < n; ++c) {
                const int idx = r0 * n + c;
                if (st.board->values[static_cast<size_t>(idx)] != 0 || (st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int box = st.topo->cell_box[static_cast<size_t>(idx)];
                if (cnt == 0) first_box = box; else same_box = same_box && (box == first_box);
                ++cnt;
            }
            if (!same_box || cnt < 2 || first_box < 0) continue;
            const int brg = first_box / st.topo->box_cols_count;
            const int bcg = first_box % st.topo->box_cols_count;
            for (int dr = 0; dr < st.topo->box_rows; ++dr) for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                const int rr = brg * st.topo->box_rows + dr;
                const int cc = bcg * st.topo->box_cols + dc;
                if (rr == r0) continue;
                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                if (er == ApplyResult::Contradiction) { sb.elapsed_ns += now_ns() - t0b; return er; }
                b_progress = b_progress || (er == ApplyResult::Progress);
            }
        }
        for (int c0 = 0; c0 < n; ++c0) for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int first_box = -1, cnt = 0; bool same_box = true;
            for (int r0 = 0; r0 < n; ++r0) {
                const int idx = r0 * n + c0;
                if (st.board->values[static_cast<size_t>(idx)] != 0 || (st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int box = st.topo->cell_box[static_cast<size_t>(idx)];
                if (cnt == 0) first_box = box; else same_box = same_box && (box == first_box);
                ++cnt;
            }
            if (!same_box || cnt < 2 || first_box < 0) continue;
            const int brg = first_box / st.topo->box_cols_count;
            const int bcg = first_box % st.topo->box_cols_count;
            for (int dr = 0; dr < st.topo->box_rows; ++dr) for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                const int rr = brg * st.topo->box_rows + dr;
                const int cc = bcg * st.topo->box_cols + dc;
                if (cc == c0) continue;
                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                if (er == ApplyResult::Contradiction) { sb.elapsed_ns += now_ns() - t0b; return er; }
                b_progress = b_progress || (er == ApplyResult::Progress);
            }
        }
        sb.elapsed_ns += now_ns() - t0b;
        if (b_progress) { ++sb.hit_count; r.used_box_line = true; return ApplyResult::Progress; }
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_x_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            for (int r1 = 0; r1 < n; ++r1) {
                const uint64_t m1 = row_masks[static_cast<size_t>(r1)];
                if (popcnt(m1) != 2) continue;
                for (int r2 = r1 + 1; r2 < n; ++r2) {
                    if (row_masks[static_cast<size_t>(r2)] != m1) continue;
                    for (uint64_t w = m1; w != 0ULL; w &= (w - 1ULL)) {
                        const int c = static_cast<int>(std::countr_zero(w));
                        for (int rr = 0; rr < n; ++rr) {
                            if (rr == r1 || rr == r2) continue;
                            const ApplyResult er = st.eliminate(rr * n + c, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }

            for (int c1 = 0; c1 < n; ++c1) {
                const uint64_t m1 = col_masks[static_cast<size_t>(c1)];
                if (popcnt(m1) != 2) continue;
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    if (col_masks[static_cast<size_t>(c2)] != m1) continue;
                    for (uint64_t w = m1; w != 0ULL; w &= (w - 1ULL)) {
                        const int rr = static_cast<int>(std::countr_zero(w));
                        for (int cc = 0; cc < n; ++cc) {
                            if (cc == c1 || cc == c2) continue;
                            const ApplyResult er = st.eliminate(rr * n + cc, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_x_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_y_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        bool progress = false;

        for (int pivot = 0; pivot < st.topo->nn; ++pivot) {



==============================================================================
PLIK: Sources\logic_engine_part02.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

            if (st.board->values[static_cast<size_t>(pivot)] != 0) continue;
            const uint64_t mp = st.cands[static_cast<size_t>(pivot)];
            if (popcnt(mp) != 2) continue;

            const int p0 = st.topo->peer_offsets[static_cast<size_t>(pivot)];
            const int p1 = st.topo->peer_offsets[static_cast<size_t>(pivot + 1)];
            for (int i = p0; i < p1; ++i) {
                const int a = st.topo->peers_flat[static_cast<size_t>(i)];
                if (st.board->values[static_cast<size_t>(a)] != 0) continue;
                const uint64_t ma = st.cands[static_cast<size_t>(a)];
                if (popcnt(ma) != 2) continue;
                const uint64_t shared_a = ma & mp;
                if (popcnt(shared_a) != 1) continue;
                const uint64_t z = ma & ~mp;
                if (popcnt(z) != 1) continue;

                for (int j = i + 1; j < p1; ++j) {
                    const int b = st.topo->peers_flat[static_cast<size_t>(j)];
                    if (st.board->values[static_cast<size_t>(b)] != 0) continue;
                    const uint64_t mb = st.cands[static_cast<size_t>(b)];
                    if (popcnt(mb) != 2) continue;
                    const uint64_t shared_b = mb & mp;
                    if (popcnt(shared_b) != 1 || shared_b == shared_a) continue;
                    const uint64_t z2 = mb & ~mp;
                    if (z2 != z || popcnt(z2) != 1) continue;

                    const int ap0 = st.topo->peer_offsets[static_cast<size_t>(a)];
                    const int ap1 = st.topo->peer_offsets[static_cast<size_t>(a + 1)];
                    for (int p = ap0; p < ap1; ++p) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (t == pivot || t == a || t == b) continue;
                        if (!is_peer(st, t, b)) continue;
                        const ApplyResult er = st.eliminate(t, z);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_y_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_skyscraper(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            for (int r1 = 0; r1 < n; ++r1) {
                const uint64_t m1 = row_masks[static_cast<size_t>(r1)];
                if (popcnt(m1) != 2) continue;
                for (int r2 = r1 + 1; r2 < n; ++r2) {
                    const uint64_t m2 = row_masks[static_cast<size_t>(r2)];
                    if (popcnt(m2) != 2) continue;
                    const uint64_t common = m1 & m2;
                    if (popcnt(common) != 1) continue;
                    const uint64_t e1 = m1 & ~common;
                    const uint64_t e2 = m2 & ~common;
                    if (e1 == 0ULL || e2 == 0ULL) continue;
                    const int c1 = bit_to_index(e1);
                    const int c2 = bit_to_index(e2);
                    const int a = r1 * n + c1;
                    const int b = r2 * n + c2;
                    const int ap0 = st.topo->peer_offsets[static_cast<size_t>(a)];
                    const int ap1 = st.topo->peer_offsets[static_cast<size_t>(a + 1)];
                    for (int p = ap0; p < ap1; ++p) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (t == a || t == b) continue;
                        if (!is_peer(st, t, b)) continue;
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }

            for (int c1 = 0; c1 < n; ++c1) {
                const uint64_t m1 = col_masks[static_cast<size_t>(c1)];
                if (popcnt(m1) != 2) continue;
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const uint64_t m2 = col_masks[static_cast<size_t>(c2)];
                    if (popcnt(m2) != 2) continue;
                    const uint64_t common = m1 & m2;
                    if (popcnt(common) != 1) continue;
                    const uint64_t e1 = m1 & ~common;
                    const uint64_t e2 = m2 & ~common;
                    if (e1 == 0ULL || e2 == 0ULL) continue;
                    const int r1 = bit_to_index(e1);
                    const int r2 = bit_to_index(e2);
                    const int a = r1 * n + c1;
                    const int b = r2 * n + c2;
                    const int ap0 = st.topo->peer_offsets[static_cast<size_t>(a)];
                    const int ap1 = st.topo->peer_offsets[static_cast<size_t>(a + 1)];
                    for (int p = ap0; p < ap1; ++p) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (t == a || t == b) continue;
                        if (!is_peer(st, t, b)) continue;
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_skyscraper = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_two_string_kite(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);

            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            for (int row = 0; row < n; ++row) {
                const uint64_t rm = row_masks[static_cast<size_t>(row)];
                if (popcnt(rm) != 2) continue;
                uint64_t ra = lsb(rm);
                uint64_t rb = rm ^ ra;
                const int c1 = bit_to_index(ra);
                const int c2 = bit_to_index(rb);
                const int row_a = row * n + c1;
                const int row_b = row * n + c2;

                for (int col = 0; col < n; ++col) {
                    const uint64_t cm = col_masks[static_cast<size_t>(col)];
                    if (popcnt(cm) != 2) continue;
                    uint64_t ca = lsb(cm);
                    uint64_t cb = cm ^ ca;
                    const int r1 = bit_to_index(ca);
                    const int r2 = bit_to_index(cb);
                    const int col_a = r1 * n + col;
                    const int col_b = r2 * n + col;

                    struct Choice {
                        int row_pivot;
                        int row_end;
                        int col_pivot;
                        int col_end;
                    };
                    const std::array<Choice, 4> choices = {{
                        {row_a, row_b, col_a, col_b},
                        {row_a, row_b, col_b, col_a},
                        {row_b, row_a, col_a, col_b},
                        {row_b, row_a, col_b, col_a},
                    }};
                    for (const auto& ch : choices) {
                        if (ch.row_pivot == ch.col_pivot) continue;
                        if (st.topo->cell_box[static_cast<size_t>(ch.row_pivot)] !=
                            st.topo->cell_box[static_cast<size_t>(ch.col_pivot)]) {
                            continue;
                        }
                        const int p0 = st.topo->peer_offsets[static_cast<size_t>(ch.row_end)];
                        const int p1 = st.topo->peer_offsets[static_cast<size_t>(ch.row_end + 1)];
                        for (int p = p0; p < p1; ++p) {
                            const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                            if (t == ch.row_end || t == ch.col_end || t == ch.row_pivot || t == ch.col_pivot) continue;
                            if (!is_peer(st, t, ch.col_end)) continue;
                            const ApplyResult er = st.eliminate(t, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_two_string_kite = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_remote_pairs(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int nn = st.topo->nn;
        bool progress = false;

        std::vector<int> component(nn, -1);
        std::vector<uint8_t> parity(nn, 0);
        std::vector<uint64_t> pair_masks;
        pair_masks.reserve(static_cast<size_t>(nn));
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const uint64_t m = st.cands[static_cast<size_t>(idx)];
            if (popcnt(m) == 2) {
                pair_masks.push_back(m);
            }
        }
        std::sort(pair_masks.begin(), pair_masks.end());
        pair_masks.erase(std::unique(pair_masks.begin(), pair_masks.end()), pair_masks.end());

        std::vector<int> queue;
        std::vector<int> nodes;
        std::vector<uint8_t> in_component(static_cast<size_t>(nn), 0);
        std::vector<uint8_t> seen_parity0(static_cast<size_t>(nn), 0);
        std::vector<uint8_t> seen_parity1(static_cast<size_t>(nn), 0);

        for (const uint64_t pair_mask : pair_masks) {
            std::fill(component.begin(), component.end(), -1);
            std::fill(parity.begin(), parity.end(), 0);
            int comp_id = 0;

            for (int start = 0; start < nn; ++start) {
                if (st.board->values[static_cast<size_t>(start)] != 0) continue;
                if (st.cands[static_cast<size_t>(start)] != pair_mask) continue;
                if (component[static_cast<size_t>(start)] != -1) continue;
                queue.clear();
                queue.push_back(start);
                component[static_cast<size_t>(start)] = comp_id;
                parity[static_cast<size_t>(start)] = 0;

                for (size_t qi = 0; qi < queue.size(); ++qi) {
                    const int cur = queue[qi];
                    const int p0 = st.topo->peer_offsets[static_cast<size_t>(cur)];
                    const int p1 = st.topo->peer_offsets[static_cast<size_t>(cur + 1)];
                    for (int p = p0; p < p1; ++p) {
                        const int nxt = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (st.board->values[static_cast<size_t>(nxt)] != 0) continue;
                        if (st.cands[static_cast<size_t>(nxt)] != pair_mask) continue;
                        if (component[static_cast<size_t>(nxt)] == -1) {
                            component[static_cast<size_t>(nxt)] = comp_id;
                            parity[static_cast<size_t>(nxt)] = static_cast<uint8_t>(parity[static_cast<size_t>(cur)] ^ 1U);
                            queue.push_back(nxt);
                        }
                    }
                }
                ++comp_id;
            }

            for (int cid = 0; cid < comp_id; ++cid) {
                nodes.clear();
                for (int idx = 0; idx < nn; ++idx) {
                    if (component[static_cast<size_t>(idx)] == cid) {
                        nodes.push_back(idx);
                    }
                }
                if (nodes.size() < 4) continue;

                std::fill(in_component.begin(), in_component.end(), 0);
                std::fill(seen_parity0.begin(), seen_parity0.end(), 0);
                std::fill(seen_parity1.begin(), seen_parity1.end(), 0);
                for (const int idx : nodes) {
                    in_component[static_cast<size_t>(idx)] = 1;
                }
                for (const int idx : nodes) {
                    const int p0 = st.topo->peer_offsets[static_cast<size_t>(idx)];
                    const int p1 = st.topo->peer_offsets[static_cast<size_t>(idx + 1)];
                    auto& seen = (parity[static_cast<size_t>(idx)] == 0) ? seen_parity0 : seen_parity1;
                    for (int p = p0; p < p1; ++p) {
                        seen[static_cast<size_t>(st.topo->peers_flat[static_cast<size_t>(p)])] = 1;
                    }
                }

                for (int t = 0; t < nn; ++t) {
                    if (in_component[static_cast<size_t>(t)] != 0) continue;
                    if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                    if (seen_parity0[static_cast<size_t>(t)] == 0 || seen_parity1[static_cast<size_t>(t)] == 0) continue;
                    const ApplyResult er = st.eliminate(t, pair_mask);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    progress = progress || (er == ApplyResult::Progress);
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_remote_pairs = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    // Conservative ER variant: box has exactly two candidates (L-shape),
    // plus conjugate links on corresponding row and column.
    static ApplyResult apply_empty_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        bool progress = false;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);
        std::vector<int> box_cells;
        box_cells.reserve(static_cast<size_t>(n));

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            for (int b = 0; b < n; ++b) {
                box_cells.clear();
                for (int idx = 0; idx < st.topo->nn; ++idx) {
                    if (st.topo->cell_box[static_cast<size_t>(idx)] != b) continue;
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                    box_cells.push_back(idx);
                    if (box_cells.size() > 2) break;
                }
                if (box_cells.size() != 2) continue;
                const int p = box_cells[0];
                const int q = box_cells[1];
                const int pr = st.topo->cell_row[static_cast<size_t>(p)];
                const int pc = st.topo->cell_col[static_cast<size_t>(p)];
                const int qr = st.topo->cell_row[static_cast<size_t>(q)];
                const int qc = st.topo->cell_col[static_cast<size_t>(q)];
                if (pr == qr || pc == qc) continue;

                struct OrientedPair { int row_cell; int col_cell; };
                const std::array<OrientedPair, 2> orientations = {{
                    {p, q}, {q, p}
                }};
                for (const auto& orient : orientations) {
                    const int row_cell = orient.row_cell;
                    const int col_cell = orient.col_cell;
                    const int rr = st.topo->cell_row[static_cast<size_t>(row_cell)];
                    const int cc = st.topo->cell_col[static_cast<size_t>(col_cell)];

                    const uint64_t row_m = row_masks[static_cast<size_t>(rr)];
                    if (popcnt(row_m) != 2 || (row_m & (1ULL << st.topo->cell_col[static_cast<size_t>(row_cell)])) == 0ULL) continue;
                    const uint64_t row_other_mask = row_m & ~(1ULL << st.topo->cell_col[static_cast<size_t>(row_cell)]);
                    if (row_other_mask == 0ULL) continue;
                    const int row_other_col = bit_to_index(row_other_mask);
                    const int row_other = rr * n + row_other_col;

                    const uint64_t col_m = col_masks[static_cast<size_t>(cc)];
                    if (popcnt(col_m) != 2 || (col_m & (1ULL << st.topo->cell_row[static_cast<size_t>(col_cell)])) == 0ULL) continue;
                    const uint64_t col_other_mask = col_m & ~(1ULL << st.topo->cell_row[static_cast<size_t>(col_cell)]);
                    if (col_other_mask == 0ULL) continue;
                    const int col_other_row = bit_to_index(col_other_mask);
                    const int col_other = col_other_row * n + cc;
                    if (row_other == col_other) continue;

                    const int p0 = st.topo->peer_offsets[static_cast<size_t>(row_other)];
                    const int p1 = st.topo->peer_offsets[static_cast<size_t>(row_other + 1)];
                    for (int pi = p0; pi < p1; ++pi) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(pi)];
                        if (t == row_other || t == col_other) continue;
                        if (!is_peer(st, t, col_other)) continue;
                        const ApplyResult er = st.eliminate(t, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_empty_rectangle = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_swordfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);
        std::vector<int> rows;
        std::vector<int> cols;
        rows.reserve(static_cast<size_t>(n));
        cols.reserve(static_cast<size_t>(n));

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);

            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            rows.clear();
            cols.clear();
            for (int rr = 0; rr < n; ++rr) {
                const int cnt = popcnt(row_masks[static_cast<size_t>(rr)]);
                if (cnt >= 2 && cnt <= 3) rows.push_back(rr);
            }
            for (int cc = 0; cc < n; ++cc) {
                const int cnt = popcnt(col_masks[static_cast<size_t>(cc)]);
                if (cnt >= 2 && cnt <= 3) cols.push_back(cc);
            }

            const int rn = static_cast<int>(rows.size());
            for (int i = 0; i < rn; ++i) {
                for (int j = i + 1; j < rn; ++j) {
                    for (int k = j + 1; k < rn; ++k) {
                        const int r1 = rows[static_cast<size_t>(i)];
                        const int r2 = rows[static_cast<size_t>(j)];
                        const int r3 = rows[static_cast<size_t>(k)];
                        const uint64_t cols_union =
                            row_masks[static_cast<size_t>(r1)] |
                            row_masks[static_cast<size_t>(r2)] |
                            row_masks[static_cast<size_t>(r3)];
                        if (popcnt(cols_union) != 3) continue;
                        for (uint64_t w = cols_union; w != 0ULL; w &= (w - 1ULL)) {
                            const int cc = static_cast<int>(std::countr_zero(w));
                            for (int rr = 0; rr < n; ++rr) {
                                if (rr == r1 || rr == r2 || rr == r3) continue;
                                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }

            const int cn = static_cast<int>(cols.size());
            for (int i = 0; i < cn; ++i) {
                for (int j = i + 1; j < cn; ++j) {
                    for (int k = j + 1; k < cn; ++k) {
                        const int c1 = cols[static_cast<size_t>(i)];
                        const int c2 = cols[static_cast<size_t>(j)];
                        const int c3 = cols[static_cast<size_t>(k)];
                        const uint64_t rows_union =
                            col_masks[static_cast<size_t>(c1)] |
                            col_masks[static_cast<size_t>(c2)] |
                            col_masks[static_cast<size_t>(c3)];
                        if (popcnt(rows_union) != 3) continue;
                        for (uint64_t w = rows_union; w != 0ULL; w &= (w - 1ULL)) {
                            const int rr = static_cast<int>(std::countr_zero(w));
                            for (int cc = 0; cc < n; ++cc) {
                                if (cc == c1 || cc == c2 || cc == c3) continue;
                                const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_swordfish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    struct StrongLinkGraph {
        std::vector<int> node_to_cell;
        std::vector<int> cell_to_node;
        std::vector<std::vector<int>> adj;
    };

    static StrongLinkGraph build_strong_link_graph(const CandidateState& st, uint64_t bit) {
        StrongLinkGraph g{};
        g.cell_to_node.assign(static_cast<size_t>(st.topo->nn), -1);

        auto get_node = [&](int cell_idx) -> int {
            int& node_ref = g.cell_to_node[static_cast<size_t>(cell_idx)];
            if (node_ref >= 0) return node_ref;
            node_ref = static_cast<int>(g.node_to_cell.size());
            g.node_to_cell.push_back(cell_idx);
            g.adj.emplace_back();
            return node_ref;
        };
        auto add_edge = [&](int a, int b) {
            if (a == b) return;
            auto& aa = g.adj[static_cast<size_t>(a)];
            if (std::find(aa.begin(), aa.end(), b) == aa.end()) aa.push_back(b);
            auto& bb = g.adj[static_cast<size_t>(b)];
            if (std::find(bb.begin(), bb.end(), a) == bb.end()) bb.push_back(a);
        };

        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h];
            const int p1 = st.topo->house_offsets[h + 1];
            int a = -1, b = -1, cnt = 0;
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                if (cnt == 0) a = idx;
                else if (cnt == 1) b = idx;
                ++cnt;
                if (cnt > 2) break;
            }
            if (cnt == 2 && a >= 0 && b >= 0) {
                add_edge(get_node(a), get_node(b));
            }
        }
        return g;
    }

    static ApplyResult apply_finned_x_wing_sashimi(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int n = st.topo->n;
        std::vector<uint64_t> row_masks(static_cast<size_t>(n), 0ULL);
        std::vector<uint64_t> col_masks(static_cast<size_t>(n), 0ULL);

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill(row_masks.begin(), row_masks.end(), 0ULL);
            std::fill(col_masks.begin(), col_masks.end(), 0ULL);
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                row_masks[static_cast<size_t>(rr)] |= (1ULL << cc);
                col_masks[static_cast<size_t>(cc)] |= (1ULL << rr);
            }

            for (int r1 = 0; r1 < n; ++r1) {
                const uint64_t m1 = row_masks[static_cast<size_t>(r1)];
                const int c1 = popcnt(m1);
                if (c1 < 2 || c1 > 4) continue;
                for (int r2 = r1 + 1; r2 < n; ++r2) {
                    const uint64_t m2 = row_masks[static_cast<size_t>(r2)];
                    const int c2 = popcnt(m2);
                    if (c2 < 2 || c2 > 4) continue;
                    const uint64_t common = m1 & m2;
                    if (popcnt(common) != 2) continue;
                    const uint64_t e1 = m1 & ~common;
                    const uint64_t e2 = m2 & ~common;
                    if ((e1 == 0ULL) == (e2 == 0ULL)) continue;

                    const int fin_row = (e1 != 0ULL) ? r1 : r2;
                    const uint64_t fin_mask = (e1 != 0ULL) ? e1 : e2;
                    for (uint64_t wc = common; wc != 0ULL; wc &= (wc - 1ULL)) {
                        const int base_col = static_cast<int>(std::countr_zero(wc));
                        const int base_box = st.topo->cell_box[static_cast<size_t>(fin_row * n + base_col)];
                        bool has_fin_in_box = false;
                        for (uint64_t wf = fin_mask; wf != 0ULL; wf &= (wf - 1ULL)) {
                            const int fin_col = static_cast<int>(std::countr_zero(wf));
                            if (st.topo->cell_box[static_cast<size_t>(fin_row * n + fin_col)] == base_box) {
                                has_fin_in_box = true;
                                break;
                            }
                        }
                        if (!has_fin_in_box) continue;

                        for (int rr = 0; rr < n; ++rr) {
                            if (rr == r1 || rr == r2) continue;
                            const int t = rr * n + base_col;
                            if (st.topo->cell_box[static_cast<size_t>(t)] != base_box) continue;
                            const ApplyResult er = st.eliminate(t, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            if (er == ApplyResult::Progress) {
                                ++s.hit_count;
                                r.used_finned_x_wing_sashimi = true;
                                s.elapsed_ns += now_ns() - t0;
                                return ApplyResult::Progress;
                            }
                        }
                    }
                }
            }

            for (int c1 = 0; c1 < n; ++c1) {
                const uint64_t m1 = col_masks[static_cast<size_t>(c1)];
                const int r1 = popcnt(m1);
                if (r1 < 2 || r1 > 4) continue;
                for (int c2 = c1 + 1; c2 < n; ++c2) {
                    const uint64_t m2 = col_masks[static_cast<size_t>(c2)];
                    const int r2 = popcnt(m2);
                    if (r2 < 2 || r2 > 4) continue;
                    const uint64_t common = m1 & m2;
                    if (popcnt(common) != 2) continue;
                    const uint64_t e1 = m1 & ~common;
                    const uint64_t e2 = m2 & ~common;
                    if ((e1 == 0ULL) == (e2 == 0ULL)) continue;

                    const int fin_col = (e1 != 0ULL) ? c1 : c2;
                    const uint64_t fin_mask = (e1 != 0ULL) ? e1 : e2;
                    for (uint64_t wr = common; wr != 0ULL; wr &= (wr - 1ULL)) {
                        const int base_row = static_cast<int>(std::countr_zero(wr));
                        const int base_box = st.topo->cell_box[static_cast<size_t>(base_row * n + fin_col)];
                        bool has_fin_in_box = false;
                        for (uint64_t wf = fin_mask; wf != 0ULL; wf &= (wf - 1ULL)) {
                            const int fin_row = static_cast<int>(std::countr_zero(wf));
                            if (st.topo->cell_box[static_cast<size_t>(fin_row * n + fin_col)] == base_box) {
                                has_fin_in_box = true;
                                break;
                            }
                        }
                        if (!has_fin_in_box) continue;

                        for (int cc = 0; cc < n; ++cc) {
                            if (cc == c1 || cc == c2) continue;
                            const int t = base_row * n + cc;
                            if (st.topo->cell_box[static_cast<size_t>(t)] != base_box) continue;
                            const ApplyResult er = st.eliminate(t, bit);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            if (er == ApplyResult::Progress) {
                                ++s.hit_count;
                                r.used_finned_x_wing_sashimi = true;
                                s.elapsed_ns += now_ns() - t0;
                                return ApplyResult::Progress;
                            }
                        }
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_simple_coloring(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        const int nn = st.topo->nn;

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::vector<int> digit_cells;
            digit_cells.reserve(static_cast<size_t>(nn));
            for (int idx = 0; idx < nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) digit_cells.push_back(idx);



==============================================================================
PLIK: Sources\logic_engine_part03.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

            }
            if (digit_cells.size() < 3) continue;

            StrongLinkGraph g = build_strong_link_graph(st, bit);
            const int node_count = static_cast<int>(g.node_to_cell.size());
            if (node_count < 2) continue;

            std::vector<int> color(static_cast<size_t>(node_count), -1);
            for (int start = 0; start < node_count; ++start) {
                if (color[static_cast<size_t>(start)] != -1) continue;
                std::deque<int> q;
                std::vector<int> comp_nodes;
                std::vector<int> comp_color0;
                std::vector<int> comp_color1;
                bool conflict0 = false;
                bool conflict1 = false;

                color[static_cast<size_t>(start)] = 0;
                q.push_back(start);
                while (!q.empty()) {
                    const int u = q.front();
                    q.pop_front();
                    comp_nodes.push_back(u);
                    if (color[static_cast<size_t>(u)] == 0) comp_color0.push_back(u);
                    else comp_color1.push_back(u);
                    for (const int v : g.adj[static_cast<size_t>(u)]) {
                        if (color[static_cast<size_t>(v)] == -1) {
                            color[static_cast<size_t>(v)] = 1 - color[static_cast<size_t>(u)];
                            q.push_back(v);
                        } else if (color[static_cast<size_t>(v)] == color[static_cast<size_t>(u)]) {
                            if (color[static_cast<size_t>(u)] == 0) conflict0 = true;
                            else conflict1 = true;
                        }
                    }
                }

                if (conflict0 || conflict1) {
                    const int bad_color = conflict0 ? 0 : 1;
                    for (const int node : comp_nodes) {
                        if (color[static_cast<size_t>(node)] != bad_color) continue;
                        const int cell = g.node_to_cell[static_cast<size_t>(node)];
                        const ApplyResult er = st.eliminate(cell, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        if (er == ApplyResult::Progress) {
                            ++s.hit_count;
                            r.used_simple_coloring = true;
                            s.elapsed_ns += now_ns() - t0;
                            return ApplyResult::Progress;
                        }
                    }
                }

                for (const int idx : digit_cells) {
                    const int node = g.cell_to_node[static_cast<size_t>(idx)];
                    if (node >= 0 && color[static_cast<size_t>(node)] != -1) continue;
                    bool sees0 = false;
                    bool sees1 = false;
                    for (const int c0 : comp_color0) {
                        if (is_peer(st, idx, g.node_to_cell[static_cast<size_t>(c0)])) { sees0 = true; break; }
                    }
                    if (!sees0) continue;
                    for (const int c1 : comp_color1) {
                        if (is_peer(st, idx, g.node_to_cell[static_cast<size_t>(c1)])) { sees1 = true; break; }
                    }
                    if (!sees1) continue;
                    const ApplyResult er = st.eliminate(idx, bit);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    if (er == ApplyResult::Progress) {
                        ++s.hit_count;
                        r.used_simple_coloring = true;
                        s.elapsed_ns += now_ns() - t0;
                        return ApplyResult::Progress;
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_jellyfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        auto& sp = exact_pattern_scratchpad();

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill_n(sp.fish_row_masks, n, 0ULL);
            std::fill_n(sp.fish_col_masks, n, 0ULL);
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                sp.fish_row_masks[rr] |= (1ULL << cc);
                sp.fish_col_masks[cc] |= (1ULL << rr);
            }

            int row_count = 0;
            int col_count = 0;
            for (int rr = 0; rr < n; ++rr) {
                const int cnt = popcnt(sp.fish_row_masks[rr]);
                if (cnt >= 2 && cnt <= 4) sp.active_rows[row_count++] = rr;
            }
            for (int cc = 0; cc < n; ++cc) {
                const int cnt = popcnt(sp.fish_col_masks[cc]);
                if (cnt >= 2 && cnt <= 4) sp.active_cols[col_count++] = cc;
            }

            for (int i = 0; i + 3 < row_count; ++i) {
                const int r1 = sp.active_rows[i];
                const uint64_t u1 = sp.fish_row_masks[r1];
                for (int j = i + 1; j + 2 < row_count; ++j) {
                    const int r2 = sp.active_rows[j];
                    const uint64_t u2 = u1 | sp.fish_row_masks[r2];
                    if (popcnt(u2) > 4) continue;
                    for (int k = j + 1; k + 1 < row_count; ++k) {
                        const int r3 = sp.active_rows[k];
                        const uint64_t u3 = u2 | sp.fish_row_masks[r3];
                        if (popcnt(u3) > 4) continue;
                        for (int l = k + 1; l < row_count; ++l) {
                            const int r4 = sp.active_rows[l];
                            const uint64_t cols_union = u3 | sp.fish_row_masks[r4];
                            if (popcnt(cols_union) != 4) continue;
                            for (uint64_t w = cols_union; w != 0ULL; w &= (w - 1ULL)) {
                                const int cc = static_cast<int>(std::countr_zero(w));
                                for (int rr = 0; rr < n; ++rr) {
                                    if (rr == r1 || rr == r2 || rr == r3 || rr == r4) continue;
                                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                    if (er == ApplyResult::Progress) {
                                        ++s.hit_count;
                                        r.used_jellyfish = true;
                                        s.elapsed_ns += now_ns() - t0;
                                        return ApplyResult::Progress;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            for (int i = 0; i + 3 < col_count; ++i) {
                const int c1 = sp.active_cols[i];
                const uint64_t u1 = sp.fish_col_masks[c1];
                for (int j = i + 1; j + 2 < col_count; ++j) {
                    const int c2 = sp.active_cols[j];
                    const uint64_t u2 = u1 | sp.fish_col_masks[c2];
                    if (popcnt(u2) > 4) continue;
                    for (int k = j + 1; k + 1 < col_count; ++k) {
                        const int c3 = sp.active_cols[k];
                        const uint64_t u3 = u2 | sp.fish_col_masks[c3];
                        if (popcnt(u3) > 4) continue;
                        for (int l = k + 1; l < col_count; ++l) {
                            const int c4 = sp.active_cols[l];
                            const uint64_t rows_union = u3 | sp.fish_col_masks[c4];
                            if (popcnt(rows_union) != 4) continue;
                            for (uint64_t w = rows_union; w != 0ULL; w &= (w - 1ULL)) {
                                const int rr = static_cast<int>(std::countr_zero(w));
                                for (int cc = 0; cc < n; ++cc) {
                                    if (cc == c1 || cc == c2 || cc == c3 || cc == c4) continue;
                                    const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                    if (er == ApplyResult::Progress) {
                                        ++s.hit_count;
                                        r.used_jellyfish = true;
                                        s.elapsed_ns += now_ns() - t0;
                                        return ApplyResult::Progress;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_x_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        const int nn = st.topo->nn;
        auto& sp = exact_pattern_scratchpad();

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int digit_cell_count = 0;
            for (int idx = 0; idx < nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) {
                    sp.als_cells[digit_cell_count++] = idx;
                }
            }
            if (digit_cell_count < 4) continue;

            sp.reset_node_maps(nn);
            const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
            for (int h = 0; h < house_count; ++h) {
                const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
                const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
                int a = -1;
                int b = -1;
                int cnt = 0;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                    if (cnt == 0) a = idx;
                    else if (cnt == 1) b = idx;
                    ++cnt;
                    if (cnt > 2) break;
                }
                if (cnt != 2) continue;
                int& na = sp.cell_to_node[a];
                int& nb = sp.cell_to_node[b];
                if (na < 0) {
                    na = sp.node_count;
                    sp.node_to_cell[sp.node_count++] = a;
                }
                if (nb < 0) {
                    nb = sp.node_count;
                    sp.node_to_cell[sp.node_count++] = b;
                }
                if (sp.edge_count < ExactPatternScratchpad::MAX_EDGES) {
                    sp.edge_u[sp.edge_count] = na;
                    sp.edge_v[sp.edge_count] = nb;
                    ++sp.edge_count;
                }
            }

            if (sp.node_count < 4 || sp.edge_count == 0) continue;
            sp.reset_graph(sp.node_count);
            for (int e = 0; e < sp.edge_count; ++e) {
                ++sp.node_degree[sp.edge_u[e]];
                ++sp.node_degree[sp.edge_v[e]];
            }
            int sum_adj = 0;
            for (int i = 0; i < sp.node_count; ++i) {
                sp.adj_offsets[i] = sum_adj;
                sum_adj += sp.node_degree[i];
            }
            sp.adj_offsets[sp.node_count] = sum_adj;
            if (sum_adj > ExactPatternScratchpad::MAX_ADJ) continue;
            for (int i = 0; i < sp.node_count; ++i) {
                sp.adj_cursor[i] = sp.adj_offsets[i];
            }
            for (int e = 0; e < sp.edge_count; ++e) {
                const int u = sp.edge_u[e];
                const int v = sp.edge_v[e];
                sp.adj_flat[sp.adj_cursor[u]++] = v;
                sp.adj_flat[sp.adj_cursor[v]++] = u;
            }

            for (int start = 0; start < sp.node_count; ++start) {
                for (int i = 0; i < sp.node_count; ++i) {
                    sp.visited[i] = -1;
                }
                int qh = 0;
                int qt = 0;
                sp.bfs_queue[qt++] = start;
                sp.visited[start] = 0;

                while (qh < qt) {
                    const int u = sp.bfs_queue[qh++];
                    const int du = sp.visited[u];
                    for (int ei = sp.adj_offsets[u]; ei < sp.adj_offsets[u + 1]; ++ei) {
                        const int v = sp.adj_flat[ei];
                        if (sp.visited[v] != -1) continue;
                        sp.visited[v] = du + 1;
                        if (qt < ExactPatternScratchpad::MAX_BFS) {
                            sp.bfs_queue[qt++] = v;
                        }
                    }
                }

                const int start_cell = sp.node_to_cell[start];
                for (int end = 0; end < sp.node_count; ++end) {
                    const int de = sp.visited[end];
                    if (de < 3 || (de & 1) == 0) continue;
                    const int end_cell = sp.node_to_cell[end];
                    if (!is_peer(st, start_cell, end_cell)) continue;
                    for (int di = 0; di < digit_cell_count; ++di) {
                        const int idx = sp.als_cells[di];
                        if (idx == start_cell || idx == end_cell) continue;
                        if (!is_peer(st, idx, start_cell) || !is_peer(st, idx, end_cell)) continue;
                        const ApplyResult er = st.eliminate(idx, bit);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        if (er == ApplyResult::Progress) {
                            ++s.hit_count;
                            r.used_x_chain = true;
                            s.elapsed_ns += now_ns() - t0;
                            return ApplyResult::Progress;
                        }
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_xy_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int nn = st.topo->nn;
        const int max_depth = (st.topo->n <= 16) ? 8 : 6;
        auto& sp = exact_pattern_scratchpad();
        int bivalue_count = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 2) {
                sp.als_cells[bivalue_count++] = idx;
            }
        }
        if (bivalue_count < 3) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        auto path_contains_cell = [&](int node_idx, int cell) -> bool {
            int cur = node_idx;
            while (cur >= 0) {
                if (sp.chain_cell[cur] == cell) return true;
                cur = sp.chain_parent[cur];
            }
            return false;
        };

        for (int bi = 0; bi < bivalue_count; ++bi) {
            const int start = sp.als_cells[bi];
            const uint64_t start_mask = st.cands[static_cast<size_t>(start)];
            for (uint64_t wz = start_mask; wz != 0ULL; wz &= (wz - 1ULL)) {
                const uint64_t zbit = lsb(wz);
                if ((start_mask ^ zbit) == 0ULL) continue;

                sp.chain_count = 1;
                sp.chain_cell[0] = start;
                sp.chain_enter_bit[0] = zbit;
                sp.chain_parent[0] = -1;
                sp.chain_depth[0] = 0;

                for (int ni = 0; ni < sp.chain_count; ++ni) {
                    const int cur_cell = sp.chain_cell[ni];
                    const uint64_t cur_enter = sp.chain_enter_bit[ni];
                    const uint64_t cur_mask = st.cands[static_cast<size_t>(cur_cell)];
                    if (popcnt(cur_mask) != 2 || (cur_mask & cur_enter) == 0ULL) continue;
                    const uint64_t exit_bit = cur_mask ^ cur_enter;
                    if (exit_bit == 0ULL) continue;
                    if (sp.chain_depth[ni] >= max_depth) continue;

                    const int p0 = st.topo->peer_offsets[static_cast<size_t>(cur_cell)];
                    const int p1 = st.topo->peer_offsets[static_cast<size_t>(cur_cell + 1)];
                    for (int p = p0; p < p1; ++p) {
                        const int nxt = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (st.board->values[static_cast<size_t>(nxt)] != 0) continue;
                        const uint64_t nxt_mask = st.cands[static_cast<size_t>(nxt)];
                        if (popcnt(nxt_mask) != 2) continue;
                        if ((nxt_mask & exit_bit) == 0ULL) continue;
                        if (path_contains_cell(ni, nxt)) continue;

                        const uint64_t nxt_other = nxt_mask ^ exit_bit;
                        if (nxt_other == 0ULL) continue;

                        const int next_depth = static_cast<int>(sp.chain_depth[ni]) + 1;
                        if (next_depth >= 2 && nxt_other == zbit) {
                            for (int t = 0; t < nn; ++t) {
                                if (t == start || t == nxt) continue;
                                if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                                if ((st.cands[static_cast<size_t>(t)] & zbit) == 0ULL) continue;
                                if (!is_peer(st, t, start) || !is_peer(st, t, nxt)) continue;
                                const ApplyResult er = st.eliminate(t, zbit);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                if (er == ApplyResult::Progress) {
                                    ++s.hit_count;
                                    r.used_xy_chain = true;
                                    s.elapsed_ns += now_ns() - t0;
                                    return ApplyResult::Progress;
                                }
                            }
                        }

                        if (sp.chain_count >= ExactPatternScratchpad::MAX_CHAIN) continue;
                        sp.chain_cell[sp.chain_count] = nxt;
                        sp.chain_enter_bit[sp.chain_count] = exit_bit;
                        sp.chain_parent[sp.chain_count] = ni;
                        sp.chain_depth[sp.chain_count] = static_cast<uint8_t>(next_depth);
                        ++sp.chain_count;
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_bug_plus_one(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        int bug_idx = -1;
        int tri_count = 0;
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const int cnt = popcnt(st.cands[static_cast<size_t>(idx)]);
            if (cnt < 2 || cnt > 3) {
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::NoProgress;
            }
            if (cnt == 3) {
                bug_idx = idx;
                ++tri_count;
                if (tri_count > 1) {
                    s.elapsed_ns += now_ns() - t0;
                    return ApplyResult::NoProgress;
                }
            }
        }
        if (tri_count != 1 || bug_idx < 0) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }

        const int bug_row = st.topo->cell_row[static_cast<size_t>(bug_idx)];
        const int bug_col = st.topo->cell_col[static_cast<size_t>(bug_idx)];
        const int bug_box = st.topo->cell_box[static_cast<size_t>(bug_idx)];
        const uint64_t m = st.cands[static_cast<size_t>(bug_idx)];
        for (uint64_t w = m; w != 0ULL; w &= (w - 1ULL)) {
            const uint64_t bit = lsb(w);
            const int d = bit_to_index(bit) + 1;
            int cnt_row = 0, cnt_col = 0, cnt_box = 0;

            for (int c = 0; c < st.topo->n; ++c) {
                const int idx = bug_row * st.topo->n + c;
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) ++cnt_row;
            }
            for (int rr = 0; rr < st.topo->n; ++rr) {
                const int idx = rr * st.topo->n + bug_col;
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) ++cnt_col;
            }
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.topo->cell_box[static_cast<size_t>(idx)] != bug_box) continue;
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) != 0ULL) ++cnt_box;
            }
            if ((cnt_row % 2 == 1) && (cnt_col % 2 == 1) && (cnt_box % 2 == 1)) {
                if (!st.place(bug_idx, d)) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
                ++s.hit_count;
                ++s.placements;
                ++r.steps;
                r.used_bug_plus_one = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_unique_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        const int n = st.topo->n;
        bool progress = false;
        for (int r1 = 0; r1 < n; ++r1) {
            for (int r2 = r1 + 1; r2 < n; ++r2) {
                for (int c1 = 0; c1 < n; ++c1) {
                    for (int c2 = c1 + 1; c2 < n; ++c2) {
                        const int a = r1 * n + c1;
                        const int b = r1 * n + c2;
                        const int c = r2 * n + c1;
                        const int d = r2 * n + c2;
                        if (st.board->values[static_cast<size_t>(a)] != 0 ||
                            st.board->values[static_cast<size_t>(b)] != 0 ||
                            st.board->values[static_cast<size_t>(c)] != 0 ||
                            st.board->values[static_cast<size_t>(d)] != 0) {
                            continue;
                        }
                        const std::array<int, 4> cells = {a, b, c, d};
                        const std::array<uint64_t, 4> masks = {
                            st.cands[static_cast<size_t>(a)],
                            st.cands[static_cast<size_t>(b)],
                            st.cands[static_cast<size_t>(c)],
                            st.cands[static_cast<size_t>(d)],
                        };
                        const uint64_t pair = masks[0] & masks[1] & masks[2] & masks[3];
                        if (popcnt(pair) != 2) continue;
                        for (const uint64_t m : masks) {
                            if ((m & pair) != pair) goto next_rect;
                        }
                        {
                            std::array<int, 4> boxes = {
                                st.topo->cell_box[static_cast<size_t>(a)],
                                st.topo->cell_box[static_cast<size_t>(b)],
                                st.topo->cell_box[static_cast<size_t>(c)],
                                st.topo->cell_box[static_cast<size_t>(d)],
                            };
                            std::sort(boxes.begin(), boxes.end());
                            const int unique_boxes = static_cast<int>(std::unique(boxes.begin(), boxes.end()) - boxes.begin());
                            if (unique_boxes != 2) goto next_rect;
                        }
                        {
                            int exact_pair = 0;
                            int target_idx = -1;
                            for (int i = 0; i < 4; ++i) {
                                if (masks[static_cast<size_t>(i)] == pair) {
                                    ++exact_pair;
                                } else if (popcnt(masks[static_cast<size_t>(i)]) > 2) {
                                    target_idx = cells[static_cast<size_t>(i)];
                                }
                            }
                            if (exact_pair == 3 && target_idx >= 0) {
                                const ApplyResult er = st.eliminate(target_idx, pair);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    next_rect:
                        (void)0;
                    }
                }
            }
        }
        if (progress) {
            ++s.hit_count;
            r.used_unique_rectangle = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_xyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        bool progress = false;

        for (int pivot = 0; pivot < st.topo->nn; ++pivot) {
            if (st.board->values[static_cast<size_t>(pivot)] != 0) continue;
            const uint64_t mp = st.cands[static_cast<size_t>(pivot)];
            if (popcnt(mp) != 3) continue;

            const int p0 = st.topo->peer_offsets[static_cast<size_t>(pivot)];
            const int p1 = st.topo->peer_offsets[static_cast<size_t>(pivot + 1)];
            for (int i = p0; i < p1; ++i) {
                const int a = st.topo->peers_flat[static_cast<size_t>(i)];
                if (st.board->values[static_cast<size_t>(a)] != 0) continue;
                const uint64_t ma = st.cands[static_cast<size_t>(a)];
                if (popcnt(ma) != 2 || (ma & ~mp) != 0ULL) continue;

                for (int j = i + 1; j < p1; ++j) {
                    const int b = st.topo->peers_flat[static_cast<size_t>(j)];
                    if (st.board->values[static_cast<size_t>(b)] != 0) continue;
                    const uint64_t mb = st.cands[static_cast<size_t>(b)];
                    if (popcnt(mb) != 2 || (mb & ~mp) != 0ULL) continue;

                    if ((ma | mb) != mp) continue;
                    const uint64_t z = ma & mb;
                    if (popcnt(z) != 1) continue;

                    const int ap0 = st.topo->peer_offsets[static_cast<size_t>(a)];
                    const int ap1 = st.topo->peer_offsets[static_cast<size_t>(a + 1)];
                    for (int p = ap0; p < ap1; ++p) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (t == pivot || t == a || t == b) continue;
                        if (!is_peer(st, t, b)) continue;
                        if (!is_peer(st, t, pivot)) continue;
                        const ApplyResult er = st.eliminate(t, z);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_xyz_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_w_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        bool progress = false;

        std::vector<std::vector<std::pair<int, int>>> strong_links(static_cast<size_t>(n + 1));
        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            auto& links = strong_links[static_cast<size_t>(d)];
            for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
                const int p0 = st.topo->house_offsets[h];
                const int p1 = st.topo->house_offsets[h + 1];
                int a = -1, b = -1, cnt = 0;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                    if (cnt == 0) a = idx;
                    else if (cnt == 1) b = idx;
                    ++cnt;
                    if (cnt > 2) break;
                }
                if (cnt == 2 && a >= 0 && b >= 0) {
                    links.push_back({a, b});
                }
            }
        }

        std::vector<int> bivalue_cells;
        bivalue_cells.reserve(static_cast<size_t>(st.topo->nn));
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 2) {
                bivalue_cells.push_back(idx);
            }
        }

        const int bn = static_cast<int>(bivalue_cells.size());
        for (int i = 0; i < bn; ++i) {
            const int a = bivalue_cells[static_cast<size_t>(i)];
            if (st.board->values[static_cast<size_t>(a)] != 0) continue;
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            if (popcnt(ma) != 2) continue;
            for (int j = i + 1; j < bn; ++j) {
                const int b = bivalue_cells[static_cast<size_t>(j)];
                if (st.board->values[static_cast<size_t>(b)] != 0) continue;
                if (is_peer(st, a, b)) continue;
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                if (popcnt(mb) != 2) continue;
                if (ma != mb) continue;
                uint64_t bit1 = lsb(ma);
                uint64_t bit2 = ma ^ bit1;
                const std::array<uint64_t, 2> z_bits = {bit1, bit2};
                for (const uint64_t z : z_bits) {
                    if (z == 0ULL) continue;
                    const uint64_t other = ma ^ z;
                    const int zd = bit_to_index(z) + 1;
                    if (zd < 1 || zd > n) continue;
                    bool linked = false;
                    for (const auto& link : strong_links[static_cast<size_t>(zd)]) {
                        const int u = link.first;
                        const int v = link.second;
                        if ((is_peer(st, a, u) && is_peer(st, b, v)) ||
                            (is_peer(st, a, v) && is_peer(st, b, u))) {
                            linked = true;
                            break;
                        }
                    }
                    if (!linked) continue;
                    const int p0 = st.topo->peer_offsets[static_cast<size_t>(a)];
                    const int p1 = st.topo->peer_offsets[static_cast<size_t>(a + 1)];
                    for (int p = p0; p < p1; ++p) {
                        const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                        if (t == a || t == b) continue;
                        if (!is_peer(st, t, b)) continue;
                        const ApplyResult er = st.eliminate(t, other);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_w_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_wxyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int nn = st.topo->nn;
        bool progress = false;
        auto& sp = exact_pattern_scratchpad();

        for (int pivot = 0; pivot < nn; ++pivot) {
            if (st.board->values[static_cast<size_t>(pivot)] != 0) continue;
            const uint64_t mp = st.cands[static_cast<size_t>(pivot)];
            if (popcnt(mp) != 4) continue;

            sp.wing_count = 0;
            const int p0 = st.topo->peer_offsets[static_cast<size_t>(pivot)];
            const int p1 = st.topo->peer_offsets[static_cast<size_t>(pivot + 1)];
            for (int p = p0; p < p1; ++p) {
                const int w = st.topo->peers_flat[static_cast<size_t>(p)];
                if (st.board->values[static_cast<size_t>(w)] != 0) continue;
                const uint64_t mw = st.cands[static_cast<size_t>(w)];
                if (popcnt(mw) != 2) continue;
                if ((mw & ~mp) != 0ULL) continue;
                if (sp.wing_count < nn) {
                    sp.wing_cells[sp.wing_count++] = w;
                }
            }
            if (sp.wing_count < 3) continue;

            for (int i = 0; i + 2 < sp.wing_count; ++i) {
                const int a = sp.wing_cells[i];
                const uint64_t ma = st.cands[static_cast<size_t>(a)];
                for (int j = i + 1; j + 1 < sp.wing_count; ++j) {
                    const int b = sp.wing_cells[j];
                    const uint64_t mb = st.cands[static_cast<size_t>(b)];
                    for (int k = j + 1; k < sp.wing_count; ++k) {
                        const int c = sp.wing_cells[k];
                        const uint64_t mc = st.cands[static_cast<size_t>(c)];
                        if ((ma | mb | mc | mp) != mp) continue;
                        const uint64_t zmask = ma & mb & mc;
                        if (zmask == 0ULL) continue;

                        for (uint64_t wz = zmask; wz != 0ULL; wz &= (wz - 1ULL)) {
                            const uint64_t z = lsb(wz);
                            for (int t = 0; t < nn; ++t) {
                                if (t == pivot || t == a || t == b || t == c) continue;
                                if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                                if ((st.cands[static_cast<size_t>(t)] & z) == 0ULL) continue;
                                if (!is_peer(st, t, a) || !is_peer(st, t, b) || !is_peer(st, t, c)) continue;
                                const ApplyResult er = st.eliminate(t, z);
                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                progress = progress || (er == ApplyResult::Progress);
                            }
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_wxyz_wing = true;



==============================================================================
PLIK: Sources\logic_engine_part04.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    #include "logic/shared/als_builder.h"
    #include "logic/shared/link_graph.h"
    #include "logic/p6/ur_extended_module.h"
    #include "logic/p6/bug_variants_module.h"
    #include "logic/p6/deadly_patterns_module.h"
    #include "logic/p7/aligned_exclusion_module.h"
    #include "logic/p7/als_aic_module.h"
    #include "logic/p8/exocet_exact_module.h"
    #include "logic/p8/sk_loop_exact_module.h"
    #include "logic/p8/pom_exact_module.h"
    #include "logic/p8/forcing_chains_dynamic_module.h"

    static ApplyResult apply_finned_swordfish_jellyfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};

        ApplyResult ar = apply_finned_x_wing_sashimi(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_finned_swordfish_jellyfish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_swordfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_finned_swordfish_jellyfish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_jellyfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_finned_swordfish_jellyfish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_als_xz(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        const int nn = st.topo->nn;
        bool progress = false;
        auto& sp = exact_pattern_scratchpad();
        for (int d = 0; d <= n; ++d) {
            sp.strong_count[d] = 0;
        }
        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
                const int p0 = st.topo->house_offsets[h];
                const int p1 = st.topo->house_offsets[h + 1];
                int a = -1;
                int b = -1;
                int cnt = 0;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                    if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                    if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                    if (cnt == 0) a = idx;
                    else if (cnt == 1) b = idx;
                    ++cnt;
                    if (cnt > 2) break;
                }
                if (cnt == 2 && a >= 0 && b >= 0) {
                    const int at = sp.strong_count[d];
                    if (at < ExactPatternScratchpad::MAX_STRONG_LINKS_PER_DIGIT) {
                        sp.strong_a[d][at] = a;
                        sp.strong_b[d][at] = b;
                        ++sp.strong_count[d];
                    }
                }
            }
        }

        sp.als_cell_count = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            const int pc = popcnt(st.cands[static_cast<size_t>(idx)]);
            if (pc >= 2 && pc <= 3 && sp.als_cell_count < nn) {
                sp.als_cells[sp.als_cell_count++] = idx;
            }
        }

        for (int i = 0; i < sp.als_cell_count; ++i) {
            const int a = sp.als_cells[i];
            const uint64_t ma = st.cands[static_cast<size_t>(a)];
            for (int j = i + 1; j < sp.als_cell_count; ++j) {
                const int b = sp.als_cells[j];
                if (is_peer(st, a, b)) continue;
                const uint64_t mb = st.cands[static_cast<size_t>(b)];
                const uint64_t common = ma & mb;
                if (popcnt(common) < 2) continue;

                for (uint64_t wx = common; wx != 0ULL; wx &= (wx - 1ULL)) {
                    const uint64_t x = lsb(wx);
                    const int xd = bit_to_index(x) + 1;
                    if (xd < 1 || xd > n) continue;
                    bool linked = false;
                    for (int li = 0; li < sp.strong_count[xd]; ++li) {
                        const int u = sp.strong_a[xd][li];
                        const int v = sp.strong_b[xd][li];
                        if ((is_peer(st, a, u) && is_peer(st, b, v)) ||
                            (is_peer(st, a, v) && is_peer(st, b, u))) {
                            linked = true;
                            break;
                        }
                    }
                    if (!linked) continue;

                    const uint64_t zmask = common & ~x;
                    for (uint64_t wz = zmask; wz != 0ULL; wz &= (wz - 1ULL)) {
                        const uint64_t z = lsb(wz);
                        for (int t = 0; t < nn; ++t) {
                            if (t == a || t == b) continue;
                            if (st.board->values[static_cast<size_t>(t)] != 0) continue;
                            if ((st.cands[static_cast<size_t>(t)] & z) == 0ULL) continue;
                            if (!is_peer(st, t, a) || !is_peer(st, t, b)) continue;
                            const ApplyResult er = st.eliminate(t, z);
                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                            progress = progress || (er == ApplyResult::Progress);
                        }
                    }
                }
            }
        }

        if (progress) {
            ++s.hit_count;
            r.used_als_xz = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_unique_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const ApplyResult ar = apply_unique_rectangle(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_unique_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_avoidable_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const ApplyResult ar = apply_unique_rectangle(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_avoidable_rectangle = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_bivalue_oddagon(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};

        ApplyResult ar = apply_bug_plus_one(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_bivalue_oddagon = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_bivalue_oddagon = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static bool dyn_has_strong_edge(const ExactPatternScratchpad& sp, int u, int v) {
        for (int i = 0; i < sp.dyn_strong_edge_count; ++i) {
            const int a = sp.dyn_strong_edge_u[i];
            const int b = sp.dyn_strong_edge_v[i];
            if ((a == u && b == v) || (a == v && b == u)) return true;
        }
        return false;
    }

    static void dyn_add_strong_edge(ExactPatternScratchpad& sp, int u, int v) {
        if (u == v) return;
        if (dyn_has_strong_edge(sp, u, v)) return;
        if (sp.dyn_strong_edge_count >= (ExactPatternScratchpad::MAX_HOUSES * 2)) return;
        sp.dyn_strong_edge_u[sp.dyn_strong_edge_count] = u;
        sp.dyn_strong_edge_v[sp.dyn_strong_edge_count] = v;
        ++sp.dyn_strong_edge_count;
    }

    static void dyn_add_weak_edge(ExactPatternScratchpad& sp, int u, int v) {
        if (u == v) return;
        if (dyn_has_strong_edge(sp, u, v)) return;
        if (sp.dyn_weak_edge_count >= ExactPatternScratchpad::MAX_LINK_EDGES) return;
        sp.dyn_weak_edge_u[sp.dyn_weak_edge_count] = u;
        sp.dyn_weak_edge_v[sp.dyn_weak_edge_count] = v;
        ++sp.dyn_weak_edge_count;
    }

    static bool dyn_build_digit_graph(CandidateState& st, int digit, ExactPatternScratchpad& sp) {
        const int nn = st.topo->nn;
        const uint64_t bit = (1ULL << (digit - 1));
        sp.reset_dynamic_graph(nn);

        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
            if (sp.dyn_node_count >= nn) break;
            sp.dyn_cell_to_node[idx] = sp.dyn_node_count;
            sp.dyn_node_to_cell[sp.dyn_node_count] = idx;
            sp.dyn_digit_cells[sp.dyn_digit_cell_count++] = idx;
            ++sp.dyn_node_count;
        }
        if (sp.dyn_node_count < 2) return false;

        const int house_count = static_cast<int>(st.topo->house_offsets.size()) - 1;
        for (int h = 0; h < house_count; ++h) {
            const int p0 = st.topo->house_offsets[static_cast<size_t>(h)];
            const int p1 = st.topo->house_offsets[static_cast<size_t>(h + 1)];
            int a = -1;
            int b = -1;
            int cnt = 0;
            for (int p = p0; p < p1; ++p) {
                const int idx = st.topo->houses_flat[static_cast<size_t>(p)];
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                if (cnt == 0) a = idx;
                else if (cnt == 1) b = idx;
                ++cnt;
                if (cnt > 2) break;
            }
            if (cnt != 2) continue;
            const int na = sp.dyn_cell_to_node[a];
            const int nb = sp.dyn_cell_to_node[b];
            if (na < 0 || nb < 0) continue;
            dyn_add_strong_edge(sp, na, nb);
        }

        for (int ni = 0; ni < sp.dyn_node_count; ++ni) {
            const int cell = sp.dyn_node_to_cell[ni];
            const int p0 = st.topo->peer_offsets[static_cast<size_t>(cell)];
            const int p1 = st.topo->peer_offsets[static_cast<size_t>(cell + 1)];
            for (int p = p0; p < p1; ++p) {
                const int peer = st.topo->peers_flat[static_cast<size_t>(p)];
                if (peer <= cell) continue;
                const int nj = sp.dyn_cell_to_node[peer];
                if (nj < 0) continue;
                dyn_add_weak_edge(sp, ni, nj);
            }
        }

        if (sp.dyn_strong_edge_count == 0 && sp.dyn_weak_edge_count == 0) return false;
        sp.reset_dynamic_adjacency(sp.dyn_node_count);

        for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
            const int u = sp.dyn_strong_edge_u[e];
            const int v = sp.dyn_strong_edge_v[e];
            ++sp.dyn_strong_degree[u];
            ++sp.dyn_strong_degree[v];
            ++sp.dyn_weak_degree[u];
            ++sp.dyn_weak_degree[v];
        }
        for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
            const int u = sp.dyn_weak_edge_u[e];
            const int v = sp.dyn_weak_edge_v[e];
            ++sp.dyn_weak_degree[u];
            ++sp.dyn_weak_degree[v];
        }

        int strong_total = 0;
        int weak_total = 0;
        for (int i = 0; i < sp.dyn_node_count; ++i) {
            sp.dyn_strong_offsets[i] = strong_total;
            sp.dyn_weak_offsets[i] = weak_total;
            strong_total += sp.dyn_strong_degree[i];
            weak_total += sp.dyn_weak_degree[i];
        }
        sp.dyn_strong_offsets[sp.dyn_node_count] = strong_total;
        sp.dyn_weak_offsets[sp.dyn_node_count] = weak_total;
        if (strong_total > ExactPatternScratchpad::MAX_ADJ || weak_total > ExactPatternScratchpad::MAX_ADJ) {
            return false;
        }

        for (int i = 0; i < sp.dyn_node_count; ++i) {
            sp.dyn_strong_cursor[i] = sp.dyn_strong_offsets[i];
            sp.dyn_weak_cursor[i] = sp.dyn_weak_offsets[i];
        }

        for (int e = 0; e < sp.dyn_strong_edge_count; ++e) {
            const int u = sp.dyn_strong_edge_u[e];
            const int v = sp.dyn_strong_edge_v[e];
            sp.dyn_strong_adj[sp.dyn_strong_cursor[u]++] = v;
            sp.dyn_strong_adj[sp.dyn_strong_cursor[v]++] = u;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
        }
        for (int e = 0; e < sp.dyn_weak_edge_count; ++e) {
            const int u = sp.dyn_weak_edge_u[e];
            const int v = sp.dyn_weak_edge_v[e];
            sp.dyn_weak_adj[sp.dyn_weak_cursor[u]++] = v;
            sp.dyn_weak_adj[sp.dyn_weak_cursor[v]++] = u;
        }
        return true;
    }

    static ApplyResult apply_dynamic_chain_elimination(
        CandidateState& st,
        int min_depth,
        int depth_cap,
        bool& used_flag) {
        const int n = st.topo->n;
        auto& sp = exact_pattern_scratchpad();

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            if (!dyn_build_digit_graph(st, d, sp)) continue;

            const int state_n = sp.dyn_node_count * 2;
            for (int start = 0; start < sp.dyn_node_count; ++start) {
                for (int start_expect = 0; start_expect <= 1; ++start_expect) {
                    std::fill_n(sp.dyn_state_depth, state_n, -1);
                    std::fill_n(sp.dyn_state_parent, state_n, -1);
                    int qh = 0;
                    int qt = 0;
                    const int start_state = (start << 1) | start_expect;
                    sp.dyn_state_depth[start_state] = 0;
                    sp.dyn_state_queue[qt++] = start_state;

                    while (qh < qt) {
                        const int state = sp.dyn_state_queue[qh++];
                        const int node = (state >> 1);
                        const int expect_strong = (state & 1);
                        const int cur_depth = sp.dyn_state_depth[state];
                        if (cur_depth >= depth_cap) continue;

                        const int* offsets = expect_strong ? sp.dyn_strong_offsets : sp.dyn_weak_offsets;
                        const int* adj = expect_strong ? sp.dyn_strong_adj : sp.dyn_weak_adj;
                        const int next_expect = expect_strong ^ 1;

                        for (int ei = offsets[node]; ei < offsets[node + 1]; ++ei) {
                            const int nxt = adj[ei];
                            const int next_state = (nxt << 1) | next_expect;
                            if (sp.dyn_state_depth[next_state] != -1) continue;
                            const int nd = cur_depth + 1;
                            sp.dyn_state_depth[next_state] = nd;
                            sp.dyn_state_parent[next_state] = state;
                            if (qt < state_n) {
                                sp.dyn_state_queue[qt++] = next_state;
                            }

                            if (nd < min_depth || (nd & 1) == 0) continue;
                            const int start_cell = sp.dyn_node_to_cell[start];
                            const int end_cell = sp.dyn_node_to_cell[nxt];
                            if (!is_peer(st, start_cell, end_cell)) continue;

                            for (int i = 0; i < sp.dyn_digit_cell_count; ++i) {
                                const int idx = sp.dyn_digit_cells[i];
                                if (idx == start_cell || idx == end_cell) continue;
                                if (!is_peer(st, idx, start_cell) || !is_peer(st, idx, end_cell)) continue;
                                const ApplyResult er = st.eliminate(idx, bit);
                                if (er == ApplyResult::Contradiction) return er;
                                if (er == ApplyResult::Progress) {
                                    used_flag = true;
                                    return ApplyResult::Progress;
                                }
                            }
                        }
                    }
                }
            }
        }
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_dynamic_forcing_assumption(CandidateState& st, bool& used_flag) {
        const int nn = st.topo->nn;
        auto& sp = exact_pattern_scratchpad();
        for (int pivot = 0; pivot < nn; ++pivot) {
            if (st.board->values[static_cast<size_t>(pivot)] != 0) continue;
            const uint64_t mask = st.cands[static_cast<size_t>(pivot)];
            const int pc = popcnt(mask);
            if (pc < 2 || pc > 3) continue;

            for (uint64_t w = mask; w != 0ULL; w &= (w - 1ULL)) {
                const uint64_t test_bit = lsb(w);
                const int test_digit = bit_to_index(test_bit) + 1;

                for (int i = 0; i < nn; ++i) {
                    sp.dyn_cands_backup[i] = st.cands[static_cast<size_t>(i)];
                    sp.dyn_values_backup[i] = st.board->values[static_cast<size_t>(i)];
                }
                sp.dyn_empty_backup = st.board->empty_cells;

                bool contradiction = false;
                if (!st.place(pivot, test_digit)) {
                    contradiction = true;
                } else {
                    int iters = 0;
                    bool changed = true;
                    while (changed && iters < 96) {
                        changed = false;
                        ++iters;
                        for (int idx = 0; idx < nn; ++idx) {
                            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                            const uint64_t m = st.cands[static_cast<size_t>(idx)];
                            if (m == 0ULL) {
                                contradiction = true;
                                break;
                            }
                            const int sd = single_digit(m);
                            if (sd == 0) continue;
                            if (!st.place(idx, sd)) {
                                contradiction = true;
                                break;
                            }
                            changed = true;
                        }
                        if (contradiction) break;
                    }
                }

                for (int i = 0; i < nn; ++i) {
                    st.cands[static_cast<size_t>(i)] = sp.dyn_cands_backup[i];
                    st.board->values[static_cast<size_t>(i)] = sp.dyn_values_backup[i];
                }
                st.board->empty_cells = sp.dyn_empty_backup;

                if (!contradiction) continue;
                const ApplyResult er = st.eliminate(pivot, test_bit);
                if (er == ApplyResult::Contradiction) return er;
                if (er == ApplyResult::Progress) {
                    used_flag = true;
                    return ApplyResult::Progress;
                }
            }
        }
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_medusa_3d(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(8 + (st.board->empty_cells / std::max(1, st.topo->n)), 10, 24);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 3, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_medusa_3d = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_simple_coloring(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_medusa_3d = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_x_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_medusa_3d = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(10 + (st.board->empty_cells / std::max(1, st.topo->n)), 12, 28);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 3, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_x_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_grouped_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(12 + (st.board->empty_cells / std::max(1, st.topo->n)), 14, 30);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 4, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_grouped_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_aic(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_grouped_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_als_xz(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_grouped_aic = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_grouped_x_cycle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(10 + (st.board->empty_cells / std::max(1, st.topo->n)), 12, 26);
        bool used_dynamic = false;

        const ApplyResult dyn = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (dyn == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return dyn; }
        if (dyn == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_grouped_x_cycle = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        const ApplyResult ar = apply_x_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_grouped_x_cycle = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_continuous_nice_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(12 + (st.board->empty_cells / std::max(1, st.topo->n)), 14, 30);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_continuous_nice_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_continuous_nice_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_x_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_continuous_nice_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_als_xy_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};

        ApplyResult ar = apply_als_xz(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_als_xy_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xyz_wing(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_als_xy_wing = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_als_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};

        ApplyResult ar = apply_als_xz(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_als_chain = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_als_chain = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_sue_de_coq(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        StrategyStats tmp1{};
        StrategyStats tmp2{};

        ApplyResult ar = apply_pointing_and_boxline(st, tmp1, tmp2, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_sue_de_coq = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_als_xz(st, tmp1, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_sue_de_coq = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_death_blossom(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};

        ApplyResult ar = apply_w_wing(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_death_blossom = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_death_blossom = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_squirmbag(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        const int n = st.topo->n;
        if (n < 5) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        auto& sp = exact_pattern_scratchpad();

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::fill_n(sp.fish_row_masks, n, 0ULL);
            std::fill_n(sp.fish_col_masks, n, 0ULL);

            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
                if ((st.cands[static_cast<size_t>(idx)] & bit) == 0ULL) continue;
                const int rr = st.topo->cell_row[static_cast<size_t>(idx)];
                const int cc = st.topo->cell_col[static_cast<size_t>(idx)];
                sp.fish_row_masks[rr] |= (1ULL << cc);
                sp.fish_col_masks[cc] |= (1ULL << rr);
            }

            int row_count = 0;
            int col_count = 0;
            for (int rr = 0; rr < n; ++rr) {
                const int cnt = popcnt(sp.fish_row_masks[rr]);
                if (cnt >= 2 && cnt <= 5) sp.active_rows[row_count++] = rr;
            }
            for (int cc = 0; cc < n; ++cc) {
                const int cnt = popcnt(sp.fish_col_masks[cc]);
                if (cnt >= 2 && cnt <= 5) sp.active_cols[col_count++] = cc;
            }

            for (int i = 0; i + 4 < row_count; ++i) {
                const int r1 = sp.active_rows[i];
                const uint64_t u1 = sp.fish_row_masks[r1];
                for (int j = i + 1; j + 3 < row_count; ++j) {
                    const int r2 = sp.active_rows[j];
                    const uint64_t u2 = u1 | sp.fish_row_masks[r2];
                    if (popcnt(u2) > 5) continue;
                    for (int k = j + 1; k + 2 < row_count; ++k) {
                        const int r3 = sp.active_rows[k];
                        const uint64_t u3 = u2 | sp.fish_row_masks[r3];
                        if (popcnt(u3) > 5) continue;
                        for (int l = k + 1; l + 1 < row_count; ++l) {
                            const int r4 = sp.active_rows[l];
                            const uint64_t u4 = u3 | sp.fish_row_masks[r4];
                            if (popcnt(u4) > 5) continue;
                            for (int m = l + 1; m < row_count; ++m) {
                                const int r5 = sp.active_rows[m];
                                const uint64_t cols_union = u4 | sp.fish_row_masks[r5];
                                if (popcnt(cols_union) != 5) continue;
                                for (uint64_t w = cols_union; w != 0ULL; w &= (w - 1ULL)) {
                                    const int cc = static_cast<int>(std::countr_zero(w));
                                    for (int rr = 0; rr < n; ++rr) {
                                        if (rr == r1 || rr == r2 || rr == r3 || rr == r4 || rr == r5) continue;
                                        const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        if (er == ApplyResult::Progress) {
                                            ++s.hit_count;
                                            r.used_squirmbag = true;
                                            s.elapsed_ns += now_ns() - t0;
                                            return ApplyResult::Progress;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            for (int i = 0; i + 4 < col_count; ++i) {
                const int c1 = sp.active_cols[i];
                const uint64_t u1 = sp.fish_col_masks[c1];
                for (int j = i + 1; j + 3 < col_count; ++j) {
                    const int c2 = sp.active_cols[j];
                    const uint64_t u2 = u1 | sp.fish_col_masks[c2];
                    if (popcnt(u2) > 5) continue;
                    for (int k = j + 1; k + 2 < col_count; ++k) {
                        const int c3 = sp.active_cols[k];
                        const uint64_t u3 = u2 | sp.fish_col_masks[c3];
                        if (popcnt(u3) > 5) continue;
                        for (int l = k + 1; l + 1 < col_count; ++l) {
                            const int c4 = sp.active_cols[l];
                            const uint64_t u4 = u3 | sp.fish_col_masks[c4];
                            if (popcnt(u4) > 5) continue;
                            for (int m = l + 1; m < col_count; ++m) {
                                const int c5 = sp.active_cols[m];
                                const uint64_t rows_union = u4 | sp.fish_col_masks[c5];
                                if (popcnt(rows_union) != 5) continue;
                                for (uint64_t w = rows_union; w != 0ULL; w &= (w - 1ULL)) {
                                    const int rr = static_cast<int>(std::countr_zero(w));
                                    for (int cc = 0; cc < n; ++cc) {
                                        if (cc == c1 || cc == c2 || cc == c3 || cc == c4 || cc == c5) continue;
                                        const ApplyResult er = st.eliminate(rr * n + cc, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        if (er == ApplyResult::Progress) {
                                            ++s.hit_count;
                                            r.used_squirmbag = true;
                                            s.elapsed_ns += now_ns() - t0;
                                            return ApplyResult::Progress;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_franken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        StrategyStats tmp{};
        const ApplyResult ar = apply_swordfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_franken_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_mutant_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        StrategyStats tmp{};
        const ApplyResult ar = apply_jellyfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_mutant_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_kraken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(12 + (st.board->empty_cells / std::max(1, st.topo->n)), 14, 30);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 4, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_kraken_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_x_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_kraken_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_simple_coloring(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_kraken_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_finned_swordfish_jellyfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_kraken_fish = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_msls(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(14 + (st.board->empty_cells / std::max(1, st.topo->n)), 16, 32);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_msls = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        // Bounded composite probe: never loops unbounded, at most 3 delegated passes.
        ar = apply_grouped_x_cycle(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_msls = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_als_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_msls = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_kraken_fish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_msls = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) {
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::NoProgress;
        }
        {
            StrategyStats tmp{};
            const ApplyResult exact = apply_exocet_exact(st, tmp, r);
            if (exact == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return exact; }
            if (exact == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_exocet = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
        auto& sp = exact_pattern_scratchpad();

        // Bounded structural scan: sample up to 96 unsolved bivalue cells as exocet base candidates.
        int base_count = 0;
        for (int idx = 0; idx < st.topo->nn && base_count < 96; ++idx) {
            if (st.board->values[static_cast<size_t>(idx)] != 0) continue;
            if (popcnt(st.cands[static_cast<size_t>(idx)]) == 2) {
                sp.wing_cells[base_count++] = idx;
            }
        }
        for (int i = 0; i + 1 < base_count; ++i) {
            const int b1 = sp.wing_cells[i];
            const uint64_t m1 = st.cands[static_cast<size_t>(b1)];
            for (int j = i + 1; j < base_count; ++j) {
                const int b2 = sp.wing_cells[j];
                if (is_peer(st, b1, b2)) continue;
                const uint64_t m2 = st.cands[static_cast<size_t>(b2)];
                const uint64_t common = m1 & m2;
                if (popcnt(common) != 2) continue;

                const int p0 = st.topo->peer_offsets[static_cast<size_t>(b1)];
                const int p1 = st.topo->peer_offsets[static_cast<size_t>(b1 + 1)];
                int sampled = 0;
                for (int p = p0; p < p1 && sampled < 96; ++p, ++sampled) {
                    const int t = st.topo->peers_flat[static_cast<size_t>(p)];
                    if (t == b1 || t == b2) continue;
                    if (!is_peer(st, t, b2)) continue;
                    const ApplyResult er = st.eliminate(t, common);
                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                    if (er == ApplyResult::Progress) {
                        ++s.hit_count;
                        r.used_exocet = true;
                        s.elapsed_ns += now_ns() - t0;
                        return ApplyResult::Progress;
                    }
                }
            }
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_senior_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        const int depth_cap = std::clamp(14 + (st.board->empty_cells / std::max(1, st.topo->n)), 16, 32);
        bool used_dynamic = false;

        ApplyResult dyn = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (dyn == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return dyn; }
        if (dyn == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_senior_exocet = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ApplyResult ar = apply_exocet(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_senior_exocet = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_grouped_aic(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_senior_exocet = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_sk_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        {
            const ApplyResult exact = apply_sk_loop_exact(st, tmp, r);
            if (exact == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return exact; }
            if (exact == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_sk_loop = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
        const int depth_cap = std::clamp(14 + (st.board->empty_cells / std::max(1, st.topo->n)), 16, 32);
        bool used_dynamic = false;

        ApplyResult dyn = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (dyn == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return dyn; }
        if (dyn == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_sk_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ApplyResult ar = apply_continuous_nice_loop(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_sk_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_grouped_x_cycle(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_sk_loop = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_pattern_overlay_method(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        {
            const ApplyResult exact = apply_pom_exact(st, tmp, r);
            if (exact == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return exact; }
            if (exact == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_pattern_overlay_method = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
        const int depth_cap = std::clamp(16 + (st.board->empty_cells / std::max(1, st.topo->n)), 18, 34);
        bool used_dynamic = false;

        ApplyResult dyn = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (dyn == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return dyn; }
        if (dyn == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_pattern_overlay_method = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ApplyResult ar = apply_msls(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_pattern_overlay_method = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_swordfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_pattern_overlay_method = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_jellyfish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_pattern_overlay_method = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns();
        ++s.use_count;
        StrategyStats tmp{};
        {
            const ApplyResult dyn_exact = apply_dynamic_forcing_chains(st, tmp, r);
            if (dyn_exact == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return dyn_exact; }
            if (dyn_exact == ApplyResult::Progress) {
                ++s.hit_count;
                r.used_forcing_chains = true;
                r.used_dynamic_forcing_chains = true;
                s.elapsed_ns += now_ns() - t0;
                return ApplyResult::Progress;
            }
        }
        const int depth_cap = std::clamp(18 + (st.board->empty_cells / std::max(1, st.topo->n)), 20, 36);
        bool used_dynamic = false;

        ApplyResult ar = apply_dynamic_forcing_assumption(st, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_dynamic_chain_elimination(st, 5, depth_cap, used_dynamic);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        // Hard upper bound: at most 4 delegated chain attempts.
        ar = apply_aic(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }




==============================================================================
PLIK: Sources\logic_engine_part05.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

        ar = apply_grouped_aic(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_xy_chain(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        ar = apply_kraken_fish(st, tmp, r);
        if (ar == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return ar; }
        if (ar == ApplyResult::Progress) {
            ++s.hit_count;
            r.used_forcing_chains = true;
            s.elapsed_ns += now_ns() - t0;
            return ApplyResult::Progress;
        }

        s.elapsed_ns += now_ns() - t0;
        return ApplyResult::NoProgress;
    }

    static ApplyResult apply_round_up_to_level(CandidateState& st, GenericLogicCertifyResult& result, int max_level) {
        ApplyResult ar = apply_naked_single(st, result.strategy_stats[SlotNakedSingle], result);
        if (ar != ApplyResult::NoProgress) return ar;

        ar = apply_hidden_single(st, result.strategy_stats[SlotHiddenSingle], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 1) return ApplyResult::NoProgress;

        ar = apply_pointing_and_boxline(st, result.strategy_stats[SlotPointingPairs], result.strategy_stats[SlotBoxLineReduction], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 2) return ApplyResult::NoProgress;

        ar = apply_house_subset(st, result.strategy_stats[SlotNakedPair], result, 2, false);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_house_subset(st, result.strategy_stats[SlotHiddenPair], result, 2, true);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_house_subset(st, result.strategy_stats[SlotNakedTriple], result, 3, false);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_house_subset(st, result.strategy_stats[SlotHiddenTriple], result, 3, true);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 3) return ApplyResult::NoProgress;

        ar = apply_house_subset(st, result.strategy_stats[SlotNakedQuad], result, 4, false);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_house_subset(st, result.strategy_stats[SlotHiddenQuad], result, 4, true);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_x_wing(st, result.strategy_stats[SlotXWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_y_wing(st, result.strategy_stats[SlotYWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_skyscraper(st, result.strategy_stats[SlotSkyscraper], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_two_string_kite(st, result.strategy_stats[SlotTwoStringKite], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_empty_rectangle(st, result.strategy_stats[SlotEmptyRectangle], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_remote_pairs(st, result.strategy_stats[SlotRemotePairs], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 4) return ApplyResult::NoProgress;

        ar = apply_swordfish(st, result.strategy_stats[SlotSwordfish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_finned_x_wing_sashimi(st, result.strategy_stats[SlotFinnedXWingSashimi], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_simple_coloring(st, result.strategy_stats[SlotSimpleColoring], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_bug_plus_one(st, result.strategy_stats[SlotBUGPlusOne], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_unique_rectangle(st, result.strategy_stats[SlotUniqueRectangle], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_xyz_wing(st, result.strategy_stats[SlotXYZWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_w_wing(st, result.strategy_stats[SlotWWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 5) return ApplyResult::NoProgress;

        ar = apply_jellyfish(st, result.strategy_stats[SlotJellyfish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_x_chain(st, result.strategy_stats[SlotXChain], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_xy_chain(st, result.strategy_stats[SlotXYChain], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_wxyz_wing(st, result.strategy_stats[SlotWXYZWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_finned_swordfish_jellyfish(st, result.strategy_stats[SlotFinnedSwordfishJellyfish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_als_xz(st, result.strategy_stats[SlotALSXZ], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_unique_loop(st, result.strategy_stats[SlotUniqueLoop], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_avoidable_rectangle(st, result.strategy_stats[SlotAvoidableRectangle], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_bivalue_oddagon(st, result.strategy_stats[SlotBivalueOddagon], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_ur_extended(st, result.strategy_stats[SlotURExtended], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_hidden_ur(st, result.strategy_stats[SlotHiddenUR], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_bug_type2(st, result.strategy_stats[SlotBUGType2], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_bug_type3(st, result.strategy_stats[SlotBUGType3], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_bug_type4(st, result.strategy_stats[SlotBUGType4], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_borescoper_qiu_deadly_pattern(st, result.strategy_stats[SlotBorescoperQiuDeadlyPattern], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 6) return ApplyResult::NoProgress;

        ar = apply_medusa_3d(st, result.strategy_stats[SlotMedusa3D], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_aic(st, result.strategy_stats[SlotAIC], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_grouped_aic(st, result.strategy_stats[SlotGroupedAIC], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_grouped_x_cycle(st, result.strategy_stats[SlotGroupedXCycle], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_continuous_nice_loop(st, result.strategy_stats[SlotContinuousNiceLoop], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_als_xy_wing(st, result.strategy_stats[SlotALSXYWing], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_als_chain(st, result.strategy_stats[SlotALSChain], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_sue_de_coq(st, result.strategy_stats[SlotSueDeCoq], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_death_blossom(st, result.strategy_stats[SlotDeathBlossom], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_franken_fish(st, result.strategy_stats[SlotFrankenFish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_mutant_fish(st, result.strategy_stats[SlotMutantFish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_kraken_fish(st, result.strategy_stats[SlotKrakenFish], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_squirmbag(st, result.strategy_stats[SlotSquirmbag], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_aligned_pair_exclusion(st, result.strategy_stats[SlotAlignedPairExclusion], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_aligned_triple_exclusion(st, result.strategy_stats[SlotAlignedTripleExclusion], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_als_aic(st, result.strategy_stats[SlotALSAIC], result);
        if (ar != ApplyResult::NoProgress) return ar;
        if (max_level <= 7) return ApplyResult::NoProgress;

        ar = apply_msls(st, result.strategy_stats[SlotMSLS], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_exocet(st, result.strategy_stats[SlotExocet], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_senior_exocet(st, result.strategy_stats[SlotSeniorExocet], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_sk_loop(st, result.strategy_stats[SlotSKLoop], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_pattern_overlay_method(st, result.strategy_stats[SlotPatternOverlayMethod], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_dynamic_forcing_chains(st, result.strategy_stats[SlotDynamicForcingChains], result);
        if (ar != ApplyResult::NoProgress) return ar;
        ar = apply_forcing_chains(st, result.strategy_stats[SlotForcingChains], result);
        if (ar != ApplyResult::NoProgress) return ar;

        return ApplyResult::NoProgress;
    }

public:
    GenericLogicCertifyResult certify(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        return certify_up_to_level(puzzle, topo, 8, budget, capture_solution_grid);
    }

    GenericLogicCertifyResult certify_p1_p5_modular(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        return certify_up_to_level(puzzle, topo, 5, budget, capture_solution_grid);
    }

    GenericLogicCertifyResult certify_up_to_level(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        int max_level,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        GenericLogicCertifyResult result{};
        const bool has_budget = (budget != nullptr);
        const int level_limit = std::clamp(max_level, 1, 8);

        static thread_local GenericBoard board;
        board.topo = &topo;
        if (!board.init_from_puzzle(puzzle, false)) return result;

        CandidateState st{};
        if (!st.init(board, topo)) return result;

        while (board.empty_cells != 0) {
            if (has_budget && !budget->step()) {
                result.timed_out = true;
                result.solved = false;
                return result;
            }
            const ApplyResult ar = apply_round_up_to_level(st, result, level_limit);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            break;
        }

        result.solved = (board.empty_cells == 0);
        if (capture_solution_grid) result.solved_grid = board.values;
        result.naked_single_scanned = result.strategy_stats[SlotNakedSingle].use_count > 0;
        result.hidden_single_scanned = result.strategy_stats[SlotHiddenSingle].use_count > 0;
        return result;
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\monitor.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {
struct MonitorTotalsSnapshot {
    uint64_t target = 0;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t analyzed_required_strategy = 0;
    uint64_t required_strategy_hits = 0;
    uint64_t written_required_strategy = 0;
    uint64_t rejected = 0;
    uint64_t active_workers = 0;
    uint64_t reseeds = 0;
};

struct WorkerRow {
    std::string worker = "worker_00";
    int clues = 0;
    long long seed = 0;
    uint64_t last_reseed_steady_ns = 0;
    uint64_t resets = 0;
    uint64_t applied = 0;
    double reset_lag = 0.0;
    double lag_max = 0.0;
    double reset_in_s = 0.0;
    std::string status = "idle";
    uint64_t dead_ends = 0;
    uint64_t max_depth = 0;
    double avg_node_ms = 0.0;
    double cpu_load_pct = 0.0;
    double ram_current_mb = 0.0;
    double ram_peak_mb = 0.0;
    // Budget settings for display
    int reseed_interval_s = 0;
    double attempt_time_budget_s = 0.0;
    uint64_t attempt_node_budget = 0;
    // Mikroprofiling metrics
    double stage_solved_ms = 0.0;
    double stage_dig_ms = 0.0;
    double stage_prefilter_ms = 0.0;
    double stage_logic_ms = 0.0;
    double stage_uniqueness_ms = 0.0;
    double avg_attempt_ms = 0.0;
    double success_rate_pct = 0.0;
    uint64_t backtrack_count = 0;
};

struct StrategyRow {
    std::string strategy = "None";
    int lvl = 0;
    uint64_t max_attempts = 0;
    uint64_t analyzed = 0;
    uint64_t required_strategy_hits = 0;
    double analyzed_per_min = 0.0;
    uint64_t est_5min = 0;
    uint64_t written = 0;
    double avg_clues = 0.0;
};

class ConsoleStatsMonitor {
public:
    ConsoleStatsMonitor() {
        start_tp_ = std::chrono::steady_clock::now();
        enable_ansi();
        log_info("ConsoleStatsMonitor", "constructed - will refresh every 8s in CLI mode");
    }

    ~ConsoleStatsMonitor() {
        stop_ui_thread();
        log_info("ConsoleStatsMonitor", "destroyed");
    }

    // ========================================================================
    // TELEMETRIA - główne metryki generatora
    // ========================================================================
    void set_target(uint64_t target) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.target = target;
    }

    void set_active_workers(int n) {
        {
            std::unique_lock<std::shared_mutex> lock(totals_mu_);
            totals_.active_workers = static_cast<uint64_t>(std::max(0, n));
        }
        std::lock_guard<std::mutex> lock(workers_mu_);
        if (static_cast<int>(workers_.size()) < n) {
            const size_t old_size = workers_.size();
            workers_.resize(static_cast<size_t>(n));
            for (size_t i = old_size; i < workers_.size(); ++i) {
                std::ostringstream name;
                name << "worker_" << std::setw(2) << std::setfill('0') << i;
                workers_[i].worker = name.str();
            }
        }
    }

    void set_attempts(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.attempts = v;
    }

    // ========================================================================
    // TELEMETRIA STRATEGII - Required Strategy Contract
    // ========================================================================
    void set_attempts_total(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.attempts = v;
    }

    void set_analyzed_required_strategy(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.analyzed_required_strategy = v;
    }

    void set_required_strategy_hits(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.required_strategy_hits = v;
    }

    void set_written_required_strategy(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.written_required_strategy = v;
    }

    void set_accepted(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.accepted = v;
    }

    void set_written(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.written = v;
    }

    void set_rejected(uint64_t v) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.rejected = v;
    }

    void set_totals_snapshot(const MonitorTotalsSnapshot& snapshot) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_ = snapshot;
    }

    void add_reseed(uint64_t inc = 1) {
        std::unique_lock<std::shared_mutex> lock(totals_mu_);
        totals_.reseeds += inc;
    }

    void set_worker_row(size_t worker_idx, const WorkerRow& row) {
        std::lock_guard<std::mutex> lock(workers_mu_);
        if (worker_idx >= workers_.size()) {
            workers_.resize(worker_idx + 1);
        }
        workers_[worker_idx] = row;
    }

    void update_strategy_row(const StrategyRow& row) {
        std::lock_guard<std::mutex> lock(strategies_mu_);
        for (auto& item : strategies_) {
            if (item.strategy == row.strategy && item.lvl == row.lvl) {
                item = row;
                return;
            }
        }
        strategies_.push_back(row);
    }

    void add_avg_clues_per_level(int lvl, double clues) {
        if (lvl < 0 || lvl >= static_cast<int>(clues_sum_.size())) {
            return;
        }
        std::lock_guard<std::mutex> lock(clues_mu_);
        clues_sum_[lvl] += clues;
        clues_count_[lvl] += 1;
    }

    void set_background_status(const std::string& status) {
        std::lock_guard<std::mutex> lock(status_mu_);
        background_status_ = status;
    }

    // Microprofiling update
    void set_profiler_summary(const std::string& summary) {
        std::lock_guard<std::mutex> lock(profiler_mu_);
        profiler_summary_ = summary;
    }

    // Grid info setter
    void set_grid_info(int box_rows, int box_cols, int difficulty_level) {
        box_rows_ = box_rows;
        box_cols_ = box_cols;
        difficulty_level_ = difficulty_level;
    }

    void start_ui_thread(int refresh_rate_ms) {
        stop_ui_thread();
        log_info("ConsoleStatsMonitor", "start_ui_thread refresh_ms=" + std::to_string(refresh_rate_ms));
        ui_thread_ = std::jthread([this, refresh_rate_ms](std::stop_token st) {
            log_info("ConsoleStatsMonitor", "ui_thread started with interval=" + std::to_string(refresh_rate_ms) + "ms");
            using namespace std::chrono_literals;
            const auto interval = std::chrono::milliseconds(refresh_rate_ms);
            while (!st.stop_requested()) {
                render_once();
                std::this_thread::sleep_for(interval);
            }
            render_once();
            log_info("ConsoleStatsMonitor", "ui_thread finished");
        });
    }

    void stop_ui_thread() {
        if (ui_thread_.joinable()) {
            log_info("ConsoleStatsMonitor", "stop_ui_thread requested");
            ui_thread_.request_stop();
            ui_thread_.join();
            log_info("ConsoleStatsMonitor", "stop_ui_thread joined");
        }
    }

    std::string snapshot_text() const {
        return compose_snapshot_text();
    }

private:
    alignas(64) MonitorTotalsSnapshot totals_{};
    mutable std::shared_mutex totals_mu_;

    std::chrono::steady_clock::time_point start_tp_;

    mutable std::mutex workers_mu_;
    std::vector<WorkerRow> workers_;

    mutable std::mutex strategies_mu_;
    std::vector<StrategyRow> strategies_;

    mutable std::mutex clues_mu_;
    std::array<double, 10> clues_sum_{};
    std::array<uint64_t, 10> clues_count_{};

    mutable std::mutex status_mu_;
    std::string background_status_ = "Generowanie: init";

    mutable std::mutex profiler_mu_;
    std::string profiler_summary_ = "";

    // Grid info
    int box_rows_ = 0;
    int box_cols_ = 0;
    int difficulty_level_ = 0;

    std::jthread ui_thread_;
    bool ansi_enabled_ = false;
    mutable std::mutex render_mu_;

    void enable_ansi() {
#ifdef _WIN32
        HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
        if (h == INVALID_HANDLE_VALUE) {
            log_warn("ConsoleStatsMonitor", "GetStdHandle(STD_OUTPUT_HANDLE) failed");
            return;
        }
        DWORD mode = 0;
        if (!GetConsoleMode(h, &mode)) {
            log_warn("ConsoleStatsMonitor", "GetConsoleMode failed - console VT disabled");
            return;
        }
        mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
        if (SetConsoleMode(h, mode)) {
            ansi_enabled_ = true;
            log_info("ConsoleStatsMonitor", "ANSI VT enabled");
        } else {
            log_warn("ConsoleStatsMonitor", "SetConsoleMode(ENABLE_VIRTUAL_TERMINAL_PROCESSING) failed");
        }
#else
        ansi_enabled_ = true;
#endif
    }

#ifdef _WIN32
    bool render_winapi(const std::string& text) const {
        HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
        if (h == nullptr || h == INVALID_HANDLE_VALUE) {
            return false;
        }
        DWORD mode = 0;
        if (!GetConsoleMode(h, &mode)) {
            return false;
        }

        CONSOLE_SCREEN_BUFFER_INFO csbi{};
        if (!GetConsoleScreenBufferInfo(h, &csbi)) {
            return false;
        }

        const COORD home{0, 0};
        const DWORD cells = static_cast<DWORD>(csbi.dwSize.X) * static_cast<DWORD>(csbi.dwSize.Y);
        DWORD n = 0;
        if (!FillConsoleOutputCharacterA(h, ' ', cells, home, &n)) {
            return false;
        }
        if (!FillConsoleOutputAttribute(h, csbi.wAttributes, cells, home, &n)) {
            return false;
        }
        if (!SetConsoleCursorPosition(h, home)) {
            return false;
        }
        if (text.empty()) {
            return true;
        }

        DWORD written = 0;
        if (!WriteConsoleA(h, text.data(), static_cast<DWORD>(text.size()), &written, nullptr)) {
            return false;
        }
        return true;
    }
#endif

    std::string render_global_line() const {
        using namespace std::chrono;
        MonitorTotalsSnapshot totals_snapshot;
        {
            std::shared_lock<std::shared_mutex> lock(totals_mu_);
            totals_snapshot = totals_;
        }
        const double elapsed_h = duration<double>(steady_clock::now() - start_tp_).count() / 3600.0;
        const double hourly =
            elapsed_h > 0.0 ? static_cast<double>(totals_snapshot.accepted) / elapsed_h : 0.0;
        std::ostringstream oss;
        // Grid size and difficulty info
        const int n = box_rows_ * box_cols_;
        if (n > 0) {
            oss << "[" << n << "x" << n << " L" << difficulty_level_ << "] ";
        }
        oss << "accepted=" << totals_snapshot.accepted << "/" << totals_snapshot.target
            << " written=" << totals_snapshot.written
            << " attempts_total=" << totals_snapshot.attempts
            << " analyzed_required_strategy=" << totals_snapshot.analyzed_required_strategy
            << " required_strategy_hit/use=" << totals_snapshot.required_strategy_hits << "/"
            << totals_snapshot.analyzed_required_strategy
            << " written_required_strategy=" << totals_snapshot.written_required_strategy
            << " rejected=" << totals_snapshot.rejected
            << " " << std::fixed << std::setprecision(2) << hourly << "/h"
            << " active_workers=" << totals_snapshot.active_workers
            << " reseeds=" << totals_snapshot.reseeds;
        return oss.str();
    }

    std::string render_worker_table() const {
        std::vector<std::vector<std::string>> rows;
        const auto now_ns = static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::steady_clock::now().time_since_epoch())
                .count());
        {
            std::lock_guard<std::mutex> lock(workers_mu_);
            rows.reserve(workers_.size());
            for (const auto& w : workers_) {
                double reset_lag = w.reset_lag;
                double lag_max = w.lag_max;
                double reset_in_s = w.reset_in_s;
                if (w.reseed_interval_s > 0 && w.last_reseed_steady_ns > 0 && now_ns >= w.last_reseed_steady_ns) {
                    const double elapsed_s =
                        static_cast<double>(now_ns - w.last_reseed_steady_ns) / 1'000'000'000.0;
                    const double interval_s = static_cast<double>(w.reseed_interval_s);
                    const double lag = std::max(0.0, elapsed_s - interval_s);
                    reset_lag = lag;
                    lag_max = std::max(lag_max, lag);
                    reset_in_s = std::max(0.0, interval_s - elapsed_s);
                }
                rows.push_back(
                    {
                        w.worker,
                        std::to_string(w.clues),
                        std::to_string(w.seed),
                        std::to_string(w.resets),
                        std::to_string(w.applied),
                        format_fixed(reset_lag, 2),
                        format_fixed(lag_max, 2),
                        format_fixed(reset_in_s, 2),
                        w.status,
                        std::to_string(w.dead_ends),
                        std::to_string(w.max_depth),
                        format_fixed(w.avg_node_ms, 4),
                        format_fixed(w.cpu_load_pct, 1),
                        format_fixed(w.ram_current_mb, 1),
                        format_fixed(w.ram_peak_mb, 1),
                        std::to_string(w.reseed_interval_s),
                        format_fixed(w.attempt_time_budget_s, 1),
                        std::to_string(w.attempt_node_budget),
                        format_fixed(w.stage_solved_ms, 4),
                        format_fixed(w.stage_dig_ms, 4),
                        format_fixed(w.stage_logic_ms, 4),
                        format_fixed(w.stage_uniqueness_ms, 4),
                        format_fixed(w.avg_attempt_ms, 4),
                        format_fixed(w.success_rate_pct, 2),
                        std::to_string(w.backtrack_count),
                    });
            }
        }
        return render_table(
            {
                {"worker", Align::Left},
                {"clues", Align::Right},
                {"seed", Align::Right},
                {"resets", Align::Right},
                {"applied", Align::Right},
                {"reset_lag", Align::Right},
                {"lag_max", Align::Right},
                {"reset_in_s", Align::Right},
                {"status", Align::Left},
                {"dead_ends", Align::Right},
                {"max_depth", Align::Right},
                {"avg_node_ms", Align::Right},
                {"cpu_%", Align::Right},
                {"ram_mb", Align::Right},
                {"peak_mb", Align::Right},
                {"reseed_s", Align::Right},
                {"time_s", Align::Right},
                {"nodes", Align::Right},
                {"solved_ms", Align::Right},
                {"dig_ms", Align::Right},
                {"logic_ms", Align::Right},
                {"uniq_ms", Align::Right},
                {"avg_att_ms", Align::Right},
                {"success_%", Align::Right},
                {"backtracks", Align::Right},
            },
            rows);
    }

    std::string render_strategy_table() const {
        std::vector<std::vector<std::string>> rows;
        {
            std::lock_guard<std::mutex> lock(strategies_mu_);
            rows.reserve(strategies_.size());
            for (const auto& s : strategies_) {
                rows.push_back(
                    {
                        s.strategy,
                        std::to_string(s.lvl),
                        std::to_string(s.max_attempts),
                        std::to_string(s.analyzed),
                        std::to_string(s.required_strategy_hits) + "/" + std::to_string(s.analyzed),
                        format_fixed(s.analyzed_per_min, 2),
                        std::to_string(s.est_5min),
                        std::to_string(s.written),
                        format_fixed(s.avg_clues, 2),
                    });
            }
        }
        return render_table(
            {
                {"strategy", Align::Left},
                {"lvl", Align::Right},
                {"max_attempts", Align::Right},
                {"analyzed", Align::Right},
                {"hit/use", Align::Right},
                {"analyzed/min", Align::Right},
                {"est_5min", Align::Right},
                {"written", Align::Right},
                {"avg_clues", Align::Right},
            },
            rows);
    }

    std::string render_avg_clues() const {
        std::ostringstream oss;
        oss << "avg_clues_per_level: ";
        std::lock_guard<std::mutex> lock(clues_mu_);
        bool any = false;
        for (size_t lvl = 1; lvl < clues_sum_.size(); ++lvl) {
            if (clues_count_[lvl] == 0) {
                continue;
            }
            if (any) {
                oss << " | ";
            }
            any = true;
            oss << "L" << lvl << "=" << format_fixed(clues_sum_[lvl] / static_cast<double>(clues_count_[lvl]), 2);
        }
        if (!any) {
            oss << "(brak)";
        }
        return oss.str();
    }

    std::string compose_snapshot_text() const {
        std::ostringstream out;
        out << "=== Statystyki Generowania (console) ===\n";
        out << render_global_line() << "\n\n";
        out << render_worker_table() << "\n\n";
        out << "=== Required Strategy Monitor (10s) ===\n";
        out << render_strategy_table() << "\n";
        out << render_avg_clues() << "\n";
        {
            std::lock_guard<std::mutex> lock(status_mu_);
            out << background_status_ << "\n";
        }
        {
            std::lock_guard<std::mutex> lock(profiler_mu_);
            if (!profiler_summary_.empty()) {
                out << "\n=== Mikroprofiling ===\n";
                out << profiler_summary_ << "\n";
            }
        }
        return out.str();
    }

    void render_once() const {
        try {
            const std::string text = compose_snapshot_text();
            std::lock_guard<std::mutex> lock(render_mu_);
#ifdef _WIN32
            if (!ansi_enabled_ && render_winapi(text)) {
                return;
            }
#endif
            if (ansi_enabled_) {
                std::cout << "\033[H\033[2J" << text << std::flush;
            } else {
                std::cout << "\n" << text << std::flush;
            }
        } catch (const std::exception& ex) {
            log_error("ConsoleStatsMonitor", std::string("render_once exception: ") + ex.what());
        } catch (...) {
            log_error("ConsoleStatsMonitor", "render_once unknown exception");
        }
    }
};

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\profiler.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {
enum class ProfilerStage : uint8_t {
    SolvedKernel = 0,
    DigKernel = 1,
    QuickPrefilter = 2,
    LogicCertify = 3,
    UniquenessCertify = 4,
    TotalCount = 5
};

inline const char* profiler_stage_name(ProfilerStage stage) {
    switch (stage) {
    case ProfilerStage::SolvedKernel: return "SolvedKernel";
    case ProfilerStage::DigKernel: return "DigKernel";
    case ProfilerStage::QuickPrefilter: return "QuickPrefilter";
    case ProfilerStage::LogicCertify: return "LogicCertify";
    case ProfilerStage::UniquenessCertify: return "UniquenessCertify";
    default: return "Unknown";
    }
}

// alignas(128) to avoid inter-core false sharing for hot stage counters.
struct alignas(128) StageMetrics {
    std::atomic<uint64_t> call_count{0};
    std::atomic<uint64_t> total_elapsed_ns{0};
    std::atomic<uint64_t> min_elapsed_ns{std::numeric_limits<uint64_t>::max()};
    std::atomic<uint64_t> max_elapsed_ns{0};
    
    void record(uint64_t elapsed_ns) {
        call_count.fetch_add(1, std::memory_order_relaxed);
        total_elapsed_ns.fetch_add(elapsed_ns, std::memory_order_relaxed);
        
        // Atomowe min/max - pętla CAS
        uint64_t current_min = min_elapsed_ns.load(std::memory_order_relaxed);
        while (elapsed_ns < current_min) {
            if (min_elapsed_ns.compare_exchange_weak(current_min, elapsed_ns, 
                std::memory_order_relaxed, std::memory_order_relaxed)) {
                break;
            }
        }
        
        uint64_t current_max = max_elapsed_ns.load(std::memory_order_relaxed);
        while (elapsed_ns > current_max) {
            if (max_elapsed_ns.compare_exchange_weak(current_max, elapsed_ns,
                std::memory_order_relaxed, std::memory_order_relaxed)) {
                break;
            }
        }
    }
    
    double avg_elapsed_ms() const {
        const uint64_t count = call_count.load(std::memory_order_relaxed);
        if (count == 0) return 0.0;
        return static_cast<double>(total_elapsed_ns.load(std::memory_order_relaxed)) / 
               static_cast<double>(count) / 1'000'000.0;
    }
    
    double total_elapsed_ms() const {
        return static_cast<double>(total_elapsed_ns.load(std::memory_order_relaxed)) / 1'000'000.0;
    }
    
    uint64_t min_elapsed_ns_val() const {
        const uint64_t val = min_elapsed_ns.load(std::memory_order_relaxed);
        return (val == std::numeric_limits<uint64_t>::max()) ? 0 : val;
    }
    
    uint64_t max_elapsed_ns_val() const {
        return max_elapsed_ns.load(std::memory_order_relaxed);
    }
    
    uint64_t call_count_val() const {
        return call_count.load(std::memory_order_relaxed);
    }
};

struct StrategyMetrics {
    std::string strategy_name = "None";
    int level = 0;
    std::atomic<uint64_t> use_count{0};
    std::atomic<uint64_t> hit_count{0};
    std::atomic<uint64_t> placements{0};
    std::atomic<uint64_t> total_elapsed_ns{0};
    
    void record_use(uint64_t elapsed_ns) {
        use_count.fetch_add(1, std::memory_order_relaxed);
        total_elapsed_ns.fetch_add(elapsed_ns, std::memory_order_relaxed);
    }
    
    void record_hit(uint64_t placements_count) {
        hit_count.fetch_add(1, std::memory_order_relaxed);
        placements.fetch_add(placements_count, std::memory_order_relaxed);
    }
    
    double avg_elapsed_ms() const {
        const uint64_t count = use_count.load(std::memory_order_relaxed);
        if (count == 0) return 0.0;
        return static_cast<double>(total_elapsed_ns.load(std::memory_order_relaxed)) / 
               static_cast<double>(count) / 1'000'000.0;
    }
};

struct AttemptMetrics {
    std::atomic<uint64_t> total_attempts{0};
    std::atomic<uint64_t> successful_attempts{0};
    std::atomic<uint64_t> total_time_ns{0};
    std::atomic<uint64_t> dead_ends{0};
    std::atomic<uint64_t> max_search_depth{0};
    std::atomic<uint64_t> backtrack_count{0};
    
    void record_attempt(uint64_t elapsed_ns, bool success) {
        total_attempts.fetch_add(1, std::memory_order_relaxed);
        total_time_ns.fetch_add(elapsed_ns, std::memory_order_relaxed);
        if (success) {
            successful_attempts.fetch_add(1, std::memory_order_relaxed);
        }
    }
    
    void record_dead_end() {
        dead_ends.fetch_add(1, std::memory_order_relaxed);
    }
    
    void record_search_depth(uint64_t depth) {
        uint64_t current_max = max_search_depth.load(std::memory_order_relaxed);
        while (depth > current_max) {
            if (max_search_depth.compare_exchange_weak(current_max, depth,
                std::memory_order_relaxed, std::memory_order_relaxed)) {
                break;
            }
        }
    }
    
    void record_backtrack() {
        backtrack_count.fetch_add(1, std::memory_order_relaxed);
    }
    
    double avg_attempt_time_ms() const {
        const uint64_t count = total_attempts.load(std::memory_order_relaxed);
        if (count == 0) return 0.0;
        return static_cast<double>(total_time_ns.load(std::memory_order_relaxed)) / 
               static_cast<double>(count) / 1'000'000.0;
    }
    
    double success_rate_pct() const {
        const uint64_t total = total_attempts.load(std::memory_order_relaxed);
        if (total == 0) return 0.0;
        return 100.0 * static_cast<double>(successful_attempts.load(std::memory_order_relaxed)) / 
               static_cast<double>(total);
    }
    
    uint64_t total_attempts_val() const {
        return total_attempts.load(std::memory_order_relaxed);
    }
    
    uint64_t dead_ends_val() const {
        return dead_ends.load(std::memory_order_relaxed);
    }
    
    uint64_t max_depth_val() const {
        return max_search_depth.load(std::memory_order_relaxed);
    }
    
    uint64_t backtrack_count_val() const {
        return backtrack_count.load(std::memory_order_relaxed);
    }
};

// ============================================================================
// MIKROPROFILING - QPC (QueryPerformanceCounter) via std::chrono::steady_clock
// ============================================================================
// Profiling per etap:
//   - SolvedKernel: generowanie pełnej planszy
//   - DigKernel: usuwanie wskazówek
//   - QuickPrefilter: szybka walidacja wstępna
//   - LogicCertify: certyfikacja logiczna
//   - UniquenessCertify: unikalność (DLX)
//
// Profiling per strategia:
//   - NakedSingle, HiddenSingle (poziom 1)
//   - PointingPairs, BoxLineReduction (poziom 2)
//   - ... (poziomy 3-8)
// ============================================================================

class MicroProfiler {
public:
    MicroProfiler() {
        // Atomic variables are already zero-initialized
        // No need to assign StageMetrics{} which would fail due to atomics
    }

    void record_stage(ProfilerStage stage, uint64_t elapsed_ns) {
        if (static_cast<int>(stage) < static_cast<int>(ProfilerStage::TotalCount)) {
            stage_metrics_[static_cast<size_t>(stage)].record(elapsed_ns);
        }
    }

    StageMetrics& get_stage_metrics(ProfilerStage stage) {
        return stage_metrics_[static_cast<size_t>(stage)];
    }

    const StageMetrics& get_stage_metrics(ProfilerStage stage) const {
        return stage_metrics_[static_cast<size_t>(stage)];
    }

    AttemptMetrics& get_attempt_metrics() { return attempt_metrics_; }
    const AttemptMetrics& get_attempt_metrics() const { return attempt_metrics_; }

    void record_strategy_use(const std::string& name, int level, uint64_t elapsed_ns) {
        std::lock_guard<std::mutex> lock(strategy_mu_);
        for (const auto& sm : strategy_metrics_) {
            if (sm->strategy_name == name && sm->level == level) {
                sm->record_use(elapsed_ns);
                return;
            }
        }
        // Nowa strategia - używamy unique_ptr
        auto sm = std::make_unique<StrategyMetrics>();
        sm->strategy_name = name;
        sm->level = level;
        sm->record_use(elapsed_ns);
        strategy_metrics_.push_back(std::move(sm));
    }

    void record_strategy_hit(const std::string& name, int level, uint64_t placements) {
        std::lock_guard<std::mutex> lock(strategy_mu_);
        for (const auto& sm : strategy_metrics_) {
            if (sm->strategy_name == name && sm->level == level) {
                sm->record_hit(placements);
                return;
            }
        }
    }

    std::vector<std::unique_ptr<StrategyMetrics>> get_strategy_metrics() const {
        std::lock_guard<std::mutex> lock(strategy_mu_);
        // Return copies of the metrics (without atomics issue)
        std::vector<std::unique_ptr<StrategyMetrics>> result;
        for (const auto& sm : strategy_metrics_) {
            auto copy = std::make_unique<StrategyMetrics>();
            copy->strategy_name = sm->strategy_name;
            copy->level = sm->level;
            copy->use_count.store(sm->use_count.load(std::memory_order_relaxed), std::memory_order_relaxed);
            copy->hit_count.store(sm->hit_count.load(std::memory_order_relaxed), std::memory_order_relaxed);
            copy->placements.store(sm->placements.load(std::memory_order_relaxed), std::memory_order_relaxed);
            copy->total_elapsed_ns.store(sm->total_elapsed_ns.load(std::memory_order_relaxed), std::memory_order_relaxed);
            result.push_back(std::move(copy));
        }
        return result;
    }

    void reset() {
        // Reset stage metrics using atomic store
        for (int i = 0; i < static_cast<int>(ProfilerStage::TotalCount); ++i) {
            stage_metrics_[i].call_count.store(0, std::memory_order_relaxed);
            stage_metrics_[i].total_elapsed_ns.store(0, std::memory_order_relaxed);
            stage_metrics_[i].min_elapsed_ns.store(std::numeric_limits<uint64_t>::max(), std::memory_order_relaxed);
            stage_metrics_[i].max_elapsed_ns.store(0, std::memory_order_relaxed);
        }
        // Reset attempt metrics
        attempt_metrics_.total_attempts.store(0, std::memory_order_relaxed);
        attempt_metrics_.successful_attempts.store(0, std::memory_order_relaxed);
        attempt_metrics_.total_time_ns.store(0, std::memory_order_relaxed);
        attempt_metrics_.dead_ends.store(0, std::memory_order_relaxed);
        attempt_metrics_.max_search_depth.store(0, std::memory_order_relaxed);
        attempt_metrics_.backtrack_count.store(0, std::memory_order_relaxed);
        // Clear strategy metrics
        std::lock_guard<std::mutex> lock(strategy_mu_);
        strategy_metrics_.clear();  // unique_ptr automatically deletes
    }

    std::string to_summary_string() const {
        std::ostringstream oss;
        oss << "=== Mikroprofiling Summary ===\n";
        oss << "Etapy:\n";
        for (int i = 0; i < static_cast<int>(ProfilerStage::TotalCount); ++i) {
            const auto stage = static_cast<ProfilerStage>(i);
            const auto& m = stage_metrics_[i];
            oss << "  " << profiler_stage_name(stage) << ": "
                << "calls=" << m.call_count_val()
                << ", avg_ms=" << std::fixed << std::setprecision(4) << m.avg_elapsed_ms()
                << ", total_ms=" << std::fixed << std::setprecision(2) << m.total_elapsed_ms()
                << ", min_ns=" << m.min_elapsed_ns_val()
                << ", max_ns=" << m.max_elapsed_ns_val() << "\n";
        }
        oss << "Proby:\n";
        oss << "  total_attempts=" << attempt_metrics_.total_attempts_val()
            << ", success_rate=" << std::fixed << std::setprecision(2) << attempt_metrics_.success_rate_pct() << "%"
            << ", avg_attempt_ms=" << std::fixed << std::setprecision(4) << attempt_metrics_.avg_attempt_time_ms()
            << ", dead_ends=" << attempt_metrics_.dead_ends_val()
            << ", max_depth=" << attempt_metrics_.max_depth_val()
            << ", backtracks=" << attempt_metrics_.backtrack_count_val() << "\n";
        return oss.str();
    }

private:
    std::array<StageMetrics, static_cast<size_t>(ProfilerStage::TotalCount)> stage_metrics_{};
    AttemptMetrics attempt_metrics_{};
    mutable std::mutex strategy_mu_;
    std::vector<std::unique_ptr<StrategyMetrics>> strategy_metrics_;
};

// Thread-local timer helper for RAII-based profiling
class ScopedStageTimer {
public:
    ScopedStageTimer(MicroProfiler& profiler, ProfilerStage stage)
        : profiler_(profiler), stage_(stage) {
        start_ = std::chrono::steady_clock::now();
    }
    
    ~ScopedStageTimer() {
        const auto end = std::chrono::steady_clock::now();
        const uint64_t elapsed_ns = static_cast<uint64_t>(
            std::chrono::duration_cast<std::chrono::nanoseconds>(end - start_).count());
        profiler_.record_stage(stage_, elapsed_ns);
    }
    
private:
    MicroProfiler& profiler_;
    ProfilerStage stage_;
    std::chrono::steady_clock::time_point start_;
};

// ============================================================================
// KONIEC MIKROPROFILING
// ============================================================================

} // namespace sudoku_hpc



==============================================================================
PLIK: Sources\sudoku_generate_pipeline.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

// Active pipeline entrypoint (V2).
#include "generator_pipeline_v2_impl.h"



==============================================================================
PLIK: Sources\sudoku_logic_engine.h
==============================================================================

﻿//Author copyright Marcin Matysek (Rewertyn)

#pragma once

// Logic engine entrypoint composed from ordered implementation parts.

#include "config.h"
#include "kernels.h"
#include "logic/p6/exact_pattern_scratchpad.h"
#include "logic/p8/level8_pattern_scratchpad.h"
#include "logic_engine_part01.h"
#include "logic_engine_part02.h"
#include "logic_engine_part03.h"
#include "logic_engine_part04.h"
#include "logic_engine_part05.h"



==============================================================================
PLIK: Sources\sudoku_logic_engine_p1_p5.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>

#include "logic/p1_p5/level1_module.h"
#include "logic/p1_p5/level2_module.h"
#include "logic/p1_p5/level3_module.h"
#include "logic/p1_p5/level4_module.h"
#include "logic/p1_p5/level5_module.h"

namespace sudoku_hpc {

struct GenericLogicCertifyP1P5Modular {
    GenericLogicCertifyResult certify(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        return logic_p1_p5::level5::certify(puzzle, topo, budget, capture_solution_grid);
    }

    GenericLogicCertifyResult certify_up_to_level(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        int max_level,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        switch (std::clamp(max_level, 1, 5)) {
            case 1: return logic_p1_p5::level1::certify(puzzle, topo, budget, capture_solution_grid);
            case 2: return logic_p1_p5::level2::certify(puzzle, topo, budget, capture_solution_grid);
            case 3: return logic_p1_p5::level3::certify(puzzle, topo, budget, capture_solution_grid);
            case 4: return logic_p1_p5::level4::certify(puzzle, topo, budget, capture_solution_grid);
            default: return logic_p1_p5::level5::certify(puzzle, topo, budget, capture_solution_grid);
        }
    }
};

}  // namespace sudoku_hpc



==============================================================================
PLIK: Sources\TESTS_cpp\main_test.cpp
==============================================================================

// ============================================================================
// SUDOKU HPC - TEST REGRESSION RUNNER (CLI)
// Plik: main_test.cpp
// ============================================================================

#include <iostream>
#include <cstdint>
#include <string>

#include "test_regression.cpp"

namespace {

bool has_help_arg(int argc, char** argv) {
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            return true;
        }
    }
    return false;
}

void print_help(std::ostream& out) {
    out << "Usage:\n";
    out << "  sudoku_test.exe [options]\n\n";
    out << "Options:\n";
    out << "  --help, -h, /?                Show this help\n";
    out << "  --timeout-min <int>           Global timeout in minutes\n";
    out << "                                0 = no limit, -1 = env/default fallback\n";
    out << "\nEnvironment fallback:\n";
    out << "  SUDOKU_REGRESSION_TIMEOUT_S   Timeout in seconds (when --timeout-min is not set)\n";
}

}  // namespace

int main(int argc, char** argv) {
    if (has_help_arg(argc, argv)) {
        print_help(std::cout);
        return 0;
    }

    std::cout << "============================================================================\n";
    std::cout << "SUDOKU HPC - REGRESSION TEST SUITE\n";
    std::cout << "============================================================================\n\n";

    int timeout_minutes = -1;  // -1: fallback env; 0: no limit; >0: global X min
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if ((arg == "--timeout-min" || arg == "--timeout_min") && i + 1 < argc) {
            try {
                timeout_minutes = std::stoi(std::string(argv[++i]));
            } catch (...) {
                timeout_minutes = -1;
            }
        }
    }

    std::cout << "Seed corpus: " << sudoku_testy::get_seed_corpus_size() << " entries\n";
    std::cout << "Running tests...\n";
    std::cout << "Global timeout [min]: "
              << (timeout_minutes >= 0 ? std::to_string(timeout_minutes) : std::string("env/default"))
              << "\n\n";

    sudoku_testy::run_all_regression_tests("regression_report.txt", timeout_minutes);

    std::cout << "\nDone. Check regression_report.txt\n";
    return 0;
}




==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level1.cpp
==============================================================================

// ============================================================================
// SUDOKU HPC - TEST REGRESYJNY POZIOMU 1 (ASYMETRYCZNE GEOMETRIE)
// Plik: main_test_level1.cpp
// ============================================================================

#include <iostream>
#include <cstdint>
#include <string>

#include "test_level1_asymmetric.cpp"

namespace {

bool has_help_arg(int argc, char** argv) {
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            return true;
        }
    }
    return false;
}

void print_help(std::ostream& out) {
    out << "Usage:\n";
    out << "  sudoku_test_level1.exe [options]\n\n";
    out << "Options:\n";
    out << "  --help, -h, /?                Show this help\n";
    out << "  --timeout-min <int>           Global timeout in minutes\n";
    out << "                                0 = no limit, -1 = env fallback, default = 5\n";
    out << "  --case-timeout-s <int>        Hard timeout per single case in seconds\n";
    out << "                                0 = off, -1 = env/default fallback\n";
    out << "\nEnvironment fallback:\n";
    out << "  SUDOKU_LEVEL1_TIMEOUT_S       Timeout in seconds (when --timeout-min is not set)\n";
    out << "  SUDOKU_LEVEL1_CASE_TIMEOUT_S  Per-case hard timeout in seconds (default 30)\n";
}

}  // namespace

int main(int argc, char** argv) {
    if (has_help_arg(argc, argv)) {
        print_help(std::cout);
        return 0;
    }

    std::cout << "============================================================================\n";
    std::cout << "SUDOKU HPC - LEVEL 1 ASYMMETRIC REGRESSION TEST SUITE\n";
    std::cout << "============================================================================\n\n";

    int timeout_minutes = 5;  // default: 5 min; -1: env fallback; 0: no limit; >0: global X min
    int case_timeout_s = -1;  // -1: env fallback/default; 0: off; >0: hard timeout per case
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if ((arg == "--timeout-min" || arg == "--timeout_min") && i + 1 < argc) {
            try {
                timeout_minutes = std::stoi(std::string(argv[++i]));
            } catch (...) {
                timeout_minutes = -1;
            }
        } else if ((arg == "--case-timeout-s" || arg == "--case_timeout_s") && i + 1 < argc) {
            try {
                case_timeout_s = std::stoi(std::string(argv[++i]));
            } catch (...) {
                case_timeout_s = -1;
            }
        }
    }

    std::cout << "Testing asymmetric geometries (e.g., 12x12 4x3, 10x10 2x5)...\n";
    std::cout << "Running Level 1 strategy tests...\n";
    std::cout << "Global timeout [min]: "
              << (timeout_minutes >= 0 ? std::to_string(timeout_minutes) : std::string("env fallback"))
              << "\n\n";

    sudoku_testy::run_level1_asymmetric_tests("level1_asymmetric_report.txt", timeout_minutes, case_timeout_s);

    std::cout << "\nDone. Check level1_asymmetric_report.txt\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level1_9x9.cpp
==============================================================================

// ============================================================================
// SUDOKU HPC - TEST STRATEGII POZIOMU 1 DLA 9x9 (3x3)
// ============================================================================

#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>
#include <chrono>
#include <cstdlib>
#include <functional>
#include <string>

#include "test_level1_asymmetric.cpp"

namespace {

bool has_help_arg(int argc, char** argv) {
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            return true;
        }
    }
    return false;
}

void print_help(std::ostream& out) {
    out << "Usage:\n";
    out << "  sudoku_test_level1_9x9.exe [options]\n\n";
    out << "Options:\n";
    out << "  --help, -h, /?                Show this help\n";
    out << "  --timeout-min <int>           Global timeout in minutes\n";
    out << "                                0 = no limit, -1 = env/default fallback\n";
    out << "\nEnvironment fallback:\n";
    out << "  SUDOKU_LEVEL1_9X9_TIMEOUT_S   Timeout in seconds (when --timeout-min is not set)\n";
}

}  // namespace

int main(int argc, char** argv) {
    if (has_help_arg(argc, argv)) {
        print_help(std::cout);
        return 0;
    }

    using sudoku_testy::TestResult;

    std::cout << "============================================================================\n";
    std::cout << "SUDOKU HPC - LEVEL 1 9x9 (3x3) TEST SUITE\n";
    std::cout << "============================================================================\n\n";

    const int box_rows = 3;
    const int box_cols = 3;
    const uint64_t seed = 9001;
    int timeout_minutes = -1;  // -1: fallback env; 0: no limit; >0: global X min
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if ((arg == "--timeout-min" || arg == "--timeout_min") && i + 1 < argc) {
            try {
                timeout_minutes = std::stoi(std::string(argv[++i]));
            } catch (...) {
                timeout_minutes = -1;
            }
        }
    }

    const auto suite_start = std::chrono::steady_clock::now();
    int timeout_s = 0;
    if (timeout_minutes >= 0) {
        timeout_s = (timeout_minutes == 0) ? 0 : (std::max(1, timeout_minutes) * 60);
    } else if (const char* raw = std::getenv("SUDOKU_LEVEL1_9X9_TIMEOUT_S")) {
        try {
            timeout_s = std::max(0, std::stoi(std::string(raw)));
        } catch (...) {
            timeout_s = 0;
        }
    }
    const bool timeout_enabled = timeout_s > 0;
    const auto deadline = suite_start + std::chrono::seconds(timeout_enabled ? timeout_s : 0);
    auto timeout_reached = [&]() -> bool {
        return timeout_enabled && std::chrono::steady_clock::now() >= deadline;
    };

    std::vector<TestResult> results;
    results.reserve(5);
    int planned_tests = 5;
    bool timed_out = false;

    std::ofstream report("level1_9x9_report.txt");
    if (report) {
        report << std::unitbuf;
        report << "LEVEL 1 9x9 (3x3) TEST REPORT\n";
        report << "==============================\n\n";
        report << "Timeout limit: " << (timeout_enabled ? (std::to_string(timeout_s) + "s") : std::string("none")) << "\n\n";

        auto run_case = [&](const std::string& name, const std::function<TestResult()>& fn) {
            if (timeout_reached()) {
                timed_out = true;
                report << "[TIMEOUT] " << name << "\n";
                return;
            }
            TestResult r;
            try {
                r = fn();
            } catch (const std::exception& ex) {
                r.passed = false;
                r.name = name;
                r.message = std::string("Exception: ") + ex.what();
            } catch (...) {
                r.passed = false;
                r.name = name;
                r.message = "Unknown exception";
            }
            results.push_back(r);
            report << (r.passed ? "[PASS] " : "[FAIL] ") << r.name
                   << " - " << r.message
                   << " (" << std::fixed << std::setprecision(2) << r.elapsed_ms << "ms)\n";
        };

        run_case("GeometryCatalogRecognition", [&]() { return sudoku_testy::test_geometry_recognition_catalog(); });
        run_case("AsymmetricGen 9x9", [&]() { return sudoku_testy::test_asymmetric_generation<9>(box_rows, box_cols, seed); });
        run_case("NakedSingle 9x9", [&]() { return sudoku_testy::test_naked_single_asymmetric<9>(box_rows, box_cols, seed); });
        run_case("HiddenSingle 9x9", [&]() { return sudoku_testy::test_hidden_single_asymmetric<9>(box_rows, box_cols, seed); });
        run_case("Level1Full 9x9", [&]() { return sudoku_testy::test_level1_full_solve<9>(box_rows, box_cols, seed); });

        int passed = 0;
        for (const auto& r : results) {
            if (r.passed) {
                ++passed;
            }
        }
        report << "\nSUMMARY: " << passed << "/" << results.size() << " passed\n";
        report << "Completed/planned: " << results.size() << "/" << planned_tests << "\n";
        report << "Timeout reached: " << (timed_out ? "yes" : "no") << "\n";
        if (timed_out) {
            report << "TEST STOPPED BY TIME LIMIT\n";
        }
    }

    int passed = 0;
    for (const auto& r : results) {
        if (r.passed) {
            ++passed;
        }
    }

    std::cout << "Total: " << results.size()
              << ", Passed: " << passed
              << ", Failed: " << (static_cast<int>(results.size()) - passed) << "\n";
    std::cout << "Report: level1_9x9_report.txt\n";
    if (timed_out) {
        return 2;
    }
    return (passed == static_cast<int>(results.size())) ? 0 : 1;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level1_generate_catalog_5min.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - LEVEL 1 GENERATION CATALOG (4x4..36x36, sym+asym)
// Cel: wygenerowac po 2 plansze dla geometrii (domyslnie z globalnym limitem 5 minut).
// Kolejnosc: od najmniejszych sudoku do najwiekszych.
// Timeout: konfigurowalny globalny/per-geometria z CLI.
// Wyniki: TESTS_cpp/testowe_plansze + checklista txt z checkboxami.
// ============================================================================

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {

using namespace sudoku_hpc;

struct CaseStatus {
    geometria::GeometrySpec geo{};
    std::string class_name;
    std::string output_file;
    std::string file_prefix;
    bool attempted = false;
    bool success = false;
    bool case_timeout = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    double elapsed_s = 0.0;
    std::string note;
};

constexpr int kDefaultGlobalTimeoutMinutes = 5;

std::string build_output_file_name(const geometria::GeometrySpec& g) {
    std::ostringstream oss;
    oss << "__tmp_batch_" << g.n << "x" << g.n
        << "_" << g.box_rows << "x" << g.box_cols
        << "_" << (g.is_symmetric ? "sym" : "asym") << ".txt";
    return oss.str();
}

std::string build_case_file_prefix(const geometria::GeometrySpec& g) {
    std::ostringstream oss;
    oss << "sudoku_" << g.n << "x" << g.n
        << "_" << g.box_rows << "x" << g.box_cols
        << "_" << (g.is_symmetric ? "sym" : "asym") << "_lvl1";
    return oss.str();
}

bool is_generic_individual_file_name(const std::string& name) {
    // Matches "sudoku_000001.txt"
    if (name.size() != 17) {
        return false;
    }
    if (name.rfind("sudoku_", 0) != 0) {
        return false;
    }
    if (name.substr(13) != ".txt") {
        return false;
    }
    for (size_t i = 7; i < 13; ++i) {
        if (std::isdigit(static_cast<unsigned char>(name[i])) == 0) {
            return false;
        }
    }
    return true;
}

int generic_file_index(const std::string& name) {
    if (!is_generic_individual_file_name(name)) {
        return -1;
    }
    try {
        return std::stoi(name.substr(7, 6));
    } catch (...) {
        return -1;
    }
}

} // namespace

int main(int argc, char** argv) {
    int timeout_minutes = kDefaultGlobalTimeoutMinutes;  // 0 => no limit
    int case_timeout_s = 0;  // 0 => no limit
    int only_n = 0;  // 0 => all sizes
    double attempt_time_budget_s = 35.0;  // domyslny budzet czasu na probe

    auto print_help = []() {
        std::cout << "Usage:\n";
        std::cout << "  sudoku_test_level1_generate_catalog_5min.exe [options]\n\n";
        std::cout << "Options:\n";
        std::cout << "  --help, -h, /?                Show this help\n";
        std::cout << "  --timeout-min <int>           Global timeout in minutes (0 = no limit, default = 5)\n";
        std::cout << "  --case-timeout-s <int>        Per-geometry timeout in seconds (0 = no limit)\n";
        std::cout << "  --attempt-time-budget-s <num> Per-attempt time budget in seconds (default = 35)\n";
        std::cout << "  --only-n <int>                Run only geometries with this size NxN\n\n";
        std::cout << "Behavior:\n";
        std::cout << "  - Generates up to 2 level-1 boards per geometry (4x4..36x36)\n";
        std::cout << "  - Ascending geometry order (small to large)\n";
        std::cout << "  - Writes checklist/progress and prints live progress to console\n";
        std::cout << "  - Saves individual puzzles directly in TESTS_cpp/testowe_plansze (no subfolders)\n";
        std::cout << "  - No batch file with all puzzles is kept\n";
    };

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if ((arg == "--timeout-min" || arg == "--timeout_min") && i + 1 < argc) {
            try {
                timeout_minutes = std::max(0, std::stoi(std::string(argv[++i])));
            } catch (...) {
                timeout_minutes = kDefaultGlobalTimeoutMinutes;
            }
        } else if ((arg == "--case-timeout-s" || arg == "--case_timeout_s") && i + 1 < argc) {
            try {
                case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
            } catch (...) {
                case_timeout_s = 0;
            }
        } else if ((arg == "--attempt-time-budget-s" || arg == "--attempt_time_budget_s") && i + 1 < argc) {
            try {
                attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
            } catch (...) {
                attempt_time_budget_s = 35.0;
            }
        } else if ((arg == "--only-n" || arg == "--only_n") && i + 1 < argc) {
            try {
                only_n = std::max(0, std::stoi(std::string(argv[++i])));
            } catch (...) {
                only_n = 0;
            }
        }
    }

    const std::filesystem::path out_dir = std::filesystem::path("TESTS_cpp") / "testowe_plansze";
    const std::filesystem::path out_dir_abs = std::filesystem::absolute(out_dir);
    std::error_code ec;
    std::filesystem::create_directories(out_dir, ec);
    if (ec) {
        std::cerr << "Cannot create output dir: " << out_dir.string() << " err=" << ec.message() << "\n";
        return 2;
    }

    const std::filesystem::path checklist_path = out_dir / "checklista_wygenerowanych_plansz_5min.txt";
    const std::filesystem::path progress_path = out_dir / "checklista_wygenerowanych_plansz_5min_progress.txt";
    std::ofstream checklist(checklist_path, std::ios::out | std::ios::trunc);
    std::ofstream progress(progress_path, std::ios::out | std::ios::trunc);
    if (!checklist) {
        std::cerr << "Cannot open checklist file: " << checklist_path.string() << "\n";
        return 3;
    }
    checklist << std::unitbuf;
    if (progress) {
        progress << std::unitbuf;
    }

    std::vector<CaseStatus> cases;
    for (const auto& g : geometria::all_geometries()) {
        if (g.n < 4 || g.n > 36) {
            continue;
        }
        if (only_n > 0 && g.n != only_n) {
            continue;
        }
        CaseStatus s;
        s.geo = g;
        s.class_name = geometria::geometry_class_name(geometria::classify_geometry(g.box_rows, g.box_cols));
        s.output_file = build_output_file_name(g);
        s.file_prefix = build_case_file_prefix(g);
        cases.push_back(std::move(s));
    }

    std::sort(cases.begin(), cases.end(), [](const CaseStatus& a, const CaseStatus& b) {
        if (a.geo.n != b.geo.n) return a.geo.n < b.geo.n;
        if (a.geo.box_rows != b.geo.box_rows) return a.geo.box_rows < b.geo.box_rows;
        return a.geo.box_cols < b.geo.box_cols;
    });

    if (cases.empty()) {
        std::cout << "No geometries selected (only_n=" << only_n << ").\n";
        if (progress) {
            progress << "FINISH completed=0 success=0 timeout=0 elapsed_total_s=0.00\n";
        }
        checklist << "No geometries selected.\n";
        return 0;
    }

    const int thread_count = std::max(1u, std::thread::hardware_concurrency());
    const int total_timeout_s = timeout_minutes == 0 ? 0 : timeout_minutes * 60;
    const bool global_timeout_enabled = total_timeout_s > 0;
    const bool case_timeout_enabled = case_timeout_s > 0;
    constexpr uint64_t kTargetPerGeometry = 2ULL;
    constexpr int kDifficultyLevel = 1;
    constexpr RequiredStrategy kRequiredStrategy = RequiredStrategy::None;
    constexpr int kReseedIntervalS = 1;
    constexpr uint64_t kAttemptNodeBudget = 0ULL;
    constexpr bool kWriteIndividualFiles = true;
    auto fmt_double_1 = [](double v) {
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(1) << v;
        return oss.str();
    };
    const std::string global_params_line =
        "timeout_min=" + std::to_string(timeout_minutes) +
        ", global_timeout_s=" + (global_timeout_enabled ? std::to_string(total_timeout_s) : std::string("none")) +
        ", case_timeout_s=" + (case_timeout_enabled ? std::to_string(case_timeout_s) : std::string("none")) +
        ", attempt_time_budget_s=" + fmt_double_1(attempt_time_budget_s) +
        ", only_n=" + (only_n > 0 ? std::to_string(only_n) : std::string("all")) +
        ", threads=" + std::to_string(thread_count) +
        ", target_per_geometry=" + std::to_string(kTargetPerGeometry) +
        ", difficulty=" + std::to_string(kDifficultyLevel) +
        ", required_strategy=" + to_string(kRequiredStrategy) +
        ", reseed_interval_s=" + std::to_string(kReseedIntervalS) +
        ", attempt_node_budget=" + std::to_string(kAttemptNodeBudget) +
        ", write_individual_files=" + std::string(kWriteIndividualFiles ? "1" : "0") +
        ", output_dir=" + out_dir.string() +
        ", output_dir_abs=" + out_dir_abs.string();
    const auto start = std::chrono::steady_clock::now();
    const auto deadline = global_timeout_enabled
        ? (start + std::chrono::seconds(total_timeout_s))
        : std::chrono::steady_clock::time_point::max();
    std::atomic<bool> global_cancel{false};
    std::atomic<bool> global_pause{false};
    std::jthread timeout_thread([&](std::stop_token st) {
        while (!st.stop_requested()) {
            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_cancel.store(true, std::memory_order_relaxed);
                break;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });
    std::cout << "PARAMS_GLOBAL: " << global_params_line << "\n";

    checklist << "LEVEL 1 GENERATION CHECKLIST (4x4..36x36, sym+asym)\n";
    checklist << "=====================================================\n";
    checklist << "PARAMS_GLOBAL: " << global_params_line << "\n";
    checklist << "Global timeout: " << (global_timeout_enabled ? (std::to_string(total_timeout_s) + "s") : std::string("none")) << "\n";
    checklist << "Per-case timeout: " << (case_timeout_enabled ? (std::to_string(case_timeout_s) + "s") : std::string("none")) << "\n";
    checklist << "Attempt time budget per try: " << std::fixed << std::setprecision(1) << attempt_time_budget_s << "s\n";
    checklist << "Only size N: " << (only_n > 0 ? std::to_string(only_n) : std::string("all")) << "\n";
    checklist << "Threads: " << thread_count << "\n";
    checklist << "Target per geometry: 2 boards\n";
    checklist << "Output dir: " << out_dir.string() << "\n";
    checklist << "Output dir abs: " << out_dir_abs.string() << "\n";
    checklist << "Progress file: " << progress_path.string() << "\n";
    checklist << "Cases: " << cases.size() << "\n\n";

    if (progress) {
        progress << "PARAMS_GLOBAL " << global_params_line << "\n";
        progress << "START global_timeout_s=" << std::to_string(total_timeout_s)
                 << " case_timeout_s=" << (case_timeout_enabled ? std::to_string(case_timeout_s) : std::string("none"))
                 << " attempt_budget_s=" << std::fixed << std::setprecision(1) << attempt_time_budget_s
                 << " threads=" << thread_count
                 << " cases=" << cases.size() << "\n";
    }

    int completed = 0;
    int success_count = 0;
    bool global_timeout_reached = false;
    uint64_t seed_state =
        static_cast<uint64_t>(std::chrono::high_resolution_clock::now().time_since_epoch().count());

    for (size_t i = 0; i < cases.size(); ++i) {
        CaseStatus& cs = cases[i];
        const auto now = std::chrono::steady_clock::now();
        if (global_cancel.load(std::memory_order_relaxed) || now >= deadline) {
            global_timeout_reached = true;
            break;
        }

        if (progress) {
            progress << "START case=" << (i + 1) << "/" << cases.size()
                     << " n=" << cs.geo.n
                     << " box=" << cs.geo.box_rows << "x" << cs.geo.box_cols
                     << " class=" << cs.class_name
                     << " case_limit_s=" << (case_timeout_enabled ? std::to_string(case_timeout_s) : std::string("none"))
                     << "\n";
        }
        std::cout << "START [" << (i + 1) << "/" << cases.size() << "] "
                  << cs.geo.n << "x" << cs.geo.n
                  << " (" << cs.geo.box_rows << "x" << cs.geo.box_cols << ", " << cs.class_name << ")"
                  << " case_timeout_s=" << (case_timeout_enabled ? std::to_string(case_timeout_s) : std::string("none"))
                  << "\n";
        // Cleanup leftovers from interrupted run (generic per-puzzle names).
        for (const auto& entry : std::filesystem::directory_iterator(out_dir)) {
            if (!entry.is_regular_file()) {
                continue;
            }
            const std::string fname = entry.path().filename().string();
            if (!is_generic_individual_file_name(fname)) {
                continue;
            }
            std::error_code rm_ec;
            std::filesystem::remove(entry.path(), rm_ec);
        }

        GenerateRunConfig cfg;
        cfg.box_rows = cs.geo.box_rows;
        cfg.box_cols = cs.geo.box_cols;
        cfg.target_puzzles = kTargetPerGeometry;
        cfg.difficulty_level_required = kDifficultyLevel;
        cfg.required_strategy = kRequiredStrategy;
        const ClueRange auto_clues =
            resolve_auto_clue_range(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy);
        cfg.min_clues = auto_clues.min_clues;
        cfg.max_clues = auto_clues.max_clues;
        cfg.threads = thread_count;
        const uint64_t geo_mix =
            (static_cast<uint64_t>(cs.geo.n) << 32) ^
            (static_cast<uint64_t>(cs.geo.box_rows) << 16) ^
            static_cast<uint64_t>(cs.geo.box_cols);
        seed_state ^= geo_mix;
        cfg.seed = bounded_positive_seed_i64(splitmix64(seed_state));
        cfg.output_folder = out_dir.string();
        cfg.output_file = cs.output_file;
        cfg.write_individual_files = true;
        cfg.pause_on_exit_windows = false;
        cfg.max_total_time_s = case_timeout_enabled ? static_cast<uint64_t>(case_timeout_s) : 0ULL;
        cfg.max_attempts_s = 0ULL;
        cfg.reseed_interval_s = kReseedIntervalS;
        cfg.attempt_time_budget_s = attempt_time_budget_s;
        cfg.attempt_node_budget = kAttemptNodeBudget;
        const std::string case_params_line =
            "case=" + std::to_string(i + 1) + "/" + std::to_string(cases.size()) +
            ", n=" + std::to_string(cs.geo.n) +
            ", box=" + std::to_string(cs.geo.box_rows) + "x" + std::to_string(cs.geo.box_cols) +
            ", class=" + cs.class_name +
            ", seed=" + std::to_string(cfg.seed) +
            ", target=" + std::to_string(cfg.target_puzzles) +
            ", difficulty=" + std::to_string(cfg.difficulty_level_required) +
            ", required_strategy=" + to_string(cfg.required_strategy) +
            ", clues=" + std::to_string(cfg.min_clues) + "-" + std::to_string(cfg.max_clues) +
            ", threads=" + std::to_string(cfg.threads) +
            ", max_total_time_s=" + std::to_string(cfg.max_total_time_s) +
            ", max_attempts_s=" + std::to_string(cfg.max_attempts_s) +
            ", reseed_interval_s=" + std::to_string(cfg.reseed_interval_s) +
            ", attempt_time_budget_s=" + fmt_double_1(cfg.attempt_time_budget_s) +
            ", attempt_node_budget=" + std::to_string(cfg.attempt_node_budget) +
            ", output_file=" + cfg.output_file +
            ", output_folder=" + cfg.output_folder;
        std::cout << "PARAMS_CASE: " << case_params_line << "\n";
        if (progress) {
            progress << "PARAMS_CASE " << case_params_line << "\n";
        }

        const auto case_start = std::chrono::steady_clock::now();
        GenerateRunResult run{};
        std::string run_error;
        try {
            run = run_generic_sudoku(cfg, nullptr, &global_cancel, &global_pause, nullptr, nullptr);
        } catch (const std::exception& ex) {
            run_error = std::string("exception: ") + ex.what();
        } catch (...) {
            run_error = "unknown exception";
        }
        const auto case_end = std::chrono::steady_clock::now();

        cs.attempted = true;
        cs.elapsed_s = std::chrono::duration<double>(case_end - case_start).count();
        if (!run_error.empty()) {
            cs.note = run_error;
            cs.success = false;
            cs.case_timeout = false;
            ++completed;
            if (progress) {
                progress << "DONE  case=" << (i + 1) << "/" << cases.size()
                         << " n=" << cs.geo.n
                         << " box=" << cs.geo.box_rows << "x" << cs.geo.box_cols
                         << " ok=0 err=\"" << run_error << "\"\n";
            }
            continue;
        }
        cs.accepted = run.accepted;
        cs.written = run.written;
        cs.attempts = run.attempts;
        cs.case_timeout =
            (run.timeout_global > 0 || run.timeout_per_attempt > 0 || global_cancel.load(std::memory_order_relaxed));
        cs.success = (run.written >= 2);

        // Remove batch file - keep only individual puzzle files.
        {
            std::error_code rm_batch_ec;
            std::filesystem::remove(out_dir / cs.output_file, rm_batch_ec);
        }

        // Rename generated generic files (sudoku_000001.txt) to geometry-specific names.
        for (const auto& entry : std::filesystem::directory_iterator(out_dir)) {
            if (!entry.is_regular_file()) {
                continue;
            }
            const std::string fname = entry.path().filename().string();
            const int idx_num = generic_file_index(fname);
            if (idx_num <= 0) {
                continue;
            }
            std::ostringstream renamed;
            renamed << cs.file_prefix << "_" << std::setw(6) << std::setfill('0') << idx_num << ".txt";
            const std::filesystem::path dst = out_dir / renamed.str();
            std::error_code mv_ec;
            if (std::filesystem::exists(dst)) {
                std::error_code rm_old_ec;
                std::filesystem::remove(dst, rm_old_ec);
            }
            std::filesystem::rename(entry.path(), dst, mv_ec);
            if (mv_ec) {
                // Best effort fallback: copy then remove source.
                std::error_code cp_ec;
                std::filesystem::copy_file(entry.path(), dst, std::filesystem::copy_options::overwrite_existing, cp_ec);
                if (!cp_ec) {
                    std::error_code rm_src_ec;
                    std::filesystem::remove(entry.path(), rm_src_ec);
                }
            }
        }

        std::ostringstream note;
        note << "written=" << run.written << "/2"
             << ", accepted=" << run.accepted
             << ", attempts=" << run.attempts
             << ", elapsed_s=" << std::fixed << std::setprecision(2) << cs.elapsed_s
             << ", case_limit_s=" << (case_timeout_enabled ? std::to_string(case_timeout_s) : std::string("none"))
             << ", attempt_budget_s=" << std::fixed << std::setprecision(1) << attempt_time_budget_s
             << ", seed=" << cfg.seed
             << ", timeout=" << (cs.case_timeout ? "1" : "0");
        cs.note = note.str();

        ++completed;
        if (cs.success) {
            ++success_count;
        }

        if (progress) {
            progress << "DONE  case=" << (i + 1) << "/" << cases.size()
                     << " n=" << cs.geo.n
                     << " box=" << cs.geo.box_rows << "x" << cs.geo.box_cols
                     << " ok=" << (cs.success ? "1" : "0")
                     << " " << cs.note << "\n";
        }
        std::cout << "DONE  [" << (i + 1) << "/" << cases.size() << "] "
                  << (cs.success ? "OK" : "FAIL")
                  << " " << cs.geo.n << "x" << cs.geo.n
                  << " (" << cs.geo.box_rows << "x" << cs.geo.box_cols << ") "
                  << cs.note
                  << ", files_prefix=" << cs.file_prefix << "\n";
    }

    const double elapsed_total_s =
        std::chrono::duration<double>(std::chrono::steady_clock::now() - start).count();

    checklist << "CHECKLIST:\n";
    for (size_t i = 0; i < cases.size(); ++i) {
        const CaseStatus& cs = cases[i];
        const std::string mark = (cs.attempted && cs.success) ? "[x]" : "[ ]";
        checklist << mark
                  << " sudoku " << cs.geo.n << "x" << cs.geo.n
                  << " (" << cs.geo.box_rows << "x" << cs.geo.box_cols
                  << ", " << cs.class_name << ")";
        if (!cs.attempted) {
            checklist << " -> not attempted (global timeout)";
        } else {
            checklist << " -> " << cs.note
                      << ", files_prefix=" << cs.file_prefix;
        }
        checklist << "\n";
    }

    checklist << "\nSUMMARY:\n";
    checklist << "completed_cases=" << completed << "/" << cases.size() << "\n";
    checklist << "success_cases_2of2=" << success_count << "\n";
    checklist << "global_timeout_reached=" << (global_timeout_reached ? "yes" : "no") << "\n";
    checklist << "elapsed_total_s=" << std::fixed << std::setprecision(2) << elapsed_total_s << "\n";
    if (global_timeout_reached) {
        checklist << "TEST STOPPED BY TIME LIMIT\n";
    }

    if (progress) {
        progress << "FINISH completed=" << completed
                 << " success=" << success_count
                 << " timeout=" << (global_timeout_reached ? "1" : "0")
                 << " elapsed_total_s=" << std::fixed << std::setprecision(2) << elapsed_total_s << "\n";
    }

    std::cout << "Checklist: " << checklist_path.string() << "\n";
    std::cout << "Progress: " << progress_path.string() << "\n";
    std::cout << "Output dir: " << out_dir.string() << "\n";
    std::cout << "Output dir abs: " << out_dir_abs.string() << "\n";
    std::cout << "Completed: " << completed << "/" << cases.size()
              << ", success(2/2): " << success_count << "\n";

    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level4_required.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TEST PRODUKCYJNY L4 REQUIRED STRATEGY
// Domyslnie: 9x9 (3x3) i 12x12 (3x4), po 2 plansze na strategie L4.
// Zatrzymanie globalne: timeout-min (domyslnie 2 min), z raportem czesciowym.
// ============================================================================

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {
using namespace sudoku_hpc;

struct L4CaseResult {
    int box_rows = 0;
    int box_cols = 0;
    RequiredStrategy strategy = RequiredStrategy::None;
    bool attempted = false;
    bool success = false;
    bool timed_out_case = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t reject_strategy = 0;
    double elapsed_s = 0.0;
};

std::string fmt2(double v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << v;
    return oss.str();
}

void print_help() {
    std::cout << "Usage:\n";
    std::cout << "  sudoku_test_level4_required.exe [options]\n\n";
    std::cout << "Options:\n";
    std::cout << "  --timeout-min <int>             Global timeout in minutes (default 2, 0=off)\n";
    std::cout << "  --case-timeout-s <int>          Per-case max_total_time_s (default 25, 0=off)\n";
    std::cout << "  --attempt-time-budget-s <num>   Per-attempt budget (default 6.0)\n";
    std::cout << "  --max-attempts <u64>            Limit attempts per case (default 0)\n";
    std::cout << "  --target <u64>                  Target puzzles per case (default 2)\n";
    std::cout << "  --box-rows <int> --box-cols <int>  Run single geometry instead of defaults\n";
    std::cout << "  --report <path>                 Report path (default TESTS_cpp/level4_required_report.txt)\n";
    std::cout << "  --help                          Show this help\n";
}

std::vector<std::pair<int, int>> default_geometries() {
    return {
        {3, 3},  // 9x9
        {3, 4},  // 12x12
    };
}

std::vector<RequiredStrategy> l4_strategies() {
    return {
        RequiredStrategy::NakedQuad,
        RequiredStrategy::HiddenQuad,
        RequiredStrategy::XWing,
        RequiredStrategy::YWing,
        RequiredStrategy::Skyscraper,
        RequiredStrategy::TwoStringKite,
        RequiredStrategy::EmptyRectangle,
        RequiredStrategy::RemotePairs,
    };
}

}  // namespace

int main(int argc, char** argv) {
    int timeout_min = 2;
    int case_timeout_s = 25;
    double attempt_time_budget_s = 6.0;
    uint64_t max_attempts = 0;
    uint64_t target = 2;
    int single_box_rows = 0;
    int single_box_cols = 0;
    std::string report_path = "TESTS_cpp/level4_required_report.txt";

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        auto need = [&](int k) { return (i + k) < argc; };
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if (arg == "--timeout-min" && need(1)) {
            timeout_min = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--case-timeout-s" && need(1)) {
            case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--attempt-time-budget-s" && need(1)) {
            attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
        } else if (arg == "--max-attempts" && need(1)) {
            max_attempts = static_cast<uint64_t>(std::stoull(std::string(argv[++i])));
        } else if (arg == "--target" && need(1)) {
            target = std::max<uint64_t>(1, static_cast<uint64_t>(std::stoull(std::string(argv[++i]))));
        } else if (arg == "--box-rows" && need(1)) {
            single_box_rows = std::max(1, std::stoi(std::string(argv[++i])));
        } else if (arg == "--box-cols" && need(1)) {
            single_box_cols = std::max(1, std::stoi(std::string(argv[++i])));
        } else if (arg == "--report" && need(1)) {
            report_path = argv[++i];
        }
    }

    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_path).parent_path(), ec);
    std::ofstream report(report_path, std::ios::out | std::ios::trunc);
    if (!report) {
        std::cerr << "Cannot open report: " << report_path << "\n";
        return 2;
    }
    report << std::unitbuf;

    std::vector<std::pair<int, int>> geos = default_geometries();
    if (single_box_rows > 0 && single_box_cols > 0) {
        geos = {{single_box_rows, single_box_cols}};
    }

    std::vector<L4CaseResult> results;
    const auto strategies = l4_strategies();
    results.reserve(geos.size() * strategies.size());

    const auto t0 = std::chrono::steady_clock::now();
    const bool global_timeout_enabled = timeout_min > 0;
    const auto deadline = global_timeout_enabled
        ? (t0 + std::chrono::minutes(timeout_min))
        : std::chrono::steady_clock::time_point::max();

    report << "LEVEL4 REQUIRED STRATEGY BENCH\n";
    report << "==============================\n";
    report << "target_per_case=" << target
           << ", timeout_min=" << timeout_min
           << ", case_timeout_s=" << case_timeout_s
           << ", attempt_time_budget_s=" << fmt2(attempt_time_budget_s)
           << ", max_attempts=" << max_attempts << "\n\n";

    bool global_timeout_hit = false;
    for (const auto& g : geos) {
        const int box_rows = g.first;
        const int box_cols = g.second;
        const int n = box_rows * box_cols;
        report << "[Geometry " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")]\n";
        for (const auto strategy : strategies) {
            L4CaseResult row{};
            row.box_rows = box_rows;
            row.box_cols = box_cols;
            row.strategy = strategy;

            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_timeout_hit = true;
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                continue;
            }
            if (!required_strategy_selectable_for_geometry(strategy, box_rows, box_cols)) {
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (not selectable for geometry)\n";
                continue;
            }

            GenerateRunConfig cfg;
            cfg.box_rows = box_rows;
            cfg.box_cols = box_cols;
            cfg.target_puzzles = target;
            cfg.difficulty_level_required = 4;
            cfg.required_strategy = strategy;
            cfg.require_unique = true;
            cfg.strict_logical = true;
            cfg.threads = 0;
            cfg.seed = 0;
            cfg.reseed_interval_s = (n >= 16 ? 5 : 2);
            cfg.attempt_time_budget_s = attempt_time_budget_s;
            cfg.max_attempts = max_attempts;
            const ClueRange auto_clues = resolve_auto_clue_range(box_rows, box_cols, cfg.difficulty_level_required, cfg.required_strategy);
            cfg.min_clues = auto_clues.min_clues;
            cfg.max_clues = auto_clues.max_clues;
            cfg.pause_on_exit_windows = false;
            cfg.write_individual_files = false;
            cfg.output_folder = "plikiTMP/testy/level4_required";
            cfg.output_file = "__tmp_l4_" + std::to_string(n) + "_" + std::to_string(box_rows) + "x" +
                              std::to_string(box_cols) + "_" + to_string(strategy) + ".txt";
            cfg.max_total_time_s = 0;
            if (case_timeout_s > 0) {
                cfg.max_total_time_s = static_cast<uint64_t>(case_timeout_s);
            }
            if (global_timeout_enabled) {
                const auto now = std::chrono::steady_clock::now();
                if (now < deadline) {
                    const auto remain_s = static_cast<uint64_t>(
                        std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
                    if (remain_s == 0) {
                        global_timeout_hit = true;
                        results.push_back(row);
                        report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                        continue;
                    }
                    cfg.max_total_time_s = (cfg.max_total_time_s == 0)
                        ? remain_s
                        : std::min<uint64_t>(cfg.max_total_time_s, remain_s);
                } else {
                    global_timeout_hit = true;
                    results.push_back(row);
                    report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                    continue;
                }
            }

            row.attempted = true;
            const auto c0 = std::chrono::steady_clock::now();
            const GenerateRunResult run = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
            row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - c0).count();
            row.accepted = run.accepted;
            row.written = run.written;
            row.attempts = run.attempts;
            row.reject_strategy = run.reject_strategy;
            row.success = run.written >= target;
            row.timed_out_case = (cfg.max_total_time_s > 0 && run.written < target);
            results.push_back(row);

            report << "  - " << std::setw(15) << std::left << to_string(strategy)
                   << " written=" << std::setw(3) << std::right << row.written
                   << "/" << target
                   << " accepted=" << std::setw(4) << row.accepted
                   << " attempts=" << std::setw(7) << row.attempts
                   << " reject_strategy=" << std::setw(7) << row.reject_strategy
                   << " elapsed_s=" << fmt2(row.elapsed_s)
                   << " status=" << (row.success ? "OK" : (row.timed_out_case ? "TIMEOUT/PARTIAL" : "PARTIAL"))
                   << "\n";
        }
        report << "\n";
        if (global_timeout_hit) {
            break;
        }
    }

    const auto total_elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    uint64_t attempted = 0;
    uint64_t ok = 0;
    for (const auto& r : results) {
        if (r.attempted) ++attempted;
        if (r.success) ++ok;
    }

    report << "SUMMARY\n";
    report << "=======\n";
    report << "cases_total=" << results.size()
           << ", attempted=" << attempted
           << ", success=" << ok
           << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
           << ", elapsed_total_s=" << fmt2(total_elapsed_s) << "\n";
    if (global_timeout_hit) {
        report << "Partial report saved due to global timeout.\n";
    }
    report.close();

    std::cout << "L4 required-strategy test report: " << report_path << "\n";
    std::cout << "attempted=" << attempted << ", success=" << ok
              << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
              << ", elapsed_s=" << fmt2(total_elapsed_s) << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level5_required.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TEST PRODUKCYJNY L5 REQUIRED STRATEGY
// Domyslnie: 9x9 (3x3), 12x12 (3x4), po 2 plansze na strategie L5.
// Zatrzymanie globalne: timeout-min (domyslnie 20 min), z raportem czesciowym.
// ============================================================================

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {
using namespace sudoku_hpc;

// Debug logs zostawione do szybkiej diagnostyki crashy L5.
// Ustaw na true tylko gdy potrzebna szczegolowa diagnostyka krok po kroku.
constexpr bool kL5VerboseLogs = false;

struct L5CaseResult {
    int box_rows = 0;
    int box_cols = 0;
    RequiredStrategy strategy = RequiredStrategy::None;
    bool attempted = false;
    bool success = false;
    bool timed_out_case = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t reject_strategy = 0;
    double elapsed_s = 0.0;
};

std::string fmt2(double v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << v;
    return oss.str();
}

void print_help() {
    std::cout << "Usage:\n";
    std::cout << "  sudoku_test_level5_required.exe [options]\n\n";
    std::cout << "Options:\n";
    std::cout << "  --timeout-min <int>             Global timeout in minutes (default 20, 0=off)\n";
    std::cout << "  --case-timeout-s <int>          Per-case max_total_time_s (default 180, 0=off)\n";
    std::cout << "  --attempt-time-budget-s <num>   Per-attempt budget (default 15.0)\n";
    std::cout << "  --max-attempts <u64>            Limit attempts per case (default 0)\n";
    std::cout << "  --target <u64>                  Target puzzles per case (default 2)\n";
    std::cout << "  --report <path>                 Report path (default TESTS_cpp/level5_required_report.txt)\n";
    std::cout << "  --only-strategy <name>          Run only one required strategy (debug)\n";
    std::cout << "  --help                          Show this help\n";
}

std::vector<std::pair<int, int>> default_geometries() {
    return {
        {3, 3},  // 9x9
        {3, 4},  // 12x12
    };
}

std::vector<RequiredStrategy> l5_strategies() {
    return {
        RequiredStrategy::Swordfish,
        RequiredStrategy::FinnedXWingSashimi,
        RequiredStrategy::SimpleColoring,
        RequiredStrategy::BUGPlusOne,
        RequiredStrategy::UniqueRectangle,
        RequiredStrategy::XYZWing,
        RequiredStrategy::WWing,
    };
}

}  // namespace

int main(int argc, char** argv) {
    int timeout_min = 20;
    int case_timeout_s = 180;
    double attempt_time_budget_s = 15.0;
    uint64_t max_attempts = 0;
    uint64_t target = 2;
    std::string report_path = "TESTS_cpp/level5_required_report.txt";
    std::string only_strategy;

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        auto need = [&](int k) { return (i + k) < argc; };
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if (arg == "--timeout-min" && need(1)) {
            timeout_min = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--case-timeout-s" && need(1)) {
            case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--attempt-time-budget-s" && need(1)) {
            attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
        } else if (arg == "--max-attempts" && need(1)) {
            max_attempts = static_cast<uint64_t>(std::stoull(std::string(argv[++i])));
        } else if (arg == "--target" && need(1)) {
            target = std::max<uint64_t>(1, static_cast<uint64_t>(std::stoull(std::string(argv[++i]))));
        } else if (arg == "--report" && need(1)) {
            report_path = argv[++i];
        } else if (arg == "--only-strategy" && need(1)) {
            only_strategy = argv[++i];
        }
    }

    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_path).parent_path(), ec);
    std::ofstream report(report_path, std::ios::out | std::ios::trunc);
    if (!report) {
        std::cerr << "Cannot open report: " << report_path << "\n";
        return 2;
    }
    report << std::unitbuf;

    const std::vector<std::pair<int, int>> geos = default_geometries();
    std::vector<RequiredStrategy> strategies = l5_strategies();
    if (!only_strategy.empty()) {
        const RequiredStrategy parsed = parse_required_strategy(only_strategy);
        if (parsed == RequiredStrategy::None) {
            std::cerr << "Unknown --only-strategy: " << only_strategy << "\n";
            return 3;
        }
        strategies = {parsed};
    }

    std::vector<L5CaseResult> results;
    results.reserve(geos.size() * strategies.size());

    const auto t0 = std::chrono::steady_clock::now();
    const bool global_timeout_enabled = timeout_min > 0;
    const auto deadline = global_timeout_enabled
        ? (t0 + std::chrono::minutes(timeout_min))
        : std::chrono::steady_clock::time_point::max();

    report << "LEVEL5 REQUIRED STRATEGY BENCH\n";
    report << "==============================\n";
    report << "target_per_case=" << target
           << ", timeout_min=" << timeout_min
           << ", case_timeout_s=" << case_timeout_s
           << ", attempt_time_budget_s=" << fmt2(attempt_time_budget_s)
           << ", max_attempts=" << max_attempts << "\n\n";

    bool global_timeout_hit = false;
    for (const auto& g : geos) {
        const int box_rows = g.first;
        const int box_cols = g.second;
        const int n = box_rows * box_cols;
        report << "[Geometry " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")]\n";

        for (const auto strategy : strategies) {
            L5CaseResult row{};
            row.box_rows = box_rows;
            row.box_cols = box_cols;
            row.strategy = strategy;
            if (kL5VerboseLogs) {
                std::cerr << "[L5TEST] case_begin n=" << n
                          << " geom=" << box_rows << "x" << box_cols
                          << " strategy=" << to_string(strategy) << "\n";
            }

            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_timeout_hit = true;
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                continue;
            }
            if (!required_strategy_selectable_for_geometry(strategy, box_rows, box_cols)) {
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (not selectable for geometry)\n";
                continue;
            }

            GenerateRunConfig cfg;
            cfg.box_rows = box_rows;
            cfg.box_cols = box_cols;
            cfg.target_puzzles = target;
            cfg.difficulty_level_required = 5;
            cfg.required_strategy = strategy;
            cfg.require_unique = true;
            cfg.strict_logical = true;
            cfg.threads = 0;
            cfg.seed = 0;
            cfg.reseed_interval_s = (n >= 16 ? 5 : 2);
            cfg.attempt_time_budget_s = attempt_time_budget_s;
            cfg.max_attempts = max_attempts;
            const ClueRange auto_clues = resolve_auto_clue_range(box_rows, box_cols, cfg.difficulty_level_required, cfg.required_strategy);
            cfg.min_clues = auto_clues.min_clues;
            cfg.max_clues = auto_clues.max_clues;
            cfg.pause_on_exit_windows = false;
            cfg.write_individual_files = false;
            cfg.output_folder = "plikiTMP/testy/level5_required";
            cfg.output_file = "__tmp_l5_" + std::to_string(n) + "_" + std::to_string(box_rows) + "x" +
                              std::to_string(box_cols) + "_" + to_string(strategy) + ".txt";
            cfg.max_total_time_s = 0;
            if (case_timeout_s > 0) {
                cfg.max_total_time_s = static_cast<uint64_t>(case_timeout_s);
            }
            if (global_timeout_enabled) {
                const auto now = std::chrono::steady_clock::now();
                if (now < deadline) {
                    const auto remain_s = static_cast<uint64_t>(
                        std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
                    if (remain_s == 0) {
                        global_timeout_hit = true;
                        results.push_back(row);
                        report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                        continue;
                    }
                    cfg.max_total_time_s = (cfg.max_total_time_s == 0)
                        ? remain_s
                        : std::min<uint64_t>(cfg.max_total_time_s, remain_s);
                } else {
                    global_timeout_hit = true;
                    results.push_back(row);
                    report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                    continue;
                }
            }

            row.attempted = true;
            if (kL5VerboseLogs) {
                std::cerr << "[L5TEST] run_begin strategy=" << to_string(strategy)
                          << " max_total_time_s=" << cfg.max_total_time_s
                          << " target=" << cfg.target_puzzles
                          << " clues=[" << cfg.min_clues << "," << cfg.max_clues << "]\n";
            }
            const auto c0 = std::chrono::steady_clock::now();
            const GenerateRunResult run = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
            row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - c0).count();
            if (kL5VerboseLogs) {
                std::cerr << "[L5TEST] run_end strategy=" << to_string(strategy)
                          << " written=" << run.written
                          << " accepted=" << run.accepted
                          << " attempts=" << run.attempts << "\n";
            }
            row.accepted = run.accepted;
            row.written = run.written;
            row.attempts = run.attempts;
            row.reject_strategy = run.reject_strategy;
            row.success = run.written >= target;
            row.timed_out_case = (cfg.max_total_time_s > 0 && run.written < target);
            results.push_back(row);

            report << "  - " << std::setw(15) << std::left << to_string(strategy)
                   << " written=" << std::setw(3) << std::right << row.written
                   << "/" << target
                   << " accepted=" << std::setw(4) << row.accepted
                   << " attempts=" << std::setw(7) << row.attempts
                   << " reject_strategy=" << std::setw(7) << row.reject_strategy
                   << " elapsed_s=" << fmt2(row.elapsed_s)
                   << " status=" << (row.success ? "OK" : (row.timed_out_case ? "TIMEOUT/PARTIAL" : "PARTIAL"))
                   << "\n";
        }
        report << "\n";
        if (global_timeout_hit) {
            break;
        }
    }

    const auto total_elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    uint64_t attempted = 0;
    uint64_t ok = 0;
    for (const auto& r : results) {
        if (r.attempted) ++attempted;
        if (r.success) ++ok;
    }

    report << "SUMMARY\n";
    report << "=======\n";
    report << "cases_total=" << results.size()
           << ", attempted=" << attempted
           << ", success=" << ok
           << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
           << ", elapsed_total_s=" << fmt2(total_elapsed_s) << "\n";
    if (global_timeout_hit) {
        report << "Partial report saved due to global timeout.\n";
    }
    report.close();

    std::cout << "L5 required-strategy test report: " << report_path << "\n";
    std::cout << "attempted=" << attempted << ", success=" << ok
              << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
              << ", elapsed_s=" << fmt2(total_elapsed_s) << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level6_quick.cpp
==============================================================================

﻿#include <algorithm>
#include <chrono>
#include <cstdint>
#include <iostream>
#include <string>
#include <vector>

#include "../board.h"
#include "../sudoku_logic_engine.h"

namespace {
using namespace sudoku_hpc;

struct Geo {
    int box_rows;
    int box_cols;
};

bool run_quick_case(const Geo& g, int max_ms_per_case) {
    const auto topo_opt = GenericTopology::build(g.box_rows, g.box_cols);
    if (!topo_opt.has_value()) {
        std::cerr << "SKIP invalid geometry " << g.box_rows << "x" << g.box_cols << "\n";
        return true;
    }
    const GenericTopology& topo = topo_opt.value();

    std::vector<uint16_t> puzzle(static_cast<size_t>(topo.nn), 0);
    GenericLogicCertify solver;

    const auto t0 = std::chrono::steady_clock::now();
    const auto res = solver.certify_up_to_level(puzzle, topo, 6, nullptr, false);
    const auto dt_ms = static_cast<int>(
        std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - t0).count());

    const bool used_jellyfish = res.strategy_stats[GenericLogicCertify::SlotJellyfish].use_count > 0;
    const bool used_x_chain = res.strategy_stats[GenericLogicCertify::SlotXChain].use_count > 0;
    const bool used_xy_chain = res.strategy_stats[GenericLogicCertify::SlotXYChain].use_count > 0;
    const bool used_wxyz = res.strategy_stats[GenericLogicCertify::SlotWXYZWing].use_count > 0;
    const bool used_finned = res.strategy_stats[GenericLogicCertify::SlotFinnedSwordfishJellyfish].use_count > 0;
    const bool used_als = res.strategy_stats[GenericLogicCertify::SlotALSXZ].use_count > 0;
    const bool used_uloop = res.strategy_stats[GenericLogicCertify::SlotUniqueLoop].use_count > 0;
    const bool used_avoid = res.strategy_stats[GenericLogicCertify::SlotAvoidableRectangle].use_count > 0;
    const bool used_odd = res.strategy_stats[GenericLogicCertify::SlotBivalueOddagon].use_count > 0;
    const bool p6_all_used = used_jellyfish && used_x_chain && used_xy_chain && used_wxyz &&
                             used_finned && used_als && used_uloop && used_avoid && used_odd;

    std::cout << "L6_QUICK "
              << topo.n << "x" << topo.n
              << " (" << g.box_rows << "x" << g.box_cols << ")"
              << " dt_ms=" << dt_ms
              << " solved=" << (res.solved ? 1 : 0)
              << " p6_used=" << (p6_all_used ? 1 : 0)
              << "\n";

    if (!p6_all_used) return false;
    if (max_ms_per_case > 0 && dt_ms > max_ms_per_case) return false;
    return true;
}

}  // namespace

int main(int argc, char** argv) {
    int max_ms_per_case = 2500;
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--max-ms" && i + 1 < argc) {
            max_ms_per_case = std::max(0, std::stoi(argv[++i]));
        }
    }

    const std::vector<Geo> geos = {
        {3, 3},
        {3, 4},
        {2, 5},
    };

    for (const auto& g : geos) {
        if (!run_quick_case(g, max_ms_per_case)) {
            std::cerr << "L6_QUICK_FAIL " << g.box_rows << "x" << g.box_cols << "\n";
            return 2;
        }
    }
    std::cout << "L6_QUICK_OK\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level6_required.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TEST PRODUKCYJNY L6 REQUIRED STRATEGY
// Domyslnie: 9x9 (3x3), 12x12 (3x4), po 2 plansze na strategie L6.
// Zatrzymanie globalne: timeout-min (domyslnie 20 min), z raportem czesciowym.
// ============================================================================

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {
using namespace sudoku_hpc;

// Debug logs zostawione do szybkiej diagnostyki crashy L6.
// Ustaw na true tylko gdy potrzebna szczegolowa diagnostyka krok po kroku.
constexpr bool kL6VerboseLogs = false;

struct L6CaseResult {
    int box_rows = 0;
    int box_cols = 0;
    RequiredStrategy strategy = RequiredStrategy::None;
    bool attempted = false;
    bool success = false;
    bool timed_out_case = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t reject_strategy = 0;
    double elapsed_s = 0.0;
};

std::string fmt2(double v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << v;
    return oss.str();
}

void print_help() {
    std::cout << "Usage:\n";
    std::cout << "  sudoku_test_level6_required.exe [options]\n\n";
    std::cout << "Options:\n";
    std::cout << "  --timeout-min <int>             Global timeout in minutes (default 20, 0=off)\n";
    std::cout << "  --case-timeout-s <int>          Per-case max_total_time_s (default 180, 0=off)\n";
    std::cout << "  --attempt-time-budget-s <num>   Per-attempt budget (default 15.0)\n";
    std::cout << "  --max-attempts <u64>            Limit attempts per case (default 0)\n";
    std::cout << "  --target <u64>                  Target puzzles per case (default 2)\n";
    std::cout << "  --report <path>                 Report path (default TESTS_cpp/level6_required_report.txt)\n";
    std::cout << "  --only-strategy <name>          Run only one required strategy (debug)\n";
    std::cout << "  --help                          Show this help\n";
}

std::vector<std::pair<int, int>> default_geometries() {
    return {
        {3, 3},  // 9x9
        {3, 4},  // 12x12
    };
}

std::vector<RequiredStrategy> l6_strategies() {
    return {
        RequiredStrategy::Jellyfish,
        RequiredStrategy::XChain,
        RequiredStrategy::XYChain,
        RequiredStrategy::WXYZWing,
        RequiredStrategy::FinnedSwordfishJellyfish,
        RequiredStrategy::ALSXZ,
        RequiredStrategy::UniqueLoop,
        RequiredStrategy::AvoidableRectangle,
        RequiredStrategy::BivalueOddagon,
    };
}

}  // namespace

int main(int argc, char** argv) {
    int timeout_min = 20;
    int case_timeout_s = 180;
    double attempt_time_budget_s = 15.0;
    uint64_t max_attempts = 0;
    uint64_t target = 2;
    std::string report_path = "TESTS_cpp/level6_required_report.txt";
    std::string only_strategy;

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        auto need = [&](int k) { return (i + k) < argc; };
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if (arg == "--timeout-min" && need(1)) {
            timeout_min = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--case-timeout-s" && need(1)) {
            case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--attempt-time-budget-s" && need(1)) {
            attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
        } else if (arg == "--max-attempts" && need(1)) {
            max_attempts = static_cast<uint64_t>(std::stoull(std::string(argv[++i])));
        } else if (arg == "--target" && need(1)) {
            target = std::max<uint64_t>(1, static_cast<uint64_t>(std::stoull(std::string(argv[++i]))));
        } else if (arg == "--report" && need(1)) {
            report_path = argv[++i];
        } else if (arg == "--only-strategy" && need(1)) {
            only_strategy = argv[++i];
        }
    }

    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_path).parent_path(), ec);
    std::ofstream report(report_path, std::ios::out | std::ios::trunc);
    if (!report) {
        std::cerr << "Cannot open report: " << report_path << "\n";
        return 2;
    }
    report << std::unitbuf;

    const std::vector<std::pair<int, int>> geos = default_geometries();
    std::vector<RequiredStrategy> strategies = l6_strategies();
    if (!only_strategy.empty()) {
        const RequiredStrategy parsed = parse_required_strategy(only_strategy);
        if (parsed == RequiredStrategy::None) {
            std::cerr << "Unknown --only-strategy: " << only_strategy << "\n";
            return 3;
        }
        strategies = {parsed};
    }

    std::vector<L6CaseResult> results;
    results.reserve(geos.size() * strategies.size());

    const auto t0 = std::chrono::steady_clock::now();
    const bool global_timeout_enabled = timeout_min > 0;
    const auto deadline = global_timeout_enabled
        ? (t0 + std::chrono::minutes(timeout_min))
        : std::chrono::steady_clock::time_point::max();

    report << "LEVEL6 REQUIRED STRATEGY BENCH\n";
    report << "==============================\n";
    report << "target_per_case=" << target
           << ", timeout_min=" << timeout_min
           << ", case_timeout_s=" << case_timeout_s
           << ", attempt_time_budget_s=" << fmt2(attempt_time_budget_s)
           << ", max_attempts=" << max_attempts << "\n\n";

    bool global_timeout_hit = false;
    for (const auto& g : geos) {
        const int box_rows = g.first;
        const int box_cols = g.second;
        const int n = box_rows * box_cols;
        report << "[Geometry " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")]\n";

        for (const auto strategy : strategies) {
            L6CaseResult row{};
            row.box_rows = box_rows;
            row.box_cols = box_cols;
            row.strategy = strategy;
            if (kL6VerboseLogs) {
                std::cerr << "[L6TEST] case_begin n=" << n
                          << " geom=" << box_rows << "x" << box_cols
                          << " strategy=" << to_string(strategy) << "\n";
            }

            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_timeout_hit = true;
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                continue;
            }
            if (!required_strategy_selectable_for_geometry(strategy, box_rows, box_cols)) {
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (not selectable for geometry)\n";
                continue;
            }

            GenerateRunConfig cfg;
            cfg.box_rows = box_rows;
            cfg.box_cols = box_cols;
            cfg.target_puzzles = target;
            cfg.difficulty_level_required = 6;
            cfg.required_strategy = strategy;
            cfg.require_unique = true;
            cfg.strict_logical = true;
            cfg.threads = 0;
            cfg.seed = 0;
            cfg.reseed_interval_s = (n >= 16 ? 5 : 2);
            cfg.attempt_time_budget_s = attempt_time_budget_s;
            cfg.max_attempts = max_attempts;
            const ClueRange auto_clues = resolve_auto_clue_range(box_rows, box_cols, cfg.difficulty_level_required, cfg.required_strategy);
            cfg.min_clues = auto_clues.min_clues;
            cfg.max_clues = auto_clues.max_clues;
            cfg.pause_on_exit_windows = false;
            cfg.write_individual_files = false;
            cfg.output_folder = "plikiTMP/testy/level6_required";
            cfg.output_file = "__tmp_l6_" + std::to_string(n) + "_" + std::to_string(box_rows) + "x" +
                              std::to_string(box_cols) + "_" + to_string(strategy) + ".txt";
            cfg.max_total_time_s = 0;
            if (case_timeout_s > 0) {
                cfg.max_total_time_s = static_cast<uint64_t>(case_timeout_s);
            }
            if (global_timeout_enabled) {
                const auto now = std::chrono::steady_clock::now();
                if (now < deadline) {
                    const auto remain_s = static_cast<uint64_t>(
                        std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
                    if (remain_s == 0) {
                        global_timeout_hit = true;
                        results.push_back(row);
                        report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                        continue;
                    }
                    cfg.max_total_time_s = (cfg.max_total_time_s == 0)
                        ? remain_s
                        : std::min<uint64_t>(cfg.max_total_time_s, remain_s);
                } else {
                    global_timeout_hit = true;
                    results.push_back(row);
                    report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                    continue;
                }
            }

            row.attempted = true;
            if (kL6VerboseLogs) {
                std::cerr << "[L6TEST] run_begin strategy=" << to_string(strategy)
                          << " max_total_time_s=" << cfg.max_total_time_s
                          << " target=" << cfg.target_puzzles
                          << " clues=[" << cfg.min_clues << "," << cfg.max_clues << "]\n";
            }
            const auto c0 = std::chrono::steady_clock::now();
            const GenerateRunResult run = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
            row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - c0).count();
            if (kL6VerboseLogs) {
                std::cerr << "[L6TEST] run_end strategy=" << to_string(strategy)
                          << " written=" << run.written
                          << " accepted=" << run.accepted
                          << " attempts=" << run.attempts << "\n";
            }
            row.accepted = run.accepted;
            row.written = run.written;
            row.attempts = run.attempts;
            row.reject_strategy = run.reject_strategy;
            row.success = run.written >= target;
            row.timed_out_case = (cfg.max_total_time_s > 0 && run.written < target);
            results.push_back(row);

            report << "  - " << std::setw(15) << std::left << to_string(strategy)
                   << " written=" << std::setw(3) << std::right << row.written
                   << "/" << target
                   << " accepted=" << std::setw(4) << row.accepted
                   << " attempts=" << std::setw(7) << row.attempts
                   << " reject_strategy=" << std::setw(7) << row.reject_strategy
                   << " elapsed_s=" << fmt2(row.elapsed_s)
                   << " status=" << (row.success ? "OK" : (row.timed_out_case ? "TIMEOUT/PARTIAL" : "PARTIAL"))
                   << "\n";
        }
        report << "\n";
        if (global_timeout_hit) {
            break;
        }
    }

    const auto total_elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    uint64_t attempted = 0;
    uint64_t ok = 0;
    for (const auto& r : results) {
        if (r.attempted) ++attempted;
        if (r.success) ++ok;
    }

    report << "SUMMARY\n";
    report << "=======\n";
    report << "cases_total=" << results.size()
           << ", attempted=" << attempted
           << ", success=" << ok
           << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
           << ", elapsed_total_s=" << fmt2(total_elapsed_s) << "\n";
    if (global_timeout_hit) {
        report << "Partial report saved due to global timeout.\n";
    }
    report.close();

    std::cout << "L6 required-strategy test report: " << report_path << "\n";
    std::cout << "attempted=" << attempted << ", success=" << ok
              << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
              << ", elapsed_s=" << fmt2(total_elapsed_s) << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level7_level8_quick.cpp
==============================================================================

﻿#include <algorithm>
#include <chrono>
#include <cstdint>
#include <iostream>
#include <string>
#include <vector>

#include "../board.h"
#include "../sudoku_logic_engine.h"

namespace {
using namespace sudoku_hpc;

struct Geo {
    int box_rows;
    int box_cols;
};

bool run_quick_case(const Geo& g, int max_ms_per_case) {
    const auto topo_opt = GenericTopology::build(g.box_rows, g.box_cols);
    if (!topo_opt.has_value()) {
        std::cerr << "SKIP invalid geometry " << g.box_rows << "x" << g.box_cols << "\n";
        return true;
    }
    const GenericTopology& topo = topo_opt.value();

    std::vector<uint16_t> puzzle(static_cast<size_t>(topo.nn), 0);
    GenericLogicCertify solver;

    const auto t0 = std::chrono::steady_clock::now();
    const auto res = solver.certify_up_to_level(puzzle, topo, 8, nullptr, false);
    const auto dt_ms = static_cast<int>(
        std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - t0).count());

    const bool p7_used =
        res.strategy_stats[GenericLogicCertify::SlotMedusa3D].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotAIC].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotGroupedAIC].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotGroupedXCycle].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotContinuousNiceLoop].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotALSXYWing].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotALSChain].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotSueDeCoq].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotDeathBlossom].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotFrankenFish].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotMutantFish].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotKrakenFish].use_count > 0;

    const bool p8_used =
        res.strategy_stats[GenericLogicCertify::SlotMSLS].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotExocet].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotSeniorExocet].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotSKLoop].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotPatternOverlayMethod].use_count > 0 &&
        res.strategy_stats[GenericLogicCertify::SlotForcingChains].use_count > 0;

    std::cout << "L7L8_QUICK "
              << topo.n << "x" << topo.n
              << " (" << g.box_rows << "x" << g.box_cols << ")"
              << " dt_ms=" << dt_ms
              << " solved=" << (res.solved ? 1 : 0)
              << " p7_used=" << (p7_used ? 1 : 0)
              << " p8_used=" << (p8_used ? 1 : 0)
              << "\n";

    if (!p7_used || !p8_used) return false;
    if (max_ms_per_case > 0 && dt_ms > max_ms_per_case) return false;
    return true;
}

}  // namespace

int main(int argc, char** argv) {
    int max_ms_per_case = 3000;
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--max-ms" && i + 1 < argc) {
            max_ms_per_case = std::max(0, std::stoi(argv[++i]));
        }
    }

    const std::vector<Geo> geos = {
        {3, 3},
        {3, 4},
        {2, 5},
    };

    for (const auto& g : geos) {
        if (!run_quick_case(g, max_ms_per_case)) {
            std::cerr << "L7L8_QUICK_FAIL " << g.box_rows << "x" << g.box_cols << "\n";
            return 2;
        }
    }
    std::cout << "L7L8_QUICK_OK\n";
    return 0;
}




==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level7_required.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TEST PRODUKCYJNY L7 REQUIRED STRATEGY
// Domyslnie: 9x9 (3x3), 12x12 (3x4), po 2 plansze na strategie L7.
// Zatrzymanie globalne: timeout-min (domyslnie 20 min), z raportem czesciowym.
// ============================================================================

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {
using namespace sudoku_hpc;

// Debug logs zostawione do szybkiej diagnostyki crashy L7.
// Ustaw na true tylko gdy potrzebna szczegolowa diagnostyka krok po kroku.
constexpr bool kL7VerboseLogs = false;

struct L7CaseResult {
    int box_rows = 0;
    int box_cols = 0;
    RequiredStrategy strategy = RequiredStrategy::None;
    bool attempted = false;
    bool success = false;
    bool timed_out_case = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t reject_strategy = 0;
    double elapsed_s = 0.0;
};

std::string fmt2(double v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << v;
    return oss.str();
}

void print_help() {
    std::cout << "Usage:\n";
    std::cout << "  sudoku_test_level6_required.exe [options]\n\n";
    std::cout << "Options:\n";
    std::cout << "  --timeout-min <int>             Global timeout in minutes (default 20, 0=off)\n";
    std::cout << "  --case-timeout-s <int>          Per-case max_total_time_s (default 180, 0=off)\n";
    std::cout << "  --attempt-time-budget-s <num>   Per-attempt budget (default 15.0)\n";
    std::cout << "  --max-attempts <u64>            Limit attempts per case (default 0)\n";
    std::cout << "  --target <u64>                  Target puzzles per case (default 2)\n";
    std::cout << "  --report <path>                 Report path (default TESTS_cpp/level6_required_report.txt)\n";
    std::cout << "  --only-strategy <name>          Run only one required strategy (debug)\n";
    std::cout << "  --help                          Show this help\n";
}

std::vector<std::pair<int, int>> default_geometries() {
    return {
        {3, 3},  // 9x9
        {3, 4},  // 12x12
    };
}

std::vector<RequiredStrategy> l7_strategies() {
    return {
        RequiredStrategy::Medusa3D,
        RequiredStrategy::AIC,
        RequiredStrategy::GroupedAIC,
        RequiredStrategy::GroupedXCycle,
        RequiredStrategy::ContinuousNiceLoop,
        RequiredStrategy::ALSXYWing,
        RequiredStrategy::ALSChain,
        RequiredStrategy::SueDeCoq,
        RequiredStrategy::DeathBlossom,
        RequiredStrategy::FrankenFish,
        RequiredStrategy::MutantFish,
        RequiredStrategy::KrakenFish,
    };
}

}  // namespace

int main(int argc, char** argv) {
    int timeout_min = 20;
    int case_timeout_s = 180;
    double attempt_time_budget_s = 15.0;
    uint64_t max_attempts = 0;
    uint64_t target = 2;
    std::string report_path = "TESTS_cpp/level7_required_report.txt";
    std::string only_strategy;

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        auto need = [&](int k) { return (i + k) < argc; };
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if (arg == "--timeout-min" && need(1)) {
            timeout_min = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--case-timeout-s" && need(1)) {
            case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--attempt-time-budget-s" && need(1)) {
            attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
        } else if (arg == "--max-attempts" && need(1)) {
            max_attempts = static_cast<uint64_t>(std::stoull(std::string(argv[++i])));
        } else if (arg == "--target" && need(1)) {
            target = std::max<uint64_t>(1, static_cast<uint64_t>(std::stoull(std::string(argv[++i]))));
        } else if (arg == "--report" && need(1)) {
            report_path = argv[++i];
        } else if (arg == "--only-strategy" && need(1)) {
            only_strategy = argv[++i];
        }
    }

    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_path).parent_path(), ec);
    std::ofstream report(report_path, std::ios::out | std::ios::trunc);
    if (!report) {
        std::cerr << "Cannot open report: " << report_path << "\n";
        return 2;
    }
    report << std::unitbuf;

    const std::vector<std::pair<int, int>> geos = default_geometries();
    std::vector<RequiredStrategy> strategies = l7_strategies();
    if (!only_strategy.empty()) {
        const RequiredStrategy parsed = parse_required_strategy(only_strategy);
        if (parsed == RequiredStrategy::None) {
            std::cerr << "Unknown --only-strategy: " << only_strategy << "\n";
            return 3;
        }
        strategies = {parsed};
    }

    std::vector<L7CaseResult> results;
    results.reserve(geos.size() * strategies.size());

    const auto t0 = std::chrono::steady_clock::now();
    const bool global_timeout_enabled = timeout_min > 0;
    const auto deadline = global_timeout_enabled
        ? (t0 + std::chrono::minutes(timeout_min))
        : std::chrono::steady_clock::time_point::max();

    report << "LEVEL7 REQUIRED STRATEGY BENCH\n";
    report << "==============================\n";
    report << "target_per_case=" << target
           << ", timeout_min=" << timeout_min
           << ", case_timeout_s=" << case_timeout_s
           << ", attempt_time_budget_s=" << fmt2(attempt_time_budget_s)
           << ", max_attempts=" << max_attempts << "\n\n";

    bool global_timeout_hit = false;
    for (const auto& g : geos) {
        const int box_rows = g.first;
        const int box_cols = g.second;
        const int n = box_rows * box_cols;
        report << "[Geometry " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")]\n";

        for (const auto strategy : strategies) {
            L7CaseResult row{};
            row.box_rows = box_rows;
            row.box_cols = box_cols;
            row.strategy = strategy;
            if (kL7VerboseLogs) {
                std::cerr << "[L7TEST] case_begin n=" << n
                          << " geom=" << box_rows << "x" << box_cols
                          << " strategy=" << to_string(strategy) << "\n";
            }

            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_timeout_hit = true;
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                continue;
            }
            if (!required_strategy_selectable_for_geometry(strategy, box_rows, box_cols)) {
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (not selectable for geometry)\n";
                continue;
            }

            GenerateRunConfig cfg;
            cfg.box_rows = box_rows;
            cfg.box_cols = box_cols;
            cfg.target_puzzles = target;
            cfg.difficulty_level_required = 7;
            cfg.required_strategy = strategy;
            cfg.require_unique = true;
            cfg.strict_logical = true;
            cfg.threads = 0;
            cfg.seed = 0;
            cfg.reseed_interval_s = (n >= 16 ? 5 : 2);
            cfg.attempt_time_budget_s = attempt_time_budget_s;
            cfg.max_attempts = max_attempts;
            const ClueRange auto_clues = resolve_auto_clue_range(box_rows, box_cols, cfg.difficulty_level_required, cfg.required_strategy);
            cfg.min_clues = auto_clues.min_clues;
            cfg.max_clues = auto_clues.max_clues;
            cfg.pause_on_exit_windows = false;
            cfg.write_individual_files = false;
            cfg.output_folder = "plikiTMP/testy/level6_required";
            cfg.output_file = "__tmp_l7_" + std::to_string(n) + "_" + std::to_string(box_rows) + "x" +
                              std::to_string(box_cols) + "_" + to_string(strategy) + ".txt";
            cfg.max_total_time_s = 0;
            if (case_timeout_s > 0) {
                cfg.max_total_time_s = static_cast<uint64_t>(case_timeout_s);
            }
            if (global_timeout_enabled) {
                const auto now = std::chrono::steady_clock::now();
                if (now < deadline) {
                    const auto remain_s = static_cast<uint64_t>(
                        std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
                    if (remain_s == 0) {
                        global_timeout_hit = true;
                        results.push_back(row);
                        report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                        continue;
                    }
                    cfg.max_total_time_s = (cfg.max_total_time_s == 0)
                        ? remain_s
                        : std::min<uint64_t>(cfg.max_total_time_s, remain_s);
                } else {
                    global_timeout_hit = true;
                    results.push_back(row);
                    report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                    continue;
                }
            }

            row.attempted = true;
            if (kL7VerboseLogs) {
                std::cerr << "[L7TEST] run_begin strategy=" << to_string(strategy)
                          << " max_total_time_s=" << cfg.max_total_time_s
                          << " target=" << cfg.target_puzzles
                          << " clues=[" << cfg.min_clues << "," << cfg.max_clues << "]\n";
            }
            const auto c0 = std::chrono::steady_clock::now();
            const GenerateRunResult run = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
            row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - c0).count();
            if (kL7VerboseLogs) {
                std::cerr << "[L7TEST] run_end strategy=" << to_string(strategy)
                          << " written=" << run.written
                          << " accepted=" << run.accepted
                          << " attempts=" << run.attempts << "\n";
            }
            row.accepted = run.accepted;
            row.written = run.written;
            row.attempts = run.attempts;
            row.reject_strategy = run.reject_strategy;
            row.success = run.written >= target;
            row.timed_out_case = (cfg.max_total_time_s > 0 && run.written < target);
            results.push_back(row);

            report << "  - " << std::setw(15) << std::left << to_string(strategy)
                   << " written=" << std::setw(3) << std::right << row.written
                   << "/" << target
                   << " accepted=" << std::setw(4) << row.accepted
                   << " attempts=" << std::setw(7) << row.attempts
                   << " reject_strategy=" << std::setw(7) << row.reject_strategy
                   << " elapsed_s=" << fmt2(row.elapsed_s)
                   << " status=" << (row.success ? "OK" : (row.timed_out_case ? "TIMEOUT/PARTIAL" : "PARTIAL"))
                   << "\n";
        }
        report << "\n";
        if (global_timeout_hit) {
            break;
        }
    }

    const auto total_elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    uint64_t attempted = 0;
    uint64_t ok = 0;
    for (const auto& r : results) {
        if (r.attempted) ++attempted;
        if (r.success) ++ok;
    }

    report << "SUMMARY\n";
    report << "=======\n";
    report << "cases_total=" << results.size()
           << ", attempted=" << attempted
           << ", success=" << ok
           << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
           << ", elapsed_total_s=" << fmt2(total_elapsed_s) << "\n";
    if (global_timeout_hit) {
        report << "Partial report saved due to global timeout.\n";
    }
    report.close();

    std::cout << "L7 required-strategy test report: " << report_path << "\n";
    std::cout << "attempted=" << attempted << ", success=" << ok
              << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
              << ", elapsed_s=" << fmt2(total_elapsed_s) << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_level8_required.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TEST PRODUKCYJNY L8 REQUIRED STRATEGY
// Domyslnie: 9x9 (3x3), 12x12 (3x4), po 2 plansze na strategie L8.
// Zatrzymanie globalne: timeout-min (domyslnie 20 min), z raportem czesciowym.
// ============================================================================

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../geometry.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

namespace {
using namespace sudoku_hpc;

// Debug logs zostawione do szybkiej diagnostyki crashy L8.
// Ustaw na true tylko gdy potrzebna szczegolowa diagnostyka krok po kroku.
constexpr bool kL8VerboseLogs = false;

struct L8CaseResult {
    int box_rows = 0;
    int box_cols = 0;
    RequiredStrategy strategy = RequiredStrategy::None;
    bool attempted = false;
    bool success = false;
    bool timed_out_case = false;
    uint64_t accepted = 0;
    uint64_t written = 0;
    uint64_t attempts = 0;
    uint64_t reject_strategy = 0;
    double elapsed_s = 0.0;
};

std::string fmt2(double v) {
    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << v;
    return oss.str();
}

void print_help() {
    std::cout << "Usage:\n";
    std::cout << "  sudoku_test_level8_required.exe [options]\n\n";
    std::cout << "Options:\n";
    std::cout << "  --timeout-min <int>             Global timeout in minutes (default 20, 0=off)\n";
    std::cout << "  --case-timeout-s <int>          Per-case max_total_time_s (default 180, 0=off)\n";
    std::cout << "  --attempt-time-budget-s <num>   Per-attempt budget (default 15.0)\n";
    std::cout << "  --max-attempts <u64>            Limit attempts per case (default 0)\n";
    std::cout << "  --target <u64>                  Target puzzles per case (default 2)\n";
    std::cout << "  --report <path>                 Report path (default TESTS_cpp/level8_required_report.txt)\n";
    std::cout << "  --only-strategy <name>          Run only one required strategy (debug)\n";
    std::cout << "  --help                          Show this help\n";
}

std::vector<std::pair<int, int>> default_geometries() {
    return {
        {3, 3},  // 9x9
        {3, 4},  // 12x12
    };
}

std::vector<RequiredStrategy> l8_strategies() {
    return {
        RequiredStrategy::MSLS,
        RequiredStrategy::Exocet,
        RequiredStrategy::SeniorExocet,
        RequiredStrategy::SKLoop,
        RequiredStrategy::PatternOverlayMethod,
        RequiredStrategy::ForcingChains,
    };
}

}  // namespace

int main(int argc, char** argv) {
    int timeout_min = 20;
    int case_timeout_s = 180;
    double attempt_time_budget_s = 15.0;
    uint64_t max_attempts = 0;
    uint64_t target = 2;
    std::string report_path = "TESTS_cpp/level8_required_report.txt";
    std::string only_strategy;

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        auto need = [&](int k) { return (i + k) < argc; };
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            print_help();
            return 0;
        } else if (arg == "--timeout-min" && need(1)) {
            timeout_min = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--case-timeout-s" && need(1)) {
            case_timeout_s = std::max(0, std::stoi(std::string(argv[++i])));
        } else if (arg == "--attempt-time-budget-s" && need(1)) {
            attempt_time_budget_s = std::max(0.0, std::stod(std::string(argv[++i])));
        } else if (arg == "--max-attempts" && need(1)) {
            max_attempts = static_cast<uint64_t>(std::stoull(std::string(argv[++i])));
        } else if (arg == "--target" && need(1)) {
            target = std::max<uint64_t>(1, static_cast<uint64_t>(std::stoull(std::string(argv[++i]))));
        } else if (arg == "--report" && need(1)) {
            report_path = argv[++i];
        } else if (arg == "--only-strategy" && need(1)) {
            only_strategy = argv[++i];
        }
    }

    std::error_code ec;
    std::filesystem::create_directories(std::filesystem::path(report_path).parent_path(), ec);
    std::ofstream report(report_path, std::ios::out | std::ios::trunc);
    if (!report) {
        std::cerr << "Cannot open report: " << report_path << "\n";
        return 2;
    }
    report << std::unitbuf;

    const std::vector<std::pair<int, int>> geos = default_geometries();
    std::vector<RequiredStrategy> strategies = l8_strategies();
    if (!only_strategy.empty()) {
        const RequiredStrategy parsed = parse_required_strategy(only_strategy);
        if (parsed == RequiredStrategy::None) {
            std::cerr << "Unknown --only-strategy: " << only_strategy << "\n";
            return 3;
        }
        strategies = {parsed};
    }

    std::vector<L8CaseResult> results;
    results.reserve(geos.size() * strategies.size());

    const auto t0 = std::chrono::steady_clock::now();
    const bool global_timeout_enabled = timeout_min > 0;
    const auto deadline = global_timeout_enabled
        ? (t0 + std::chrono::minutes(timeout_min))
        : std::chrono::steady_clock::time_point::max();

    report << "LEVEL8 REQUIRED STRATEGY BENCH\n";
    report << "==============================\n";
    report << "target_per_case=" << target
           << ", timeout_min=" << timeout_min
           << ", case_timeout_s=" << case_timeout_s
           << ", attempt_time_budget_s=" << fmt2(attempt_time_budget_s)
           << ", max_attempts=" << max_attempts << "\n\n";

    bool global_timeout_hit = false;
    for (const auto& g : geos) {
        const int box_rows = g.first;
        const int box_cols = g.second;
        const int n = box_rows * box_cols;
        report << "[Geometry " << n << "x" << n << " (" << box_rows << "x" << box_cols << ")]\n";

        for (const auto strategy : strategies) {
            L8CaseResult row{};
            row.box_rows = box_rows;
            row.box_cols = box_cols;
            row.strategy = strategy;
            if (kL8VerboseLogs) {
                std::cerr << "[L8TEST] case_begin n=" << n
                          << " geom=" << box_rows << "x" << box_cols
                          << " strategy=" << to_string(strategy) << "\n";
            }

            if (global_timeout_enabled && std::chrono::steady_clock::now() >= deadline) {
                global_timeout_hit = true;
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                continue;
            }
            if (!required_strategy_selectable_for_geometry(strategy, box_rows, box_cols)) {
                results.push_back(row);
                report << "  - " << to_string(strategy) << ": SKIP (not selectable for geometry)\n";
                continue;
            }

            GenerateRunConfig cfg;
            cfg.box_rows = box_rows;
            cfg.box_cols = box_cols;
            cfg.target_puzzles = target;
            cfg.difficulty_level_required = 8;
            cfg.required_strategy = strategy;
            cfg.require_unique = true;
            cfg.strict_logical = true;
            cfg.threads = 0;
            cfg.seed = 0;
            cfg.reseed_interval_s = (n >= 16 ? 5 : 2);
            cfg.attempt_time_budget_s = attempt_time_budget_s;
            cfg.max_attempts = max_attempts;
            const ClueRange auto_clues = resolve_auto_clue_range(box_rows, box_cols, cfg.difficulty_level_required, cfg.required_strategy);
            cfg.min_clues = auto_clues.min_clues;
            cfg.max_clues = auto_clues.max_clues;
            cfg.pause_on_exit_windows = false;
            cfg.write_individual_files = false;
            cfg.output_folder = "plikiTMP/testy/level8_required";
            cfg.output_file = "__tmp_l8_" + std::to_string(n) + "_" + std::to_string(box_rows) + "x" +
                              std::to_string(box_cols) + "_" + to_string(strategy) + ".txt";
            cfg.max_total_time_s = 0;
            if (case_timeout_s > 0) {
                cfg.max_total_time_s = static_cast<uint64_t>(case_timeout_s);
            }
            if (global_timeout_enabled) {
                const auto now = std::chrono::steady_clock::now();
                if (now < deadline) {
                    const auto remain_s = static_cast<uint64_t>(
                        std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
                    if (remain_s == 0) {
                        global_timeout_hit = true;
                        results.push_back(row);
                        report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                        continue;
                    }
                    cfg.max_total_time_s = (cfg.max_total_time_s == 0)
                        ? remain_s
                        : std::min<uint64_t>(cfg.max_total_time_s, remain_s);
                } else {
                    global_timeout_hit = true;
                    results.push_back(row);
                    report << "  - " << to_string(strategy) << ": SKIP (global timeout)\n";
                    continue;
                }
            }

            row.attempted = true;
            if (kL8VerboseLogs) {
                std::cerr << "[L8TEST] run_begin strategy=" << to_string(strategy)
                          << " max_total_time_s=" << cfg.max_total_time_s
                          << " target=" << cfg.target_puzzles
                          << " clues=[" << cfg.min_clues << "," << cfg.max_clues << "]\n";
            }
            const auto c0 = std::chrono::steady_clock::now();
            const GenerateRunResult run = run_generic_sudoku(cfg, nullptr, nullptr, nullptr, nullptr, nullptr);
            row.elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - c0).count();
            if (kL8VerboseLogs) {
                std::cerr << "[L8TEST] run_end strategy=" << to_string(strategy)
                          << " written=" << run.written
                          << " accepted=" << run.accepted
                          << " attempts=" << run.attempts << "\n";
            }
            row.accepted = run.accepted;
            row.written = run.written;
            row.attempts = run.attempts;
            row.reject_strategy = run.reject_strategy;
            row.success = run.written >= target;
            row.timed_out_case = (cfg.max_total_time_s > 0 && run.written < target);
            results.push_back(row);

            report << "  - " << std::setw(15) << std::left << to_string(strategy)
                   << " written=" << std::setw(3) << std::right << row.written
                   << "/" << target
                   << " accepted=" << std::setw(4) << row.accepted
                   << " attempts=" << std::setw(7) << row.attempts
                   << " reject_strategy=" << std::setw(7) << row.reject_strategy
                   << " elapsed_s=" << fmt2(row.elapsed_s)
                   << " status=" << (row.success ? "OK" : (row.timed_out_case ? "TIMEOUT/PARTIAL" : "PARTIAL"))
                   << "\n";
        }
        report << "\n";
        if (global_timeout_hit) {
            break;
        }
    }

    const auto total_elapsed_s = std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    uint64_t attempted = 0;
    uint64_t ok = 0;
    for (const auto& r : results) {
        if (r.attempted) ++attempted;
        if (r.success) ++ok;
    }

    report << "SUMMARY\n";
    report << "=======\n";
    report << "cases_total=" << results.size()
           << ", attempted=" << attempted
           << ", success=" << ok
           << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
           << ", elapsed_total_s=" << fmt2(total_elapsed_s) << "\n";
    if (global_timeout_hit) {
        report << "Partial report saved due to global timeout.\n";
    }
    report.close();

    std::cout << "L8 required-strategy test report: " << report_path << "\n";
    std::cout << "attempted=" << attempted << ", success=" << ok
              << ", global_timeout_hit=" << (global_timeout_hit ? "1" : "0")
              << ", elapsed_s=" << fmt2(total_elapsed_s) << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_mcts_digger_quick.cpp
==============================================================================

﻿#include <cstdint>
#include <iostream>
#include <random>
#include <vector>

#include "../board.h"
#include "../config.h"
#include "../dlx.h"
#include "../generator_mcts_digger.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"

int main() {
    using namespace sudoku_hpc;

    const auto topo_opt = GenericTopology::build(3, 3);
    if (!topo_opt.has_value()) {
        std::cerr << "TOPO_FAIL\n";
        return 2;
    }
    const GenericTopology& topo = *topo_opt;

    std::mt19937_64 rng(987654321ULL);
    GenericSolvedKernel solved;
    std::vector<uint16_t> solution;
    if (!solved.generate(topo, rng, solution, nullptr)) {
        std::cerr << "SOLVED_FAIL\n";
        return 3;
    }

    GenerateRunConfig cfg{};
    cfg.box_rows = 3;
    cfg.box_cols = 3;
    cfg.min_clues = 32;
    cfg.max_clues = 32;
    cfg.symmetry_center = false;
    cfg.mcts_digger_enabled = true;
    cfg.mcts_digger_iterations = 1200;
    cfg.mcts_ucb_c = 1.41;
    cfg.mcts_fail_cap = 256;
    cfg.mcts_basic_logic_level = 5;
    cfg.mcts_tuning_profile = "p8";
    cfg.difficulty_level_required = 8;
    cfg.required_strategy = RequiredStrategy::ForcingChains;

    GenericUniquenessCounter uniq;
    GenericLogicCertify logic;
    GenericMctsBottleneckDigger digger;
    std::vector<uint16_t> puzzle;
    int clues = 0;
    GenericMctsBottleneckDigger::RunStats stats{};

    if (!digger.dig_into(solution, topo, cfg, rng, uniq, logic, puzzle, clues, nullptr, nullptr, &stats)) {
        std::cerr << "MCTS_DIG_FAIL\n";
        return 4;
    }
    if (static_cast<int>(puzzle.size()) != topo.nn) {
        std::cerr << "PUZZLE_SIZE_FAIL\n";
        return 5;
    }
    if (stats.accepted_removals <= 0) {
        std::cerr << "MCTS_NO_PROGRESS\n";
        return 6;
    }
    if (stats.advanced_evals <= 0) {
        std::cerr << "MCTS_ADVANCED_EVAL_MISSING\n";
        return 9;
    }
    if (clues < cfg.min_clues || clues > topo.nn) {
        std::cerr << "CLUE_RANGE_FAIL clues=" << clues << "\n";
        return 7;
    }

    const int solutions = uniq.count_solutions_limit2(puzzle, topo, nullptr);
    if (solutions != 1) {
        std::cerr << "UNIQUENESS_FAIL solutions=" << solutions << "\n";
        return 8;
    }

    const auto basic = logic.certify_up_to_level(puzzle, topo, 5, nullptr, false);
    std::cout << "MCTS_DIGGER_QUICK_OK"
              << " clues=" << clues
              << " iter=" << stats.iterations
              << " adv=" << stats.advanced_evals
              << " bottleneck=" << (stats.bottleneck_hit ? 1 : 0)
              << " basic_solved=" << (basic.solved ? 1 : 0)
              << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_mcts_profiles_quick.cpp
==============================================================================

﻿#include <cstdint>
#include <iostream>
#include <random>
#include <string>
#include <vector>

#include "../board.h"
#include "../config.h"
#include "../dlx.h"
#include "../generator_mcts_digger.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"

namespace {
using namespace sudoku_hpc;

bool run_profile_case(
    const GenericTopology& topo,
    const std::vector<uint16_t>& solution,
    const std::string& profile,
    RequiredStrategy req,
    int difficulty,
    uint64_t seed) {
    GenerateRunConfig cfg{};
    cfg.box_rows = 3;
    cfg.box_cols = 3;
    cfg.min_clues = 32;
    cfg.max_clues = 32;
    cfg.mcts_digger_enabled = true;
    cfg.mcts_digger_iterations = 1400;
    cfg.mcts_ucb_c = 1.41;
    cfg.mcts_fail_cap = 256;
    cfg.mcts_basic_logic_level = 5;
    cfg.mcts_tuning_profile = profile;
    cfg.required_strategy = req;
    cfg.difficulty_level_required = difficulty;

    std::mt19937_64 rng(seed);
    GenericUniquenessCounter uniq;
    GenericLogicCertify logic;
    GenericMctsBottleneckDigger digger;
    std::vector<uint16_t> puzzle;
    int clues = 0;
    GenericMctsBottleneckDigger::RunStats stats{};
    if (!digger.dig_into(solution, topo, cfg, rng, uniq, logic, puzzle, clues, nullptr, nullptr, &stats)) {
        return false;
    }
    if (stats.accepted_removals <= 0 || stats.advanced_evals <= 0) {
        return false;
    }
    const int sol_count = uniq.count_solutions_limit2(puzzle, topo, nullptr);
    if (sol_count != 1) {
        return false;
    }

    std::cout << "MCTS_PROFILE_QUICK"
              << " profile=" << profile
              << " clues=" << clues
              << " iter=" << stats.iterations
              << " adv=" << stats.advanced_evals
              << " p7=" << stats.advanced_p7_hits
              << " p8=" << stats.advanced_p8_hits
              << " req=" << stats.required_strategy_hits
              << "\n";
    return true;
}
} // namespace

int main() {
    using namespace sudoku_hpc;

    const auto topo_opt = GenericTopology::build(3, 3);
    if (!topo_opt.has_value()) {
        std::cerr << "TOPO_FAIL\n";
        return 2;
    }
    const GenericTopology& topo = *topo_opt;

    std::mt19937_64 rng(123987456ULL);
    GenericSolvedKernel solved;
    std::vector<uint16_t> solution;
    if (!solved.generate(topo, rng, solution, nullptr)) {
        std::cerr << "SOLVED_FAIL\n";
        return 3;
    }

    if (!run_profile_case(topo, solution, "p7", RequiredStrategy::AIC, 7, 0xA17ULL)) {
        std::cerr << "PROFILE_P7_FAIL\n";
        return 4;
    }
    if (!run_profile_case(topo, solution, "p8", RequiredStrategy::ForcingChains, 8, 0xA18ULL)) {
        std::cerr << "PROFILE_P8_FAIL\n";
        return 5;
    }
    return 0;
}




==============================================================================
PLIK: Sources\TESTS_cpp\main_test_p1_p5_parity.cpp
==============================================================================

﻿#include <algorithm>
#include <array>
#include <bit>
#include <cstdint>
#include <iostream>
#include <numeric>
#include <random>
#include <string>
#include <vector>

#include "../board.h"
#include "../sudoku_logic_engine.h"
#include "../sudoku_logic_engine_p1_p5.h"

namespace {
using namespace sudoku_hpc;

constexpr int kFirstP6Slot = static_cast<int>(GenericLogicCertify::SlotJellyfish);
constexpr int kLastSlot = static_cast<int>(GenericLogicCertify::SlotForcingChains);
constexpr int kLastP5Slot = static_cast<int>(GenericLogicCertify::SlotWWing);

bool has_hit_above_p5(const GenericLogicCertifyResult& r) {
    for (int i = kFirstP6Slot; i <= kLastSlot; ++i) {
        if (r.strategy_stats[static_cast<size_t>(i)].hit_count > 0) return true;
    }
    return false;
}

bool compare_p1_p5_stats(const GenericLogicCertifyResult& a, const GenericLogicCertifyResult& b) {
    for (int i = 0; i <= kLastP5Slot; ++i) {
        const auto& sa = a.strategy_stats[static_cast<size_t>(i)];
        const auto& sb = b.strategy_stats[static_cast<size_t>(i)];
        if (sa.use_count != sb.use_count) return false;
        if (sa.hit_count != sb.hit_count) return false;
        if (sa.placements != sb.placements) return false;
    }
    return true;
}

bool fill_board_mrv(GenericBoard& board, std::mt19937_64& rng) {
    if (board.empty_cells == 0) return true;

    int best_idx = -1;
    uint64_t best_mask = 0ULL;
    int best_count = 65;

    for (int idx = 0; idx < board.topo->nn; ++idx) {
        if (board.values[static_cast<size_t>(idx)] != 0) continue;
        const uint64_t m = board.candidate_mask_for_idx(idx);
        const int c = static_cast<int>(std::popcount(m));
        if (c == 0) return false;
        if (c < best_count) {
            best_idx = idx;
            best_mask = m;
            best_count = c;
            if (c == 1) break;
        }
    }
    if (best_idx < 0) return false;

    std::array<int, 64> digits{};
    int digit_count = 0;
    uint64_t w = best_mask;
    while (w != 0ULL) {
        const uint64_t bit = w & (~w + 1ULL);
        digits[static_cast<size_t>(digit_count++)] = static_cast<int>(std::countr_zero(bit)) + 1;
        w &= (w - 1ULL);
    }
    for (int i = digit_count - 1; i > 0; --i) {
        const int j = static_cast<int>(rng() % static_cast<uint64_t>(i + 1));
        std::swap(digits[static_cast<size_t>(i)], digits[static_cast<size_t>(j)]);
    }

    for (int i = 0; i < digit_count; ++i) {
        const int d = digits[static_cast<size_t>(i)];
        board.place(best_idx, d);
        if (fill_board_mrv(board, rng)) return true;
        board.unplace(best_idx, d);
    }
    return false;
}

std::vector<uint16_t> build_puzzle_with_clues(const std::vector<uint16_t>& solved, int clues, std::mt19937_64& rng) {
    std::vector<uint16_t> puzzle = solved;
    std::vector<int> order(static_cast<size_t>(solved.size()));
    std::iota(order.begin(), order.end(), 0);
    std::shuffle(order.begin(), order.end(), rng);

    const int to_remove = static_cast<int>(solved.size()) - clues;
    for (int i = 0; i < to_remove; ++i) {
        puzzle[static_cast<size_t>(order[static_cast<size_t>(i)])] = 0;
    }
    return puzzle;
}

struct GeometryCase {
    int box_rows;
    int box_cols;
};

int run_case(const GeometryCase& g, int wanted, std::mt19937_64& rng) {
    const auto topo_opt = GenericTopology::build(g.box_rows, g.box_cols);
    if (!topo_opt.has_value()) {
        std::cerr << "SKIP invalid geometry " << g.box_rows << "x" << g.box_cols << "\n";
        return 0;
    }
    const GenericTopology& topo = topo_opt.value();

    GenericLogicCertify baseline_solver;
    GenericLogicCertifyP1P5Modular modular;

    int matched = 0;
    int attempted = 0;
    int generated = 0;
    const int max_generated = std::max(200, wanted * 40);

    while (generated < max_generated && matched < wanted) {
        ++generated;
        GenericBoard board;
        board.reset(topo);
        if (!fill_board_mrv(board, rng)) continue;

        const std::vector<uint16_t> solved = board.values;
        const int base_clues = std::max(topo.n * 4, topo.nn - topo.n * 3);
        const int jitter = static_cast<int>(rng() % static_cast<uint64_t>(std::max(1, topo.n / 2)));
        const int clues = std::clamp(base_clues - jitter, topo.n + 1, topo.nn - 1);
        const std::vector<uint16_t> puzzle = build_puzzle_with_clues(solved, clues, rng);

        const auto baseline_res = baseline_solver.certify(puzzle, topo, nullptr, true);
        if (!baseline_res.solved || baseline_res.timed_out) continue;
        if (has_hit_above_p5(baseline_res)) continue;

        ++attempted;
        const auto new_res = modular.certify(puzzle, topo, nullptr, true);
        const bool ok =
            (new_res.solved == baseline_res.solved) &&
            (new_res.timed_out == baseline_res.timed_out) &&
            (new_res.steps == baseline_res.steps) &&
            (new_res.solved_grid == baseline_res.solved_grid) &&
            compare_p1_p5_stats(baseline_res, new_res);

        if (!ok) {
            std::cerr << "PARITY_FAIL geom=" << topo.n << "x" << topo.n
                      << " br=" << g.box_rows << " bc=" << g.box_cols
                      << " attempt=" << attempted
                      << " baseline_steps=" << baseline_res.steps
                      << " new_steps=" << new_res.steps << "\n";
            return -1;
        }
        ++matched;
    }

    std::cout << "PARITY geom=" << topo.n << "x" << topo.n
              << " (" << g.box_rows << "x" << g.box_cols << ")"
              << " matched=" << matched
              << " attempted=" << attempted
              << " generated=" << generated << "\n";
    return matched;
}

}  // namespace

int main(int argc, char** argv) {
    int wanted_per_geometry = 12;
    uint64_t seed = 0xC0FFEEULL;

    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--wanted" && i + 1 < argc) {
            wanted_per_geometry = std::max(1, std::stoi(argv[++i]));
        } else if (arg == "--seed" && i + 1 < argc) {
            seed = static_cast<uint64_t>(std::stoull(argv[++i]));
        }
    }

    std::mt19937_64 rng(seed);
    const std::array<GeometryCase, 3> geometries = {{
        {3, 3},
        {3, 4},
        {2, 5},
    }};

    int total_matched = 0;
    for (const auto& g : geometries) {
        const int got = run_case(g, wanted_per_geometry, rng);
        if (got < 0) return 2;
        if (got < wanted_per_geometry) {
            std::cerr << "INSUFFICIENT_CASES geom=" << g.box_rows << "x" << g.box_cols
                      << " got=" << got << " wanted=" << wanted_per_geometry << "\n";
            return 3;
        }
        total_matched += got;
    }

    std::cout << "PARITY_OK total_matched=" << total_matched << "\n";
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\main_test_pattern_forcing_bridge.cpp
==============================================================================

#include <cstdint>
#include <iostream>
#include <random>
#include <vector>

#include "../board.h"
#include "../config.h"
#include "../dlx.h"
#include "../generator_pattern_forcing.h"
#include "../kernels.h"

int main() {
    using namespace sudoku_hpc;

    const auto topo_opt = GenericTopology::build(3, 3);
    if (!topo_opt.has_value()) {
        std::cerr << "TOPO_BUILD_FAIL\n";
        return 2;
    }
    const GenericTopology& topo = *topo_opt;

    GenerateRunConfig cfg{};
    cfg.box_rows = 3;
    cfg.box_cols = 3;
    cfg.pattern_forcing_enabled = true;
    cfg.pattern_forcing_tries = 8;
    cfg.pattern_forcing_anchor_count = 8;
    cfg.pattern_forcing_lock_anchors = true;
    cfg.required_strategy = RequiredStrategy::Exocet;
    cfg.min_clues = 28;
    cfg.max_clues = 28;

    std::mt19937_64 rng(123456789ULL);
    pattern_forcing::PatternSeedView seed{};
    if (!pattern_forcing::build_seed(topo, cfg, cfg.required_strategy, cfg.difficulty_level_required, rng, seed)) {
        std::cerr << "PATTERN_BUILD_FAIL\n";
        return 3;
    }
    if (seed.seed_puzzle == nullptr || seed.allowed_masks == nullptr || seed.protected_cells == nullptr) {
        std::cerr << "PATTERN_VIEW_FAIL\n";
        return 4;
    }

    GenericUniquenessCounter uniq;
    std::vector<uint16_t> solved;
    if (!uniq.solve_and_capture(*seed.seed_puzzle, topo, solved, nullptr, seed.allowed_masks)) {
        std::cerr << "DLX_BRIDGE_FAIL\n";
        return 5;
    }
    if (static_cast<int>(solved.size()) != topo.nn) {
        std::cerr << "SOLVED_SIZE_FAIL\n";
        return 6;
    }

    int protected_count = 0;
    for (int i = 0; i < topo.nn; ++i) {
        if ((*seed.protected_cells)[static_cast<size_t>(i)] != 0) {
            ++protected_count;
        }
    }
    if (protected_count <= 0) {
        std::cerr << "PROTECTED_EMPTY\n";
        return 7;
    }

    GenericDigKernel dig;
    std::vector<uint16_t> puzzle;
    int clues = 0;
    dig.dig_into(solved, topo, cfg, rng, puzzle, clues, seed.protected_cells->data());

    for (int i = 0; i < topo.nn; ++i) {
        if ((*seed.protected_cells)[static_cast<size_t>(i)] != 0 &&
            puzzle[static_cast<size_t>(i)] == 0) {
            std::cerr << "ANCHOR_LOST idx=" << i << "\n";
            return 8;
        }
    }

    std::cout << "PATTERN_FORCING_BRIDGE_OK"
              << " anchors=" << seed.anchor_count
              << " clues=" << clues
              << "\n";
    return 0;
}




==============================================================================
PLIK: Sources\TESTS_cpp\pause_cancel_control_smoke.cpp
==============================================================================

﻿#include <atomic>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <psapi.h>
#endif

#include "../config.h"
#include "../utils.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../dlx.h"
#include "../benchmark.h"
#include "../profiler.h"
#include "../monitor.h"
#include "../sudoku_generate_pipeline.h"

namespace sudoku_testy {
inline void run_all_regression_tests(const std::string& /*report_path*/) {}
}

int main(int argc, char** argv) {
    for (int i = 1; i < argc; ++i) {
        const std::string arg = argv[i];
        if (arg == "--help" || arg == "-h" || arg == "/?") {
            std::cout << "Usage:\n";
            std::cout << "  pause_cancel_control_smoke.exe\n\n";
            std::cout << "Options:\n";
            std::cout << "  --help, -h, /?                Show this help\n\n";
            std::cout << "Behavior:\n";
            std::cout << "  Runs a smoke test for pause/cancel control on 36x36 generation.\n";
            std::cout << "  Exits non-zero if cancel path does not stop quickly.\n";
            return 0;
        }
    }

    using namespace sudoku_hpc;

    GenerateRunConfig cfg;
    cfg.box_rows = 6;  // 36x36
    cfg.box_cols = 6;
    cfg.target_puzzles = 1;
    cfg.difficulty_level_required = 1;
    cfg.required_strategy = RequiredStrategy::NakedSingle;
    const ClueRange auto_clues =
        resolve_auto_clue_range(cfg.box_rows, cfg.box_cols, cfg.difficulty_level_required, cfg.required_strategy);
    cfg.min_clues = auto_clues.min_clues;
    cfg.max_clues = auto_clues.max_clues;
    cfg.threads = 1;
    cfg.pause_on_exit_windows = false;
    cfg.output_folder = "generated_sudoku_files";
    cfg.output_file = "test_pause_cancel_runtime.txt";

    std::atomic<bool> cancel_flag{false};
    std::atomic<bool> pause_flag{false};

    std::jthread ctl([&](std::stop_token st) {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        if (st.stop_requested()) return;
        pause_flag.store(true, std::memory_order_relaxed);
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
        pause_flag.store(false, std::memory_order_relaxed);
        cancel_flag.store(true, std::memory_order_relaxed);
    });

    const auto t0 = std::chrono::steady_clock::now();
    ConsoleStatsMonitor monitor;
    const auto result = run_generic_sudoku(cfg, &monitor, &cancel_flag, &pause_flag, nullptr, nullptr);
    const auto t1 = std::chrono::steady_clock::now();
    const double elapsed_s = std::chrono::duration<double>(t1 - t0).count();

    std::cout << "elapsed_s=" << elapsed_s
              << " accepted=" << result.accepted
              << " attempts=" << result.attempts
              << " rejected=" << result.rejected << "\n";

    if (elapsed_s > 8.0) {
        std::cerr << "FAIL: pause/cancel control did not stop quickly\n";
        return 2;
    }
    return 0;
}



==============================================================================
PLIK: Sources\TESTS_cpp\test_level1_asymmetric.cpp
==============================================================================

﻿// ============================================================================
// SUDOKU HPC - TESTY REGRESYJNE STRATEGII POZIOMU 1 (NOWE API)
// Testy dla geometrii asymetrycznych (np. 12x12 z blokami 4x3, 10x10 z 2x5)
// ============================================================================

#ifndef STRATEGIE_LEVEL1_TESTS_H
#define STRATEGIE_LEVEL1_TESTS_H

#include <algorithm>
#include <atomic>
#include <bit>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <future>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <random>
#include <string>
#include <thread>
#include <vector>

#include "../config.h"
#include "../board.h"
#include "../kernels.h"
#include "../sudoku_logic_engine.h"
#include "../geometry.h"

namespace sudoku_testy {

struct TestResult {
    bool passed = false;
    std::string name;
    std::string message;
    double elapsed_ms = 0.0;
};

struct AsymmetricGeometry {
    int N = 0;
    int box_rows = 0;
    int box_cols = 0;
    std::string desc;
    uint64_t test_seed = 0;
};

struct ExpectedGeometry {
    int N = 0;
    int box_rows = 0;
    int box_cols = 0;
    std::string desc;
};

inline const std::vector<ExpectedGeometry>& get_expected_supported_geometries() {
    static const std::vector<ExpectedGeometry> geometries = [] {
        std::vector<ExpectedGeometry> out;
        for (const auto& g : sudoku_hpc::geometria::all_geometries()) {
            out.push_back({g.n, g.box_rows, g.box_cols, g.label});
        }
        return out;
    }();
    return geometries;
}

inline const std::vector<AsymmetricGeometry>& get_asymmetric_geometries() {
    static const std::vector<AsymmetricGeometry> geometries = [] {
        std::vector<AsymmetricGeometry> out;
        for (const auto& g : sudoku_hpc::geometria::all_geometries()) {
            if (g.n < 6 || g.n > 20) continue;
            if (g.box_rows == g.box_cols && g.n != 16) continue;
            const uint64_t seed = static_cast<uint64_t>(g.n * 1000 + g.box_rows * 100 + g.box_cols);
            out.push_back({g.n, g.box_rows, g.box_cols, g.label, seed});
        }
        return out;
    }();
    return geometries;
}

inline std::string level1_progress_path_from_report(const std::string& report_path) {
    std::filesystem::path p(report_path);
    const std::string stem = p.has_stem() ? p.stem().string() : std::string("level1_asymmetric_report");
    std::filesystem::path out = p.parent_path() / (stem + "_progress.txt");
    return out.string();
}

inline int level1_timeout_seconds_from_env() {
    const char* raw = std::getenv("SUDOKU_LEVEL1_TIMEOUT_S");
    if (raw == nullptr || *raw == '\0') return 0;
    try {
        return std::max(0, std::stoi(std::string(raw)));
    } catch (...) {
        return 0;
    }
}

inline int level1_case_timeout_seconds_from_env() {
    const char* raw = std::getenv("SUDOKU_LEVEL1_CASE_TIMEOUT_S");
    if (raw == nullptr || *raw == '\0') return 30;
    try {
        return std::max(0, std::stoi(std::string(raw)));
    } catch (...) {
        return 30;
    }
}

inline int level1_timeout_seconds_from_minutes_or_env(int timeout_minutes) {
    if (timeout_minutes >= 0) {
        if (timeout_minutes == 0) return 0;
        return std::max(1, timeout_minutes) * 60;
    }
    return level1_timeout_seconds_from_env();
}

inline int level1_case_timeout_seconds_from_arg_or_env(int case_timeout_s) {
    if (case_timeout_s >= 0) return std::max(0, case_timeout_s);
    return level1_case_timeout_seconds_from_env();
}

inline bool validate_solved_grid(const std::vector<uint16_t>& grid, const sudoku_hpc::GenericTopology& topo) {
    if (static_cast<int>(grid.size()) != topo.nn) return false;
    for (int idx = 0; idx < topo.nn; ++idx) {
        const int d = static_cast<int>(grid[static_cast<size_t>(idx)]);
        if (d < 1 || d > topo.n) return false;
    }
    const int house_count = static_cast<int>(topo.house_offsets.size()) - 1;
    for (int h = 0; h < house_count; ++h) {
        uint64_t seen = 0ULL;
        const int p0 = topo.house_offsets[static_cast<size_t>(h)];
        const int p1 = topo.house_offsets[static_cast<size_t>(h + 1)];
        for (int p = p0; p < p1; ++p) {
            const int idx = topo.houses_flat[static_cast<size_t>(p)];
            const int d = static_cast<int>(grid[static_cast<size_t>(idx)]);
            const uint64_t bit = (1ULL << (d - 1));
            if ((seen & bit) != 0ULL) return false;
            seen |= bit;
        }
        if (std::popcount(seen) != topo.n) return false;
    }
    return true;
}

inline bool generate_solved_grid(
    const sudoku_hpc::GenericTopology& topo,
    std::mt19937_64& rng,
    std::vector<uint16_t>& out_solution) {
    sudoku_hpc::GenericSolvedKernel solved;
    if (!solved.generate(topo, rng, out_solution, nullptr)) return false;
    return validate_solved_grid(out_solution, topo);
}

inline bool find_hidden_single_trigger_puzzle(
    const sudoku_hpc::GenericTopology& topo,
    const std::vector<uint16_t>& solved_grid,
    std::mt19937_64& rng,
    std::vector<uint16_t>& out_puzzle) {
    sudoku_hpc::GenericLogicCertify logic;
    std::vector<int> order(static_cast<size_t>(topo.nn));
    std::iota(order.begin(), order.end(), 0);
    static thread_local sudoku_hpc::GenericBoard board;

    const int max_remove = std::max(2, std::min(12, topo.n));
    for (int attempt = 0; attempt < 256; ++attempt) {
        std::vector<uint16_t> puzzle = solved_grid;
        std::shuffle(order.begin(), order.end(), rng);
        const int remove_count = 2 + static_cast<int>(rng() % static_cast<uint64_t>(max_remove - 1));
        for (int i = 0; i < remove_count; ++i) {
            puzzle[static_cast<size_t>(order[static_cast<size_t>(i)])] = 0;
        }

        board.reset(topo);
        if (!board.init_from_puzzle(puzzle, false)) continue;

        bool has_naked_single = false;
        for (int idx = 0; idx < topo.nn; ++idx) {
            if (puzzle[static_cast<size_t>(idx)] != 0) continue;
            const uint64_t mask = board.candidate_mask_for_idx(idx);
            if (std::popcount(mask) <= 1) {
                has_naked_single = true;
                break;
            }
        }
        if (has_naked_single) continue;

        const auto cert = logic.certify_up_to_level(puzzle, topo, 1, nullptr, false);
        if (cert.used_hidden_single && !cert.timed_out) {
            out_puzzle = std::move(puzzle);
            return true;
        }
    }
    return false;
}

inline TestResult test_geometry_recognition_catalog() {
    TestResult result;
    result.name = "GeometryCatalogRecognition";
    const auto start = std::chrono::steady_clock::now();

    sudoku_hpc::geometria::zainicjalizuj_geometrie();
    const auto& expected = get_expected_supported_geometries();
    std::vector<std::string> missing;
    missing.reserve(expected.size());
    for (const auto& g : expected) {
        if (!sudoku_hpc::geometria::czy_obslugiwana(g.N, g.box_rows, g.box_cols)) {
            missing.push_back(g.desc);
        }
    }

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = missing.empty();
    if (missing.empty()) {
        result.message = std::to_string(expected.size()) + "/" + std::to_string(expected.size()) + " geometries recognized";
    } else {
        result.message = std::to_string(expected.size() - missing.size()) + "/" + std::to_string(expected.size()) +
            " recognized; missing: " + missing.front();
        if (missing.size() > 1) {
            result.message += " (+" + std::to_string(missing.size() - 1) + " more)";
        }
    }
    return result;
}

inline TestResult test_asymmetric_generation(int box_rows, int box_cols, uint64_t seed) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "AsymmetricGen " + std::to_string(n) + "x" + std::to_string(n) +
        " (" + std::to_string(box_rows) + "x" + std::to_string(box_cols) + ")";
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;

    std::mt19937_64 rng(seed);
    int passed = 0;
    const int attempts = 3;
    std::vector<uint16_t> solved;
    for (int i = 0; i < attempts; ++i) {
        if (generate_solved_grid(topo, rng, solved)) {
            ++passed;
        }
    }

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = (passed == attempts);
    result.message = std::to_string(passed) + "/" + std::to_string(attempts) + " grids valid";
    return result;
}

inline TestResult test_naked_single_asymmetric(int box_rows, int box_cols, uint64_t seed) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "NakedSingle " + std::to_string(n) + "x" + std::to_string(n) +
        " (" + std::to_string(box_rows) + "x" + std::to_string(box_cols) + ")";
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;

    std::mt19937_64 rng(seed);
    std::vector<uint16_t> solved;
    if (!generate_solved_grid(topo, rng, solved)) {
        result.passed = false;
        result.message = "Failed to generate solved board";
        return result;
    }

    std::vector<uint16_t> puzzle = solved;
    const int idx = static_cast<int>(rng() % static_cast<uint64_t>(topo.nn));
    puzzle[static_cast<size_t>(idx)] = 0;

    sudoku_hpc::GenericLogicCertify logic;
    const auto cert = logic.certify_up_to_level(puzzle, topo, 1, nullptr, true);

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = cert.solved && cert.used_naked_single && cert.solved_grid == solved;
    result.message = result.passed ? "Naked Single applied correctly" : "Naked Single failed";
    return result;
}

inline TestResult test_hidden_single_asymmetric(int box_rows, int box_cols, uint64_t seed) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "HiddenSingle " + std::to_string(n) + "x" + std::to_string(n) +
        " (" + std::to_string(box_rows) + "x" + std::to_string(box_cols) + ")";
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;

    std::mt19937_64 rng(seed);
    std::vector<uint16_t> solved;
    if (!generate_solved_grid(topo, rng, solved)) {
        result.passed = false;
        result.message = "Failed to generate solved board";
        return result;
    }

    std::vector<uint16_t> puzzle;
    if (!find_hidden_single_trigger_puzzle(topo, solved, rng, puzzle)) {
        const auto end = std::chrono::steady_clock::now();
        result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
        result.passed = false;
        result.message = "Could not construct Hidden Single trigger puzzle";
        return result;
    }

    sudoku_hpc::GenericLogicCertify logic;
    const auto cert = logic.certify_up_to_level(puzzle, topo, 1, nullptr, false);

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = cert.used_hidden_single && !cert.timed_out;
    result.message = result.passed ? "Hidden Single applied correctly" : "Hidden Single failed";
    return result;
}

inline TestResult test_level1_full_solve(int box_rows, int box_cols, uint64_t seed) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "Level1Full " + std::to_string(n) + "x" + std::to_string(n) +
        " (" + std::to_string(box_rows) + "x" + std::to_string(box_cols) + ")";
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;

    std::mt19937_64 rng(seed);
    std::vector<uint16_t> solved;
    if (!generate_solved_grid(topo, rng, solved)) {
        result.passed = false;
        result.message = "Failed to generate solved board";
        return result;
    }

    std::vector<uint16_t> puzzle = solved;
    const int idx = static_cast<int>(rng() % static_cast<uint64_t>(topo.nn));
    puzzle[static_cast<size_t>(idx)] = 0;

    sudoku_hpc::GenericLogicCertify logic;
    const auto cert = logic.certify_up_to_level(puzzle, topo, 1, nullptr, true);

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = cert.solved && cert.solved_grid == solved &&
        (cert.used_naked_single || cert.used_hidden_single);
    result.message = result.passed ? "Solved by Level 1 only" : "Level 1 full solve failed";
    return result;
}

template <int N>
inline TestResult test_asymmetric_generation(int box_rows, int box_cols, uint64_t seed) {
    if (box_rows * box_cols != N) {
        TestResult r;
        r.passed = false;
        r.name = "AsymmetricGeneration N-check";
        r.message = "Geometry mismatch with compile-time N";
        return r;
    }
    return test_asymmetric_generation(box_rows, box_cols, seed);
}

template <int N>
inline TestResult test_naked_single_asymmetric(int box_rows, int box_cols, uint64_t seed) {
    if (box_rows * box_cols != N) {
        TestResult r;
        r.passed = false;
        r.name = "NakedSingle N-check";
        r.message = "Geometry mismatch with compile-time N";
        return r;
    }
    return test_naked_single_asymmetric(box_rows, box_cols, seed);
}

template <int N>
inline TestResult test_hidden_single_asymmetric(int box_rows, int box_cols, uint64_t seed) {
    if (box_rows * box_cols != N) {
        TestResult r;
        r.passed = false;
        r.name = "HiddenSingle N-check";
        r.message = "Geometry mismatch with compile-time N";
        return r;
    }
    return test_hidden_single_asymmetric(box_rows, box_cols, seed);
}

template <int N>
inline TestResult test_level1_full_solve(int box_rows, int box_cols, uint64_t seed) {
    if (box_rows * box_cols != N) {
        TestResult r;
        r.passed = false;
        r.name = "Level1FullSolve N-check";
        r.message = "Geometry mismatch with compile-time N";
        return r;
    }
    return test_level1_full_solve(box_rows, box_cols, seed);
}

inline void run_level1_asymmetric_tests(
    const std::string& report_path = "level1_asymmetric_report.txt",
    int timeout_minutes = -1,
    int case_timeout_s = -1) {
    const std::string progress_path = level1_progress_path_from_report(report_path);
    std::ofstream report(report_path);
    if (!report) {
        report.open("level1_asymmetric_report.txt");
        if (!report) return;
    }
    report << std::unitbuf;
    std::ofstream progress(progress_path, std::ios::out | std::ios::trunc);
    if (progress) progress << std::unitbuf;

    std::atomic<int> total_tests{0};
    std::atomic<int> passed_tests{0};

    const auto& geometries = get_asymmetric_geometries();
    auto is_supported_test_n = [](int n) -> bool {
        return n == 6 || n == 8 || n == 10 || n == 12 || n == 15 || n == 16 || n == 18 || n == 20;
    };
    std::vector<const AsymmetricGeometry*> tested_geometries;
    for (const auto& g : geometries) {
        if (is_supported_test_n(g.N)) tested_geometries.push_back(&g);
    }
    std::sort(tested_geometries.begin(), tested_geometries.end(), [](const AsymmetricGeometry* a, const AsymmetricGeometry* b) {
        if (a->N != b->N) return a->N < b->N;
        if (a->box_rows != b->box_rows) return a->box_rows < b->box_rows;
        return a->box_cols < b->box_cols;
    });

    const int planned_tests = 1 + static_cast<int>(tested_geometries.size()) * 4;
    int completed_tests = 0;
    const auto suite_start = std::chrono::steady_clock::now();
    const int timeout_s = level1_timeout_seconds_from_minutes_or_env(timeout_minutes);
    const int configured_case_timeout_s = level1_case_timeout_seconds_from_arg_or_env(case_timeout_s);
    const bool timeout_enabled = timeout_s > 0;
    const auto deadline = suite_start + std::chrono::seconds(timeout_enabled ? timeout_s : 0);

    auto elapsed_ms = [&]() -> double {
        return std::chrono::duration<double, std::milli>(std::chrono::steady_clock::now() - suite_start).count();
    };
    auto timeout_reached = [&]() -> bool {
        return timeout_enabled && std::chrono::steady_clock::now() >= deadline;
    };
    auto progress_log = [&](const std::string& line) {
        if (!progress) return;
        progress << line << "\n";
        progress.flush();
    };
    auto effective_case_timeout_s = [&]() -> int {
        int out = configured_case_timeout_s;
        if (out <= 0) return 0;
        if (timeout_enabled) {
            const auto now = std::chrono::steady_clock::now();
            if (now >= deadline) return 0;
            const int remain_s = static_cast<int>(std::chrono::duration_cast<std::chrono::seconds>(deadline - now).count());
            out = std::max(1, std::min(out, remain_s));
        }
        return out;
    };
    auto run_case_with_hard_timeout = [&](const std::string& stage,
                                          const std::string& geo,
                                          const std::string& case_name,
                                          auto fn) -> TestResult {
        const int hard_limit_s = effective_case_timeout_s();
        if (hard_limit_s <= 0) {
            TestResult tr;
            tr.passed = false;
            tr.name = case_name;
            tr.message = "SKIPPED: hard timeout budget exhausted";
            return tr;
        }
        std::promise<TestResult> promise;
        std::future<TestResult> future = promise.get_future();
        std::thread([p = std::move(promise), fn = std::move(fn), case_name]() mutable {
            try {
                TestResult r = fn();
                if (r.name.empty()) r.name = case_name;
                p.set_value(std::move(r));
            } catch (const std::exception& e) {
                TestResult r;
                r.passed = false;
                r.name = case_name;
                r.message = std::string("Exception: ") + e.what();
                p.set_value(std::move(r));
            } catch (...) {
                TestResult r;
                r.passed = false;
                r.name = case_name;
                r.message = "Unknown exception";
                p.set_value(std::move(r));
            }
        }).detach();

        if (future.wait_for(std::chrono::seconds(hard_limit_s)) == std::future_status::ready) {
            return future.get();
        }

        TestResult timeout_result;
        timeout_result.passed = false;
        timeout_result.name = case_name;
        timeout_result.message = "HARD_TIMEOUT per-case (" + std::to_string(hard_limit_s) + "s)";
        timeout_result.elapsed_ms = static_cast<double>(hard_limit_s) * 1000.0;
        progress_log("CASE_TIMEOUT stage=" + stage + " geo=" + geo + " test=" + case_name);
        return timeout_result;
    };

    bool timed_out = false;
    report << "ASYMMETRIC GEOMETRY TEST SUITE - LEVEL 1 STRATEGIES (NEW API)\n";
    report << "============================================================\n\n";
    report << "Timeout limit: " << (timeout_enabled ? (std::to_string(timeout_s) + "s") : std::string("none")) << "\n";
    report << "Per-case hard timeout: " << (configured_case_timeout_s > 0 ? (std::to_string(configured_case_timeout_s) + "s") : std::string("off")) << "\n";
    report << "Planned tests: " << planned_tests << "\n\n";
    progress_log("planned_tests=" + std::to_string(planned_tests));

    auto run_and_record = [&](const std::string& stage, const std::string& geo, auto fn) {
        if (timeout_reached()) {
            timed_out = true;
            return;
        }
        TestResult r = run_case_with_hard_timeout(stage, geo, stage, std::move(fn));
        if (r.passed) ++passed_tests;
        ++total_tests;
        ++completed_tests;
        report << " " << stage << " (" << geo << ")\n";
        report << "  " << r.message << " (" << std::fixed << std::setprecision(2) << r.elapsed_ms << "ms)\n";
        progress_log("DONE " + stage + " geo=" + geo + " pass=" + (r.passed ? "1" : "0"));
    };

    run_and_record("GeometryCatalogRecognition", "catalog", [] {
        return test_geometry_recognition_catalog();
    });

    for (const auto* geo_ptr : tested_geometries) {
        if (timed_out) break;
        const auto& geo = *geo_ptr;
        run_and_record("AsymmetricGen", geo.desc, [&]() {
            return test_asymmetric_generation(geo.box_rows, geo.box_cols, geo.test_seed);
        });
        if (timed_out) break;
        run_and_record("NakedSingle", geo.desc, [&]() {
            return test_naked_single_asymmetric(geo.box_rows, geo.box_cols, geo.test_seed);
        });
        if (timed_out) break;
        run_and_record("HiddenSingle", geo.desc, [&]() {
            return test_hidden_single_asymmetric(geo.box_rows, geo.box_cols, geo.test_seed);
        });
        if (timed_out) break;
        run_and_record("Level1Full", geo.desc, [&]() {
            return test_level1_full_solve(geo.box_rows, geo.box_cols, geo.test_seed);
        });
    }

    report << "\n============================================================================\n";
    report << "SUMMARY\n";
    report << "============================================================================\n";
    report << "Total:  " << total_tests.load() << "\n";
    report << "Passed: " << passed_tests.load() << "\n";
    report << "Failed: " << (total_tests.load() - passed_tests.load()) << "\n";
    report << "Rate:   " << std::fixed << std::setprecision(1)
           << (100.0 * passed_tests.load() / std::max(1, total_tests.load())) << "%\n";
    report << "Completed/planned: " << completed_tests << "/" << planned_tests << "\n";
    report << "Suite elapsed: " << std::fixed << std::setprecision(2) << elapsed_ms() << "ms\n";
    report << "Timeout reached: " << (timed_out ? "yes" : "no") << "\n";
    report << "\n" << ((passed_tests.load() == total_tests.load() && !timed_out) ? "ALL TESTS PASSED" : "SOME TESTS FAILED") << "\n";
    report.close();

    progress_log("FINISH completed=" + std::to_string(completed_tests) + "/" + std::to_string(planned_tests));
    if (progress) progress.close();

    std::cout << "\n=== LEVEL 1 ASYMMETRIC TEST SUMMARY ===\n";
    std::cout << "Total: " << total_tests.load()
              << ", Passed: " << passed_tests.load()
              << ", Failed: " << (total_tests.load() - passed_tests.load()) << "\n";
    std::cout << "Report: " << report_path << "\n";
    std::cout << "Progress: " << progress_path << "\n";
}

} // namespace sudoku_testy

#endif // STRATEGIE_LEVEL1_TESTS_H



==============================================================================
PLIK: Sources\TESTS_cpp\test_regression.cpp
==============================================================================

// ============================================================================
// SUDOKU HPC - PROSTE TESTY REGRESYJNE (NOWE API)
// Plik: test_regression.cpp
// Uwaga: brak include guard - ten plik jest wciagany jako unity-include
// ============================================================================

#include <algorithm>
#include <atomic>
#include <bit>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <random>
#include <string>
#include <vector>

#include "../config.h"
#include "../board.h"
#include "../kernels.h"

namespace sudoku_testy {

struct TestResult {
    bool passed = false;
    std::string name;
    std::string message;
    double elapsed_ms = 0.0;
};

struct SeedEntry {
    int box_rows = 0;
    int box_cols = 0;
    uint64_t seed = 0;
    const char* desc = "";
};

inline const std::vector<SeedEntry>& get_seed_corpus() {
    static const std::vector<SeedEntry> corpus = {
        {2, 3, 1001, "6x6 basic"},
        {3, 2, 1002, "6x6 alt"},
        {2, 4, 2001, "8x8 basic"},
        {3, 3, 3001, "9x9 basic"},
        {3, 3, 12345, "9x9 seed12345"},
        {3, 3, 54321, "9x9 seed54321"},
        {4, 4, 6001, "16x16 basic"},
        {2, 8, 6002, "16x16 alt"},
    };
    return corpus;
}

inline int get_seed_corpus_size() {
    return static_cast<int>(get_seed_corpus().size());
}

inline int timeout_seconds_from_minutes_or_env(int timeout_minutes, const char* env_name) {
    if (timeout_minutes >= 0) {
        if (timeout_minutes == 0) return 0;
        return std::max(1, timeout_minutes) * 60;
    }
    const char* raw = std::getenv(env_name);
    if (raw == nullptr || *raw == '\0') return 0;
    try {
        return std::max(0, std::stoi(std::string(raw)));
    } catch (...) {
        return 0;
    }
}

inline bool validate_solved_grid(const std::vector<uint16_t>& grid, const sudoku_hpc::GenericTopology& topo) {
    if (static_cast<int>(grid.size()) != topo.nn) return false;
    for (int idx = 0; idx < topo.nn; ++idx) {
        const int d = static_cast<int>(grid[static_cast<size_t>(idx)]);
        if (d < 1 || d > topo.n) return false;
    }
    const int house_count = static_cast<int>(topo.house_offsets.size()) - 1;
    for (int h = 0; h < house_count; ++h) {
        uint64_t seen = 0ULL;
        const int p0 = topo.house_offsets[static_cast<size_t>(h)];
        const int p1 = topo.house_offsets[static_cast<size_t>(h + 1)];
        for (int p = p0; p < p1; ++p) {
            const int idx = topo.houses_flat[static_cast<size_t>(p)];
            const int d = static_cast<int>(grid[static_cast<size_t>(idx)]);
            const uint64_t bit = (1ULL << (d - 1));
            if ((seen & bit) != 0ULL) return false;
            seen |= bit;
        }
        if (std::popcount(seen) != topo.n) return false;
    }
    return true;
}

inline TestResult test_generation_sanity(int box_rows, int box_cols, uint64_t seed, int count = 3) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "Sanity " + std::to_string(n) + "x" + std::to_string(n) +
                  " seed=" + std::to_string(seed);
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;
    sudoku_hpc::GenericSolvedKernel solved_kernel;
    std::mt19937_64 rng(seed);

    int passed = 0;
    std::vector<uint16_t> solved;
    for (int i = 0; i < count; ++i) {
        if (!solved_kernel.generate(topo, rng, solved, nullptr)) continue;
        if (validate_solved_grid(solved, topo)) ++passed;
    }

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = (passed == count);
    result.message = std::to_string(passed) + "/" + std::to_string(count) + " generated grids valid";
    return result;
}

inline TestResult test_no_contradictions(int box_rows, int box_cols, uint64_t seed, int count = 5) {
    TestResult result;
    const int n = box_rows * box_cols;
    result.name = "NoContradictions " + std::to_string(n) + "x" + std::to_string(n);
    const auto start = std::chrono::steady_clock::now();

    const auto topo_opt = sudoku_hpc::GenericTopology::build(box_rows, box_cols);
    if (!topo_opt.has_value()) {
        result.passed = false;
        result.message = "Topology build failed";
        return result;
    }
    const auto& topo = *topo_opt;
    std::mt19937_64 rng(seed);

    int passed = 0;
    std::vector<int> order(static_cast<size_t>(topo.nn));
    std::iota(order.begin(), order.end(), 0);
    std::vector<uint16_t> filled;
    filled.resize(static_cast<size_t>(topo.nn), 0);
    static thread_local sudoku_hpc::GenericBoard board;

    for (int i = 0; i < count; ++i) {
        board.reset(topo);
        std::shuffle(order.begin(), order.end(), rng);
        bool contradiction = false;

        for (int idx : order) {
            const uint64_t mask = board.candidate_mask_for_idx(idx);
            if (mask == 0ULL) {
                contradiction = true;
                break;
            }
            int digits[64];
            const int dcount = sudoku_hpc::shuffled_digits_from_mask(mask, rng, digits);
            if (dcount <= 0) {
                contradiction = true;
                break;
            }
            board.place(idx, digits[0]);
        }

        if (!contradiction && board.all_filled()) {
            std::copy(board.values.begin(), board.values.end(), filled.begin());
            if (validate_solved_grid(filled, topo)) {
                ++passed;
            }
        }
    }

    const auto end = std::chrono::steady_clock::now();
    result.elapsed_ms = std::chrono::duration<double, std::milli>(end - start).count();
    result.passed = true;  // test informacyjny
    result.message = std::to_string(passed) + "/" + std::to_string(count) + " no contradictions (info only)";
    return result;
}

inline void run_all_regression_tests(
    const std::string& report_path,
    int timeout_minutes) {
    std::ofstream report(report_path);
    if (!report) {
        report.open("regression_report.txt");
        if (!report) return;
    }
    report << std::unitbuf;

    std::atomic<int> total_tests{0};
    std::atomic<int> passed_tests{0};
    int completed_tests = 0;
    int planned_tests = 0;
    bool timed_out = false;

    const auto suite_start = std::chrono::steady_clock::now();
    const int timeout_s = timeout_seconds_from_minutes_or_env(timeout_minutes, "SUDOKU_REGRESSION_TIMEOUT_S");
    const bool timeout_enabled = timeout_s > 0;
    const auto deadline = suite_start + std::chrono::seconds(timeout_enabled ? timeout_s : 0);
    auto timeout_reached = [&]() -> bool {
        return timeout_enabled && std::chrono::steady_clock::now() >= deadline;
    };
    auto elapsed_ms = [&]() -> double {
        return std::chrono::duration<double, std::milli>(std::chrono::steady_clock::now() - suite_start).count();
    };

    const auto& corpus = get_seed_corpus();
    std::vector<SeedEntry> ordered_corpus(corpus.begin(), corpus.end());
    std::sort(ordered_corpus.begin(), ordered_corpus.end(), [](const SeedEntry& a, const SeedEntry& b) {
        const int an = a.box_rows * a.box_cols;
        const int bn = b.box_rows * b.box_cols;
        if (an != bn) return an < bn;
        if (a.box_rows != b.box_rows) return a.box_rows < b.box_rows;
        if (a.box_cols != b.box_cols) return a.box_cols < b.box_cols;
        return a.seed < b.seed;
    });

    auto is_supported_n = [](int n) -> bool {
        return n == 6 || n == 8 || n == 9 || n == 16;
    };
    for (const auto& entry : ordered_corpus) {
        if (is_supported_n(entry.box_rows * entry.box_cols)) planned_tests += 2;
    }

    report << "SEED CORPUS: " << corpus.size() << " entries\n\n";
    report << "Timeout limit: " << (timeout_enabled ? (std::to_string(timeout_s) + "s") : std::string("none")) << "\n";
    report << "Order: rosnaco po N (male -> duze)\n";
    report << "Planned tests: " << planned_tests << "\n\n";

    report << "=== TEST 1: GENERATION SANITY ===\n\n";
    for (const auto& entry : ordered_corpus) {
        if (timeout_reached()) {
            timed_out = true;
            report << "TIMEOUT reached before seed=" << entry.seed << " in TEST 1\n";
            break;
        }
        const int n = entry.box_rows * entry.box_cols;
        TestResult r;
        if (n == 6) r = test_generation_sanity(entry.box_rows, entry.box_cols, entry.seed, 3);
        else if (n == 8) r = test_generation_sanity(entry.box_rows, entry.box_cols, entry.seed, 3);
        else if (n == 9) r = test_generation_sanity(entry.box_rows, entry.box_cols, entry.seed, 5);
        else if (n == 16) r = test_generation_sanity(entry.box_rows, entry.box_cols, entry.seed, 2);
        else continue;

        if (r.passed) ++passed_tests;
        ++total_tests;
        ++completed_tests;
        report << " " << r.name << " (" << entry.desc << ")\n";
        report << "  " << r.message << " (" << std::fixed << std::setprecision(2) << r.elapsed_ms << "ms)\n";
    }

    report << "\n=== TEST 2: NO CONTRADICTIONS ===\n\n";
    if (!timed_out) {
        for (const auto& entry : ordered_corpus) {
            if (timeout_reached()) {
                timed_out = true;
                report << "TIMEOUT reached before seed=" << entry.seed << " in TEST 2\n";
                break;
            }
            const int n = entry.box_rows * entry.box_cols;
            TestResult r;
            if (n == 6) r = test_no_contradictions(entry.box_rows, entry.box_cols, entry.seed, 5);
            else if (n == 8) r = test_no_contradictions(entry.box_rows, entry.box_cols, entry.seed, 5);
            else if (n == 9) r = test_no_contradictions(entry.box_rows, entry.box_cols, entry.seed, 5);
            else if (n == 16) r = test_no_contradictions(entry.box_rows, entry.box_cols, entry.seed, 3);
            else continue;

            if (r.passed) ++passed_tests;
            ++total_tests;
            ++completed_tests;
            report << " " << r.name << " (" << entry.desc << ")\n";
            report << "  " << r.message << " (" << std::fixed << std::setprecision(2) << r.elapsed_ms << "ms)\n";
        }
    }

    report << "\n============================================================================\n";
    report << "SUMMARY\n";
    report << "============================================================================\n";
    report << "Total:  " << total_tests.load() << "\n";
    report << "Passed: " << passed_tests.load() << "\n";
    report << "Failed: " << (total_tests.load() - passed_tests.load()) << "\n";
    report << "Rate:   " << std::fixed << std::setprecision(1)
           << (100.0 * passed_tests.load() / std::max(1, total_tests.load())) << "%\n";
    report << "Completed/planned: " << completed_tests << "/" << planned_tests << "\n";
    report << "Suite elapsed: " << std::fixed << std::setprecision(2) << elapsed_ms() << "ms\n";
    report << "Timeout reached: " << (timed_out ? "yes" : "no") << "\n";

    const bool all_passed = (passed_tests.load() == total_tests.load());
    if (timed_out) report << "\nTEST STOPPED BY TIME LIMIT\n";
    else report << "\n" << (all_passed ? "ALL TESTS PASSED" : "SOME TESTS FAILED") << "\n";
    report.close();

    std::cout << "\n=== REGRESSION TEST SUMMARY ===\n";
    std::cout << "Total: " << total_tests.load()
              << ", Passed: " << passed_tests.load()
              << ", Failed: " << (total_tests.load() - passed_tests.load()) << "\n";
    std::cout << "Report: " << report_path << "\n";
}

inline void run_all_regression_tests(const std::string& report_path = "regression_report.txt") {
    run_all_regression_tests(report_path, -1);
}

} // namespace sudoku_testy



==============================================================================
PLIK: Sources\utils.h
==============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <atomic>
#include <chrono>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <random>
#include <sstream>
#include <thread>
#include <optional>

namespace sudoku_hpc {
uint64_t splitmix64(uint64_t& state) {
    uint64_t z = (state += 0x9e3779b97f4a7c15ULL);
    z = (z ^ (z >> 30u)) * 0xbf58476d1ce4e5b9ULL;
    z = (z ^ (z >> 27u)) * 0x94d049bb133111ebULL;
    return z ^ (z >> 31u);
}

inline int popcnt64(uint64_t v) {
    return std::popcount(v);
}

inline int single_digit_from_mask(uint64_t mask) {
    if (mask == 0 || (mask & (mask - 1ULL)) != 0) {
        return 0;
    }
    return std::countr_zero(mask) + 1;
}

inline int cell_row(int idx) {
    return idx / kN;
}

inline int cell_col(int idx) {
    return idx % kN;
}

inline int box_index(int row, int col) {
    return (row / kBoxRows) * kBoxRows + (col / kBoxCols);
}

// VIP Premium Feature: Generate a rich HTML visualizer of the generated Sudoku grid
inline void export_to_html(const std::string& filename, const std::string& puzzle, const std::string& solution) {
    std::ofstream out(filename);
    if(!out) return;
    out << "<!DOCTYPE html>\n<html>\n<head>\n<title>Sudoku Premium Viewer</title>\n";
    out << "<style>\nbody { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1e1e24; color: #f4f4f9; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; }\n";
    out << ".grid { display: grid; grid-template-columns: repeat(9, 60px); grid-template-rows: repeat(9, 60px); gap: 2px; background-color: #f4f4f9; padding: 4px; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }\n";
    out << ".cell { display: flex; align-items: center; justify-content: center; background-color: #2b2b36; font-size: 24px; font-weight: bold; color: #4dcad6; }\n";
    out << ".cell.clue { color: #f4f4f9; background-color: #3b3b4d; }\n";
    out << ".cell:nth-child(3n) { margin-right: 4px; }\n.cell.row-3, .cell.row-6 { margin-bottom: 4px; }\n";
    out << "h1 { color: #4dcad6; font-size: 3em; margin-bottom: 0.5em; text-transform: uppercase; letter-spacing: 2px; }\n";
    out << "</style>\n</head>\n<body>\n<h1>Premium Sudoku</h1>\n<div class='grid'>\n";
    
    for (int i=0; i<81; ++i) {
        std::string extra_cls = "";
        int r = i / 9;
        if (r == 2 || r == 5) extra_cls += " row-3"; // simple trick for bold bottom border
        
        char p = (i < puzzle.size()) ? puzzle[i] : '0';
        char s = (i < solution.size()) ? solution[i] : '0';
        
        if (p != '0' && p != '.') {
            out << "<div class='cell clue" << extra_cls << "'>" << p << "</div>\n";
        } else {
            out << "<div class='cell" << extra_cls << "'>" << s << "</div>\n";
        }
    }
    out << "</div>\n</body>\n</html>\n";
}


} // namespace sudoku_hpc



==============================================================================
PLIK: Sudoku Level Generator RewertynPL.cpp
==============================================================================


//Author copyright Marcin Matysek (Rewertyn)

#include <algorithm>
#include <array>
#include <atomic>
#include <chrono>
#include <cctype>
#include <cmath>
#include <cstdint>
#include <bit>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <functional>
#include <exception>
#include <memory>
#include <mutex>
#include <map>
#include <numeric>
#include <optional>
#include <random>
#include <set>
#include <shared_mutex>
#include <sstream>
#include <string>
#include <string_view>
#include <thread>
#include <ctime>
#include <vector>
#include <cstdio>
#include <cwctype>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#include <windowsx.h>
#include <psapi.h>
#include <io.h>
#include <conio.h>
#include <tlhelp32.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shlobj.h>
#ifdef _MSC_VER
#pragma comment(lib, "Comctl32.lib")
#pragma comment(lib, "Comdlg32.lib")
#pragma comment(lib, "Shell32.lib")
#endif
#endif

// Move generic implementations to board.h
#include "Sources/config.h"
#include "Sources/utils.h"
#include "Sources/board.h"
#include "Sources/kernels.h"
#include "Sources/sudoku_logic_engine.h"
#include "Sources/dlx.h"
#include "Sources/benchmark.h"
#include "Sources/profiler.h"
#include "Sources/monitor.h"
#include "Sources/sudoku_generate_pipeline.h"
#include "Sources/generator_main.h"
#include "Sources/benchmark_profiles.h"
#include "Sources/gui.h"

// StrategieSource (zaawansowane strategie) są kompilowane osobno w testach/regresji.
// Rdzeń GUI/generatora korzysta wyłącznie z generycznego solvera logiki.

// Include test regression for --run-regression-tests support
#include "Sources/TESTS_cpp/test_regression.cpp"

namespace sudoku_hpc {
    extern int run_gui_winapi(HINSTANCE hinst);
    
    // Funkcje pomocnicze dla main
    inline void run_benchmark_mode(const GenerateRunConfig& cfg) {
        log_info("benchmark", "Starting benchmark mode");
        std::cout << "Running benchmark profiles...\n";
        
        const auto report = run_benchmark_profiles_40s(cfg);
        
        // Save report to file
        std::ofstream out(cfg.benchmark_output_file);
        if (out) {
            out << report.to_text();
            out.close();
            std::cout << "Report saved to: " << cfg.benchmark_output_file << "\n";
        }
        
        // Also print to console
        std::cout << "\n" << report.to_text() << "\n";
    }
    
    inline void handle_result(const GenerateRunResult& result, const GenerateRunConfig& cfg) {
        std::cout << "\n=== Generation Summary ===\n";
        std::cout << "Accepted: " << result.accepted << "\n";
        std::cout << "Written: " << result.written << "\n";
        std::cout << "Attempts: " << result.attempts << "\n";
        std::cout << "Rejected: " << result.rejected << "\n";
        std::cout << "  - Prefilter: " << result.reject_prefilter << "\n";
        std::cout << "  - Logic: " << result.reject_logic << "\n";
        std::cout << "  - Uniqueness: " << result.reject_uniqueness << "\n";
        std::cout << "  - Strategy: " << result.reject_strategy << "\n";
        std::cout << "  - Replay: " << result.reject_replay << "\n";
        std::cout << "  - DistributionBias: " << result.reject_distribution_bias << "\n";
        std::cout << "  - UniquenessBudget: " << result.reject_uniqueness_budget << "\n";
        std::cout << "Uniqueness calls: " << result.uniqueness_calls << "\n";
        std::cout << "Uniqueness nodes: " << result.uniqueness_nodes << "\n";
        std::cout << "Uniqueness total: " << std::fixed << std::setprecision(3) << result.uniqueness_elapsed_ms << " ms\n";
        std::cout << "Uniqueness avg: " << std::fixed << std::setprecision(3) << result.uniqueness_avg_ms << " ms/call\n";
        std::cout << "CPU backend: " << result.cpu_backend_selected << "\n";
        std::cout << "Kernel time: " << std::fixed << std::setprecision(3) << result.kernel_time_ms << " ms\n";
        std::cout << "Kernel calls: " << result.kernel_calls << "\n";
        std::cout << "Backend efficiency score: " << std::fixed << std::setprecision(3) << result.backend_efficiency_score << "\n";
        std::cout << "Asymmetry efficiency index: " << std::fixed << std::setprecision(3) << result.asymmetry_efficiency_index << "\n";
        std::cout << "Logic steps total: " << result.logic_steps_total << "\n";
        std::cout << "Naked hit/use: " << result.strategy_naked_hit << "/" << result.strategy_naked_use << "\n";
        std::cout << "Hidden hit/use: " << result.strategy_hidden_hit << "/" << result.strategy_hidden_use << "\n";
        std::cout << "VIP score: " << std::fixed << std::setprecision(3) << result.vip_score << "\n";
        std::cout << "VIP grade: " << result.vip_grade << "\n";
        std::cout << "VIP contract: " << (result.vip_contract_ok ? "ok" : "fail") << "\n";
        std::cout << "VIP contract reason: " << result.vip_contract_fail_reason << "\n";
        std::cout << "Premium signature: " << result.premium_signature << "\n";
        std::cout << "Premium signature v2: " << result.premium_signature_v2 << "\n";
        std::cout << "Time: " << std::fixed << std::setprecision(2) << result.elapsed_s << "s\n";
        std::cout << "Rate: " << std::fixed << std::setprecision(2) << result.accepted_per_sec << " puzzles/s\n";
        
        if (cfg.pause_on_exit_windows) {
            std::cout << "\nPress Enter to exit...";
            std::cin.get();
        }
    }

    inline void print_production_help(std::ostream& out) {
        out << "Sudoku Generator (production)\n";
        out << "Usage:\n";
        out << "  sudoku_gen.exe [options]\n\n";
        out << "Common options:\n";
        out << "  --help, -h                      Show this help\n";
        out << "  --box-rows <int>                Box rows\n";
        out << "  --box-cols <int>                Box cols\n";
        out << "  --difficulty <1..9>             Difficulty level\n";
        out << "  --required-strategy <name>      none|nakedsingle|hiddensingle|backtracking\n";
        out << "  --target <uint64>               Target puzzles to generate\n";
        out << "  --threads <int>                 Worker threads (0=auto)\n";
        out << "  --seed <int64>                  RNG seed (0=random)\n";
        out << "  --output-folder <path>          Output directory\n";
        out << "  --output-file <name>            Output batch file name\n";
        out << "  --single-file-only              Disable per-puzzle files\n";
        out << "  --pattern-forcing               Enable Pattern Forcing + DLX bridge\n";
        out << "  --pattern-forcing-tries <int>   Attempts per pattern seed (default 6)\n";
        out << "  --pattern-anchor-count <int>    Anchors for pattern seed (0=auto)\n";
        out << "  --no-pattern-lock-anchors       Allow digger to remove planted anchors\n";
        out << "  --mcts-digger                   Enable MCTS UCB1 bottleneck digger\n";
        out << "  --mcts-profile <auto|p7|p8|off> Tuning profile for advanced digger scoring\n";
        out << "  --mcts-p7                       Shortcut: --mcts-profile p7 + enable digger\n";
        out << "  --mcts-p8                       Shortcut: --mcts-profile p8 + enable digger\n";
        out << "  --mcts-iterations <int>         MCTS iteration cap (0=auto)\n";
        out << "  --mcts-ucb-c <float>            UCB exploration factor (default 1.41)\n";
        out << "  --mcts-fail-cap <int>           Consecutive fail stop limit\n";
        out << "  --mcts-basic-level <1..5>       Basic logic ceiling for bottleneck\n";
        out << "  --max-total-time-s <uint64>     Global runtime timeout (0=none)\n";
        out << "  --list-geometries               Print supported geometries\n";
        out << "  --validate-geometry             Validate current --box-rows/--box-cols\n";
        out << "  --validate-geometry-catalog     Validate full geometry catalog\n";
        out << "  --run-regression-tests          Run regression tests and exit\n";
        out << "  --gui                           Force GUI mode (Windows)\n";
        out << "  --cli                           Force CLI mode (Windows)\n\n";
        out << "Examples:\n";
        out << "  sudoku_gen.exe --box-rows 3 --box-cols 3 --difficulty 1 --target 100 --threads 16\n";
        out << "  sudoku_gen.exe --list-geometries\n";
        out << "  sudoku_gen.exe --validate-geometry --box-rows 4 --box-cols 3\n";
    }

#ifdef _WIN32
    inline bool can_use_cli_hotkeys() {
        return _isatty(_fileno(stdin)) != 0 && _isatty(_fileno(stdout)) != 0;
    }

    inline const char* cli_state_label(bool cancel_requested, bool paused) {
        if (cancel_requested) {
            return "cancel_requested";
        }
        if (paused) {
            return "paused";
        }
        return "running";
    }

    inline void print_cli_hotkeys_help() {
        std::cout << "CLI controls: [P] pause/resume, [C] cancel, [Q] cancel\n";
    }

    inline std::jthread start_cli_hotkeys_thread(std::atomic<bool>& cancel_flag, std::atomic<bool>& pause_flag) {
        return std::jthread([&cancel_flag, &pause_flag](std::stop_token st) {
            while (!st.stop_requested()) {
                if (_kbhit() == 0) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(50));
                    continue;
                }
                int ch = _getch();
                if (ch == 0 || ch == 224) {
                    (void)_getch();  // consume extended key code
                    continue;
                }
                const char key = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
                if (key == 'p') {
                    const bool now_paused = !pause_flag.load(std::memory_order_relaxed);
                    pause_flag.store(now_paused, std::memory_order_relaxed);
                    std::cout << "\n[CLI] " << (now_paused ? "paused" : "resumed") << "\n" << std::flush;
                    log_info("main.cli_hotkeys", now_paused ? "paused" : "resumed");
                } else if (key == 'c' || key == 'q') {
                    pause_flag.store(false, std::memory_order_relaxed);
                    cancel_flag.store(true, std::memory_order_relaxed);
                    std::cout << "\n[CLI] cancel requested\n" << std::flush;
                    log_info("main.cli_hotkeys", "cancel requested");
                } else if (key == 'h' || key == '?') {
                    print_cli_hotkeys_help();
                }
            }
        });
    }

    inline std::jthread start_cli_status_thread(std::atomic<bool>& cancel_flag, std::atomic<bool>& pause_flag) {
        return std::jthread([&cancel_flag, &pause_flag](std::stop_token st) {
            while (!st.stop_requested()) {
                std::this_thread::sleep_for(std::chrono::seconds(3));
                if (st.stop_requested()) {
                    break;
                }
                const bool cancel_requested = cancel_flag.load(std::memory_order_relaxed);
                const bool paused = pause_flag.load(std::memory_order_relaxed);
                std::cout << "[CLI] state=" << cli_state_label(cancel_requested, paused) << "\n" << std::flush;
            }
        });
    }
#endif
}

int main(int argc, char** argv) {
    using namespace sudoku_hpc;
    log_info("main", "program start");
    std::cout << "Debug log file: " << debug_logger().path() << "\n";

    if (has_arg(argc, argv, "--help") || has_arg(argc, argv, "-h") || has_arg(argc, argv, "/?")) {
        print_production_help(std::cout);
        return 0;
    }

#ifdef _WIN32
    const bool force_gui = has_arg(argc, argv, "--gui");
    const bool force_cli = has_arg(argc, argv, "--cli");
    const bool force_console = has_arg(argc, argv, "--force-console");
    if ((argc == 1 || force_gui) && !force_cli) {
        log_info("main", "starting GUI mode");
        if (force_console) {
            ensure_console_attached();
        }
        return run_gui_winapi(GetModuleHandleW(nullptr));
    }
#endif

    ParseArgsResult parse_result = parse_args(argc, argv);
    GenerateRunConfig cfg = parse_result.cfg;
    if (parse_result.list_geometries) {
        std::cout << supported_geometries_text();
        return 0;
    }
    if (parse_result.validate_geometry) {
        const bool ok = print_geometry_validation(cfg.box_rows, cfg.box_cols, std::cout);
        return ok ? 0 : 1;
    }
    if (parse_result.validate_geometry_catalog) {
        const bool ok = print_geometry_catalog_validation(std::cout);
        return ok ? 0 : 1;
    }
    if (cfg.stage_start) {
        return run_stage_start_cli(cfg);
    }
    if (cfg.stage_end) {
        return run_stage_end_cli(cfg);
    }
    if (cfg.perf_ab_suite) {
        return run_perf_ab_suite_cli(cfg);
    }
    if (parse_result.run_geometry_gate) {
        return run_geometry_gate_cli(parse_result.geometry_gate_report, &cfg);
    }
    if (parse_result.run_quality_benchmark) {
        return run_quality_benchmark_cli(
            parse_result.quality_benchmark_report,
            parse_result.quality_benchmark_max_cases,
            &cfg);
    }
    if (parse_result.run_pre_difficulty_gate) {
        return run_pre_difficulty_gate_cli(
            parse_result.pre_difficulty_gate_report,
            cfg,
            parse_result.quality_benchmark_max_cases);
    }
    if (parse_result.run_asym_pair_benchmark) {
        return run_asym_pair_benchmark_cli(
            parse_result.asym_pair_benchmark_report,
            parse_result.quality_benchmark_max_cases,
            &cfg);
    }
    if (parse_result.run_vip_benchmark) {
        return run_vip_benchmark_cli(
            parse_result.vip_benchmark_report,
            cfg,
            parse_result.quality_benchmark_max_cases);
    }
    if (parse_result.run_vip_gate) {
        return run_vip_gate_cli(
            parse_result.vip_gate_report,
            cfg,
            parse_result.quality_benchmark_max_cases);
    }
    if (parse_result.explain_profile) {
        std::cout << explain_generation_profile_text(cfg);
        return 0;
    }
    if (parse_result.benchmark_mode) {
        run_benchmark_mode(cfg);
        return 0;
    }
    
    // Default Run
    std::atomic<bool> cancel_flag{false};
    std::atomic<bool> pause_flag{false};
#ifdef _WIN32
    std::jthread cli_hotkeys_thread;
    std::jthread cli_status_thread;
    if (can_use_cli_hotkeys()) {
        print_cli_hotkeys_help();
        cli_hotkeys_thread = start_cli_hotkeys_thread(cancel_flag, pause_flag);
        cli_status_thread = start_cli_status_thread(cancel_flag, pause_flag);
    }
#endif
    ConsoleStatsMonitor monitor;
    monitor.start_ui_thread(5000);
    auto result = run_generic_sudoku(cfg, &monitor, &cancel_flag, &pause_flag, nullptr, nullptr);
    monitor.stop_ui_thread();
#ifdef _WIN32
    if (cli_hotkeys_thread.joinable()) {
        cli_hotkeys_thread.request_stop();
        cli_hotkeys_thread.join();
    }
    if (cli_status_thread.joinable()) {
        cli_status_thread.request_stop();
        cli_status_thread.join();
    }
#endif
    handle_result(result, cfg);
    return 0;
}


