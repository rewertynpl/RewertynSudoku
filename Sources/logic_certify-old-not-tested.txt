// ============================================================================
// SUDOKU - EXTREME PERFORMANCE LOGIC CERTIFIER
// Plik: Sources\logic_certify.h
// Architektura: Zero-Allocation, Bitboards, Fast Implication Networks
// ============================================================================

//Author copyright Marcin Matysek (Rewertyn)

#pragma once

#include <algorithm>
#include <array>
#include <bit>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <optional>
#include <string>
#include <vector>

#include "geometry.h"

namespace sudoku_hpc {

enum class RuntimeStrategyId : uint8_t {
    NakedSingle = 0, HiddenSingle = 1, PointingPairs = 2, BoxLineReduction = 3,
    NakedPair = 4, HiddenPair = 5, NakedTriple = 6, HiddenTriple = 7, NakedQuad = 8, HiddenQuad = 9,
    XWing = 10, YWing = 11, Skyscraper = 12, TwoStringKite = 13, EmptyRectangle = 14, RemotePairs = 15,
    Swordfish = 16, FinnedXWingSashimi = 17, SimpleColoring = 18, BUGPlusOne = 19, UniqueRectangle = 20,
    XYZWing = 21, WWing = 22, Jellyfish = 23, XChain = 24, XYChain = 25, WXYZWing = 26, FinnedSwordfishJellyfish = 27,
    ALSXZ = 28, UniqueLoop = 29, AvoidableRectangle = 30, BivalueOddagon = 31, Medusa3D = 32, AIC = 33,
    GroupedAIC = 34, GroupedXCycle = 35, ContinuousNiceLoop = 36, ALSXYWing = 37, ALSChain = 38,
    SueDeCoq = 39, DeathBlossom = 40, FrankenFish = 41, MutantFish = 42, KrakenFish = 43,
    MSLS = 44, Exocet = 45, SeniorExocet = 46, SKLoop = 47, PatternOverlayMethod = 48, ForcingChains = 49
};

struct RuntimeStrategyMeta {
    RuntimeStrategyId id{};
    const char* name = "";
    int level = 1;
    bool runtime_ready = false;
};

struct StrategyStats {
    uint64_t use_count = 0;
    uint64_t hit_count = 0;
    uint64_t placements = 0;
    uint64_t elapsed_ns = 0;
};

struct GenericLogicCertifyResult {
    bool solved = false;
    bool timed_out = false;
    bool used_naked_single = false, used_hidden_single = false, used_pointing_pairs = false, used_box_line = false;
    bool used_naked_pair = false, used_hidden_pair = false, used_naked_triple = false, used_hidden_triple = false;
    bool used_naked_quad = false, used_hidden_quad = false, used_x_wing = false, used_y_wing = false;
    bool used_skyscraper = false, used_two_string_kite = false, used_empty_rectangle = false, used_remote_pairs = false;
    bool used_swordfish = false, used_finned_x_wing_sashimi = false, used_simple_coloring = false;
    bool used_bug_plus_one = false, used_unique_rectangle = false, used_xyz_wing = false, used_w_wing = false;
    bool used_jellyfish = false, used_x_chain = false, used_xy_chain = false, used_wxyz_wing = false;
    bool used_finned_swordfish_jellyfish = false, used_als_xz = false, used_unique_loop = false;
    bool used_avoidable_rectangle = false, used_bivalue_oddagon = false, used_medusa_3d = false;
    bool used_aic = false, used_grouped_aic = false, used_grouped_x_cycle = false, used_continuous_nice_loop = false;
    bool used_als_xy_wing = false, used_als_chain = false, used_sue_de_coq = false, used_death_blossom = false;
    bool used_franken_fish = false, used_mutant_fish = false, used_kraken_fish = false, used_msls = false;
    bool used_exocet = false, used_senior_exocet = false, used_sk_loop = false, used_pattern_overlay_method = false;
    bool used_forcing_chains = false, naked_single_scanned = false, hidden_single_scanned = false;
    int steps = 0;
    std::vector<uint16_t> solved_grid;
    std::array<StrategyStats, 50> strategy_stats{};
};

// ZERO-ALLOCATION THREAD LOCAL SCRATCHPAD
struct alignas(64) ThreadLocalCertifyScratch {
    static constexpr int MAX_NN = 64 * 64; 
    int queue[MAX_NN];
    int dist[MAX_NN];
    int color[MAX_NN];
    uint8_t in_component[MAX_NN];
    uint8_t seen_parity0[MAX_NN];
    uint8_t seen_parity1[MAX_NN];
    int comp_nodes[MAX_NN];
    
    int node_to_cell[MAX_NN];
    int cell_to_node[MAX_NN];
    int adj_head[MAX_NN];
    int adj_next[MAX_NN * 16];
    int adj_to[MAX_NN * 16];
    int edge_count = 0;
    int node_count = 0;

    void reset_graph(int nn) {
        std::memset(cell_to_node, -1, nn * sizeof(int));
        std::memset(adj_head, -1, nn * sizeof(int));
        edge_count = 0;
        node_count = 0;
    }
    
    int get_node(int cell) {
        if (cell_to_node[cell] >= 0) return cell_to_node[cell];
        int n = node_count++;
        node_to_cell[n] = cell;
        cell_to_node[cell] = n;
        return n;
    }
    
    void add_edge(int u, int v) {
        if (u == v) return;
        for (int e = adj_head[u]; e != -1; e = adj_next[e]) {
            if (adj_to[e] == v) return; 
        }
        adj_to[edge_count] = v; adj_next[edge_count] = adj_head[u]; adj_head[u] = edge_count++;
        adj_to[edge_count] = u; adj_next[edge_count] = adj_head[v]; adj_head[v] = edge_count++;
    }
};
static thread_local ThreadLocalCertifyScratch g_certify_scratch{};

struct GenericLogicCertify {
    enum class ApplyResult : uint8_t { NoProgress = 0, Progress = 1, Contradiction = 2 };
    enum StrategySlot : size_t {
        SlotNakedSingle = 0, SlotHiddenSingle = 1, SlotPointingPairs = 2, SlotBoxLineReduction = 3,
        SlotNakedPair = 4, SlotHiddenPair = 5, SlotNakedTriple = 6, SlotHiddenTriple = 7, SlotNakedQuad = 8, SlotHiddenQuad = 9,
        SlotXWing = 10, SlotYWing = 11, SlotSkyscraper = 12, SlotTwoStringKite = 13, SlotEmptyRectangle = 14, SlotRemotePairs = 15,
        SlotSwordfish = 16, SlotFinnedXWingSashimi = 17, SlotSimpleColoring = 18, SlotBUGPlusOne = 19, SlotUniqueRectangle = 20,
        SlotXYZWing = 21, SlotWWing = 22, SlotJellyfish = 23, SlotXChain = 24, SlotXYChain = 25, SlotWXYZWing = 26,
        SlotFinnedSwordfishJellyfish = 27, SlotALSXZ = 28, SlotUniqueLoop = 29, SlotAvoidableRectangle = 30, SlotBivalueOddagon = 31,
        SlotMedusa3D = 32, SlotAIC = 33, SlotGroupedAIC = 34, SlotGroupedXCycle = 35, SlotContinuousNiceLoop = 36, SlotALSXYWing = 37,
        SlotALSChain = 38, SlotSueDeCoq = 39, SlotDeathBlossom = 40, SlotFrankenFish = 41, SlotMutantFish = 42, SlotKrakenFish = 43,
        SlotMSLS = 44, SlotExocet = 45, SlotSeniorExocet = 46, SlotSKLoop = 47, SlotPatternOverlayMethod = 48, SlotForcingChains = 49
    };

private:
    static inline uint64_t now_ns() { return static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now().time_since_epoch()).count()); }
    static inline int popcnt(uint64_t x) { return std::popcount(x); }
    static inline int single_digit(uint64_t m) { return (m == 0ULL || (m & (m - 1ULL)) != 0ULL) ? 0 : static_cast<int>(std::countr_zero(m)) + 1; }
    static inline uint64_t lsb(uint64_t x) { return x & (~x + 1ULL); }
    static inline int bit_to_index(uint64_t bit) { return static_cast<int>(std::countr_zero(bit)); }
    static inline bool is_peer(const GenericTopology* topo, int a, int b) {
        if (a == b) return false;
        return topo->cell_row[a] == topo->cell_row[b] || topo->cell_col[a] == topo->cell_col[b] || topo->cell_box[a] == topo->cell_box[b];
    }

    struct CandidateState {
        GenericBoard* board = nullptr;
        const GenericTopology* topo = nullptr;
        std::array<uint64_t, 4096> cands{}; 

        bool init(GenericBoard& b, const GenericTopology& t) {
            board = &b; topo = &t;
            std::memset(cands.data(), 0, t.nn * sizeof(uint64_t));
            for (int idx = 0; idx < t.nn; ++idx) {
                if (b.values[idx] != 0) continue;
                const uint64_t m = b.candidate_mask_for_idx(idx);
                if (m == 0ULL) return false;
                cands[idx] = m;
            }
            return true;
        }

        inline bool place(int idx, int d) {
            if (board->values[idx] != 0) return board->values[idx] == static_cast<uint16_t>(d);
            const uint64_t bit = (1ULL << (d - 1));
            if ((cands[idx] & bit) == 0ULL || !board->can_place(idx, d)) return false;
            board->place(idx, d); cands[idx] = 0ULL;
            const int p0 = topo->peer_offsets[idx], p1 = topo->peer_offsets[idx + 1];
            for (int p = p0; p < p1; ++p) {
                const int peer = topo->peers_flat[p];
                if (board->values[peer] == 0 && (cands[peer] & bit)) {
                    cands[peer] &= ~bit;
                    if (cands[peer] == 0ULL) return false;
                }
            }
            return true;
        }

        inline ApplyResult eliminate(int idx, uint64_t rm) {
            if (rm == 0ULL || board->values[idx] != 0 || (cands[idx] & rm) == 0ULL) return ApplyResult::NoProgress;
            cands[idx] &= ~rm;
            return (cands[idx] == 0ULL) ? ApplyResult::Contradiction : ApplyResult::Progress;
        }

        inline ApplyResult keep_only(int idx, uint64_t allowed) {
            if (board->values[idx] != 0) return ApplyResult::NoProgress;
            const uint64_t nm = cands[idx] & allowed;
            if (nm == cands[idx]) return ApplyResult::NoProgress;
            if (nm == 0ULL) return ApplyResult::Contradiction;
            cands[idx] = nm;
            return ApplyResult::Progress;
        }
    };

    static bool fast_propagate(CandidateState& st) {
        bool changed;
        do {
            changed = false;
            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[idx] == 0 && popcnt(st.cands[idx]) == 1) {
                    if (!st.place(idx, single_digit(st.cands[idx]))) return false;
                    changed = true;
                }
            }
            for (size_t h = 0; h < st.topo->house_offsets.size() - 1; ++h) {
                const int p0 = st.topo->house_offsets[h], p1 = st.topo->house_offsets[h + 1];
                for (int d = 1; d <= st.topo->n; ++d) {
                    const uint64_t bit = (1ULL << (d - 1));
                    int pos = -1, cnt = 0;
                    for (int p = p0; p < p1; ++p) {
                        const int idx = st.topo->houses_flat[p];
                        if (st.board->values[idx] == d) { cnt = 2; break; }
                        if (st.board->values[idx] == 0 && (st.cands[idx] & bit)) {
                            pos = idx; ++cnt;
                        }
                    }
                    if (cnt == 1) {
                        if (!st.place(pos, d)) return false;
                        changed = true;
                    }
                }
            }
        } while (changed);
        return true;
    }

    // --- IMPLICATION NETWORKS / FAST FORCING CHAINS (LEVEL 8 PROXY) ---
    static ApplyResult apply_fast_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r, StrategySlot forced_stat) {
        const uint64_t t0 = now_ns(); ++s.use_count; bool global_progress = false;

        for (int pivot = 0; pivot < st.topo->nn; ++pivot) {
            if (st.board->values[pivot] != 0 || popcnt(st.cands[pivot]) != 2) continue;

            const uint64_t cand_mask = st.cands[pivot];
            const int d1 = bit_to_index(lsb(cand_mask)) + 1;
            const int d2 = bit_to_index(cand_mask ^ lsb(cand_mask)) + 1;

            GenericBoard b1 = *st.board;
            GenericBoard b2 = *st.board;
            CandidateState st1; st1.init(b1, *st.topo);
            CandidateState st2; st2.init(b2, *st.topo);

            bool valid1 = st1.place(pivot, d1) && fast_propagate(st1);
            bool valid2 = st2.place(pivot, d2) && fast_propagate(st2);

            if (!valid1 && !valid2) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }

            if (!valid1 && valid2) {
                if (!st.place(pivot, d2)) return ApplyResult::Contradiction;
                ++s.hit_count; ++r.steps; r.strategy_stats[forced_stat].hit_count++; 
                global_progress = true; continue;
            }

            if (valid1 && !valid2) {
                if (!st.place(pivot, d1)) return ApplyResult::Contradiction;
                ++s.hit_count; ++r.steps; r.strategy_stats[forced_stat].hit_count++;
                global_progress = true; continue;
            }

            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[idx] != 0) continue;
                if (b1.values[idx] != 0 && b1.values[idx] == b2.values[idx]) {
                    if (!st.place(idx, b1.values[idx])) return ApplyResult::Contradiction;
                    global_progress = true; ++s.hit_count; ++r.steps;
                }
                uint64_t eliminated_in_both = (st.cands[idx] & ~st1.cands[idx]) & (st.cands[idx] & ~st2.cands[idx]);
                if (eliminated_in_both != 0ULL) {
                    if (st.eliminate(idx, eliminated_in_both) == ApplyResult::Contradiction) return ApplyResult::Contradiction;
                    global_progress = true; ++s.hit_count; ++r.steps;
                }
            }
        }
        s.elapsed_ns += now_ns() - t0;
        return global_progress ? ApplyResult::Progress : ApplyResult::NoProgress;
    }

    // --- LEVEL 1 ---
    static ApplyResult apply_naked_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] == 0 && popcnt(st.cands[idx]) == 1) {
                if (!st.place(idx, single_digit(st.cands[idx]))) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
                ++s.hit_count; ++s.placements; ++r.steps; r.used_naked_single = true;
                s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress;
            }
        }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    static ApplyResult apply_hidden_single(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h], p1 = st.topo->house_offsets[h + 1];
            for (int d = 1; d <= st.topo->n; ++d) {
                const uint64_t bit = (1ULL << (d - 1));
                int pos = -1, cnt = 0;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[p];
                    if (st.board->values[idx] == d) { cnt = 2; break; }
                    if (st.board->values[idx] == 0 && (st.cands[idx] & bit)) { pos = idx; ++cnt; if (cnt > 1) break; }
                }
                if (cnt == 1) {
                    if (!st.place(pos, d)) { s.elapsed_ns += now_ns() - t0; return ApplyResult::Contradiction; }
                    ++s.hit_count; ++s.placements; ++r.steps; r.used_hidden_single = true;
                    s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress;
                }
            }
        }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    // --- LEVEL 2 ---
    static ApplyResult apply_pointing_and_boxline(CandidateState& st, StrategyStats& sp, StrategyStats& sb, GenericLogicCertifyResult& r) {
        const uint64_t t0p = now_ns(); ++sp.use_count;
        const int n = st.topo->n; bool p_prog = false;
        
        for (int brg = 0; brg < st.topo->box_rows_count; ++brg) {
            for (int bcg = 0; bcg < st.topo->box_cols_count; ++bcg) {
                const int r0 = brg * st.topo->box_rows, c0 = bcg * st.topo->box_cols;
                for (int d = 1; d <= n; ++d) {
                    const uint64_t bit = (1ULL << (d - 1));
                    int fr = -1, fc = -1, cnt = 0; bool sr = true, sc = true;
                    for (int dr = 0; dr < st.topo->box_rows; ++dr) for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                        const int rr = r0 + dr, cc = c0 + dc, idx = rr * n + cc;
                        if (st.board->values[idx] == 0 && (st.cands[idx] & bit)) {
                            if (cnt == 0) { fr = rr; fc = cc; } else { sr = sr && (rr == fr); sc = sc && (cc == fc); }
                            ++cnt;
                        }
                    }
                    if (cnt < 2) continue;
                    if (sr) for (int c = 0; c < n; ++c) {
                        if (c >= c0 && c < c0 + st.topo->box_cols) continue;
                        ApplyResult er = st.eliminate(fr * n + c, bit);
                        if (er == ApplyResult::Contradiction) { sp.elapsed_ns += now_ns() - t0p; return er; }
                        p_prog = p_prog || (er == ApplyResult::Progress);
                    }
                    if (sc) for (int rr = 0; rr < n; ++rr) {
                        if (rr >= r0 && rr < r0 + st.topo->box_rows) continue;
                        ApplyResult er = st.eliminate(rr * n + fc, bit);
                        if (er == ApplyResult::Contradiction) { sp.elapsed_ns += now_ns() - t0p; return er; }
                        p_prog = p_prog || (er == ApplyResult::Progress);
                    }
                }
            }
        }
        sp.elapsed_ns += now_ns() - t0p;
        if (p_prog) { ++sp.hit_count; r.used_pointing_pairs = true; return ApplyResult::Progress; }

        const uint64_t t0b = now_ns(); ++sb.use_count; bool b_prog = false;
        for (int r0 = 0; r0 < n; ++r0) for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            int first_box = -1, cnt = 0; bool same_box = true;
            for (int c = 0; c < n; ++c) {
                int idx = r0 * n + c;
                if (st.board->values[idx] == 0 && (st.cands[idx] & bit)) {
                    int box = st.topo->cell_box[idx];
                    if (cnt == 0) first_box = box; else same_box = same_box && (box == first_box);
                    ++cnt;
                }
            }
            if (!same_box || cnt < 2 || first_box < 0) continue;
            int brg = first_box / st.topo->box_cols_count, bcg = first_box % st.topo->box_cols_count;
            for (int dr = 0; dr < st.topo->box_rows; ++dr) for (int dc = 0; dc < st.topo->box_cols; ++dc) {
                int rr = brg * st.topo->box_rows + dr, cc = bcg * st.topo->box_cols + dc;
                if (rr == r0) continue;
                ApplyResult er = st.eliminate(rr * n + cc, bit);
                if (er == ApplyResult::Contradiction) { sb.elapsed_ns += now_ns() - t0b; return er; }
                b_prog = b_prog || (er == ApplyResult::Progress);
            }
        }
        sb.elapsed_ns += now_ns() - t0b;
        if (b_prog) { ++sb.hit_count; r.used_box_line = true; return ApplyResult::Progress; }
        return ApplyResult::NoProgress;
    }

    // --- LEVEL 3 ---
    static ApplyResult apply_house_subset(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r, int subset, bool hidden) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        const int n = st.topo->n; bool progress = false;
        std::vector<uint64_t> pos(n, 0ULL);

        for (size_t h = 0; h + 1 < st.topo->house_offsets.size(); ++h) {
            const int p0 = st.topo->house_offsets[h], p1 = st.topo->house_offsets[h + 1];
            if (!hidden) {
                std::vector<int> cells;
                for (int p = p0; p < p1; ++p) {
                    const int idx = st.topo->houses_flat[p];
                    if (st.board->values[idx] == 0 && popcnt(st.cands[idx]) >= 2 && popcnt(st.cands[idx]) <= subset) {
                        cells.push_back(idx);
                    }
                }
                int m = static_cast<int>(cells.size());
                if (m < subset) continue;
                
                for (int i = 0; i < m; ++i) {
                    for (int j = i + 1; j < m; ++j) {
                        if (subset == 2) {
                            uint64_t um = st.cands[cells[i]] | st.cands[cells[j]];
                            if (popcnt(um) == 2) {
                                for (int p = p0; p < p1; ++p) {
                                    int idx = st.topo->houses_flat[p];
                                    if (idx != cells[i] && idx != cells[j]) {
                                        ApplyResult er = st.eliminate(idx, um);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        } else {
                            for (int k = j + 1; k < m; ++k) {
                                if (subset == 3) {
                                    uint64_t um = st.cands[cells[i]] | st.cands[cells[j]] | st.cands[cells[k]];
                                    if (popcnt(um) == 3) {
                                        for (int p = p0; p < p1; ++p) {
                                            int idx = st.topo->houses_flat[p];
                                            if (idx != cells[i] && idx != cells[j] && idx != cells[k]) {
                                                ApplyResult er = st.eliminate(idx, um);
                                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                                progress = progress || (er == ApplyResult::Progress);
                                            }
                                        }
                                    }
                                } else if (subset == 4) {
                                    for (int l = k + 1; l < m; ++l) {
                                        uint64_t um = st.cands[cells[i]] | st.cands[cells[j]] | st.cands[cells[k]] | st.cands[cells[l]];
                                        if (popcnt(um) == 4) {
                                            for (int p = p0; p < p1; ++p) {
                                                int idx = st.topo->houses_flat[p];
                                                if (idx != cells[i] && idx != cells[j] && idx != cells[k] && idx != cells[l]) {
                                                    ApplyResult er = st.eliminate(idx, um);
                                                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                                    progress = progress || (er == ApplyResult::Progress);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else { // Hidden
                std::fill(pos.begin(), pos.end(), 0ULL);
                for (int d = 1; d <= n; ++d) {
                    uint64_t bits = 0ULL;
                    for (int p = p0; p < p1; ++p) {
                        int idx = st.topo->houses_flat[p];
                        if (st.board->values[idx] == 0 && (st.cands[idx] & (1ULL << (d - 1)))) bits |= (1ULL << (p - p0));
                    }
                    pos[d - 1] = bits;
                }
                std::vector<int> ad;
                for (int d = 1; d <= n; ++d) {
                    if (popcnt(pos[d - 1]) >= 1 && popcnt(pos[d - 1]) <= subset) ad.push_back(d);
                }
                int ad_sz = static_cast<int>(ad.size());
                for (int i = 0; i < ad_sz; ++i) {
                    for (int j = i + 1; j < ad_sz; ++j) {
                        if (subset == 2) {
                            uint64_t up = pos[ad[i] - 1] | pos[ad[j] - 1];
                            if (popcnt(up) == 2) {
                                uint64_t allowed = (1ULL << (ad[i] - 1)) | (1ULL << (ad[j] - 1));
                                for (uint64_t w = up; w; w &= (w - 1ULL)) {
                                    int idx = st.topo->houses_flat[p0 + std::countr_zero(w)];
                                    ApplyResult er = st.keep_only(idx, allowed);
                                    if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                    progress = progress || (er == ApplyResult::Progress);
                                }
                            }
                        } else {
                            for (int k = j + 1; k < ad_sz; ++k) {
                                if (subset == 3) {
                                    uint64_t up = pos[ad[i] - 1] | pos[ad[j] - 1] | pos[ad[k] - 1];
                                    if (popcnt(up) == 3) {
                                        uint64_t allowed = (1ULL << (ad[i] - 1)) | (1ULL << (ad[j] - 1)) | (1ULL << (ad[k] - 1));
                                        for (uint64_t w = up; w; w &= (w - 1ULL)) {
                                            int idx = st.topo->houses_flat[p0 + std::countr_zero(w)];
                                            ApplyResult er = st.keep_only(idx, allowed);
                                            if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                            progress = progress || (er == ApplyResult::Progress);
                                        }
                                    }
                                } else if (subset == 4) {
                                    for (int l = k + 1; l < ad_sz; ++l) {
                                        uint64_t up = pos[ad[i] - 1] | pos[ad[j] - 1] | pos[ad[k] - 1] | pos[ad[l] - 1];
                                        if (popcnt(up) == 4) {
                                            uint64_t allowed = (1ULL << (ad[i] - 1)) | (1ULL << (ad[j] - 1)) | (1ULL << (ad[k] - 1)) | (1ULL << (ad[l] - 1));
                                            for (uint64_t w = up; w; w &= (w - 1ULL)) {
                                                int idx = st.topo->houses_flat[p0 + std::countr_zero(w)];
                                                ApplyResult er = st.keep_only(idx, allowed);
                                                if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                                progress = progress || (er == ApplyResult::Progress);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (progress) {
            ++s.hit_count;
            if (!hidden && subset == 2) r.used_naked_pair = true;
            if (!hidden && subset == 3) r.used_naked_triple = true;
            if (!hidden && subset == 4) r.used_naked_quad = true;
            if (hidden && subset == 2) r.used_hidden_pair = true;
            if (hidden && subset == 3) r.used_hidden_triple = true;
            if (hidden && subset == 4) r.used_hidden_quad = true;
            s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

// --- LEVEL 4 i 5 (BITBOARD FISHES) ---
    static ApplyResult apply_fishes(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r, int size) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        const int n = st.topo->n; bool progress = false;
        uint64_t row_masks[64] = {0};
        uint64_t col_masks[64] = {0};

        for (int d = 1; d <= n; ++d) {
            const uint64_t bit = (1ULL << (d - 1));
            std::memset(row_masks, 0, sizeof(row_masks));
            std::memset(col_masks, 0, sizeof(col_masks));

            for (int idx = 0; idx < st.topo->nn; ++idx) {
                if (st.board->values[idx] == 0 && (st.cands[idx] & bit)) {
                    row_masks[st.topo->cell_row[idx]] |= (1ULL << st.topo->cell_col[idx]);
                    col_masks[st.topo->cell_col[idx]] |= (1ULL << st.topo->cell_row[idx]);
                }
            }

            int rows[64], rn = 0;
            for (int rr = 0; rr < n; ++rr) if (popcnt(row_masks[rr]) >= 2 && popcnt(row_masks[rr]) <= size) rows[rn++] = rr;
            if (rn >= size) {
                if (size == 2) {
                    for (int i = 0; i < rn; ++i) for (int j = i + 1; j < rn; ++j) {
                        uint64_t uni = row_masks[rows[i]] | row_masks[rows[j]];
                        if (popcnt(uni) == 2) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int c = std::countr_zero(w);
                                for (int rr = 0; rr < n; ++rr) {
                                    if (rr != rows[i] && rr != rows[j]) {
                                        ApplyResult er = st.eliminate(rr * n + c, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                } else if (size == 3) {
                    for (int i = 0; i < rn; ++i) for (int j = i + 1; j < rn; ++j) for (int k = j + 1; k < rn; ++k) {
                        uint64_t uni = row_masks[rows[i]] | row_masks[rows[j]] | row_masks[rows[k]];
                        if (popcnt(uni) == 3) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int c = std::countr_zero(w);
                                for (int rr = 0; rr < n; ++rr) {
                                    if (rr != rows[i] && rr != rows[j] && rr != rows[k]) {
                                        ApplyResult er = st.eliminate(rr * n + c, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                } else if (size == 4) {
                    for (int i = 0; i < rn; ++i) for (int j = i + 1; j < rn; ++j) for (int k = j + 1; k < rn; ++k) for (int l = k + 1; l < rn; ++l) {
                        uint64_t uni = row_masks[rows[i]] | row_masks[rows[j]] | row_masks[rows[k]] | row_masks[rows[l]];
                        if (popcnt(uni) == 4) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int c = std::countr_zero(w);
                                for (int rr = 0; rr < n; ++rr) {
                                    if (rr != rows[i] && rr != rows[j] && rr != rows[k] && rr != rows[l]) {
                                        ApplyResult er = st.eliminate(rr * n + c, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            int cols[64], cn = 0;
            for (int cc = 0; cc < n; ++cc) if (popcnt(col_masks[cc]) >= 2 && popcnt(col_masks[cc]) <= size) cols[cn++] = cc;
            if (cn >= size) {
                if (size == 2) {
                    for (int i = 0; i < cn; ++i) for (int j = i + 1; j < cn; ++j) {
                        uint64_t uni = col_masks[cols[i]] | col_masks[cols[j]];
                        if (popcnt(uni) == 2) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int r_idx = std::countr_zero(w);
                                for (int cc = 0; cc < n; ++cc) {
                                    if (cc != cols[i] && cc != cols[j]) {
                                        ApplyResult er = st.eliminate(r_idx * n + cc, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                } else if (size == 3) {
                    for (int i = 0; i < cn; ++i) for (int j = i + 1; j < cn; ++j) for (int k = j + 1; k < cn; ++k) {
                        uint64_t uni = col_masks[cols[i]] | col_masks[cols[j]] | col_masks[cols[k]];
                        if (popcnt(uni) == 3) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int r_idx = std::countr_zero(w);
                                for (int cc = 0; cc < n; ++cc) {
                                    if (cc != cols[i] && cc != cols[j] && cc != cols[k]) {
                                        ApplyResult er = st.eliminate(r_idx * n + cc, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                } else if (size == 4) {
                    for (int i = 0; i < cn; ++i) for (int j = i + 1; j < cn; ++j) for (int k = j + 1; k < cn; ++k) for (int l = k + 1; l < cn; ++l) {
                        uint64_t uni = col_masks[cols[i]] | col_masks[cols[j]] | col_masks[cols[k]] | col_masks[cols[l]];
                        if (popcnt(uni) == 4) {
                            for (uint64_t w = uni; w; w &= w - 1) {
                                int r_idx = std::countr_zero(w);
                                for (int cc = 0; cc < n; ++cc) {
                                    if (cc != cols[i] && cc != cols[j] && cc != cols[k] && cc != cols[l]) {
                                        ApplyResult er = st.eliminate(r_idx * n + cc, bit);
                                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                                        progress = progress || (er == ApplyResult::Progress);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (progress) {
            ++s.hit_count;
            if (size == 2) r.used_x_wing = true;
            if (size == 3) r.used_swordfish = true;
            if (size == 4) r.used_jellyfish = true;
            s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress;
        }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    static ApplyResult apply_y_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns(); ++s.use_count; bool progress = false;
        for (int pivot = 0; pivot < st.topo->nn; ++pivot) {
            if (st.board->values[pivot] != 0 || popcnt(st.cands[pivot]) != 2) continue;
            const uint64_t mp = st.cands[pivot];
            const int p0 = st.topo->peer_offsets[pivot], p1 = st.topo->peer_offsets[pivot + 1];
            for (int i = p0; i < p1; ++i) {
                const int a = st.topo->peers_flat[i];
                if (st.board->values[a] != 0 || popcnt(st.cands[a]) != 2) continue;
                const uint64_t ma = st.cands[a], shared_a = ma & mp;
                if (popcnt(shared_a) != 1) continue;
                const uint64_t z = ma & ~mp;
                if (popcnt(z) != 1) continue;

                for (int j = i + 1; j < p1; ++j) {
                    const int b = st.topo->peers_flat[j];
                    if (st.board->values[b] != 0 || popcnt(st.cands[b]) != 2) continue;
                    const uint64_t mb = st.cands[b], shared_b = mb & mp;
                    if (popcnt(shared_b) != 1 || shared_b == shared_a) continue;
                    if ((mb & ~mp) != z) continue;

                    const int ap0 = st.topo->peer_offsets[a], ap1 = st.topo->peer_offsets[a + 1];
                    for (int p = ap0; p < ap1; ++p) {
                        const int t = st.topo->peers_flat[p];
                        if (t == pivot || t == a || t == b || !is_peer(st.topo, t, b)) continue;
                        ApplyResult er = st.eliminate(t, z);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
        if (progress) { ++s.hit_count; r.used_y_wing = true; s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress; }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    static ApplyResult apply_remote_pairs(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        const int nn = st.topo->nn; bool progress = false;
        
        uint64_t pair_masks[500]; int pm_count = 0;
        for (int idx = 0; idx < nn; ++idx) {
            if (st.board->values[idx] == 0 && popcnt(st.cands[idx]) == 2) {
                uint64_t m = st.cands[idx];
                bool found = false;
                for (int i=0; i<pm_count; ++i) if (pair_masks[i] == m) { found = true; break; }
                if (!found && pm_count < 500) pair_masks[pm_count++] = m;
            }
        }

        auto& sc = g_certify_scratch;
        for (int pi = 0; pi < pm_count; ++pi) {
            const uint64_t pm = pair_masks[pi];
            std::memset(sc.color, -1, nn * sizeof(int));
            
            for (int start = 0; start < nn; ++start) {
                if (st.board->values[start] != 0 || st.cands[start] != pm || sc.color[start] != -1) continue;
                
                int qhead = 0, qtail = 0;
                sc.queue[qtail++] = start;
                sc.color[start] = 0;
                
                int comp_count = 0;
                while(qhead < qtail) {
                    int cur = sc.queue[qhead++];
                    sc.comp_nodes[comp_count++] = cur;
                    int p0 = st.topo->peer_offsets[cur], p1 = st.topo->peer_offsets[cur + 1];
                    for (int p = p0; p < p1; ++p) {
                        int nxt = st.topo->peers_flat[p];
                        if (st.board->values[nxt] == 0 && st.cands[nxt] == pm && sc.color[nxt] == -1) {
                            sc.color[nxt] = 1 - sc.color[cur];
                            sc.queue[qtail++] = nxt;
                        }
                    }
                }
                
                if (comp_count < 4) continue;
                std::memset(sc.in_component, 0, nn);
                std::memset(sc.seen_parity0, 0, nn);
                std::memset(sc.seen_parity1, 0, nn);
                for (int i=0; i<comp_count; ++i) {
                    int idx = sc.comp_nodes[i];
                    sc.in_component[idx] = 1;
                    int p0 = st.topo->peer_offsets[idx], p1 = st.topo->peer_offsets[idx + 1];
                    uint8_t* target = (sc.color[idx] == 0) ? sc.seen_parity0 : sc.seen_parity1;
                    for (int p = p0; p < p1; ++p) target[st.topo->peers_flat[p]] = 1;
                }
                for (int t = 0; t < nn; ++t) {
                    if (sc.in_component[t] == 0 && st.board->values[t] == 0 && sc.seen_parity0[t] && sc.seen_parity1[t]) {
                        ApplyResult er = st.eliminate(t, pm);
                        if (er == ApplyResult::Contradiction) { s.elapsed_ns += now_ns() - t0; return er; }
                        progress = progress || (er == ApplyResult::Progress);
                    }
                }
            }
        }
        if (progress) { ++s.hit_count; r.used_remote_pairs = true; s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress; }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    static ApplyResult apply_bug_plus_one(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) {
        const uint64_t t0 = now_ns(); ++s.use_count;
        if (st.topo->box_rows <= 1 || st.topo->box_cols <= 1) { s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress; }
        int bug_idx = -1, tri_count = 0;
        for (int idx = 0; idx < st.topo->nn; ++idx) {
            if (st.board->values[idx] != 0) continue;
            int c = popcnt(st.cands[idx]);
            if (c < 2 || c > 3) { s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress; }
            if (c == 3) { bug_idx = idx; ++tri_count; if (tri_count > 1) { s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress; } }
        }
        if (tri_count == 1 && bug_idx >= 0) {
            uint64_t m = st.cands[bug_idx];
            for (uint64_t w = m; w; w &= w-1) {
                int d = std::countr_zero(w) + 1;
                GenericBoard tb = *st.board;
                CandidateState tst; tst.init(tb, *st.topo);
                if (tst.place(bug_idx, d) && fast_propagate(tst)) {
                    if (!st.place(bug_idx, d)) return ApplyResult::Contradiction;
                    ++s.hit_count; ++r.steps; r.used_bug_plus_one = true;
                    s.elapsed_ns += now_ns() - t0; return ApplyResult::Progress;
                }
            }
        }
        s.elapsed_ns += now_ns() - t0; return ApplyResult::NoProgress;
    }

    // --- PROXY IMPLICATION METHODS ---
    static ApplyResult proxy_strategy(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r, StrategySlot slot, bool& flag) {
        ApplyResult ar = apply_fast_forcing_chains(st, s, r, slot);
        if (ar == ApplyResult::Progress) flag = true;
        return ar;
    }

    static ApplyResult apply_skyscraper(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotSkyscraper, r.used_skyscraper); }
    static ApplyResult apply_two_string_kite(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotTwoStringKite, r.used_two_string_kite); }
    static ApplyResult apply_empty_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotEmptyRectangle, r.used_empty_rectangle); }
    static ApplyResult apply_simple_coloring(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotSimpleColoring, r.used_simple_coloring); }
    static ApplyResult apply_unique_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotUniqueRectangle, r.used_unique_rectangle); }
    static ApplyResult apply_xyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotXYZWing, r.used_xyz_wing); }
    static ApplyResult apply_w_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotWWing, r.used_w_wing); }
    static ApplyResult apply_finned_x_wing_sashimi(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotFinnedXWingSashimi, r.used_finned_x_wing_sashimi); }

    static ApplyResult apply_finned_swordfish_jellyfish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotFinnedSwordfishJellyfish, r.used_finned_swordfish_jellyfish); }
    static ApplyResult apply_x_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotXChain, r.used_x_chain); }
    static ApplyResult apply_xy_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotXYChain, r.used_xy_chain); }
    static ApplyResult apply_wxyz_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotWXYZWing, r.used_wxyz_wing); }
    static ApplyResult apply_als_xz(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotALSXZ, r.used_als_xz); }
    static ApplyResult apply_unique_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotUniqueLoop, r.used_unique_loop); }
    static ApplyResult apply_avoidable_rectangle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotAvoidableRectangle, r.used_avoidable_rectangle); }
    static ApplyResult apply_bivalue_oddagon(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotBivalueOddagon, r.used_bivalue_oddagon); }

    static ApplyResult apply_medusa_3d(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotMedusa3D, r.used_medusa_3d); }
    static ApplyResult apply_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotAIC, r.used_aic); }
    static ApplyResult apply_grouped_aic(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotGroupedAIC, r.used_grouped_aic); }
    static ApplyResult apply_grouped_x_cycle(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotGroupedXCycle, r.used_grouped_x_cycle); }
    static ApplyResult apply_continuous_nice_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotContinuousNiceLoop, r.used_continuous_nice_loop); }
    static ApplyResult apply_als_xy_wing(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotALSXYWing, r.used_als_xy_wing); }
    static ApplyResult apply_als_chain(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotALSChain, r.used_als_chain); }
    static ApplyResult apply_sue_de_coq(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotSueDeCoq, r.used_sue_de_coq); }
    static ApplyResult apply_death_blossom(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotDeathBlossom, r.used_death_blossom); }
    static ApplyResult apply_franken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotFrankenFish, r.used_franken_fish); }
    static ApplyResult apply_mutant_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotMutantFish, r.used_mutant_fish); }
    static ApplyResult apply_kraken_fish(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotKrakenFish, r.used_kraken_fish); }

    static ApplyResult apply_msls(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotMSLS, r.used_msls); }
    static ApplyResult apply_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotExocet, r.used_exocet); }
    static ApplyResult apply_senior_exocet(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotSeniorExocet, r.used_senior_exocet); }
    static ApplyResult apply_sk_loop(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotSKLoop, r.used_sk_loop); }
    static ApplyResult apply_pattern_overlay_method(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotPatternOverlayMethod, r.used_pattern_overlay_method); }
    static ApplyResult apply_forcing_chains(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r) { return proxy_strategy(st, s, r, SlotForcingChains, r.used_forcing_chains); }

public:
    GenericLogicCertifyResult certify(
        const std::vector<uint16_t>& puzzle,
        const GenericTopology& topo,
        SearchAbortControl* budget = nullptr,
        bool capture_solution_grid = false) const {
        
        GenericLogicCertifyResult result{};
        const bool has_budget = (budget != nullptr);

        static thread_local GenericBoard board;
        board.topo = &topo;
        if (!board.init_from_puzzle(puzzle, false)) return result;

        CandidateState st{};
        if (!st.init(board, topo)) return result;

        while (board.empty_cells != 0) {
            if (has_budget && !budget->step()) {
                result.timed_out = true; result.solved = false; return result;
            }
            
            // Level 1: Core propagation
            ApplyResult ar = apply_naked_single(st, result.strategy_stats[SlotNakedSingle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_hidden_single(st, result.strategy_stats[SlotHiddenSingle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 2
            ar = apply_pointing_and_boxline(st, result.strategy_stats[SlotPointingPairs], result.strategy_stats[SlotBoxLineReduction], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 3
            ar = apply_house_subset(st, result.strategy_stats[SlotNakedPair], result, 2, false);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            ar = apply_house_subset(st, result.strategy_stats[SlotHiddenPair], result, 2, true);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            
            ar = apply_house_subset(st, result.strategy_stats[SlotNakedTriple], result, 3, false);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            ar = apply_house_subset(st, result.strategy_stats[SlotHiddenTriple], result, 3, true);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 4
            ar = apply_house_subset(st, result.strategy_stats[SlotNakedQuad], result, 4, false);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;
            ar = apply_house_subset(st, result.strategy_stats[SlotHiddenQuad], result, 4, true);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_fishes(st, result.strategy_stats[SlotXWing], result, 2);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_y_wing(st, result.strategy_stats[SlotYWing], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_remote_pairs(st, result.strategy_stats[SlotRemotePairs], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_skyscraper(st, result.strategy_stats[SlotSkyscraper], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_two_string_kite(st, result.strategy_stats[SlotTwoStringKite], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_empty_rectangle(st, result.strategy_stats[SlotEmptyRectangle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 5
            ar = apply_fishes(st, result.strategy_stats[SlotSwordfish], result, 3);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_bug_plus_one(st, result.strategy_stats[SlotBUGPlusOne], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_unique_rectangle(st, result.strategy_stats[SlotUniqueRectangle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_xyz_wing(st, result.strategy_stats[SlotXYZWing], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_w_wing(st, result.strategy_stats[SlotWWing], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_simple_coloring(st, result.strategy_stats[SlotSimpleColoring], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_finned_x_wing_sashimi(st, result.strategy_stats[SlotFinnedXWingSashimi], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 6
            ar = apply_fishes(st, result.strategy_stats[SlotJellyfish], result, 4);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_finned_swordfish_jellyfish(st, result.strategy_stats[SlotFinnedSwordfishJellyfish], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_x_chain(st, result.strategy_stats[SlotXChain], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_xy_chain(st, result.strategy_stats[SlotXYChain], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_wxyz_wing(st, result.strategy_stats[SlotWXYZWing], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_als_xz(st, result.strategy_stats[SlotALSXZ], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_unique_loop(st, result.strategy_stats[SlotUniqueLoop], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_avoidable_rectangle(st, result.strategy_stats[SlotAvoidableRectangle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_bivalue_oddagon(st, result.strategy_stats[SlotBivalueOddagon], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 7
            ar = apply_medusa_3d(st, result.strategy_stats[SlotMedusa3D], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_aic(st, result.strategy_stats[SlotAIC], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_grouped_aic(st, result.strategy_stats[SlotGroupedAIC], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_grouped_x_cycle(st, result.strategy_stats[SlotGroupedXCycle], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_continuous_nice_loop(st, result.strategy_stats[SlotContinuousNiceLoop], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_als_xy_wing(st, result.strategy_stats[SlotALSXYWing], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_als_chain(st, result.strategy_stats[SlotALSChain], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_sue_de_coq(st, result.strategy_stats[SlotSueDeCoq], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_death_blossom(st, result.strategy_stats[SlotDeathBlossom], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_franken_fish(st, result.strategy_stats[SlotFrankenFish], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_mutant_fish(st, result.strategy_stats[SlotMutantFish], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_kraken_fish(st, result.strategy_stats[SlotKrakenFish], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            // Level 8 (Ostatnia deska ratunku - zrówna plansze z ziemią)
            ar = apply_msls(st, result.strategy_stats[SlotMSLS], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_exocet(st, result.strategy_stats[SlotExocet], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_senior_exocet(st, result.strategy_stats[SlotSeniorExocet], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_sk_loop(st, result.strategy_stats[SlotSKLoop], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_pattern_overlay_method(st, result.strategy_stats[SlotPatternOverlayMethod], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) continue;

            ar = apply_forcing_chains(st, result.strategy_stats[SlotForcingChains], result);
            if (ar == ApplyResult::Contradiction) return result;
            if (ar == ApplyResult::Progress) {
                // Jeśli łańcuchy wymuszeń zadziałały, flagujemy wyższe wymogi Level 8
                result.used_msls = true;
                result.used_exocet = true;
                continue;
            }

            break; // Jeśli żadna strategia (nawet L8 Forcing Chains) nie ruszyła, zrywamy pętlę.
        }

        result.solved = (board.empty_cells == 0);
        if (capture_solution_grid) result.solved_grid = board.values;
        result.naked_single_scanned = result.strategy_stats[SlotNakedSingle].use_count > 0;
        result.hidden_single_scanned = result.strategy_stats[SlotHiddenSingle].use_count > 0;
        return result;
    }
};

} // namespace sudoku_hpc