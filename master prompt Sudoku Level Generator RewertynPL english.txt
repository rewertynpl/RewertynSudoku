//Author Marcin Matysek (Rewertyn)Act as a Principal C++ Performance Engineer, Graph Theory Expert, and HPC Systems Architect. You specialize in solving NP-complete problems (Constraint Satisfaction Problems) using the C++20 standard, L1-cache optimization, bitboards, and lock-free concurrency.Your task is to implement all Sudoku solving strategies (from Level 1 to Level 7, with optional Backtracking support at Level 8) and integrate the "Pattern Forcing" and "Heuristic MCTS Digger" systems for a highly optimized Sudoku generator and certifier.You are required to rewrite generator.h and logic_certify.h from scratch, breaking them down into smaller files, and propose new names for them.SYSTEM CONTEXT AND STRICT CONSTRAINTS:The system operates on grids ranging from N=4 (4x4) up to N=64 (64x64).ASYMMETRIC geometries are supported (e.g., a 12x12 board with 4x3 blocks, 10x10 with 2x5 blocks). The code MUST NOT assume that box_rows == box_cols.We use 64-bit masks (uint64_t) to represent candidates, where bit 0 represents the digit 1, bit 1 represents the digit 2, etc. (1ULL << (d - 1)).ZERO-ALLOCATION POLICY: Inside the solver loop (in logic functions), it is STRICTLY FORBIDDEN to use std::vector, std::set, std::map, new, or std::deque. For graph operations, BFS queues, MCTS trees, and structure lists (e.g., ALS), you must exclusively use the pre-allocated ExactPatternScratchpad buffer placed in thread_local memory, or local flat arrays on the stack (C-style arrays).Bitwise optimization: extensive use of std::popcount and std::countr_zero instead of loops.DATA STRUCTURES YOU MUST ADAPT TO:st.topo->n (board size), st.topo->nn (number of cells), st.topo->box_rows, st.topo->box_cols.st.topo->cell_row[idx], st.topo->cell_col[idx], st.topo->cell_box[idx].st.topo->peer_offsets[idx] and st.topo->peers_flat[p] (for iterating over "visible" peer cells).st.board->values[idx] - the value entered in a cell (0 if empty).st.cands[idx] - bitmask (uint64_t) of current candidates in a cell.st.eliminate(idx, mask) - method to remove candidates. Returns ApplyResult::Progress, NoProgress, or Contradiction.ExactPatternScratchpad - global thread buffer. It contains structures for BFS (bfs_queue, bfs_depth, bfs_path, visited), a flat als_list[] array of type ALS (cell_mask, digit_mask, size, degree, house), as well as space for Strong/Weak links graphs used in chains.KNOWN BUGS TO AVOID (Architecture Context):I have already fixed the following bugs in the main code; do not break them:PersistentThreadPool had a race/missed wake-up (now seen_epoch starts from 0).The workers' main loop checked the time every 1024 iterations (now it checks every iteration).Reseed used the same state (now worker_seed_state is updated before the reseed).The --max-attempts and --time-limit-s limits are correctly respected.Spinning on remaining.wait(0) has been changed to the correct wait(rem).LIST OF STRATEGIES TO IMPLEMENT (CONTRACT):ðŸŸ¢ 1. Easy (Level 1)P1a: Naked Single, Hidden SingleP2b: Pointing Pairs/Triples, Box/Line Reduction (Intersection Removal)ðŸŸ¡ 2. Medium (Level 2)P2: Naked Pair, Hidden Pair, Naked Triple, Hidden TripleðŸŸ  3. Hard (Level 3)P3: Naked Quad, Hidden Quad, X-Wing, Y-Wing (XY-Wing), Skyscraper, 2-String Kite, Empty Rectangle, Remote PairsðŸ”´ 4. Expert (Level 4)P4: Swordfish, XYZ-Wing, Finned X-Wing/Sashimi, Unique Rectangle (Type 1), BUG+1, W-Wing, Simple ColoringðŸŸ£ 5. Diabolical (Level 5)P5: Jellyfish, WXYZ-Wing, Finned Swordfish/Jellyfish, X-Chain, XY-Chain, ALS-XZ, Unique Loop, Avoidable Rectangle, Bivalue Oddagon, Extended Unique Rectangles (Types 2-6 and Hidden UR), BUG Variants (Types 2, 3, 4), Borescoper's / Qiu's Deadly Patternâš« 6. Nightmare (Level 6)P6: 3D Medusa, AIC/Grouped AIC, Grouped X-Cycle, Continuous Nice Loop, ALS-XY-Wing, ALS-Chain, Sue de Coq, Death Blossom, Franken/Mutant Fish, Kraken Fish, Squirmbag (Starfish), Aligned Pair/Triple Exclusion (APE/ATE), ALS-AICðŸ‘½ 7. Theoretical (Level 7)P7: MSLS, Exocet/Senior Exocet, SK Loop, Pattern Overlay Method, Forcing Chains, Dynamic Forcing ChainsðŸ’» 8. Brute Force (Level 8)P8: Backtracking (The DLX solver is already implemented, you do not need to write it).RULES FOR STRATEGY CODE:Each function must have a precise signature (or be called by a function with this signature):ApplyResult apply_STRATEGY_NAME(CandidateState& st, StrategyStats& s, GenericLogicCertifyResult& r)For Levels 6 and 7, the implementation of chains must be based on BFS over the strong/weak links graph implemented on the ExactPatternScratchpad. For techniques utilizing ALS, use the precompiled function that creates the flat als_list array.Performance above all else. Avoid nested loops over the entire board $O(N^6)$ if you can isolate candidates using row/column bitboards.Apply generalized mathematics: instead of hardcoding box_size = 3, use st.topo->box_rows and st.topo->box_cols. For Fishes and Wings, fully utilize st.topo->n.Proxy Mode vs Exact Mode: Remember that for the heaviest strategies (Level 6 and 7), the implementation must rely on BFS searches over the Strong and Weak links graph using flat arrays from ExactPatternScratchpad.Utilize ALS structures for techniques like Sue de Coq, ALS-XZ, ALS-XY-Wing. Assume that the build_als_list(st, scratch) function generates a flat array of all identified Almost Locked Sets for the current board state.C++// MODE CONFIGURATION (WHITE-BOX vs BLACK-BOX)
// Set to 0 if you want 100% exact structural patterns (slower, certifies rigorously).
// Set to 1 if you want raw power with Fast Implication Proxy (fast, uses links as shortcuts).
#ifndef SUDOKU_USE_PROXY_STRATEGIES
#define SUDOKU_USE_PROXY_STRATEGIES 0
#endif
NEW BOARD GENERATION PARADIGM (PATTERN FORCING MODULES):Standard digging from a random full board and hoping to roll a P8 strategy takes years. Implement an innovative generation system:MODULE 1: EXACT PATTERN FORCING (Geometric Template Generator)Define coordinate structures for Level 8 techniques (e.g., define Base Cells, Target Cells, and Cross Cells for Exocet; determine vertices for SK Loop; set up chains for Forcing Chains).Inject (plant) specific candidate masks into an empty board (imposing a mathematical structure template).Use dlx_solver.solve_and_capture(...) to solve the rest of the board around the imposed template. This guarantees a 100% Hit Rate for the existence of the starting logic.MODULE 2: LOGICAL BOTTLENECK DIGGER (MCTS UCB1 Digger)The digging algorithm evaluates nodes (removed cells) using Monte Carlo Tree Search (UCB1), providing rewards for creating advanced chains (e.g., X-Chain, ALS).It features a Basic Logical Solver (calibrated for P1-P5). The Digger removes digits (prioritizing those outside the injected template from Module 1). It will stop and secure the Bottleneck when the Basic Logical Solver GETS STUCK, but DLX still confirms 1 unique solution.MODULE 3: VERIFICATIONAt the end, the board is passed through the full Certifier (Levels 1-7) to ensure the puzzle is unsolvable without the chosen P5/P6/P7 technique and that it is 100% logically consistent with it.

HOW TO EXECUTE THE TASK (VERY IMPORTANT):
Since there is a vast amount of code, do not try to generate it in a single output, because you will truncate the response. We will work iteratively. You will provide ready C++ code blocks, 1 full file at a time, complete for copy-pasting, with all functions 100% filled in, optimized for C++20 HPC.

To this message, reply ONLY with:

A brief confirmation of understanding the architecture rules (zero-allocation, flat arrays, MCTS/Pattern Forcing).

A ready, complete plan.







